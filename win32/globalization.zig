//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1332)
//--------------------------------------------------------------------------------
pub const ALL_SERVICE_TYPES = @as(u32, 0);
pub const HIGHLEVEL_SERVICE_TYPES = @as(u32, 1);
pub const LOWLEVEL_SERVICE_TYPES = @as(u32, 2);
pub const ALL_SERVICES = @as(u32, 0);
pub const ONLINE_SERVICES = @as(u32, 1);
pub const OFFLINE_SERVICES = @as(u32, 2);
pub const MAX_LEADBYTES = @as(u32, 12);
pub const MAX_DEFAULTCHAR = @as(u32, 2);
pub const HIGH_SURROGATE_START = @as(u32, 55296);
pub const HIGH_SURROGATE_END = @as(u32, 56319);
pub const LOW_SURROGATE_START = @as(u32, 56320);
pub const LOW_SURROGATE_END = @as(u32, 57343);
pub const WC_COMPOSITECHECK = @as(u32, 512);
pub const WC_DISCARDNS = @as(u32, 16);
pub const WC_SEPCHARS = @as(u32, 32);
pub const WC_DEFAULTCHAR = @as(u32, 64);
pub const WC_ERR_INVALID_CHARS = @as(u32, 128);
pub const WC_NO_BEST_FIT_CHARS = @as(u32, 1024);
pub const CT_CTYPE1 = @as(u32, 1);
pub const CT_CTYPE2 = @as(u32, 2);
pub const CT_CTYPE3 = @as(u32, 4);
pub const C1_UPPER = @as(u32, 1);
pub const C1_LOWER = @as(u32, 2);
pub const C1_DIGIT = @as(u32, 4);
pub const C1_SPACE = @as(u32, 8);
pub const C1_PUNCT = @as(u32, 16);
pub const C1_CNTRL = @as(u32, 32);
pub const C1_BLANK = @as(u32, 64);
pub const C1_XDIGIT = @as(u32, 128);
pub const C1_ALPHA = @as(u32, 256);
pub const C1_DEFINED = @as(u32, 512);
pub const C2_LEFTTORIGHT = @as(u32, 1);
pub const C2_RIGHTTOLEFT = @as(u32, 2);
pub const C2_EUROPENUMBER = @as(u32, 3);
pub const C2_EUROPESEPARATOR = @as(u32, 4);
pub const C2_EUROPETERMINATOR = @as(u32, 5);
pub const C2_ARABICNUMBER = @as(u32, 6);
pub const C2_COMMONSEPARATOR = @as(u32, 7);
pub const C2_BLOCKSEPARATOR = @as(u32, 8);
pub const C2_SEGMENTSEPARATOR = @as(u32, 9);
pub const C2_WHITESPACE = @as(u32, 10);
pub const C2_OTHERNEUTRAL = @as(u32, 11);
pub const C2_NOTAPPLICABLE = @as(u32, 0);
pub const C3_NONSPACING = @as(u32, 1);
pub const C3_DIACRITIC = @as(u32, 2);
pub const C3_VOWELMARK = @as(u32, 4);
pub const C3_SYMBOL = @as(u32, 8);
pub const C3_KATAKANA = @as(u32, 16);
pub const C3_HIRAGANA = @as(u32, 32);
pub const C3_HALFWIDTH = @as(u32, 64);
pub const C3_FULLWIDTH = @as(u32, 128);
pub const C3_IDEOGRAPH = @as(u32, 256);
pub const C3_KASHIDA = @as(u32, 512);
pub const C3_LEXICAL = @as(u32, 1024);
pub const C3_HIGHSURROGATE = @as(u32, 2048);
pub const C3_LOWSURROGATE = @as(u32, 4096);
pub const C3_ALPHA = @as(u32, 32768);
pub const C3_NOTAPPLICABLE = @as(u32, 0);
pub const LCMAP_LOWERCASE = @as(u32, 256);
pub const LCMAP_UPPERCASE = @as(u32, 512);
pub const LCMAP_TITLECASE = @as(u32, 768);
pub const LCMAP_SORTKEY = @as(u32, 1024);
pub const LCMAP_BYTEREV = @as(u32, 2048);
pub const LCMAP_HIRAGANA = @as(u32, 1048576);
pub const LCMAP_KATAKANA = @as(u32, 2097152);
pub const LCMAP_HALFWIDTH = @as(u32, 4194304);
pub const LCMAP_FULLWIDTH = @as(u32, 8388608);
pub const LCMAP_LINGUISTIC_CASING = @as(u32, 16777216);
pub const LCMAP_SIMPLIFIED_CHINESE = @as(u32, 33554432);
pub const LCMAP_TRADITIONAL_CHINESE = @as(u32, 67108864);
pub const LCMAP_SORTHANDLE = @as(u32, 536870912);
pub const LCMAP_HASH = @as(u32, 262144);
pub const FIND_STARTSWITH = @as(u32, 1048576);
pub const FIND_ENDSWITH = @as(u32, 2097152);
pub const FIND_FROMSTART = @as(u32, 4194304);
pub const FIND_FROMEND = @as(u32, 8388608);
pub const LCID_ALTERNATE_SORTS = @as(u32, 4);
pub const LOCALE_ALL = @as(u32, 0);
pub const LOCALE_WINDOWS = @as(u32, 1);
pub const LOCALE_SUPPLEMENTAL = @as(u32, 2);
pub const LOCALE_ALTERNATE_SORTS = @as(u32, 4);
pub const LOCALE_REPLACEMENT = @as(u32, 8);
pub const LOCALE_NEUTRALDATA = @as(u32, 16);
pub const LOCALE_SPECIFICDATA = @as(u32, 32);
pub const CSTR_LESS_THAN = @as(u32, 1);
pub const CSTR_EQUAL = @as(u32, 2);
pub const CSTR_GREATER_THAN = @as(u32, 3);
pub const CP_ACP = @as(u32, 0);
pub const CP_OEMCP = @as(u32, 1);
pub const CP_MACCP = @as(u32, 2);
pub const CP_THREAD_ACP = @as(u32, 3);
pub const CP_SYMBOL = @as(u32, 42);
pub const CP_UTF7 = @as(u32, 65000);
pub const CP_UTF8 = @as(u32, 65001);
pub const CTRY_DEFAULT = @as(u32, 0);
pub const CTRY_ALBANIA = @as(u32, 355);
pub const CTRY_ALGERIA = @as(u32, 213);
pub const CTRY_ARGENTINA = @as(u32, 54);
pub const CTRY_ARMENIA = @as(u32, 374);
pub const CTRY_AUSTRALIA = @as(u32, 61);
pub const CTRY_AUSTRIA = @as(u32, 43);
pub const CTRY_AZERBAIJAN = @as(u32, 994);
pub const CTRY_BAHRAIN = @as(u32, 973);
pub const CTRY_BELARUS = @as(u32, 375);
pub const CTRY_BELGIUM = @as(u32, 32);
pub const CTRY_BELIZE = @as(u32, 501);
pub const CTRY_BOLIVIA = @as(u32, 591);
pub const CTRY_BRAZIL = @as(u32, 55);
pub const CTRY_BRUNEI_DARUSSALAM = @as(u32, 673);
pub const CTRY_BULGARIA = @as(u32, 359);
pub const CTRY_CANADA = @as(u32, 2);
pub const CTRY_CARIBBEAN = @as(u32, 1);
pub const CTRY_CHILE = @as(u32, 56);
pub const CTRY_COLOMBIA = @as(u32, 57);
pub const CTRY_COSTA_RICA = @as(u32, 506);
pub const CTRY_CROATIA = @as(u32, 385);
pub const CTRY_CZECH = @as(u32, 420);
pub const CTRY_DENMARK = @as(u32, 45);
pub const CTRY_DOMINICAN_REPUBLIC = @as(u32, 1);
pub const CTRY_ECUADOR = @as(u32, 593);
pub const CTRY_EGYPT = @as(u32, 20);
pub const CTRY_EL_SALVADOR = @as(u32, 503);
pub const CTRY_ESTONIA = @as(u32, 372);
pub const CTRY_FAEROE_ISLANDS = @as(u32, 298);
pub const CTRY_FINLAND = @as(u32, 358);
pub const CTRY_FRANCE = @as(u32, 33);
pub const CTRY_GEORGIA = @as(u32, 995);
pub const CTRY_GERMANY = @as(u32, 49);
pub const CTRY_GREECE = @as(u32, 30);
pub const CTRY_GUATEMALA = @as(u32, 502);
pub const CTRY_HONDURAS = @as(u32, 504);
pub const CTRY_HONG_KONG = @as(u32, 852);
pub const CTRY_HUNGARY = @as(u32, 36);
pub const CTRY_ICELAND = @as(u32, 354);
pub const CTRY_INDIA = @as(u32, 91);
pub const CTRY_INDONESIA = @as(u32, 62);
pub const CTRY_IRAN = @as(u32, 981);
pub const CTRY_IRAQ = @as(u32, 964);
pub const CTRY_IRELAND = @as(u32, 353);
pub const CTRY_ISRAEL = @as(u32, 972);
pub const CTRY_ITALY = @as(u32, 39);
pub const CTRY_JAMAICA = @as(u32, 1);
pub const CTRY_JAPAN = @as(u32, 81);
pub const CTRY_JORDAN = @as(u32, 962);
pub const CTRY_KAZAKSTAN = @as(u32, 7);
pub const CTRY_KENYA = @as(u32, 254);
pub const CTRY_KUWAIT = @as(u32, 965);
pub const CTRY_KYRGYZSTAN = @as(u32, 996);
pub const CTRY_LATVIA = @as(u32, 371);
pub const CTRY_LEBANON = @as(u32, 961);
pub const CTRY_LIBYA = @as(u32, 218);
pub const CTRY_LIECHTENSTEIN = @as(u32, 41);
pub const CTRY_LITHUANIA = @as(u32, 370);
pub const CTRY_LUXEMBOURG = @as(u32, 352);
pub const CTRY_MACAU = @as(u32, 853);
pub const CTRY_MACEDONIA = @as(u32, 389);
pub const CTRY_MALAYSIA = @as(u32, 60);
pub const CTRY_MALDIVES = @as(u32, 960);
pub const CTRY_MEXICO = @as(u32, 52);
pub const CTRY_MONACO = @as(u32, 33);
pub const CTRY_MONGOLIA = @as(u32, 976);
pub const CTRY_MOROCCO = @as(u32, 212);
pub const CTRY_NETHERLANDS = @as(u32, 31);
pub const CTRY_NEW_ZEALAND = @as(u32, 64);
pub const CTRY_NICARAGUA = @as(u32, 505);
pub const CTRY_NORWAY = @as(u32, 47);
pub const CTRY_OMAN = @as(u32, 968);
pub const CTRY_PAKISTAN = @as(u32, 92);
pub const CTRY_PANAMA = @as(u32, 507);
pub const CTRY_PARAGUAY = @as(u32, 595);
pub const CTRY_PERU = @as(u32, 51);
pub const CTRY_PHILIPPINES = @as(u32, 63);
pub const CTRY_POLAND = @as(u32, 48);
pub const CTRY_PORTUGAL = @as(u32, 351);
pub const CTRY_PRCHINA = @as(u32, 86);
pub const CTRY_PUERTO_RICO = @as(u32, 1);
pub const CTRY_QATAR = @as(u32, 974);
pub const CTRY_ROMANIA = @as(u32, 40);
pub const CTRY_RUSSIA = @as(u32, 7);
pub const CTRY_SAUDI_ARABIA = @as(u32, 966);
pub const CTRY_SERBIA = @as(u32, 381);
pub const CTRY_SINGAPORE = @as(u32, 65);
pub const CTRY_SLOVAK = @as(u32, 421);
pub const CTRY_SLOVENIA = @as(u32, 386);
pub const CTRY_SOUTH_AFRICA = @as(u32, 27);
pub const CTRY_SOUTH_KOREA = @as(u32, 82);
pub const CTRY_SPAIN = @as(u32, 34);
pub const CTRY_SWEDEN = @as(u32, 46);
pub const CTRY_SWITZERLAND = @as(u32, 41);
pub const CTRY_SYRIA = @as(u32, 963);
pub const CTRY_TAIWAN = @as(u32, 886);
pub const CTRY_TATARSTAN = @as(u32, 7);
pub const CTRY_THAILAND = @as(u32, 66);
pub const CTRY_TRINIDAD_Y_TOBAGO = @as(u32, 1);
pub const CTRY_TUNISIA = @as(u32, 216);
pub const CTRY_TURKEY = @as(u32, 90);
pub const CTRY_UAE = @as(u32, 971);
pub const CTRY_UKRAINE = @as(u32, 380);
pub const CTRY_UNITED_KINGDOM = @as(u32, 44);
pub const CTRY_UNITED_STATES = @as(u32, 1);
pub const CTRY_URUGUAY = @as(u32, 598);
pub const CTRY_UZBEKISTAN = @as(u32, 7);
pub const CTRY_VENEZUELA = @as(u32, 58);
pub const CTRY_VIET_NAM = @as(u32, 84);
pub const CTRY_YEMEN = @as(u32, 967);
pub const CTRY_ZIMBABWE = @as(u32, 263);
pub const LOCALE_NOUSEROVERRIDE = @as(u32, 2147483648);
pub const LOCALE_USE_CP_ACP = @as(u32, 1073741824);
pub const LOCALE_RETURN_NUMBER = @as(u32, 536870912);
pub const LOCALE_RETURN_GENITIVE_NAMES = @as(u32, 268435456);
pub const LOCALE_ALLOW_NEUTRAL_NAMES = @as(u32, 134217728);
pub const LOCALE_SLOCALIZEDDISPLAYNAME = @as(u32, 2);
pub const LOCALE_SENGLISHDISPLAYNAME = @as(u32, 114);
pub const LOCALE_SNATIVEDISPLAYNAME = @as(u32, 115);
pub const LOCALE_SLOCALIZEDLANGUAGENAME = @as(u32, 111);
pub const LOCALE_SENGLISHLANGUAGENAME = @as(u32, 4097);
pub const LOCALE_SNATIVELANGUAGENAME = @as(u32, 4);
pub const LOCALE_SLOCALIZEDCOUNTRYNAME = @as(u32, 6);
pub const LOCALE_SENGLISHCOUNTRYNAME = @as(u32, 4098);
pub const LOCALE_SNATIVECOUNTRYNAME = @as(u32, 8);
pub const LOCALE_IDIALINGCODE = @as(u32, 5);
pub const LOCALE_SLIST = @as(u32, 12);
pub const LOCALE_IMEASURE = @as(u32, 13);
pub const LOCALE_SDECIMAL = @as(u32, 14);
pub const LOCALE_STHOUSAND = @as(u32, 15);
pub const LOCALE_SGROUPING = @as(u32, 16);
pub const LOCALE_IDIGITS = @as(u32, 17);
pub const LOCALE_ILZERO = @as(u32, 18);
pub const LOCALE_INEGNUMBER = @as(u32, 4112);
pub const LOCALE_SNATIVEDIGITS = @as(u32, 19);
pub const LOCALE_SCURRENCY = @as(u32, 20);
pub const LOCALE_SINTLSYMBOL = @as(u32, 21);
pub const LOCALE_SMONDECIMALSEP = @as(u32, 22);
pub const LOCALE_SMONTHOUSANDSEP = @as(u32, 23);
pub const LOCALE_SMONGROUPING = @as(u32, 24);
pub const LOCALE_ICURRDIGITS = @as(u32, 25);
pub const LOCALE_ICURRENCY = @as(u32, 27);
pub const LOCALE_INEGCURR = @as(u32, 28);
pub const LOCALE_SSHORTDATE = @as(u32, 31);
pub const LOCALE_SLONGDATE = @as(u32, 32);
pub const LOCALE_STIMEFORMAT = @as(u32, 4099);
pub const LOCALE_SAM = @as(u32, 40);
pub const LOCALE_SPM = @as(u32, 41);
pub const LOCALE_ICALENDARTYPE = @as(u32, 4105);
pub const LOCALE_IOPTIONALCALENDAR = @as(u32, 4107);
pub const LOCALE_IFIRSTDAYOFWEEK = @as(u32, 4108);
pub const LOCALE_IFIRSTWEEKOFYEAR = @as(u32, 4109);
pub const LOCALE_SDAYNAME1 = @as(u32, 42);
pub const LOCALE_SDAYNAME2 = @as(u32, 43);
pub const LOCALE_SDAYNAME3 = @as(u32, 44);
pub const LOCALE_SDAYNAME4 = @as(u32, 45);
pub const LOCALE_SDAYNAME5 = @as(u32, 46);
pub const LOCALE_SDAYNAME6 = @as(u32, 47);
pub const LOCALE_SDAYNAME7 = @as(u32, 48);
pub const LOCALE_SABBREVDAYNAME1 = @as(u32, 49);
pub const LOCALE_SABBREVDAYNAME2 = @as(u32, 50);
pub const LOCALE_SABBREVDAYNAME3 = @as(u32, 51);
pub const LOCALE_SABBREVDAYNAME4 = @as(u32, 52);
pub const LOCALE_SABBREVDAYNAME5 = @as(u32, 53);
pub const LOCALE_SABBREVDAYNAME6 = @as(u32, 54);
pub const LOCALE_SABBREVDAYNAME7 = @as(u32, 55);
pub const LOCALE_SMONTHNAME1 = @as(u32, 56);
pub const LOCALE_SMONTHNAME2 = @as(u32, 57);
pub const LOCALE_SMONTHNAME3 = @as(u32, 58);
pub const LOCALE_SMONTHNAME4 = @as(u32, 59);
pub const LOCALE_SMONTHNAME5 = @as(u32, 60);
pub const LOCALE_SMONTHNAME6 = @as(u32, 61);
pub const LOCALE_SMONTHNAME7 = @as(u32, 62);
pub const LOCALE_SMONTHNAME8 = @as(u32, 63);
pub const LOCALE_SMONTHNAME9 = @as(u32, 64);
pub const LOCALE_SMONTHNAME10 = @as(u32, 65);
pub const LOCALE_SMONTHNAME11 = @as(u32, 66);
pub const LOCALE_SMONTHNAME12 = @as(u32, 67);
pub const LOCALE_SMONTHNAME13 = @as(u32, 4110);
pub const LOCALE_SABBREVMONTHNAME1 = @as(u32, 68);
pub const LOCALE_SABBREVMONTHNAME2 = @as(u32, 69);
pub const LOCALE_SABBREVMONTHNAME3 = @as(u32, 70);
pub const LOCALE_SABBREVMONTHNAME4 = @as(u32, 71);
pub const LOCALE_SABBREVMONTHNAME5 = @as(u32, 72);
pub const LOCALE_SABBREVMONTHNAME6 = @as(u32, 73);
pub const LOCALE_SABBREVMONTHNAME7 = @as(u32, 74);
pub const LOCALE_SABBREVMONTHNAME8 = @as(u32, 75);
pub const LOCALE_SABBREVMONTHNAME9 = @as(u32, 76);
pub const LOCALE_SABBREVMONTHNAME10 = @as(u32, 77);
pub const LOCALE_SABBREVMONTHNAME11 = @as(u32, 78);
pub const LOCALE_SABBREVMONTHNAME12 = @as(u32, 79);
pub const LOCALE_SABBREVMONTHNAME13 = @as(u32, 4111);
pub const LOCALE_SPOSITIVESIGN = @as(u32, 80);
pub const LOCALE_SNEGATIVESIGN = @as(u32, 81);
pub const LOCALE_IPOSSIGNPOSN = @as(u32, 82);
pub const LOCALE_INEGSIGNPOSN = @as(u32, 83);
pub const LOCALE_IPOSSYMPRECEDES = @as(u32, 84);
pub const LOCALE_IPOSSEPBYSPACE = @as(u32, 85);
pub const LOCALE_INEGSYMPRECEDES = @as(u32, 86);
pub const LOCALE_INEGSEPBYSPACE = @as(u32, 87);
pub const LOCALE_FONTSIGNATURE = @as(u32, 88);
pub const LOCALE_SISO639LANGNAME = @as(u32, 89);
pub const LOCALE_SISO3166CTRYNAME = @as(u32, 90);
pub const LOCALE_IPAPERSIZE = @as(u32, 4106);
pub const LOCALE_SENGCURRNAME = @as(u32, 4103);
pub const LOCALE_SNATIVECURRNAME = @as(u32, 4104);
pub const LOCALE_SYEARMONTH = @as(u32, 4102);
pub const LOCALE_SSORTNAME = @as(u32, 4115);
pub const LOCALE_IDIGITSUBSTITUTION = @as(u32, 4116);
pub const LOCALE_SNAME = @as(u32, 92);
pub const LOCALE_SDURATION = @as(u32, 93);
pub const LOCALE_SSHORTESTDAYNAME1 = @as(u32, 96);
pub const LOCALE_SSHORTESTDAYNAME2 = @as(u32, 97);
pub const LOCALE_SSHORTESTDAYNAME3 = @as(u32, 98);
pub const LOCALE_SSHORTESTDAYNAME4 = @as(u32, 99);
pub const LOCALE_SSHORTESTDAYNAME5 = @as(u32, 100);
pub const LOCALE_SSHORTESTDAYNAME6 = @as(u32, 101);
pub const LOCALE_SSHORTESTDAYNAME7 = @as(u32, 102);
pub const LOCALE_SISO639LANGNAME2 = @as(u32, 103);
pub const LOCALE_SISO3166CTRYNAME2 = @as(u32, 104);
pub const LOCALE_SNAN = @as(u32, 105);
pub const LOCALE_SPOSINFINITY = @as(u32, 106);
pub const LOCALE_SNEGINFINITY = @as(u32, 107);
pub const LOCALE_SSCRIPTS = @as(u32, 108);
pub const LOCALE_SPARENT = @as(u32, 109);
pub const LOCALE_SCONSOLEFALLBACKNAME = @as(u32, 110);
pub const LOCALE_IREADINGLAYOUT = @as(u32, 112);
pub const LOCALE_INEUTRAL = @as(u32, 113);
pub const LOCALE_INEGATIVEPERCENT = @as(u32, 116);
pub const LOCALE_IPOSITIVEPERCENT = @as(u32, 117);
pub const LOCALE_SPERCENT = @as(u32, 118);
pub const LOCALE_SPERMILLE = @as(u32, 119);
pub const LOCALE_SMONTHDAY = @as(u32, 120);
pub const LOCALE_SSHORTTIME = @as(u32, 121);
pub const LOCALE_SOPENTYPELANGUAGETAG = @as(u32, 122);
pub const LOCALE_SSORTLOCALE = @as(u32, 123);
pub const LOCALE_SRELATIVELONGDATE = @as(u32, 124);
pub const LOCALE_SSHORTESTAM = @as(u32, 126);
pub const LOCALE_SSHORTESTPM = @as(u32, 127);
pub const LOCALE_IDEFAULTCODEPAGE = @as(u32, 11);
pub const LOCALE_IDEFAULTANSICODEPAGE = @as(u32, 4100);
pub const LOCALE_IDEFAULTMACCODEPAGE = @as(u32, 4113);
pub const LOCALE_IDEFAULTEBCDICCODEPAGE = @as(u32, 4114);
pub const LOCALE_ILANGUAGE = @as(u32, 1);
pub const LOCALE_SABBREVLANGNAME = @as(u32, 3);
pub const LOCALE_SABBREVCTRYNAME = @as(u32, 7);
pub const LOCALE_IGEOID = @as(u32, 91);
pub const LOCALE_IDEFAULTLANGUAGE = @as(u32, 9);
pub const LOCALE_IDEFAULTCOUNTRY = @as(u32, 10);
pub const LOCALE_IINTLCURRDIGITS = @as(u32, 26);
pub const LOCALE_SDATE = @as(u32, 29);
pub const LOCALE_STIME = @as(u32, 30);
pub const LOCALE_IDATE = @as(u32, 33);
pub const LOCALE_ILDATE = @as(u32, 34);
pub const LOCALE_ITIME = @as(u32, 35);
pub const LOCALE_ITIMEMARKPOSN = @as(u32, 4101);
pub const LOCALE_ICENTURY = @as(u32, 36);
pub const LOCALE_ITLZERO = @as(u32, 37);
pub const LOCALE_IDAYLZERO = @as(u32, 38);
pub const LOCALE_IMONLZERO = @as(u32, 39);
pub const LOCALE_SKEYBOARDSTOINSTALL = @as(u32, 94);
pub const CAL_ICALINTVALUE = @as(u32, 1);
pub const CAL_SCALNAME = @as(u32, 2);
pub const CAL_IYEAROFFSETRANGE = @as(u32, 3);
pub const CAL_SERASTRING = @as(u32, 4);
pub const CAL_SSHORTDATE = @as(u32, 5);
pub const CAL_SLONGDATE = @as(u32, 6);
pub const CAL_SDAYNAME1 = @as(u32, 7);
pub const CAL_SDAYNAME2 = @as(u32, 8);
pub const CAL_SDAYNAME3 = @as(u32, 9);
pub const CAL_SDAYNAME4 = @as(u32, 10);
pub const CAL_SDAYNAME5 = @as(u32, 11);
pub const CAL_SDAYNAME6 = @as(u32, 12);
pub const CAL_SDAYNAME7 = @as(u32, 13);
pub const CAL_SABBREVDAYNAME1 = @as(u32, 14);
pub const CAL_SABBREVDAYNAME2 = @as(u32, 15);
pub const CAL_SABBREVDAYNAME3 = @as(u32, 16);
pub const CAL_SABBREVDAYNAME4 = @as(u32, 17);
pub const CAL_SABBREVDAYNAME5 = @as(u32, 18);
pub const CAL_SABBREVDAYNAME6 = @as(u32, 19);
pub const CAL_SABBREVDAYNAME7 = @as(u32, 20);
pub const CAL_SMONTHNAME1 = @as(u32, 21);
pub const CAL_SMONTHNAME2 = @as(u32, 22);
pub const CAL_SMONTHNAME3 = @as(u32, 23);
pub const CAL_SMONTHNAME4 = @as(u32, 24);
pub const CAL_SMONTHNAME5 = @as(u32, 25);
pub const CAL_SMONTHNAME6 = @as(u32, 26);
pub const CAL_SMONTHNAME7 = @as(u32, 27);
pub const CAL_SMONTHNAME8 = @as(u32, 28);
pub const CAL_SMONTHNAME9 = @as(u32, 29);
pub const CAL_SMONTHNAME10 = @as(u32, 30);
pub const CAL_SMONTHNAME11 = @as(u32, 31);
pub const CAL_SMONTHNAME12 = @as(u32, 32);
pub const CAL_SMONTHNAME13 = @as(u32, 33);
pub const CAL_SABBREVMONTHNAME1 = @as(u32, 34);
pub const CAL_SABBREVMONTHNAME2 = @as(u32, 35);
pub const CAL_SABBREVMONTHNAME3 = @as(u32, 36);
pub const CAL_SABBREVMONTHNAME4 = @as(u32, 37);
pub const CAL_SABBREVMONTHNAME5 = @as(u32, 38);
pub const CAL_SABBREVMONTHNAME6 = @as(u32, 39);
pub const CAL_SABBREVMONTHNAME7 = @as(u32, 40);
pub const CAL_SABBREVMONTHNAME8 = @as(u32, 41);
pub const CAL_SABBREVMONTHNAME9 = @as(u32, 42);
pub const CAL_SABBREVMONTHNAME10 = @as(u32, 43);
pub const CAL_SABBREVMONTHNAME11 = @as(u32, 44);
pub const CAL_SABBREVMONTHNAME12 = @as(u32, 45);
pub const CAL_SABBREVMONTHNAME13 = @as(u32, 46);
pub const CAL_SYEARMONTH = @as(u32, 47);
pub const CAL_ITWODIGITYEARMAX = @as(u32, 48);
pub const CAL_SSHORTESTDAYNAME1 = @as(u32, 49);
pub const CAL_SSHORTESTDAYNAME2 = @as(u32, 50);
pub const CAL_SSHORTESTDAYNAME3 = @as(u32, 51);
pub const CAL_SSHORTESTDAYNAME4 = @as(u32, 52);
pub const CAL_SSHORTESTDAYNAME5 = @as(u32, 53);
pub const CAL_SSHORTESTDAYNAME6 = @as(u32, 54);
pub const CAL_SSHORTESTDAYNAME7 = @as(u32, 55);
pub const CAL_SMONTHDAY = @as(u32, 56);
pub const CAL_SABBREVERASTRING = @as(u32, 57);
pub const CAL_SRELATIVELONGDATE = @as(u32, 58);
pub const CAL_SENGLISHERANAME = @as(u32, 59);
pub const CAL_SENGLISHABBREVERANAME = @as(u32, 60);
pub const CAL_SJAPANESEERAFIRSTYEAR = @as(u32, 61);
pub const ENUM_ALL_CALENDARS = @as(u32, 4294967295);
pub const CAL_GREGORIAN = @as(u32, 1);
pub const CAL_GREGORIAN_US = @as(u32, 2);
pub const CAL_JAPAN = @as(u32, 3);
pub const CAL_TAIWAN = @as(u32, 4);
pub const CAL_KOREA = @as(u32, 5);
pub const CAL_HIJRI = @as(u32, 6);
pub const CAL_THAI = @as(u32, 7);
pub const CAL_HEBREW = @as(u32, 8);
pub const CAL_GREGORIAN_ME_FRENCH = @as(u32, 9);
pub const CAL_GREGORIAN_ARABIC = @as(u32, 10);
pub const CAL_GREGORIAN_XLIT_ENGLISH = @as(u32, 11);
pub const CAL_GREGORIAN_XLIT_FRENCH = @as(u32, 12);
pub const CAL_PERSIAN = @as(u32, 22);
pub const CAL_UMALQURA = @as(u32, 23);
pub const LGRPID_WESTERN_EUROPE = @as(u32, 1);
pub const LGRPID_CENTRAL_EUROPE = @as(u32, 2);
pub const LGRPID_BALTIC = @as(u32, 3);
pub const LGRPID_GREEK = @as(u32, 4);
pub const LGRPID_CYRILLIC = @as(u32, 5);
pub const LGRPID_TURKIC = @as(u32, 6);
pub const LGRPID_TURKISH = @as(u32, 6);
pub const LGRPID_JAPANESE = @as(u32, 7);
pub const LGRPID_KOREAN = @as(u32, 8);
pub const LGRPID_TRADITIONAL_CHINESE = @as(u32, 9);
pub const LGRPID_SIMPLIFIED_CHINESE = @as(u32, 10);
pub const LGRPID_THAI = @as(u32, 11);
pub const LGRPID_HEBREW = @as(u32, 12);
pub const LGRPID_ARABIC = @as(u32, 13);
pub const LGRPID_VIETNAMESE = @as(u32, 14);
pub const LGRPID_INDIC = @as(u32, 15);
pub const LGRPID_GEORGIAN = @as(u32, 16);
pub const LGRPID_ARMENIAN = @as(u32, 17);
pub const MUI_LANGUAGE_ID = @as(u32, 4);
pub const MUI_LANGUAGE_NAME = @as(u32, 8);
pub const MUI_MERGE_SYSTEM_FALLBACK = @as(u32, 16);
pub const MUI_MERGE_USER_FALLBACK = @as(u32, 32);
pub const MUI_THREAD_LANGUAGES = @as(u32, 64);
pub const MUI_CONSOLE_FILTER = @as(u32, 256);
pub const MUI_COMPLEX_SCRIPT_FILTER = @as(u32, 512);
pub const MUI_RESET_FILTERS = @as(u32, 1);
pub const MUI_USER_PREFERRED_UI_LANGUAGES = @as(u32, 16);
pub const MUI_USE_INSTALLED_LANGUAGES = @as(u32, 32);
pub const MUI_USE_SEARCH_ALL_LANGUAGES = @as(u32, 64);
pub const MUI_LANG_NEUTRAL_PE_FILE = @as(u32, 256);
pub const MUI_NON_LANG_NEUTRAL_FILE = @as(u32, 512);
pub const MUI_MACHINE_LANGUAGE_SETTINGS = @as(u32, 1024);
pub const MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL = @as(u32, 1);
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN = @as(u32, 2);
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI = @as(u32, 4);
pub const MUI_QUERY_TYPE = @as(u32, 1);
pub const MUI_QUERY_CHECKSUM = @as(u32, 2);
pub const MUI_QUERY_LANGUAGE_NAME = @as(u32, 4);
pub const MUI_QUERY_RESOURCE_TYPES = @as(u32, 8);
pub const MUI_FILEINFO_VERSION = @as(u32, 1);
pub const MUI_FULL_LANGUAGE = @as(u32, 1);
pub const MUI_PARTIAL_LANGUAGE = @as(u32, 2);
pub const MUI_LIP_LANGUAGE = @as(u32, 4);
pub const MUI_LANGUAGE_INSTALLED = @as(u32, 32);
pub const MUI_LANGUAGE_LICENSED = @as(u32, 64);
pub const GEOID_NOT_AVAILABLE = @as(i32, -1);
pub const IDN_ALLOW_UNASSIGNED = @as(u32, 1);
pub const IDN_USE_STD3_ASCII_RULES = @as(u32, 2);
pub const IDN_EMAIL_ADDRESS = @as(u32, 4);
pub const IDN_RAW_PUNYCODE = @as(u32, 8);
pub const VS_ALLOW_LATIN = @as(u32, 1);
pub const GSS_ALLOW_INHERITED_COMMON = @as(u32, 1);
pub const MUI_FORMAT_REG_COMPAT = @as(u32, 1);
pub const MUI_FORMAT_INF_COMPAT = @as(u32, 2);
pub const MUI_VERIFY_FILE_EXISTS = @as(u32, 4);
pub const MUI_SKIP_STRING_CACHE = @as(u32, 8);
pub const MUI_IMMUTABLE_LOOKUP = @as(u32, 16);
pub const CLSID_VERSION_DEPENDENT_MSIME_JAPANESE = Guid.initString("6a91029e-aa49-471b-aee7-7d332785660d");
pub const IFEC_S_ALREADY_DEFAULT = @import("zig.zig").typedConst(HRESULT, @as(i32, 291840));
pub const FELANG_REQ_CONV = @as(u32, 65536);
pub const FELANG_REQ_RECONV = @as(u32, 131072);
pub const FELANG_REQ_REV = @as(u32, 196608);
pub const FELANG_CMODE_MONORUBY = @as(u32, 2);
pub const FELANG_CMODE_NOPRUNING = @as(u32, 4);
pub const FELANG_CMODE_KATAKANAOUT = @as(u32, 8);
pub const FELANG_CMODE_HIRAGANAOUT = @as(u32, 0);
pub const FELANG_CMODE_HALFWIDTHOUT = @as(u32, 16);
pub const FELANG_CMODE_FULLWIDTHOUT = @as(u32, 32);
pub const FELANG_CMODE_BOPOMOFO = @as(u32, 64);
pub const FELANG_CMODE_HANGUL = @as(u32, 128);
pub const FELANG_CMODE_PINYIN = @as(u32, 256);
pub const FELANG_CMODE_PRECONV = @as(u32, 512);
pub const FELANG_CMODE_RADICAL = @as(u32, 1024);
pub const FELANG_CMODE_UNKNOWNREADING = @as(u32, 2048);
pub const FELANG_CMODE_MERGECAND = @as(u32, 4096);
pub const FELANG_CMODE_ROMAN = @as(u32, 8192);
pub const FELANG_CMODE_BESTFIRST = @as(u32, 16384);
pub const FELANG_CMODE_USENOREVWORDS = @as(u32, 32768);
pub const FELANG_CMODE_NONE = @as(u32, 16777216);
pub const FELANG_CMODE_PLAURALCLAUSE = @as(u32, 33554432);
pub const FELANG_CMODE_SINGLECONVERT = @as(u32, 67108864);
pub const FELANG_CMODE_AUTOMATIC = @as(u32, 134217728);
pub const FELANG_CMODE_PHRASEPREDICT = @as(u32, 268435456);
pub const FELANG_CMODE_CONVERSATION = @as(u32, 536870912);
pub const FELANG_CMODE_NOINVISIBLECHAR = @as(u32, 1073741824);
pub const E_NOCAND = @as(u32, 48);
pub const E_NOTENOUGH_BUFFER = @as(u32, 49);
pub const E_NOTENOUGH_WDD = @as(u32, 50);
pub const E_LARGEINPUT = @as(u32, 51);
pub const FELANG_CLMN_WBREAK = @as(u32, 1);
pub const FELANG_CLMN_NOWBREAK = @as(u32, 2);
pub const FELANG_CLMN_PBREAK = @as(u32, 4);
pub const FELANG_CLMN_NOPBREAK = @as(u32, 8);
pub const FELANG_CLMN_FIXR = @as(u32, 16);
pub const FELANG_CLMN_FIXD = @as(u32, 32);
pub const FELANG_INVALD_PO = @as(u32, 65535);
pub const IFED_POS_NONE = @as(u32, 0);
pub const IFED_POS_NOUN = @as(u32, 1);
pub const IFED_POS_VERB = @as(u32, 2);
pub const IFED_POS_ADJECTIVE = @as(u32, 4);
pub const IFED_POS_ADJECTIVE_VERB = @as(u32, 8);
pub const IFED_POS_ADVERB = @as(u32, 16);
pub const IFED_POS_ADNOUN = @as(u32, 32);
pub const IFED_POS_CONJUNCTION = @as(u32, 64);
pub const IFED_POS_INTERJECTION = @as(u32, 128);
pub const IFED_POS_INDEPENDENT = @as(u32, 255);
pub const IFED_POS_INFLECTIONALSUFFIX = @as(u32, 256);
pub const IFED_POS_PREFIX = @as(u32, 512);
pub const IFED_POS_SUFFIX = @as(u32, 1024);
pub const IFED_POS_AFFIX = @as(u32, 1536);
pub const IFED_POS_TANKANJI = @as(u32, 2048);
pub const IFED_POS_IDIOMS = @as(u32, 4096);
pub const IFED_POS_SYMBOLS = @as(u32, 8192);
pub const IFED_POS_PARTICLE = @as(u32, 16384);
pub const IFED_POS_AUXILIARY_VERB = @as(u32, 32768);
pub const IFED_POS_SUB_VERB = @as(u32, 65536);
pub const IFED_POS_DEPENDENT = @as(u32, 114688);
pub const IFED_POS_ALL = @as(u32, 131071);
pub const IFED_SELECT_NONE = @as(u32, 0);
pub const IFED_SELECT_READING = @as(u32, 1);
pub const IFED_SELECT_DISPLAY = @as(u32, 2);
pub const IFED_SELECT_POS = @as(u32, 4);
pub const IFED_SELECT_COMMENT = @as(u32, 8);
pub const IFED_SELECT_ALL = @as(u32, 15);
pub const IFED_REG_NONE = @as(u32, 0);
pub const IFED_REG_USER = @as(u32, 1);
pub const IFED_REG_AUTO = @as(u32, 2);
pub const IFED_REG_GRAMMAR = @as(u32, 4);
pub const IFED_REG_ALL = @as(u32, 7);
pub const IFED_TYPE_NONE = @as(u32, 0);
pub const IFED_TYPE_GENERAL = @as(u32, 1);
pub const IFED_TYPE_NAMEPLACE = @as(u32, 2);
pub const IFED_TYPE_SPEECH = @as(u32, 4);
pub const IFED_TYPE_REVERSE = @as(u32, 8);
pub const IFED_TYPE_ENGLISH = @as(u32, 16);
pub const IFED_TYPE_ALL = @as(u32, 31);
pub const IFED_S_MORE_ENTRIES = @import("zig.zig").typedConst(HRESULT, @as(i32, 291328));
pub const IFED_S_EMPTY_DICTIONARY = @import("zig.zig").typedConst(HRESULT, @as(i32, 291329));
pub const IFED_S_WORD_EXISTS = @import("zig.zig").typedConst(HRESULT, @as(i32, 291330));
pub const IFED_S_COMMENT_CHANGED = @import("zig.zig").typedConst(HRESULT, @as(i32, 291331));
pub const IFED_E_NOT_FOUND = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192064));
pub const IFED_E_INVALID_FORMAT = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192063));
pub const IFED_E_OPEN_FAILED = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192062));
pub const IFED_E_WRITE_FAILED = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192061));
pub const IFED_E_NO_ENTRY = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192060));
pub const IFED_E_REGISTER_FAILED = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192059));
pub const IFED_E_NOT_USER_DIC = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192058));
pub const IFED_E_NOT_SUPPORTED = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192057));
pub const IFED_E_USER_COMMENT = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192056));
pub const IFED_E_REGISTER_ILLEGAL_POS = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192055));
pub const IFED_E_REGISTER_IMPROPER_WORD = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192054));
pub const IFED_E_REGISTER_DISCONNECTED = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147192053));
pub const POS_UNDEFINED = @as(u32, 0);
pub const JPOS_MEISHI_FUTSU = @as(u32, 100);
pub const JPOS_MEISHI_SAHEN = @as(u32, 101);
pub const JPOS_MEISHI_ZAHEN = @as(u32, 102);
pub const JPOS_MEISHI_KEIYOUDOUSHI = @as(u32, 103);
pub const JPOS_HUKUSIMEISHI = @as(u32, 104);
pub const JPOS_MEISA_KEIDOU = @as(u32, 105);
pub const JPOS_JINMEI = @as(u32, 106);
pub const JPOS_JINMEI_SEI = @as(u32, 107);
pub const JPOS_JINMEI_MEI = @as(u32, 108);
pub const JPOS_CHIMEI = @as(u32, 109);
pub const JPOS_CHIMEI_KUNI = @as(u32, 110);
pub const JPOS_CHIMEI_KEN = @as(u32, 111);
pub const JPOS_CHIMEI_GUN = @as(u32, 112);
pub const JPOS_CHIMEI_KU = @as(u32, 113);
pub const JPOS_CHIMEI_SHI = @as(u32, 114);
pub const JPOS_CHIMEI_MACHI = @as(u32, 115);
pub const JPOS_CHIMEI_MURA = @as(u32, 116);
pub const JPOS_CHIMEI_EKI = @as(u32, 117);
pub const JPOS_SONOTA = @as(u32, 118);
pub const JPOS_SHAMEI = @as(u32, 119);
pub const JPOS_SOSHIKI = @as(u32, 120);
pub const JPOS_KENCHIKU = @as(u32, 121);
pub const JPOS_BUPPIN = @as(u32, 122);
pub const JPOS_DAIMEISHI = @as(u32, 123);
pub const JPOS_DAIMEISHI_NINSHOU = @as(u32, 124);
pub const JPOS_DAIMEISHI_SHIJI = @as(u32, 125);
pub const JPOS_KAZU = @as(u32, 126);
pub const JPOS_KAZU_SURYOU = @as(u32, 127);
pub const JPOS_KAZU_SUSHI = @as(u32, 128);
pub const JPOS_5DAN_AWA = @as(u32, 200);
pub const JPOS_5DAN_KA = @as(u32, 201);
pub const JPOS_5DAN_GA = @as(u32, 202);
pub const JPOS_5DAN_SA = @as(u32, 203);
pub const JPOS_5DAN_TA = @as(u32, 204);
pub const JPOS_5DAN_NA = @as(u32, 205);
pub const JPOS_5DAN_BA = @as(u32, 206);
pub const JPOS_5DAN_MA = @as(u32, 207);
pub const JPOS_5DAN_RA = @as(u32, 208);
pub const JPOS_5DAN_AWAUON = @as(u32, 209);
pub const JPOS_5DAN_KASOKUON = @as(u32, 210);
pub const JPOS_5DAN_RAHEN = @as(u32, 211);
pub const JPOS_4DAN_HA = @as(u32, 212);
pub const JPOS_1DAN = @as(u32, 213);
pub const JPOS_TOKUSHU_KAHEN = @as(u32, 214);
pub const JPOS_TOKUSHU_SAHENSURU = @as(u32, 215);
pub const JPOS_TOKUSHU_SAHEN = @as(u32, 216);
pub const JPOS_TOKUSHU_ZAHEN = @as(u32, 217);
pub const JPOS_TOKUSHU_NAHEN = @as(u32, 218);
pub const JPOS_KURU_KI = @as(u32, 219);
pub const JPOS_KURU_KITA = @as(u32, 220);
pub const JPOS_KURU_KITARA = @as(u32, 221);
pub const JPOS_KURU_KITARI = @as(u32, 222);
pub const JPOS_KURU_KITAROU = @as(u32, 223);
pub const JPOS_KURU_KITE = @as(u32, 224);
pub const JPOS_KURU_KUREBA = @as(u32, 225);
pub const JPOS_KURU_KO = @as(u32, 226);
pub const JPOS_KURU_KOI = @as(u32, 227);
pub const JPOS_KURU_KOYOU = @as(u32, 228);
pub const JPOS_SURU_SA = @as(u32, 229);
pub const JPOS_SURU_SI = @as(u32, 230);
pub const JPOS_SURU_SITA = @as(u32, 231);
pub const JPOS_SURU_SITARA = @as(u32, 232);
pub const JPOS_SURU_SIATRI = @as(u32, 233);
pub const JPOS_SURU_SITAROU = @as(u32, 234);
pub const JPOS_SURU_SITE = @as(u32, 235);
pub const JPOS_SURU_SIYOU = @as(u32, 236);
pub const JPOS_SURU_SUREBA = @as(u32, 237);
pub const JPOS_SURU_SE = @as(u32, 238);
pub const JPOS_SURU_SEYO = @as(u32, 239);
pub const JPOS_KEIYOU = @as(u32, 300);
pub const JPOS_KEIYOU_GARU = @as(u32, 301);
pub const JPOS_KEIYOU_GE = @as(u32, 302);
pub const JPOS_KEIYOU_ME = @as(u32, 303);
pub const JPOS_KEIYOU_YUU = @as(u32, 304);
pub const JPOS_KEIYOU_U = @as(u32, 305);
pub const JPOS_KEIDOU = @as(u32, 400);
pub const JPOS_KEIDOU_NO = @as(u32, 401);
pub const JPOS_KEIDOU_TARU = @as(u32, 402);
pub const JPOS_KEIDOU_GARU = @as(u32, 403);
pub const JPOS_FUKUSHI = @as(u32, 500);
pub const JPOS_FUKUSHI_SAHEN = @as(u32, 501);
pub const JPOS_FUKUSHI_NI = @as(u32, 502);
pub const JPOS_FUKUSHI_NANO = @as(u32, 503);
pub const JPOS_FUKUSHI_DA = @as(u32, 504);
pub const JPOS_FUKUSHI_TO = @as(u32, 505);
pub const JPOS_FUKUSHI_TOSURU = @as(u32, 506);
pub const JPOS_RENTAISHI = @as(u32, 600);
pub const JPOS_RENTAISHI_SHIJI = @as(u32, 601);
pub const JPOS_SETSUZOKUSHI = @as(u32, 650);
pub const JPOS_KANDOUSHI = @as(u32, 670);
pub const JPOS_SETTOU = @as(u32, 700);
pub const JPOS_SETTOU_KAKU = @as(u32, 701);
pub const JPOS_SETTOU_SAI = @as(u32, 702);
pub const JPOS_SETTOU_FUKU = @as(u32, 703);
pub const JPOS_SETTOU_MI = @as(u32, 704);
pub const JPOS_SETTOU_DAISHOU = @as(u32, 705);
pub const JPOS_SETTOU_KOUTEI = @as(u32, 706);
pub const JPOS_SETTOU_CHOUTAN = @as(u32, 707);
pub const JPOS_SETTOU_SHINKYU = @as(u32, 708);
pub const JPOS_SETTOU_JINMEI = @as(u32, 709);
pub const JPOS_SETTOU_CHIMEI = @as(u32, 710);
pub const JPOS_SETTOU_SONOTA = @as(u32, 711);
pub const JPOS_SETTOU_JOSUSHI = @as(u32, 712);
pub const JPOS_SETTOU_TEINEI_O = @as(u32, 713);
pub const JPOS_SETTOU_TEINEI_GO = @as(u32, 714);
pub const JPOS_SETTOU_TEINEI_ON = @as(u32, 715);
pub const JPOS_SETSUBI = @as(u32, 800);
pub const JPOS_SETSUBI_TEKI = @as(u32, 801);
pub const JPOS_SETSUBI_SEI = @as(u32, 802);
pub const JPOS_SETSUBI_KA = @as(u32, 803);
pub const JPOS_SETSUBI_CHU = @as(u32, 804);
pub const JPOS_SETSUBI_FU = @as(u32, 805);
pub const JPOS_SETSUBI_RYU = @as(u32, 806);
pub const JPOS_SETSUBI_YOU = @as(u32, 807);
pub const JPOS_SETSUBI_KATA = @as(u32, 808);
pub const JPOS_SETSUBI_MEISHIRENDAKU = @as(u32, 809);
pub const JPOS_SETSUBI_JINMEI = @as(u32, 810);
pub const JPOS_SETSUBI_CHIMEI = @as(u32, 811);
pub const JPOS_SETSUBI_KUNI = @as(u32, 812);
pub const JPOS_SETSUBI_KEN = @as(u32, 813);
pub const JPOS_SETSUBI_GUN = @as(u32, 814);
pub const JPOS_SETSUBI_KU = @as(u32, 815);
pub const JPOS_SETSUBI_SHI = @as(u32, 816);
pub const JPOS_SETSUBI_MACHI = @as(u32, 817);
pub const JPOS_SETSUBI_CHOU = @as(u32, 818);
pub const JPOS_SETSUBI_MURA = @as(u32, 819);
pub const JPOS_SETSUBI_SON = @as(u32, 820);
pub const JPOS_SETSUBI_EKI = @as(u32, 821);
pub const JPOS_SETSUBI_SONOTA = @as(u32, 822);
pub const JPOS_SETSUBI_SHAMEI = @as(u32, 823);
pub const JPOS_SETSUBI_SOSHIKI = @as(u32, 824);
pub const JPOS_SETSUBI_KENCHIKU = @as(u32, 825);
pub const JPOS_RENYOU_SETSUBI = @as(u32, 826);
pub const JPOS_SETSUBI_JOSUSHI = @as(u32, 827);
pub const JPOS_SETSUBI_JOSUSHIPLUS = @as(u32, 828);
pub const JPOS_SETSUBI_JIKAN = @as(u32, 829);
pub const JPOS_SETSUBI_JIKANPLUS = @as(u32, 830);
pub const JPOS_SETSUBI_TEINEI = @as(u32, 831);
pub const JPOS_SETSUBI_SAN = @as(u32, 832);
pub const JPOS_SETSUBI_KUN = @as(u32, 833);
pub const JPOS_SETSUBI_SAMA = @as(u32, 834);
pub const JPOS_SETSUBI_DONO = @as(u32, 835);
pub const JPOS_SETSUBI_FUKUSU = @as(u32, 836);
pub const JPOS_SETSUBI_TACHI = @as(u32, 837);
pub const JPOS_SETSUBI_RA = @as(u32, 838);
pub const JPOS_TANKANJI = @as(u32, 900);
pub const JPOS_TANKANJI_KAO = @as(u32, 901);
pub const JPOS_KANYOUKU = @as(u32, 902);
pub const JPOS_DOKURITSUGO = @as(u32, 903);
pub const JPOS_FUTEIGO = @as(u32, 904);
pub const JPOS_KIGOU = @as(u32, 905);
pub const JPOS_EIJI = @as(u32, 906);
pub const JPOS_KUTEN = @as(u32, 907);
pub const JPOS_TOUTEN = @as(u32, 908);
pub const JPOS_KANJI = @as(u32, 909);
pub const JPOS_OPENBRACE = @as(u32, 910);
pub const JPOS_CLOSEBRACE = @as(u32, 911);
pub const JPOS_YOKUSEI = @as(u32, 912);
pub const JPOS_TANSHUKU = @as(u32, 913);
pub const VERSION_ID_JAPANESE = @as(u32, 16777216);
pub const VERSION_ID_KOREAN = @as(u32, 33554432);
pub const VERSION_ID_CHINESE_TRADITIONAL = @as(u32, 67108864);
pub const VERSION_ID_CHINESE_SIMPLIFIED = @as(u32, 134217728);
pub const FID_MSIME_VERSION = @as(u32, 0);
pub const VERSION_MOUSE_OPERATION = @as(u32, 1);
pub const IMEMOUSERET_NOTHANDLED = @as(i32, -1);
pub const IMEMOUSE_VERSION = @as(u32, 255);
pub const IMEMOUSE_NONE = @as(u32, 0);
pub const IMEMOUSE_LDOWN = @as(u32, 1);
pub const IMEMOUSE_RDOWN = @as(u32, 2);
pub const IMEMOUSE_MDOWN = @as(u32, 4);
pub const IMEMOUSE_WUP = @as(u32, 16);
pub const IMEMOUSE_WDOWN = @as(u32, 32);
pub const FID_RECONVERT_VERSION = @as(u32, 268435456);
pub const VERSION_RECONVERSION = @as(u32, 1);
pub const VERSION_DOCUMENTFEED = @as(u32, 1);
pub const VERSION_QUERYPOSITION = @as(u32, 1);
pub const VERSION_MODEBIAS = @as(u32, 1);
pub const MODEBIAS_GETVERSION = @as(u32, 0);
pub const MODEBIAS_SETVALUE = @as(u32, 1);
pub const MODEBIAS_GETVALUE = @as(u32, 2);
pub const MODEBIASMODE_DEFAULT = @as(u32, 0);
pub const MODEBIASMODE_FILENAME = @as(u32, 1);
pub const MODEBIASMODE_READING = @as(u32, 2);
pub const MODEBIASMODE_DIGIT = @as(u32, 4);
pub const SHOWIMEPAD_DEFAULT = @as(u32, 0);
pub const SHOWIMEPAD_CATEGORY = @as(u32, 1);
pub const SHOWIMEPAD_GUID = @as(u32, 2);
pub const FID_MSIME_KMS_VERSION = @as(u32, 1);
pub const FID_MSIME_KMS_INIT = @as(u32, 2);
pub const FID_MSIME_KMS_TERM = @as(u32, 3);
pub const FID_MSIME_KMS_DEL_KEYLIST = @as(u32, 4);
pub const FID_MSIME_KMS_NOTIFY = @as(u32, 5);
pub const FID_MSIME_KMS_GETMAP = @as(u32, 6);
pub const FID_MSIME_KMS_INVOKE = @as(u32, 7);
pub const FID_MSIME_KMS_SETMAP = @as(u32, 8);
pub const FID_MSIME_KMS_FUNCDESC = @as(u32, 9);
pub const FID_MSIME_KMS_GETMAPSEAMLESS = @as(u32, 10);
pub const FID_MSIME_KMS_GETMAPFAST = @as(u32, 11);
pub const IMEKMS_NOCOMPOSITION = @as(u32, 0);
pub const IMEKMS_COMPOSITION = @as(u32, 1);
pub const IMEKMS_SELECTION = @as(u32, 2);
pub const IMEKMS_IMEOFF = @as(u32, 3);
pub const IMEKMS_2NDLEVEL = @as(u32, 4);
pub const IMEKMS_INPTGL = @as(u32, 5);
pub const IMEKMS_CANDIDATE = @as(u32, 6);
pub const IMEKMS_TYPECAND = @as(u32, 7);
pub const RECONVOPT_NONE = @as(u32, 0);
pub const RECONVOPT_USECANCELNOTIFY = @as(u32, 1);
pub const GCSEX_CANCELRECONVERT = @as(u32, 268435456);
pub const STYLE_DESCRIPTION_SIZE = @as(u32, 32);
pub const IMEMENUITEM_STRING_SIZE = @as(u32, 80);
pub const IMC_GETCANDIDATEPOS = @as(u32, 7);
pub const IMC_SETCANDIDATEPOS = @as(u32, 8);
pub const IMC_GETCOMPOSITIONFONT = @as(u32, 9);
pub const IMC_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMC_GETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMC_SETCOMPOSITIONWINDOW = @as(u32, 12);
pub const IMC_GETSTATUSWINDOWPOS = @as(u32, 15);
pub const IMC_SETSTATUSWINDOWPOS = @as(u32, 16);
pub const IMC_CLOSESTATUSWINDOW = @as(u32, 33);
pub const IMC_OPENSTATUSWINDOW = @as(u32, 34);
pub const NI_FINALIZECONVERSIONRESULT = @as(u32, 20);
pub const ISC_SHOWUICANDIDATEWINDOW = @as(u32, 1);
pub const ISC_SHOWUICOMPOSITIONWINDOW = @as(u32, 2147483648);
pub const ISC_SHOWUIGUIDELINE = @as(u32, 1073741824);
pub const ISC_SHOWUIALLCANDIDATEWINDOW = @as(u32, 15);
pub const ISC_SHOWUIALL = @as(u32, 3221225487);
pub const MOD_LEFT = @as(u32, 32768);
pub const MOD_RIGHT = @as(u32, 16384);
pub const MOD_ON_KEYUP = @as(u32, 2048);
pub const MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const IME_CHOTKEY_IME_NONIME_TOGGLE = @as(u32, 16);
pub const IME_CHOTKEY_SHAPE_TOGGLE = @as(u32, 17);
pub const IME_CHOTKEY_SYMBOL_TOGGLE = @as(u32, 18);
pub const IME_JHOTKEY_CLOSE_OPEN = @as(u32, 48);
pub const IME_KHOTKEY_SHAPE_TOGGLE = @as(u32, 80);
pub const IME_KHOTKEY_HANJACONVERT = @as(u32, 81);
pub const IME_KHOTKEY_ENGLISH = @as(u32, 82);
pub const IME_THOTKEY_IME_NONIME_TOGGLE = @as(u32, 112);
pub const IME_THOTKEY_SHAPE_TOGGLE = @as(u32, 113);
pub const IME_THOTKEY_SYMBOL_TOGGLE = @as(u32, 114);
pub const IME_HOTKEY_DSWITCH_FIRST = @as(u32, 256);
pub const IME_HOTKEY_DSWITCH_LAST = @as(u32, 287);
pub const IME_HOTKEY_PRIVATE_FIRST = @as(u32, 512);
pub const IME_ITHOTKEY_RESEND_RESULTSTR = @as(u32, 512);
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION = @as(u32, 513);
pub const IME_ITHOTKEY_UISTYLE_TOGGLE = @as(u32, 514);
pub const IME_ITHOTKEY_RECONVERTSTRING = @as(u32, 515);
pub const IME_HOTKEY_PRIVATE_LAST = @as(u32, 543);
pub const GCS_COMPREADSTR = @as(u32, 1);
pub const GCS_COMPREADATTR = @as(u32, 2);
pub const GCS_COMPREADCLAUSE = @as(u32, 4);
pub const GCS_COMPSTR = @as(u32, 8);
pub const GCS_COMPATTR = @as(u32, 16);
pub const GCS_COMPCLAUSE = @as(u32, 32);
pub const GCS_CURSORPOS = @as(u32, 128);
pub const GCS_DELTASTART = @as(u32, 256);
pub const GCS_RESULTREADSTR = @as(u32, 512);
pub const GCS_RESULTREADCLAUSE = @as(u32, 1024);
pub const GCS_RESULTSTR = @as(u32, 2048);
pub const GCS_RESULTCLAUSE = @as(u32, 4096);
pub const CS_INSERTCHAR = @as(u32, 8192);
pub const CS_NOMOVECARET = @as(u32, 16384);
pub const IMEVER_0310 = @as(u32, 196618);
pub const IMEVER_0400 = @as(u32, 262144);
pub const IME_PROP_AT_CARET = @as(u32, 65536);
pub const IME_PROP_SPECIAL_UI = @as(u32, 131072);
pub const IME_PROP_CANDLIST_START_FROM_1 = @as(u32, 262144);
pub const IME_PROP_UNICODE = @as(u32, 524288);
pub const IME_PROP_COMPLETE_ON_UNSELECT = @as(u32, 1048576);
pub const UI_CAP_2700 = @as(u32, 1);
pub const UI_CAP_ROT90 = @as(u32, 2);
pub const UI_CAP_ROTANY = @as(u32, 4);
pub const SCS_CAP_COMPSTR = @as(u32, 1);
pub const SCS_CAP_MAKEREAD = @as(u32, 2);
pub const SCS_CAP_SETRECONVERTSTRING = @as(u32, 4);
pub const SELECT_CAP_CONVERSION = @as(u32, 1);
pub const SELECT_CAP_SENTENCE = @as(u32, 2);
pub const GL_LEVEL_NOGUIDELINE = @as(u32, 0);
pub const GL_LEVEL_FATAL = @as(u32, 1);
pub const GL_LEVEL_ERROR = @as(u32, 2);
pub const GL_LEVEL_WARNING = @as(u32, 3);
pub const GL_LEVEL_INFORMATION = @as(u32, 4);
pub const GL_ID_UNKNOWN = @as(u32, 0);
pub const GL_ID_NOMODULE = @as(u32, 1);
pub const GL_ID_NODICTIONARY = @as(u32, 16);
pub const GL_ID_CANNOTSAVE = @as(u32, 17);
pub const GL_ID_NOCONVERT = @as(u32, 32);
pub const GL_ID_TYPINGERROR = @as(u32, 33);
pub const GL_ID_TOOMANYSTROKE = @as(u32, 34);
pub const GL_ID_READINGCONFLICT = @as(u32, 35);
pub const GL_ID_INPUTREADING = @as(u32, 36);
pub const GL_ID_INPUTRADICAL = @as(u32, 37);
pub const GL_ID_INPUTCODE = @as(u32, 38);
pub const GL_ID_INPUTSYMBOL = @as(u32, 39);
pub const GL_ID_CHOOSECANDIDATE = @as(u32, 40);
pub const GL_ID_REVERSECONVERSION = @as(u32, 41);
pub const GL_ID_PRIVATE_FIRST = @as(u32, 32768);
pub const GL_ID_PRIVATE_LAST = @as(u32, 65535);
pub const ATTR_INPUT = @as(u32, 0);
pub const ATTR_TARGET_CONVERTED = @as(u32, 1);
pub const ATTR_CONVERTED = @as(u32, 2);
pub const ATTR_TARGET_NOTCONVERTED = @as(u32, 3);
pub const ATTR_INPUT_ERROR = @as(u32, 4);
pub const ATTR_FIXEDCONVERTED = @as(u32, 5);
pub const CFS_DEFAULT = @as(u32, 0);
pub const CFS_RECT = @as(u32, 1);
pub const CFS_POINT = @as(u32, 2);
pub const CFS_FORCE_POSITION = @as(u32, 32);
pub const CFS_CANDIDATEPOS = @as(u32, 64);
pub const CFS_EXCLUDE = @as(u32, 128);
pub const IME_CMODE_SOFTKBD = @as(u32, 128);
pub const IME_CMODE_NOCONVERSION = @as(u32, 256);
pub const IME_CMODE_EUDC = @as(u32, 512);
pub const IME_CMODE_SYMBOL = @as(u32, 1024);
pub const IME_CMODE_FIXED = @as(u32, 2048);
pub const IME_CMODE_RESERVED = @as(u32, 4026531840);
pub const IME_SMODE_NONE = @as(u32, 0);
pub const IME_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IME_SMODE_SINGLECONVERT = @as(u32, 2);
pub const IME_SMODE_AUTOMATIC = @as(u32, 4);
pub const IME_SMODE_PHRASEPREDICT = @as(u32, 8);
pub const IME_SMODE_CONVERSATION = @as(u32, 16);
pub const IME_SMODE_RESERVED = @as(u32, 61440);
pub const IME_CAND_UNKNOWN = @as(u32, 0);
pub const IME_CAND_READ = @as(u32, 1);
pub const IME_CAND_CODE = @as(u32, 2);
pub const IME_CAND_MEANING = @as(u32, 3);
pub const IME_CAND_RADICAL = @as(u32, 4);
pub const IME_CAND_STROKE = @as(u32, 5);
pub const IMN_CLOSESTATUSWINDOW = @as(u32, 1);
pub const IMN_OPENSTATUSWINDOW = @as(u32, 2);
pub const IMN_CHANGECANDIDATE = @as(u32, 3);
pub const IMN_CLOSECANDIDATE = @as(u32, 4);
pub const IMN_OPENCANDIDATE = @as(u32, 5);
pub const IMN_SETCONVERSIONMODE = @as(u32, 6);
pub const IMN_SETSENTENCEMODE = @as(u32, 7);
pub const IMN_SETOPENSTATUS = @as(u32, 8);
pub const IMN_SETCANDIDATEPOS = @as(u32, 9);
pub const IMN_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMN_SETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMN_SETSTATUSWINDOWPOS = @as(u32, 12);
pub const IMN_GUIDELINE = @as(u32, 13);
pub const IMN_PRIVATE = @as(u32, 14);
pub const IMR_COMPOSITIONWINDOW = @as(u32, 1);
pub const IMR_CANDIDATEWINDOW = @as(u32, 2);
pub const IMR_COMPOSITIONFONT = @as(u32, 3);
pub const IMR_RECONVERTSTRING = @as(u32, 4);
pub const IMR_CONFIRMRECONVERTSTRING = @as(u32, 5);
pub const IMR_QUERYCHARPOSITION = @as(u32, 6);
pub const IMR_DOCUMENTFEED = @as(u32, 7);
pub const IMM_ERROR_NODATA = @as(i32, -1);
pub const IMM_ERROR_GENERAL = @as(i32, -2);
pub const IME_CONFIG_GENERAL = @as(u32, 1);
pub const IME_CONFIG_REGISTERWORD = @as(u32, 2);
pub const IME_CONFIG_SELECTDICTIONARY = @as(u32, 3);
pub const IME_ESC_QUERY_SUPPORT = @as(u32, 3);
pub const IME_ESC_RESERVED_FIRST = @as(u32, 4);
pub const IME_ESC_RESERVED_LAST = @as(u32, 2047);
pub const IME_ESC_PRIVATE_FIRST = @as(u32, 2048);
pub const IME_ESC_PRIVATE_LAST = @as(u32, 4095);
pub const IME_ESC_SEQUENCE_TO_INTERNAL = @as(u32, 4097);
pub const IME_ESC_GET_EUDC_DICTIONARY = @as(u32, 4099);
pub const IME_ESC_SET_EUDC_DICTIONARY = @as(u32, 4100);
pub const IME_ESC_MAX_KEY = @as(u32, 4101);
pub const IME_ESC_IME_NAME = @as(u32, 4102);
pub const IME_ESC_SYNC_HOTKEY = @as(u32, 4103);
pub const IME_ESC_HANJA_MODE = @as(u32, 4104);
pub const IME_ESC_AUTOMATA = @as(u32, 4105);
pub const IME_ESC_PRIVATE_HOTKEY = @as(u32, 4106);
pub const IME_ESC_GETHELPFILENAME = @as(u32, 4107);
pub const IME_REGWORD_STYLE_EUDC = @as(u32, 1);
pub const IME_REGWORD_STYLE_USER_FIRST = @as(u32, 2147483648);
pub const IME_REGWORD_STYLE_USER_LAST = @as(u32, 4294967295);
pub const IACE_CHILDREN = @as(u32, 1);
pub const IACE_DEFAULT = @as(u32, 16);
pub const IACE_IGNORENOCONTEXT = @as(u32, 32);
pub const IGIMIF_RIGHTMENU = @as(u32, 1);
pub const IGIMII_CMODE = @as(u32, 1);
pub const IGIMII_SMODE = @as(u32, 2);
pub const IGIMII_CONFIGURE = @as(u32, 4);
pub const IGIMII_TOOLS = @as(u32, 8);
pub const IGIMII_HELP = @as(u32, 16);
pub const IGIMII_OTHER = @as(u32, 32);
pub const IGIMII_INPUTTOOLS = @as(u32, 64);
pub const IMFT_RADIOCHECK = @as(u32, 1);
pub const IMFT_SEPARATOR = @as(u32, 2);
pub const IMFT_SUBMENU = @as(u32, 4);
pub const SOFTKEYBOARD_TYPE_T1 = @as(u32, 1);
pub const SOFTKEYBOARD_TYPE_C1 = @as(u32, 2);
pub const IMMGWL_IMC = @as(u32, 0);
pub const IMMGWLP_IMC = @as(u32, 0);
pub const IMC_SETCONVERSIONMODE = @as(u32, 2);
pub const IMC_SETSENTENCEMODE = @as(u32, 4);
pub const IMC_SETOPENSTATUS = @as(u32, 6);
pub const IMC_GETSOFTKBDFONT = @as(u32, 17);
pub const IMC_SETSOFTKBDFONT = @as(u32, 18);
pub const IMC_GETSOFTKBDPOS = @as(u32, 19);
pub const IMC_SETSOFTKBDPOS = @as(u32, 20);
pub const IMC_GETSOFTKBDSUBTYPE = @as(u32, 21);
pub const IMC_SETSOFTKBDSUBTYPE = @as(u32, 22);
pub const IMC_SETSOFTKBDDATA = @as(u32, 24);
pub const NI_CONTEXTUPDATED = @as(u32, 3);
pub const IME_SYSINFO_WINLOGON = @as(u32, 1);
pub const IME_SYSINFO_WOW16 = @as(u32, 2);
pub const INIT_STATUSWNDPOS = @as(u32, 1);
pub const INIT_CONVERSION = @as(u32, 2);
pub const INIT_SENTENCE = @as(u32, 4);
pub const INIT_LOGFONT = @as(u32, 8);
pub const INIT_COMPFORM = @as(u32, 16);
pub const INIT_SOFTKBDPOS = @as(u32, 32);
pub const IME_PROP_END_UNLOAD = @as(u32, 1);
pub const IME_PROP_KBD_CHAR_FIRST = @as(u32, 2);
pub const IME_PROP_IGNORE_UPKEYS = @as(u32, 4);
pub const IME_PROP_NEED_ALTKEY = @as(u32, 8);
pub const IME_PROP_NO_KEYS_ON_CLOSE = @as(u32, 16);
pub const IME_PROP_ACCEPT_WIDE_VKEY = @as(u32, 32);
pub const UI_CAP_SOFTKBD = @as(u32, 65536);
pub const IMN_SOFTKBDDESTROYED = @as(u32, 17);
pub const IME_UI_CLASS_NAME_SIZE = @as(u32, 16);
pub const IME_ESC_STRING_BUFFER_SIZE = @as(u32, 80);
pub const CATID_MSIME_IImePadApplet_VER7 = Guid.initString("4a0f8e31-c3ee-11d1-afef-00805f0c8b6d");
pub const CATID_MSIME_IImePadApplet_VER80 = Guid.initString("56f7a792-fef1-11d3-8463-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet_VER81 = Guid.initString("656520b0-bb88-11d4-84c0-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet900 = Guid.initString("faae51bf-5e5b-4a1d-8de1-17c1d9e1728d");
pub const CATID_MSIME_IImePadApplet1000 = Guid.initString("e081e1d6-2389-43cb-b66f-609f823d9f9c");
pub const CATID_MSIME_IImePadApplet1200 = Guid.initString("a47fb5fc-7d15-4223-a789-b781bf9ae667");
pub const CATID_MSIME_IImePadApplet = Guid.initString("7566cad1-4ec9-4478-9fe9-8ed766619edf");
pub const FEID_NONE = @as(u32, 0);
pub const FEID_CHINESE_TRADITIONAL = @as(u32, 1);
pub const FEID_CHINESE_SIMPLIFIED = @as(u32, 2);
pub const FEID_CHINESE_HONGKONG = @as(u32, 3);
pub const FEID_CHINESE_SINGAPORE = @as(u32, 4);
pub const FEID_JAPANESE = @as(u32, 5);
pub const FEID_KOREAN = @as(u32, 6);
pub const FEID_KOREAN_JOHAB = @as(u32, 7);
pub const INFOMASK_NONE = @as(u32, 0);
pub const INFOMASK_QUERY_CAND = @as(u32, 1);
pub const INFOMASK_APPLY_CAND = @as(u32, 2);
pub const INFOMASK_APPLY_CAND_EX = @as(u32, 4);
pub const INFOMASK_STRING_FIX = @as(u32, 65536);
pub const INFOMASK_HIDE_CAND = @as(u32, 131072);
pub const INFOMASK_BLOCK_CAND = @as(u32, 262144);
pub const IMEFAREASTINFO_TYPE_DEFAULT = @as(u32, 0);
pub const IMEFAREASTINFO_TYPE_READING = @as(u32, 1);
pub const IMEFAREASTINFO_TYPE_COMMENT = @as(u32, 2);
pub const IMEFAREASTINFO_TYPE_COSTTIME = @as(u32, 3);
pub const CHARINFO_APPLETID_MASK = @as(u32, 4278190080);
pub const CHARINFO_FEID_MASK = @as(u32, 15728640);
pub const CHARINFO_CHARID_MASK = @as(u32, 65535);
pub const MAX_APPLETTITLE = @as(u32, 64);
pub const MAX_FONTFACE = @as(u32, 32);
pub const IPACFG_NONE = @as(i32, 0);
pub const IPACFG_PROPERTY = @as(i32, 1);
pub const IPACFG_HELP = @as(i32, 2);
pub const IPACFG_TITLE = @as(i32, 65536);
pub const IPACFG_TITLEFONTFACE = @as(i32, 131072);
pub const IPACFG_CATEGORY = @as(i32, 262144);
pub const IPACFG_LANG = @as(i32, 16);
pub const IPACID_NONE = @as(u32, 0);
pub const IPACID_SOFTKEY = @as(u32, 1);
pub const IPACID_HANDWRITING = @as(u32, 2);
pub const IPACID_STROKESEARCH = @as(u32, 3);
pub const IPACID_RADICALSEARCH = @as(u32, 4);
pub const IPACID_SYMBOLSEARCH = @as(u32, 5);
pub const IPACID_VOICE = @as(u32, 6);
pub const IPACID_EPWING = @as(u32, 7);
pub const IPACID_OCR = @as(u32, 8);
pub const IPACID_CHARLIST = @as(u32, 9);
pub const IPACID_USER = @as(u32, 256);
pub const IMEPADREQ_FIRST = @as(u32, 4096);
pub const IMEPADREQ_INSERTSTRINGCANDIDATE = @as(u32, 4098);
pub const IMEPADREQ_INSERTITEMCANDIDATE = @as(u32, 4099);
pub const IMEPADREQ_SENDKEYCONTROL = @as(u32, 4101);
pub const IMEPADREQ_GETSELECTEDSTRING = @as(u32, 4103);
pub const IMEPADREQ_SETAPPLETDATA = @as(u32, 4105);
pub const IMEPADREQ_GETAPPLETDATA = @as(u32, 4106);
pub const IMEPADREQ_SETTITLEFONT = @as(u32, 4107);
pub const IMEPADREQ_GETCOMPOSITIONSTRINGID = @as(u32, 4109);
pub const IMEPADREQ_INSERTSTRINGCANDIDATEINFO = @as(u32, 4110);
pub const IMEPADREQ_CHANGESTRINGCANDIDATEINFO = @as(u32, 4111);
pub const IMEPADREQ_INSERTSTRINGINFO = @as(u32, 4114);
pub const IMEPADREQ_CHANGESTRINGINFO = @as(u32, 4115);
pub const IMEPADREQ_GETCURRENTUILANGID = @as(u32, 4120);
pub const IMEPADCTRL_CONVERTALL = @as(u32, 1);
pub const IMEPADCTRL_DETERMINALL = @as(u32, 2);
pub const IMEPADCTRL_DETERMINCHAR = @as(u32, 3);
pub const IMEPADCTRL_CLEARALL = @as(u32, 4);
pub const IMEPADCTRL_CARETSET = @as(u32, 5);
pub const IMEPADCTRL_CARETLEFT = @as(u32, 6);
pub const IMEPADCTRL_CARETRIGHT = @as(u32, 7);
pub const IMEPADCTRL_CARETTOP = @as(u32, 8);
pub const IMEPADCTRL_CARETBOTTOM = @as(u32, 9);
pub const IMEPADCTRL_CARETBACKSPACE = @as(u32, 10);
pub const IMEPADCTRL_CARETDELETE = @as(u32, 11);
pub const IMEPADCTRL_PHRASEDELETE = @as(u32, 12);
pub const IMEPADCTRL_INSERTSPACE = @as(u32, 13);
pub const IMEPADCTRL_INSERTFULLSPACE = @as(u32, 14);
pub const IMEPADCTRL_INSERTHALFSPACE = @as(u32, 15);
pub const IMEPADCTRL_ONIME = @as(u32, 16);
pub const IMEPADCTRL_OFFIME = @as(u32, 17);
pub const IMEPADCTRL_ONPRECONVERSION = @as(u32, 18);
pub const IMEPADCTRL_OFFPRECONVERSION = @as(u32, 19);
pub const IMEPADCTRL_PHONETICCANDIDATE = @as(u32, 20);
pub const IMEKEYCTRLMASK_ALT = @as(u32, 1);
pub const IMEKEYCTRLMASK_CTRL = @as(u32, 2);
pub const IMEKEYCTRLMASK_SHIFT = @as(u32, 4);
pub const IMEKEYCTRL_UP = @as(u32, 1);
pub const IMEKEYCTRL_DOWN = @as(u32, 0);
pub const IMEPN_FIRST = @as(u32, 256);
pub const IMEPN_ACTIVATE = @as(u32, 257);
pub const IMEPN_INACTIVATE = @as(u32, 258);
pub const IMEPN_SHOW = @as(u32, 260);
pub const IMEPN_HIDE = @as(u32, 261);
pub const IMEPN_SIZECHANGING = @as(u32, 262);
pub const IMEPN_SIZECHANGED = @as(u32, 263);
pub const IMEPN_CONFIG = @as(u32, 264);
pub const IMEPN_HELP = @as(u32, 265);
pub const IMEPN_QUERYCAND = @as(u32, 266);
pub const IMEPN_APPLYCAND = @as(u32, 267);
pub const IMEPN_APPLYCANDEX = @as(u32, 268);
pub const IMEPN_SETTINGCHANGED = @as(u32, 269);
pub const IMEPN_USER = @as(u32, 356);
pub const IPAWS_ENABLED = @as(i32, 1);
pub const IPAWS_SIZINGNOTIFY = @as(i32, 4);
pub const IPAWS_VERTICALFIXED = @as(i32, 256);
pub const IPAWS_HORIZONTALFIXED = @as(i32, 512);
pub const IPAWS_SIZEFIXED = @as(i32, 768);
pub const IPAWS_MAXWIDTHFIXED = @as(i32, 4096);
pub const IPAWS_MAXHEIGHTFIXED = @as(i32, 8192);
pub const IPAWS_MAXSIZEFIXED = @as(i32, 12288);
pub const IPAWS_MINWIDTHFIXED = @as(i32, 65536);
pub const IPAWS_MINHEIGHTFIXED = @as(i32, 131072);
pub const IPAWS_MINSIZEFIXED = @as(i32, 196608);
pub const CLSID_ImePlugInDictDictionaryList_CHS = Guid.initString("7bf0129b-5bef-4de4-9b0b-5edb66ac2fa6");
pub const CLSID_ImePlugInDictDictionaryList_JPN = Guid.initString("4fe2776b-b0f9-4396-b5fc-e9d4cf1ec195");
pub const SCRIPT_UNDEFINED = @as(u32, 0);
pub const USP_E_SCRIPT_NOT_IN_FONT = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const SGCM_RTL = @as(u32, 1);
pub const SSA_PASSWORD = @as(u32, 1);
pub const SSA_TAB = @as(u32, 2);
pub const SSA_CLIP = @as(u32, 4);
pub const SSA_FIT = @as(u32, 8);
pub const SSA_DZWG = @as(u32, 16);
pub const SSA_FALLBACK = @as(u32, 32);
pub const SSA_BREAK = @as(u32, 64);
pub const SSA_GLYPHS = @as(u32, 128);
pub const SSA_RTL = @as(u32, 256);
pub const SSA_GCP = @as(u32, 512);
pub const SSA_HOTKEY = @as(u32, 1024);
pub const SSA_METAFILE = @as(u32, 2048);
pub const SSA_LINK = @as(u32, 4096);
pub const SSA_HIDEHOTKEY = @as(u32, 8192);
pub const SSA_HOTKEYONLY = @as(u32, 9216);
pub const SSA_FULLMEASURE = @as(u32, 67108864);
pub const SSA_LPKANSIFALLBACK = @as(u32, 134217728);
pub const SSA_PIDX = @as(u32, 268435456);
pub const SSA_LAYOUTRTL = @as(u32, 536870912);
pub const SSA_DONTGLYPH = @as(u32, 1073741824);
pub const SSA_NOKASHIDA = @as(u32, 2147483648);
pub const SCRIPT_DIGITSUBSTITUTE_CONTEXT = @as(u32, 0);
pub const SCRIPT_DIGITSUBSTITUTE_NONE = @as(u32, 1);
pub const SCRIPT_DIGITSUBSTITUTE_NATIONAL = @as(u32, 2);
pub const SCRIPT_DIGITSUBSTITUTE_TRADITIONAL = @as(u32, 3);
pub const UNISCRIBE_OPENTYPE = @as(u32, 256);
pub const SCRIPT_TAG_UNKNOWN = @as(u32, 0);
pub const MUI_LANGUAGE_EXACT = @as(u32, 16);
pub const NLS_CP_CPINFO = @as(u32, 268435456);
pub const NLS_CP_MBTOWC = @as(u32, 1073741824);
pub const NLS_CP_WCTOMB = @as(u32, 2147483648);
pub const U_DISABLE_RENAMING = @as(u32, 1);
pub const U_SHOW_CPLUSPLUS_API = @as(u32, 0);
pub const U_DEFAULT_SHOW_DRAFT = @as(u32, 0);
pub const U_HIDE_DRAFT_API = @as(u32, 1);
pub const U_HIDE_DEPRECATED_API = @as(u32, 1);
pub const U_HIDE_OBSOLETE_API = @as(u32, 1);
pub const U_HIDE_INTERNAL_API = @as(u32, 1);
pub const U_NO_DEFAULT_INCLUDE_UTF_HEADERS = @as(u32, 1);
pub const UCLN_NO_AUTO_CLEANUP = @as(u32, 1);
pub const U_OVERRIDE_CXX_ALLOCATION = @as(u32, 1);
pub const U_ENABLE_TRACING = @as(u32, 0);
pub const UCONFIG_ENABLE_PLUGINS = @as(u32, 0);
pub const U_ENABLE_DYLOAD = @as(u32, 1);
pub const U_CHECK_DYLOAD = @as(u32, 1);
pub const U_PF_UNKNOWN = @as(u32, 0);
pub const U_PF_WINDOWS = @as(u32, 1000);
pub const U_PF_MINGW = @as(u32, 1800);
pub const U_PF_CYGWIN = @as(u32, 1900);
pub const U_PF_HPUX = @as(u32, 2100);
pub const U_PF_SOLARIS = @as(u32, 2600);
pub const U_PF_BSD = @as(u32, 3000);
pub const U_PF_AIX = @as(u32, 3100);
pub const U_PF_IRIX = @as(u32, 3200);
pub const U_PF_DARWIN = @as(u32, 3500);
pub const U_PF_IPHONE = @as(u32, 3550);
pub const U_PF_QNX = @as(u32, 3700);
pub const U_PF_LINUX = @as(u32, 4000);
pub const U_PF_BROWSER_NATIVE_CLIENT = @as(u32, 4020);
pub const U_PF_ANDROID = @as(u32, 4050);
pub const U_PF_FUCHSIA = @as(u32, 4100);
pub const U_PF_OS390 = @as(u32, 9000);
pub const U_PF_OS400 = @as(u32, 9400);
pub const U_ASCII_FAMILY = @as(u32, 0);
pub const U_EBCDIC_FAMILY = @as(u32, 1);
pub const U_SIZEOF_UCHAR = @as(u32, 2);
pub const U_SENTINEL = @as(i32, -1);
pub const U8_MAX_LENGTH = @as(u32, 4);
pub const U16_MAX_LENGTH = @as(u32, 2);
pub const UTF_SIZE = @as(u32, 16);
pub const UTF8_ERROR_VALUE_1 = @as(u32, 21);
pub const UTF8_ERROR_VALUE_2 = @as(u32, 159);
pub const UTF_ERROR_VALUE = @as(u32, 65535);
pub const UTF8_MAX_CHAR_LENGTH = @as(u32, 4);
pub const UTF16_MAX_CHAR_LENGTH = @as(u32, 2);
pub const UTF32_MAX_CHAR_LENGTH = @as(u32, 1);
pub const U_COPYRIGHT_STRING_LENGTH = @as(u32, 128);
pub const U_MAX_VERSION_LENGTH = @as(u32, 4);
pub const U_MAX_VERSION_STRING_LENGTH = @as(u32, 20);
pub const U_MILLIS_PER_SECOND = @as(u32, 1000);
pub const U_MILLIS_PER_MINUTE = @as(u32, 60000);
pub const U_MILLIS_PER_HOUR = @as(u32, 3600000);
pub const U_MILLIS_PER_DAY = @as(u32, 86400000);
pub const U_COMBINED_IMPLEMENTATION = @as(u32, 1);
pub const U_SHAPE_LENGTH_GROW_SHRINK = @as(u32, 0);
pub const U_SHAPE_LAMALEF_RESIZE = @as(u32, 0);
pub const U_SHAPE_LENGTH_FIXED_SPACES_NEAR = @as(u32, 1);
pub const U_SHAPE_LAMALEF_NEAR = @as(u32, 1);
pub const U_SHAPE_LENGTH_FIXED_SPACES_AT_END = @as(u32, 2);
pub const U_SHAPE_LAMALEF_END = @as(u32, 2);
pub const U_SHAPE_LENGTH_FIXED_SPACES_AT_BEGINNING = @as(u32, 3);
pub const U_SHAPE_LAMALEF_BEGIN = @as(u32, 3);
pub const U_SHAPE_LAMALEF_AUTO = @as(u32, 65536);
pub const U_SHAPE_LENGTH_MASK = @as(u32, 65539);
pub const U_SHAPE_LAMALEF_MASK = @as(u32, 65539);
pub const U_SHAPE_TEXT_DIRECTION_LOGICAL = @as(u32, 0);
pub const U_SHAPE_TEXT_DIRECTION_VISUAL_RTL = @as(u32, 0);
pub const U_SHAPE_TEXT_DIRECTION_VISUAL_LTR = @as(u32, 4);
pub const U_SHAPE_TEXT_DIRECTION_MASK = @as(u32, 4);
pub const U_SHAPE_LETTERS_NOOP = @as(u32, 0);
pub const U_SHAPE_LETTERS_SHAPE = @as(u32, 8);
pub const U_SHAPE_LETTERS_UNSHAPE = @as(u32, 16);
pub const U_SHAPE_LETTERS_SHAPE_TASHKEEL_ISOLATED = @as(u32, 24);
pub const U_SHAPE_LETTERS_MASK = @as(u32, 24);
pub const U_SHAPE_DIGITS_NOOP = @as(u32, 0);
pub const U_SHAPE_DIGITS_EN2AN = @as(u32, 32);
pub const U_SHAPE_DIGITS_AN2EN = @as(u32, 64);
pub const U_SHAPE_DIGITS_ALEN2AN_INIT_LR = @as(u32, 96);
pub const U_SHAPE_DIGITS_ALEN2AN_INIT_AL = @as(u32, 128);
pub const U_SHAPE_DIGITS_RESERVED = @as(u32, 160);
pub const U_SHAPE_DIGITS_MASK = @as(u32, 224);
pub const U_SHAPE_DIGIT_TYPE_AN = @as(u32, 0);
pub const U_SHAPE_DIGIT_TYPE_AN_EXTENDED = @as(u32, 256);
pub const U_SHAPE_DIGIT_TYPE_RESERVED = @as(u32, 512);
pub const U_SHAPE_DIGIT_TYPE_MASK = @as(u32, 768);
pub const U_SHAPE_AGGREGATE_TASHKEEL = @as(u32, 16384);
pub const U_SHAPE_AGGREGATE_TASHKEEL_NOOP = @as(u32, 0);
pub const U_SHAPE_AGGREGATE_TASHKEEL_MASK = @as(u32, 16384);
pub const U_SHAPE_PRESERVE_PRESENTATION = @as(u32, 32768);
pub const U_SHAPE_PRESERVE_PRESENTATION_NOOP = @as(u32, 0);
pub const U_SHAPE_PRESERVE_PRESENTATION_MASK = @as(u32, 32768);
pub const U_SHAPE_SEEN_TWOCELL_NEAR = @as(u32, 2097152);
pub const U_SHAPE_SEEN_MASK = @as(u32, 7340032);
pub const U_SHAPE_YEHHAMZA_TWOCELL_NEAR = @as(u32, 16777216);
pub const U_SHAPE_YEHHAMZA_MASK = @as(u32, 58720256);
pub const U_SHAPE_TASHKEEL_BEGIN = @as(u32, 262144);
pub const U_SHAPE_TASHKEEL_END = @as(u32, 393216);
pub const U_SHAPE_TASHKEEL_RESIZE = @as(u32, 524288);
pub const U_SHAPE_TASHKEEL_REPLACE_BY_TATWEEL = @as(u32, 786432);
pub const U_SHAPE_TASHKEEL_MASK = @as(u32, 917504);
pub const U_SHAPE_SPACES_RELATIVE_TO_TEXT_BEGIN_END = @as(u32, 67108864);
pub const U_SHAPE_SPACES_RELATIVE_TO_TEXT_MASK = @as(u32, 67108864);
pub const U_SHAPE_TAIL_NEW_UNICODE = @as(u32, 134217728);
pub const U_SHAPE_TAIL_TYPE_MASK = @as(u32, 134217728);
pub const ULOC_LANG_CAPACITY = @as(u32, 12);
pub const ULOC_COUNTRY_CAPACITY = @as(u32, 4);
pub const ULOC_FULLNAME_CAPACITY = @as(u32, 157);
pub const ULOC_SCRIPT_CAPACITY = @as(u32, 6);
pub const ULOC_KEYWORDS_CAPACITY = @as(u32, 96);
pub const ULOC_KEYWORD_AND_VALUES_CAPACITY = @as(u32, 100);
pub const ULOC_KEYWORD_SEPARATOR_UNICODE = @as(u32, 64);
pub const ULOC_KEYWORD_ASSIGN_UNICODE = @as(u32, 61);
pub const ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE = @as(u32, 59);
pub const UCNV_MAX_CONVERTER_NAME_LENGTH = @as(u32, 60);
pub const UCNV_SI = @as(u32, 15);
pub const UCNV_SO = @as(u32, 14);
pub const U_FOLD_CASE_DEFAULT = @as(u32, 0);
pub const U_FOLD_CASE_EXCLUDE_SPECIAL_I = @as(u32, 1);
pub const U_TITLECASE_WHOLE_STRING = @as(u32, 32);
pub const U_TITLECASE_SENTENCES = @as(u32, 64);
pub const U_TITLECASE_NO_LOWERCASE = @as(u32, 256);
pub const U_TITLECASE_NO_BREAK_ADJUSTMENT = @as(u32, 512);
pub const U_TITLECASE_ADJUST_TO_CASED = @as(u32, 1024);
pub const U_EDITS_NO_RESET = @as(u32, 8192);
pub const U_OMIT_UNCHANGED_TEXT = @as(u32, 16384);
pub const U_COMPARE_CODE_POINT_ORDER = @as(u32, 32768);
pub const U_COMPARE_IGNORE_CASE = @as(u32, 65536);
pub const UNORM_INPUT_IS_FCD = @as(u32, 131072);
pub const UCHAR_MIN_VALUE = @as(u32, 0);
pub const UCHAR_MAX_VALUE = @as(u32, 1114111);
pub const UBIDI_DEFAULT_LTR = @as(u32, 254);
pub const UBIDI_DEFAULT_RTL = @as(u32, 255);
pub const UBIDI_MAX_EXPLICIT_LEVEL = @as(u32, 125);
pub const UBIDI_LEVEL_OVERRIDE = @as(u32, 128);
pub const UBIDI_MAP_NOWHERE = @as(i32, -1);
pub const UBIDI_KEEP_BASE_COMBINING = @as(u32, 1);
pub const UBIDI_DO_MIRRORING = @as(u32, 2);
pub const UBIDI_INSERT_LRM_FOR_NUMERIC = @as(u32, 4);
pub const UBIDI_REMOVE_BIDI_CONTROLS = @as(u32, 8);
pub const UBIDI_OUTPUT_REVERSE = @as(u32, 16);
pub const USPREP_DEFAULT = @as(u32, 0);
pub const USPREP_ALLOW_UNASSIGNED = @as(u32, 1);
pub const USEARCH_DONE = @as(i32, -1);
pub const UITER_UNKNOWN_INDEX = @as(i32, -2);
pub const UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE = @as(i32, 1);
pub const UTEXT_PROVIDER_STABLE_CHUNKS = @as(i32, 2);
pub const UTEXT_PROVIDER_WRITABLE = @as(i32, 3);
pub const UTEXT_PROVIDER_HAS_META_DATA = @as(i32, 4);
pub const UTEXT_PROVIDER_OWNS_TEXT = @as(i32, 5);
pub const UTEXT_MAGIC = @as(i32, 878368812);
pub const USET_IGNORE_SPACE = @as(i32, 1);
pub const USET_CASE_INSENSITIVE = @as(i32, 2);
pub const USET_ADD_CASE_MAPPINGS = @as(i32, 4);
pub const USET_SERIALIZED_STATIC_ARRAY_CAPACITY = @as(i32, 8);
pub const U_PARSE_CONTEXT_LEN = @as(i32, 16);
pub const UIDNA_DEFAULT = @as(i32, 0);
pub const UIDNA_USE_STD3_RULES = @as(i32, 2);
pub const UIDNA_CHECK_BIDI = @as(i32, 4);
pub const UIDNA_CHECK_CONTEXTJ = @as(i32, 8);
pub const UIDNA_NONTRANSITIONAL_TO_ASCII = @as(i32, 16);
pub const UIDNA_NONTRANSITIONAL_TO_UNICODE = @as(i32, 32);
pub const UIDNA_CHECK_CONTEXTO = @as(i32, 64);
pub const UIDNA_ERROR_EMPTY_LABEL = @as(i32, 1);
pub const UIDNA_ERROR_LABEL_TOO_LONG = @as(i32, 2);
pub const UIDNA_ERROR_DOMAIN_NAME_TOO_LONG = @as(i32, 4);
pub const UIDNA_ERROR_LEADING_HYPHEN = @as(i32, 8);
pub const UIDNA_ERROR_TRAILING_HYPHEN = @as(i32, 16);
pub const UIDNA_ERROR_HYPHEN_3_4 = @as(i32, 32);
pub const UIDNA_ERROR_LEADING_COMBINING_MARK = @as(i32, 64);
pub const UIDNA_ERROR_DISALLOWED = @as(i32, 128);
pub const UIDNA_ERROR_PUNYCODE = @as(i32, 256);
pub const UIDNA_ERROR_LABEL_HAS_DOT = @as(i32, 512);
pub const UIDNA_ERROR_INVALID_ACE_LABEL = @as(i32, 1024);
pub const UIDNA_ERROR_BIDI = @as(i32, 2048);
pub const UIDNA_ERROR_CONTEXTJ = @as(i32, 4096);
pub const UIDNA_ERROR_CONTEXTO_PUNCTUATION = @as(i32, 8192);
pub const UIDNA_ERROR_CONTEXTO_DIGITS = @as(i32, 16384);

//--------------------------------------------------------------------------------
// Section: Types (358)
//--------------------------------------------------------------------------------
pub const FOLD_STRING_MAP_FLAGS = enum(u32) {
    COMPOSITE = 64,
    EXPAND_LIGATURES = 8192,
    FOLDCZONE = 16,
    FOLDDIGITS = 128,
    PRECOMPOSED = 32,
    _,
    pub fn initFlags(o: struct {
        COMPOSITE: u1 = 0,
        EXPAND_LIGATURES: u1 = 0,
        FOLDCZONE: u1 = 0,
        FOLDDIGITS: u1 = 0,
        PRECOMPOSED: u1 = 0,
    }) FOLD_STRING_MAP_FLAGS {
        return @intToEnum(FOLD_STRING_MAP_FLAGS,
              (if (o.COMPOSITE == 1) @enumToInt(FOLD_STRING_MAP_FLAGS.COMPOSITE) else 0)
            | (if (o.EXPAND_LIGATURES == 1) @enumToInt(FOLD_STRING_MAP_FLAGS.EXPAND_LIGATURES) else 0)
            | (if (o.FOLDCZONE == 1) @enumToInt(FOLD_STRING_MAP_FLAGS.FOLDCZONE) else 0)
            | (if (o.FOLDDIGITS == 1) @enumToInt(FOLD_STRING_MAP_FLAGS.FOLDDIGITS) else 0)
            | (if (o.PRECOMPOSED == 1) @enumToInt(FOLD_STRING_MAP_FLAGS.PRECOMPOSED) else 0)
        );
    }
};
pub const MAP_COMPOSITE = FOLD_STRING_MAP_FLAGS.COMPOSITE;
pub const MAP_EXPAND_LIGATURES = FOLD_STRING_MAP_FLAGS.EXPAND_LIGATURES;
pub const MAP_FOLDCZONE = FOLD_STRING_MAP_FLAGS.FOLDCZONE;
pub const MAP_FOLDDIGITS = FOLD_STRING_MAP_FLAGS.FOLDDIGITS;
pub const MAP_PRECOMPOSED = FOLD_STRING_MAP_FLAGS.PRECOMPOSED;

pub const SET_COMPOSITION_STRING_TYPE = enum(u32) {
    SETSTR = 9,
    CHANGEATTR = 18,
    CHANGECLAUSE = 36,
    SETRECONVERTSTRING = 65536,
    QUERYRECONVERTSTRING = 131072,
};
pub const SCS_SETSTR = SET_COMPOSITION_STRING_TYPE.SETSTR;
pub const SCS_CHANGEATTR = SET_COMPOSITION_STRING_TYPE.CHANGEATTR;
pub const SCS_CHANGECLAUSE = SET_COMPOSITION_STRING_TYPE.CHANGECLAUSE;
pub const SCS_SETRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.SETRECONVERTSTRING;
pub const SCS_QUERYRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.QUERYRECONVERTSTRING;

pub const GET_GUIDE_LINE_TYPE = enum(u32) {
    LEVEL = 1,
    INDEX = 2,
    STRING = 3,
    PRIVATE = 4,
};
pub const GGL_LEVEL = GET_GUIDE_LINE_TYPE.LEVEL;
pub const GGL_INDEX = GET_GUIDE_LINE_TYPE.INDEX;
pub const GGL_STRING = GET_GUIDE_LINE_TYPE.STRING;
pub const GGL_PRIVATE = GET_GUIDE_LINE_TYPE.PRIVATE;

pub const ENUM_DATE_FORMATS_FLAGS = enum(u32) {
    SHORTDATE = 1,
    LONGDATE = 2,
    YEARMONTH = 8,
    MONTHDAY = 128,
    AUTOLAYOUT = 64,
    LTRREADING = 16,
    RTLREADING = 32,
    USE_ALT_CALENDAR = 4,
};
pub const DATE_SHORTDATE = ENUM_DATE_FORMATS_FLAGS.SHORTDATE;
pub const DATE_LONGDATE = ENUM_DATE_FORMATS_FLAGS.LONGDATE;
pub const DATE_YEARMONTH = ENUM_DATE_FORMATS_FLAGS.YEARMONTH;
pub const DATE_MONTHDAY = ENUM_DATE_FORMATS_FLAGS.MONTHDAY;
pub const DATE_AUTOLAYOUT = ENUM_DATE_FORMATS_FLAGS.AUTOLAYOUT;
pub const DATE_LTRREADING = ENUM_DATE_FORMATS_FLAGS.LTRREADING;
pub const DATE_RTLREADING = ENUM_DATE_FORMATS_FLAGS.RTLREADING;
pub const DATE_USE_ALT_CALENDAR = ENUM_DATE_FORMATS_FLAGS.USE_ALT_CALENDAR;

pub const NOTIFY_IME_INDEX = enum(u32) {
    CANCEL = 4,
    COMPLETE = 1,
    CONVERT = 2,
    REVERT = 3,
};
pub const CPS_CANCEL = NOTIFY_IME_INDEX.CANCEL;
pub const CPS_COMPLETE = NOTIFY_IME_INDEX.COMPLETE;
pub const CPS_CONVERT = NOTIFY_IME_INDEX.CONVERT;
pub const CPS_REVERT = NOTIFY_IME_INDEX.REVERT;

pub const TRANSLATE_CHARSET_INFO_FLAGS = enum(u32) {
    CHARSET = 1,
    CODEPAGE = 2,
    FONTSIG = 3,
    LOCALE = 4096,
};
pub const TCI_SRCCHARSET = TRANSLATE_CHARSET_INFO_FLAGS.CHARSET;
pub const TCI_SRCCODEPAGE = TRANSLATE_CHARSET_INFO_FLAGS.CODEPAGE;
pub const TCI_SRCFONTSIG = TRANSLATE_CHARSET_INFO_FLAGS.FONTSIG;
pub const TCI_SRCLOCALE = TRANSLATE_CHARSET_INFO_FLAGS.LOCALE;

pub const TIME_FORMAT_FLAGS = enum(u32) {
    NOMINUTESORSECONDS = 1,
    NOSECONDS = 2,
    NOTIMEMARKER = 4,
    FORCE24HOURFORMAT = 8,
    _,
    pub fn initFlags(o: struct {
        NOMINUTESORSECONDS: u1 = 0,
        NOSECONDS: u1 = 0,
        NOTIMEMARKER: u1 = 0,
        FORCE24HOURFORMAT: u1 = 0,
    }) TIME_FORMAT_FLAGS {
        return @intToEnum(TIME_FORMAT_FLAGS,
              (if (o.NOMINUTESORSECONDS == 1) @enumToInt(TIME_FORMAT_FLAGS.NOMINUTESORSECONDS) else 0)
            | (if (o.NOSECONDS == 1) @enumToInt(TIME_FORMAT_FLAGS.NOSECONDS) else 0)
            | (if (o.NOTIMEMARKER == 1) @enumToInt(TIME_FORMAT_FLAGS.NOTIMEMARKER) else 0)
            | (if (o.FORCE24HOURFORMAT == 1) @enumToInt(TIME_FORMAT_FLAGS.FORCE24HOURFORMAT) else 0)
        );
    }
};
pub const TIME_NOMINUTESORSECONDS = TIME_FORMAT_FLAGS.NOMINUTESORSECONDS;
pub const TIME_NOSECONDS = TIME_FORMAT_FLAGS.NOSECONDS;
pub const TIME_NOTIMEMARKER = TIME_FORMAT_FLAGS.NOTIMEMARKER;
pub const TIME_FORCE24HOURFORMAT = TIME_FORMAT_FLAGS.FORCE24HOURFORMAT;

pub const NOTIFY_IME_ACTION = enum(u32) {
    CHANGECANDIDATELIST = 19,
    CLOSECANDIDATE = 17,
    COMPOSITIONSTR = 21,
    IMEMENUSELECTED = 24,
    OPENCANDIDATE = 16,
    SELECTCANDIDATESTR = 18,
    SETCANDIDATE_PAGESIZE = 23,
    SETCANDIDATE_PAGESTART = 22,
};
pub const NI_CHANGECANDIDATELIST = NOTIFY_IME_ACTION.CHANGECANDIDATELIST;
pub const NI_CLOSECANDIDATE = NOTIFY_IME_ACTION.CLOSECANDIDATE;
pub const NI_COMPOSITIONSTR = NOTIFY_IME_ACTION.COMPOSITIONSTR;
pub const NI_IMEMENUSELECTED = NOTIFY_IME_ACTION.IMEMENUSELECTED;
pub const NI_OPENCANDIDATE = NOTIFY_IME_ACTION.OPENCANDIDATE;
pub const NI_SELECTCANDIDATESTR = NOTIFY_IME_ACTION.SELECTCANDIDATESTR;
pub const NI_SETCANDIDATE_PAGESIZE = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESIZE;
pub const NI_SETCANDIDATE_PAGESTART = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESTART;

pub const GET_CONVERSION_LIST_FLAG = enum(u32) {
    CONVERSION = 1,
    REVERSECONVERSION = 2,
    REVERSE_LENGTH = 3,
};
pub const GCL_CONVERSION = GET_CONVERSION_LIST_FLAG.CONVERSION;
pub const GCL_REVERSECONVERSION = GET_CONVERSION_LIST_FLAG.REVERSECONVERSION;
pub const GCL_REVERSE_LENGTH = GET_CONVERSION_LIST_FLAG.REVERSE_LENGTH;

pub const ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const LGRPID_INSTALLED = ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS.INSTALLED;
pub const LGRPID_SUPPORTED = ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS.SUPPORTED;

pub const MULTI_BYTE_TO_WIDE_CHAR_FLAGS = enum(u32) {
    COMPOSITE = 2,
    ERR_INVALID_CHARS = 8,
    PRECOMPOSED = 1,
    USEGLYPHCHARS = 4,
    _,
    pub fn initFlags(o: struct {
        COMPOSITE: u1 = 0,
        ERR_INVALID_CHARS: u1 = 0,
        PRECOMPOSED: u1 = 0,
        USEGLYPHCHARS: u1 = 0,
    }) MULTI_BYTE_TO_WIDE_CHAR_FLAGS {
        return @intToEnum(MULTI_BYTE_TO_WIDE_CHAR_FLAGS,
              (if (o.COMPOSITE == 1) @enumToInt(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.COMPOSITE) else 0)
            | (if (o.ERR_INVALID_CHARS == 1) @enumToInt(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.ERR_INVALID_CHARS) else 0)
            | (if (o.PRECOMPOSED == 1) @enumToInt(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.PRECOMPOSED) else 0)
            | (if (o.USEGLYPHCHARS == 1) @enumToInt(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.USEGLYPHCHARS) else 0)
        );
    }
};
pub const MB_COMPOSITE = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.COMPOSITE;
pub const MB_ERR_INVALID_CHARS = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.ERR_INVALID_CHARS;
pub const MB_PRECOMPOSED = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.PRECOMPOSED;
pub const MB_USEGLYPHCHARS = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.USEGLYPHCHARS;

pub const COMPARE_STRING_FLAGS = enum(u32) {
    LINGUISTIC_IGNORECASE = 16,
    LINGUISTIC_IGNOREDIACRITIC = 32,
    NORM_IGNORECASE = 1,
    NORM_IGNOREKANATYPE = 65536,
    NORM_IGNORENONSPACE = 2,
    NORM_IGNORESYMBOLS = 4,
    NORM_IGNOREWIDTH = 131072,
    NORM_LINGUISTIC_CASING = 134217728,
    SORT_DIGITSASNUMBERS = 8,
    SORT_STRINGSORT = 4096,
    _,
    pub fn initFlags(o: struct {
        LINGUISTIC_IGNORECASE: u1 = 0,
        LINGUISTIC_IGNOREDIACRITIC: u1 = 0,
        NORM_IGNORECASE: u1 = 0,
        NORM_IGNOREKANATYPE: u1 = 0,
        NORM_IGNORENONSPACE: u1 = 0,
        NORM_IGNORESYMBOLS: u1 = 0,
        NORM_IGNOREWIDTH: u1 = 0,
        NORM_LINGUISTIC_CASING: u1 = 0,
        SORT_DIGITSASNUMBERS: u1 = 0,
        SORT_STRINGSORT: u1 = 0,
    }) COMPARE_STRING_FLAGS {
        return @intToEnum(COMPARE_STRING_FLAGS,
              (if (o.LINGUISTIC_IGNORECASE == 1) @enumToInt(COMPARE_STRING_FLAGS.LINGUISTIC_IGNORECASE) else 0)
            | (if (o.LINGUISTIC_IGNOREDIACRITIC == 1) @enumToInt(COMPARE_STRING_FLAGS.LINGUISTIC_IGNOREDIACRITIC) else 0)
            | (if (o.NORM_IGNORECASE == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_IGNORECASE) else 0)
            | (if (o.NORM_IGNOREKANATYPE == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_IGNOREKANATYPE) else 0)
            | (if (o.NORM_IGNORENONSPACE == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_IGNORENONSPACE) else 0)
            | (if (o.NORM_IGNORESYMBOLS == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_IGNORESYMBOLS) else 0)
            | (if (o.NORM_IGNOREWIDTH == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_IGNOREWIDTH) else 0)
            | (if (o.NORM_LINGUISTIC_CASING == 1) @enumToInt(COMPARE_STRING_FLAGS.NORM_LINGUISTIC_CASING) else 0)
            | (if (o.SORT_DIGITSASNUMBERS == 1) @enumToInt(COMPARE_STRING_FLAGS.SORT_DIGITSASNUMBERS) else 0)
            | (if (o.SORT_STRINGSORT == 1) @enumToInt(COMPARE_STRING_FLAGS.SORT_STRINGSORT) else 0)
        );
    }
};
pub const LINGUISTIC_IGNORECASE = COMPARE_STRING_FLAGS.LINGUISTIC_IGNORECASE;
pub const LINGUISTIC_IGNOREDIACRITIC = COMPARE_STRING_FLAGS.LINGUISTIC_IGNOREDIACRITIC;
pub const NORM_IGNORECASE = COMPARE_STRING_FLAGS.NORM_IGNORECASE;
pub const NORM_IGNOREKANATYPE = COMPARE_STRING_FLAGS.NORM_IGNOREKANATYPE;
pub const NORM_IGNORENONSPACE = COMPARE_STRING_FLAGS.NORM_IGNORENONSPACE;
pub const NORM_IGNORESYMBOLS = COMPARE_STRING_FLAGS.NORM_IGNORESYMBOLS;
pub const NORM_IGNOREWIDTH = COMPARE_STRING_FLAGS.NORM_IGNOREWIDTH;
pub const NORM_LINGUISTIC_CASING = COMPARE_STRING_FLAGS.NORM_LINGUISTIC_CASING;
pub const SORT_DIGITSASNUMBERS = COMPARE_STRING_FLAGS.SORT_DIGITSASNUMBERS;
pub const SORT_STRINGSORT = COMPARE_STRING_FLAGS.SORT_STRINGSORT;

pub const IS_VALID_LOCALE_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const LCID_INSTALLED = IS_VALID_LOCALE_FLAGS.INSTALLED;
pub const LCID_SUPPORTED = IS_VALID_LOCALE_FLAGS.SUPPORTED;

pub const ENUM_SYSTEM_CODE_PAGES_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const CP_INSTALLED = ENUM_SYSTEM_CODE_PAGES_FLAGS.INSTALLED;
pub const CP_SUPPORTED = ENUM_SYSTEM_CODE_PAGES_FLAGS.SUPPORTED;

pub const IME_PAD_REQUEST_FLAGS = enum(u32) {
    INSERTSTRING = 4097,
    SENDCONTROL = 4100,
    SETAPPLETSIZE = 4104,
    GETCOMPOSITIONSTRING = 4102,
    GETCOMPOSITIONSTRINGINFO = 4108,
    DELETESTRING = 4112,
    CHANGESTRING = 4113,
    GETAPPLHWND = 4116,
    FORCEIMEPADWINDOWSHOW = 4117,
    POSTMODALNOTIFY = 4118,
    GETDEFAULTUILANGID = 4119,
    GETAPPLETUISTYLE = 4121,
    SETAPPLETUISTYLE = 4122,
    ISAPPLETACTIVE = 4123,
    ISIMEPADWINDOWVISIBLE = 4124,
    SETAPPLETMINMAXSIZE = 4125,
    GETCONVERSIONSTATUS = 4126,
    GETVERSION = 4127,
    GETCURRENTIMEINFO = 4128,
};
pub const IMEPADREQ_INSERTSTRING = IME_PAD_REQUEST_FLAGS.INSERTSTRING;
pub const IMEPADREQ_SENDCONTROL = IME_PAD_REQUEST_FLAGS.SENDCONTROL;
pub const IMEPADREQ_SETAPPLETSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETSIZE;
pub const IMEPADREQ_GETCOMPOSITIONSTRING = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRING;
pub const IMEPADREQ_GETCOMPOSITIONSTRINGINFO = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRINGINFO;
pub const IMEPADREQ_DELETESTRING = IME_PAD_REQUEST_FLAGS.DELETESTRING;
pub const IMEPADREQ_CHANGESTRING = IME_PAD_REQUEST_FLAGS.CHANGESTRING;
pub const IMEPADREQ_GETAPPLHWND = IME_PAD_REQUEST_FLAGS.GETAPPLHWND;
pub const IMEPADREQ_FORCEIMEPADWINDOWSHOW = IME_PAD_REQUEST_FLAGS.FORCEIMEPADWINDOWSHOW;
pub const IMEPADREQ_POSTMODALNOTIFY = IME_PAD_REQUEST_FLAGS.POSTMODALNOTIFY;
pub const IMEPADREQ_GETDEFAULTUILANGID = IME_PAD_REQUEST_FLAGS.GETDEFAULTUILANGID;
pub const IMEPADREQ_GETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.GETAPPLETUISTYLE;
pub const IMEPADREQ_SETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.SETAPPLETUISTYLE;
pub const IMEPADREQ_ISAPPLETACTIVE = IME_PAD_REQUEST_FLAGS.ISAPPLETACTIVE;
pub const IMEPADREQ_ISIMEPADWINDOWVISIBLE = IME_PAD_REQUEST_FLAGS.ISIMEPADWINDOWVISIBLE;
pub const IMEPADREQ_SETAPPLETMINMAXSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETMINMAXSIZE;
pub const IMEPADREQ_GETCONVERSIONSTATUS = IME_PAD_REQUEST_FLAGS.GETCONVERSIONSTATUS;
pub const IMEPADREQ_GETVERSION = IME_PAD_REQUEST_FLAGS.GETVERSION;
pub const IMEPADREQ_GETCURRENTIMEINFO = IME_PAD_REQUEST_FLAGS.GETCURRENTIMEINFO;

pub const SCRIPT_IS_COMPLEX_FLAGS = enum(u32) {
    ASCIIDIGIT = 2,
    COMPLEX = 1,
    NEUTRAL = 4,
};
pub const SIC_ASCIIDIGIT = SCRIPT_IS_COMPLEX_FLAGS.ASCIIDIGIT;
pub const SIC_COMPLEX = SCRIPT_IS_COMPLEX_FLAGS.COMPLEX;
pub const SIC_NEUTRAL = SCRIPT_IS_COMPLEX_FLAGS.NEUTRAL;

pub const IS_TEXT_UNICODE_RESULT = enum(u32) {
    ASCII16 = 1,
    REVERSE_ASCII16 = 16,
    STATISTICS = 2,
    REVERSE_STATISTICS = 32,
    CONTROLS = 4,
    REVERSE_CONTROLS = 64,
    SIGNATURE = 8,
    REVERSE_SIGNATURE = 128,
    ILLEGAL_CHARS = 256,
    ODD_LENGTH = 512,
    NULL_BYTES = 4096,
    UNICODE_MASK = 15,
    REVERSE_MASK = 240,
    NOT_UNICODE_MASK = 3840,
    NOT_ASCII_MASK = 61440,
    _,
    pub fn initFlags(o: struct {
        ASCII16: u1 = 0,
        REVERSE_ASCII16: u1 = 0,
        STATISTICS: u1 = 0,
        REVERSE_STATISTICS: u1 = 0,
        CONTROLS: u1 = 0,
        REVERSE_CONTROLS: u1 = 0,
        SIGNATURE: u1 = 0,
        REVERSE_SIGNATURE: u1 = 0,
        ILLEGAL_CHARS: u1 = 0,
        ODD_LENGTH: u1 = 0,
        NULL_BYTES: u1 = 0,
        UNICODE_MASK: u1 = 0,
        REVERSE_MASK: u1 = 0,
        NOT_UNICODE_MASK: u1 = 0,
        NOT_ASCII_MASK: u1 = 0,
    }) IS_TEXT_UNICODE_RESULT {
        return @intToEnum(IS_TEXT_UNICODE_RESULT,
              (if (o.ASCII16 == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.ASCII16) else 0)
            | (if (o.REVERSE_ASCII16 == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.REVERSE_ASCII16) else 0)
            | (if (o.STATISTICS == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.STATISTICS) else 0)
            | (if (o.REVERSE_STATISTICS == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.REVERSE_STATISTICS) else 0)
            | (if (o.CONTROLS == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.CONTROLS) else 0)
            | (if (o.REVERSE_CONTROLS == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.REVERSE_CONTROLS) else 0)
            | (if (o.SIGNATURE == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.SIGNATURE) else 0)
            | (if (o.REVERSE_SIGNATURE == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.REVERSE_SIGNATURE) else 0)
            | (if (o.ILLEGAL_CHARS == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.ILLEGAL_CHARS) else 0)
            | (if (o.ODD_LENGTH == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.ODD_LENGTH) else 0)
            | (if (o.NULL_BYTES == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.NULL_BYTES) else 0)
            | (if (o.UNICODE_MASK == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.UNICODE_MASK) else 0)
            | (if (o.REVERSE_MASK == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.REVERSE_MASK) else 0)
            | (if (o.NOT_UNICODE_MASK == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.NOT_UNICODE_MASK) else 0)
            | (if (o.NOT_ASCII_MASK == 1) @enumToInt(IS_TEXT_UNICODE_RESULT.NOT_ASCII_MASK) else 0)
        );
    }
};
pub const IS_TEXT_UNICODE_ASCII16 = IS_TEXT_UNICODE_RESULT.ASCII16;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16 = IS_TEXT_UNICODE_RESULT.REVERSE_ASCII16;
pub const IS_TEXT_UNICODE_STATISTICS = IS_TEXT_UNICODE_RESULT.STATISTICS;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS = IS_TEXT_UNICODE_RESULT.REVERSE_STATISTICS;
pub const IS_TEXT_UNICODE_CONTROLS = IS_TEXT_UNICODE_RESULT.CONTROLS;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS = IS_TEXT_UNICODE_RESULT.REVERSE_CONTROLS;
pub const IS_TEXT_UNICODE_SIGNATURE = IS_TEXT_UNICODE_RESULT.SIGNATURE;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE = IS_TEXT_UNICODE_RESULT.REVERSE_SIGNATURE;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS = IS_TEXT_UNICODE_RESULT.ILLEGAL_CHARS;
pub const IS_TEXT_UNICODE_ODD_LENGTH = IS_TEXT_UNICODE_RESULT.ODD_LENGTH;
pub const IS_TEXT_UNICODE_NULL_BYTES = IS_TEXT_UNICODE_RESULT.NULL_BYTES;
pub const IS_TEXT_UNICODE_UNICODE_MASK = IS_TEXT_UNICODE_RESULT.UNICODE_MASK;
pub const IS_TEXT_UNICODE_REVERSE_MASK = IS_TEXT_UNICODE_RESULT.REVERSE_MASK;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK = IS_TEXT_UNICODE_RESULT.NOT_UNICODE_MASK;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK = IS_TEXT_UNICODE_RESULT.NOT_ASCII_MASK;

pub const UEnumeration = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UResourceBundle = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const ULocaleDisplayNames = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UConverter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USet = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UBiDi = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UBiDiTransform = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNormalizer2 = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UConverterSelector = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UBreakIterator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCaseMap = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UStringPrepProfile = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UIDNA = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCollator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCollationElements = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCharsetDetector = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCharsetMatch = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFieldPositionIterator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UDateIntervalFormat = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UGenderInfo = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UListFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const ULocaleData = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UDateFormatSymbols = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNumberFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedNumber = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNumberingSystem = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UPluralRules = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const URegularExpression = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const URegion = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const URelativeDateTimeFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UStringSearch = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USpoofChecker = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USpoofCheckResult = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const HIMC = *opaque{};

pub const HIMCC = *opaque{};

pub const HSAVEDUILANGUAGES = *opaque{};

pub const FONTSIGNATURE = extern struct {
    fsUsb: [4]u32,
    fsCsb: [2]u32,
};

pub const CHARSETINFO = extern struct {
    ciCharset: u32,
    ciACP: u32,
    fs: FONTSIGNATURE,
};

pub const LOCALESIGNATURE = extern struct {
    lsUsb: [4]u32,
    lsCsbDefault: [2]u32,
    lsCsbSupported: [2]u32,
};

pub const CPINFO = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
};

pub const CPINFOEXA = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: [260]CHAR,
};

pub const CPINFOEXW = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: [260]u16,
};

pub const NUMBERFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PSTR,
    lpThousandSep: ?PSTR,
    NegativeOrder: u32,
};

pub const NUMBERFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PWSTR,
    lpThousandSep: ?PWSTR,
    NegativeOrder: u32,
};

pub const CURRENCYFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PSTR,
    lpThousandSep: ?PSTR,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?PSTR,
};

pub const CURRENCYFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PWSTR,
    lpThousandSep: ?PWSTR,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?PWSTR,
};

pub const SYSNLS_FUNCTION = enum(i32) {
    G = 1,
};
pub const COMPARE_STRING = SYSNLS_FUNCTION.G;

pub const NLSVERSIONINFO = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};

pub const NLSVERSIONINFOEX = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};

pub const SYSGEOTYPE = enum(i32) {
    NATION = 1,
    LATITUDE = 2,
    LONGITUDE = 3,
    ISO2 = 4,
    ISO3 = 5,
    RFC1766 = 6,
    LCID = 7,
    FRIENDLYNAME = 8,
    OFFICIALNAME = 9,
    TIMEZONES = 10,
    OFFICIALLANGUAGES = 11,
    ISO_UN_NUMBER = 12,
    PARENT = 13,
    DIALINGCODE = 14,
    CURRENCYCODE = 15,
    CURRENCYSYMBOL = 16,
    NAME = 17,
    ID = 18,
};
pub const GEO_NATION = SYSGEOTYPE.NATION;
pub const GEO_LATITUDE = SYSGEOTYPE.LATITUDE;
pub const GEO_LONGITUDE = SYSGEOTYPE.LONGITUDE;
pub const GEO_ISO2 = SYSGEOTYPE.ISO2;
pub const GEO_ISO3 = SYSGEOTYPE.ISO3;
pub const GEO_RFC1766 = SYSGEOTYPE.RFC1766;
pub const GEO_LCID = SYSGEOTYPE.LCID;
pub const GEO_FRIENDLYNAME = SYSGEOTYPE.FRIENDLYNAME;
pub const GEO_OFFICIALNAME = SYSGEOTYPE.OFFICIALNAME;
pub const GEO_TIMEZONES = SYSGEOTYPE.TIMEZONES;
pub const GEO_OFFICIALLANGUAGES = SYSGEOTYPE.OFFICIALLANGUAGES;
pub const GEO_ISO_UN_NUMBER = SYSGEOTYPE.ISO_UN_NUMBER;
pub const GEO_PARENT = SYSGEOTYPE.PARENT;
pub const GEO_DIALINGCODE = SYSGEOTYPE.DIALINGCODE;
pub const GEO_CURRENCYCODE = SYSGEOTYPE.CURRENCYCODE;
pub const GEO_CURRENCYSYMBOL = SYSGEOTYPE.CURRENCYSYMBOL;
pub const GEO_NAME = SYSGEOTYPE.NAME;
pub const GEO_ID = SYSGEOTYPE.ID;

pub const SYSGEOCLASS = enum(i32) {
    NATION = 16,
    REGION = 14,
    ALL = 0,
};
pub const GEOCLASS_NATION = SYSGEOCLASS.NATION;
pub const GEOCLASS_REGION = SYSGEOCLASS.REGION;
pub const GEOCLASS_ALL = SYSGEOCLASS.ALL;

pub const LOCALE_ENUMPROCA = fn(
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LOCALE_ENUMPROCW = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NORM_FORM = enum(i32) {
    Other = 0,
    C = 1,
    D = 2,
    KC = 5,
    KD = 6,
};
pub const NormalizationOther = NORM_FORM.Other;
pub const NormalizationC = NORM_FORM.C;
pub const NormalizationD = NORM_FORM.D;
pub const NormalizationKC = NORM_FORM.KC;
pub const NormalizationKD = NORM_FORM.KD;

pub const LANGUAGEGROUP_ENUMPROCA = fn(
    param0: u32,
    param1: ?PSTR,
    param2: ?PSTR,
    param3: u32,
    param4: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGGROUPLOCALE_ENUMPROCA = fn(
    param0: u32,
    param1: u32,
    param2: ?PSTR,
    param3: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const UILANGUAGE_ENUMPROCA = fn(
    param0: ?PSTR,
    param1: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CODEPAGE_ENUMPROCA = fn(
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCA = fn(
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXA = fn(
    param0: ?PSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCA = fn(
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCA = fn(
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCEXA = fn(
    param0: ?PSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGUAGEGROUP_ENUMPROCW = fn(
    param0: u32,
    param1: ?PWSTR,
    param2: ?PWSTR,
    param3: u32,
    param4: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGGROUPLOCALE_ENUMPROCW = fn(
    param0: u32,
    param1: u32,
    param2: ?PWSTR,
    param3: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const UILANGUAGE_ENUMPROCW = fn(
    param0: ?PWSTR,
    param1: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CODEPAGE_ENUMPROCW = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCW = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXW = fn(
    param0: ?PWSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCW = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCW = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCEXW = fn(
    param0: ?PWSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const GEO_ENUMPROC = fn(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const GEO_ENUMNAMEPROC = fn(
    param0: ?PWSTR,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const FILEMUIINFO = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFileType: u32,
    pChecksum: [16]u8,
    pServiceChecksum: [16]u8,
    dwLanguageNameOffset: u32,
    dwTypeIDMainSize: u32,
    dwTypeIDMainOffset: u32,
    dwTypeNameMainOffset: u32,
    dwTypeIDMUISize: u32,
    dwTypeIDMUIOffset: u32,
    dwTypeNameMUIOffset: u32,
    abBuffer: [8]u8,
};

pub const CALINFO_ENUMPROCEXEX = fn(
    param0: ?PWSTR,
    param1: u32,
    param2: ?PWSTR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXEX = fn(
    param0: ?PWSTR,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCEX = fn(
    param0: ?PWSTR,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LOCALE_ENUMPROCEX = fn(
    param0: ?PWSTR,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const COMPOSITIONFORM = extern struct {
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATEFORM = extern struct {
    dwIndex: u32,
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATELIST = extern struct {
    dwSize: u32,
    dwStyle: u32,
    dwCount: u32,
    dwSelection: u32,
    dwPageStart: u32,
    dwPageSize: u32,
    dwOffset: [1]u32,
};

pub const REGISTERWORDA = extern struct {
    lpReading: ?PSTR,
    lpWord: ?PSTR,
};

pub const REGISTERWORDW = extern struct {
    lpReading: ?PWSTR,
    lpWord: ?PWSTR,
};

pub const RECONVERTSTRING = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwTargetStrLen: u32,
    dwTargetStrOffset: u32,
};

pub const STYLEBUFA = extern struct {
    dwStyle: u32,
    szDescription: [32]CHAR,
};

pub const STYLEBUFW = extern struct {
    dwStyle: u32,
    szDescription: [32]u16,
};

pub const IMEMENUITEMINFOA = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]CHAR,
    hbmpItem: ?HBITMAP,
};

pub const IMEMENUITEMINFOW = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]u16,
    hbmpItem: ?HBITMAP,
};

pub const IMECHARPOSITION = extern struct {
    dwSize: u32,
    dwCharPos: u32,
    pt: POINT,
    cLineHeight: u32,
    rcDocument: RECT,
};

pub const IMCENUMPROC = fn(
    param0: ?HIMC,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REGISTERWORDENUMPROCA = fn(
    lpszReading: ?[*:0]const u8,
    param1: u32,
    lpszString: ?[*:0]const u8,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const REGISTERWORDENUMPROCW = fn(
    lpszReading: ?[*:0]const u16,
    param1: u32,
    lpszString: ?[*:0]const u16,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_MAPPINGCALLBACKPROC = fn(
    pBag: ?*MAPPING_PROPERTY_BAG,
    data: ?*c_void,
    dwDataSize: u32,
    Result: HRESULT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MAPPING_SERVICE_INFO = extern struct {
    Size: usize,
    pszCopyright: ?PWSTR,
    wMajorVersion: u16,
    wMinorVersion: u16,
    wBuildVersion: u16,
    wStepVersion: u16,
    dwInputContentTypesCount: u32,
    prgInputContentTypes: ?*?PWSTR,
    dwOutputContentTypesCount: u32,
    prgOutputContentTypes: ?*?PWSTR,
    dwInputLanguagesCount: u32,
    prgInputLanguages: ?*?PWSTR,
    dwOutputLanguagesCount: u32,
    prgOutputLanguages: ?*?PWSTR,
    dwInputScriptsCount: u32,
    prgInputScripts: ?*?PWSTR,
    dwOutputScriptsCount: u32,
    prgOutputScripts: ?*?PWSTR,
    guid: Guid,
    pszCategory: ?PWSTR,
    pszDescription: ?PWSTR,
    dwPrivateDataSize: u32,
    pPrivateData: ?*c_void,
    pContext: ?*c_void,
    _bitfield: u32,
};

pub const MAPPING_ENUM_OPTIONS = extern struct {
    Size: usize,
    pszCategory: ?PWSTR,
    pszInputLanguage: ?PWSTR,
    pszOutputLanguage: ?PWSTR,
    pszInputScript: ?PWSTR,
    pszOutputScript: ?PWSTR,
    pszInputContentType: ?PWSTR,
    pszOutputContentType: ?PWSTR,
    pGuid: ?*Guid,
    _bitfield: u32,
};

pub const MAPPING_OPTIONS = extern struct {
    Size: usize,
    pszInputLanguage: ?PWSTR,
    pszOutputLanguage: ?PWSTR,
    pszInputScript: ?PWSTR,
    pszOutputScript: ?PWSTR,
    pszInputContentType: ?PWSTR,
    pszOutputContentType: ?PWSTR,
    pszUILanguage: ?PWSTR,
    pfnRecognizeCallback: ?PFN_MAPPINGCALLBACKPROC,
    pRecognizeCallerData: ?*c_void,
    dwRecognizeCallerDataSize: u32,
    pfnActionCallback: ?PFN_MAPPINGCALLBACKPROC,
    pActionCallerData: ?*c_void,
    dwActionCallerDataSize: u32,
    dwServiceFlag: u32,
    _bitfield: u32,
};

pub const MAPPING_DATA_RANGE = extern struct {
    dwStartIndex: u32,
    dwEndIndex: u32,
    pszDescription: ?PWSTR,
    dwDescriptionLength: u32,
    pData: ?*c_void,
    dwDataSize: u32,
    pszContentType: ?PWSTR,
    prgActionIds: ?*?PWSTR,
    dwActionsCount: u32,
    prgActionDisplayNames: ?*?PWSTR,
};

pub const MAPPING_PROPERTY_BAG = extern struct {
    Size: usize,
    prgResultRanges: ?*MAPPING_DATA_RANGE,
    dwRangesCount: u32,
    pServiceData: ?*c_void,
    dwServiceDataSize: u32,
    pCallerData: ?*c_void,
    dwCallerDataSize: u32,
    pContext: ?*c_void,
};

const CLSID_SpellCheckerFactory_Value = @import("zig.zig").Guid.initString("7ab36653-1796-484b-bdfa-e74f1db7c1dc");
pub const CLSID_SpellCheckerFactory = &CLSID_SpellCheckerFactory_Value;

pub const WORDLIST_TYPE = enum(i32) {
    IGNORE = 0,
    ADD = 1,
    EXCLUDE = 2,
    AUTOCORRECT = 3,
};
pub const WORDLIST_TYPE_IGNORE = WORDLIST_TYPE.IGNORE;
pub const WORDLIST_TYPE_ADD = WORDLIST_TYPE.ADD;
pub const WORDLIST_TYPE_EXCLUDE = WORDLIST_TYPE.EXCLUDE;
pub const WORDLIST_TYPE_AUTOCORRECT = WORDLIST_TYPE.AUTOCORRECT;

pub const CORRECTIVE_ACTION = enum(i32) {
    NONE = 0,
    GET_SUGGESTIONS = 1,
    REPLACE = 2,
    DELETE = 3,
};
pub const CORRECTIVE_ACTION_NONE = CORRECTIVE_ACTION.NONE;
pub const CORRECTIVE_ACTION_GET_SUGGESTIONS = CORRECTIVE_ACTION.GET_SUGGESTIONS;
pub const CORRECTIVE_ACTION_REPLACE = CORRECTIVE_ACTION.REPLACE;
pub const CORRECTIVE_ACTION_DELETE = CORRECTIVE_ACTION.DELETE;

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellingError_Value = @import("zig.zig").Guid.initString("b7c82d61-fbe8-4b47-9b27-6c0d2e0de0a3");
pub const IID_ISpellingError = &IID_ISpellingError_Value;
pub const ISpellingError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartIndex: fn(
            self: *const ISpellingError,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const ISpellingError,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CorrectiveAction: fn(
            self: *const ISpellingError,
            value: ?*CORRECTIVE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Replacement: fn(
            self: *const ISpellingError,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellingError_get_StartIndex(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellingError.VTable, self.vtable).get_StartIndex(@ptrCast(*const ISpellingError, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellingError_get_Length(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellingError.VTable, self.vtable).get_Length(@ptrCast(*const ISpellingError, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellingError_get_CorrectiveAction(self: *const T, value: ?*CORRECTIVE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellingError.VTable, self.vtable).get_CorrectiveAction(@ptrCast(*const ISpellingError, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellingError_get_Replacement(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellingError.VTable, self.vtable).get_Replacement(@ptrCast(*const ISpellingError, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IEnumSpellingError_Value = @import("zig.zig").Guid.initString("803e3bd4-2828-4410-8290-418d1d73c762");
pub const IID_IEnumSpellingError = &IID_IEnumSpellingError_Value;
pub const IEnumSpellingError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSpellingError,
            value: ?*?*ISpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpellingError_Next(self: *const T, value: ?*?*ISpellingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpellingError.VTable, self.vtable).Next(@ptrCast(*const IEnumSpellingError, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IOptionDescription_Value = @import("zig.zig").Guid.initString("432e5f85-35cf-4606-a801-6f70277e1d7a");
pub const IID_IOptionDescription = &IID_IOptionDescription_Value;
pub const IOptionDescription = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Heading: fn(
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Labels: fn(
            self: *const IOptionDescription,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOptionDescription_get_Id(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOptionDescription.VTable, self.vtable).get_Id(@ptrCast(*const IOptionDescription, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOptionDescription_get_Heading(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOptionDescription.VTable, self.vtable).get_Heading(@ptrCast(*const IOptionDescription, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOptionDescription_get_Description(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOptionDescription.VTable, self.vtable).get_Description(@ptrCast(*const IOptionDescription, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOptionDescription_get_Labels(self: *const T, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOptionDescription.VTable, self.vtable).get_Labels(@ptrCast(*const IOptionDescription, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckerChangedEventHandler_Value = @import("zig.zig").Guid.initString("0b83a5b0-792f-4eab-9799-acf52c5ed08a");
pub const IID_ISpellCheckerChangedEventHandler = &IID_ISpellCheckerChangedEventHandler_Value;
pub const ISpellCheckerChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: fn(
            self: *const ISpellCheckerChangedEventHandler,
            sender: ?*ISpellChecker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckerChangedEventHandler_Invoke(self: *const T, sender: ?*ISpellChecker) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckerChangedEventHandler.VTable, self.vtable).Invoke(@ptrCast(*const ISpellCheckerChangedEventHandler, self), sender);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellChecker_Value = @import("zig.zig").Guid.initString("b6fd0b71-e2bc-4653-8d05-f197e412770b");
pub const IID_ISpellChecker = &IID_ISpellChecker_Value;
pub const ISpellChecker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageTag: fn(
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Check: fn(
            self: *const ISpellChecker,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suggest: fn(
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Ignore: fn(
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCorrect: fn(
            self: *const ISpellChecker,
            from: ?[*:0]const u16,
            to: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionValue: fn(
            self: *const ISpellChecker,
            optionId: ?[*:0]const u16,
            value: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OptionIds: fn(
            self: *const ISpellChecker,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalizedName: fn(
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        add_SpellCheckerChanged: fn(
            self: *const ISpellChecker,
            handler: ?*ISpellCheckerChangedEventHandler,
            eventCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        remove_SpellCheckerChanged: fn(
            self: *const ISpellChecker,
            eventCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionDescription: fn(
            self: *const ISpellChecker,
            optionId: ?[*:0]const u16,
            value: ?*?*IOptionDescription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComprehensiveCheck: fn(
            self: *const ISpellChecker,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_get_LanguageTag(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).get_LanguageTag(@ptrCast(*const ISpellChecker, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_Check(self: *const T, text: ?[*:0]const u16, value: ?*?*IEnumSpellingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).Check(@ptrCast(*const ISpellChecker, self), text, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_Suggest(self: *const T, word: ?[*:0]const u16, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).Suggest(@ptrCast(*const ISpellChecker, self), word, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_Add(self: *const T, word: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).Add(@ptrCast(*const ISpellChecker, self), word);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_Ignore(self: *const T, word: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).Ignore(@ptrCast(*const ISpellChecker, self), word);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_AutoCorrect(self: *const T, from: ?[*:0]const u16, to: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).AutoCorrect(@ptrCast(*const ISpellChecker, self), from, to);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_GetOptionValue(self: *const T, optionId: ?[*:0]const u16, value: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).GetOptionValue(@ptrCast(*const ISpellChecker, self), optionId, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_get_OptionIds(self: *const T, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).get_OptionIds(@ptrCast(*const ISpellChecker, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_get_Id(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).get_Id(@ptrCast(*const ISpellChecker, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_get_LocalizedName(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).get_LocalizedName(@ptrCast(*const ISpellChecker, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_add_SpellCheckerChanged(self: *const T, handler: ?*ISpellCheckerChangedEventHandler, eventCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).add_SpellCheckerChanged(@ptrCast(*const ISpellChecker, self), handler, eventCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_remove_SpellCheckerChanged(self: *const T, eventCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).remove_SpellCheckerChanged(@ptrCast(*const ISpellChecker, self), eventCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_GetOptionDescription(self: *const T, optionId: ?[*:0]const u16, value: ?*?*IOptionDescription) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).GetOptionDescription(@ptrCast(*const ISpellChecker, self), optionId, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker_ComprehensiveCheck(self: *const T, text: ?[*:0]const u16, value: ?*?*IEnumSpellingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker.VTable, self.vtable).ComprehensiveCheck(@ptrCast(*const ISpellChecker, self), text, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ISpellChecker2_Value = @import("zig.zig").Guid.initString("e7ed1c71-87f7-4378-a840-c9200dacee47");
pub const IID_ISpellChecker2 = &IID_ISpellChecker2_Value;
pub const ISpellChecker2 = extern struct {
    pub const VTable = extern struct {
        base: ISpellChecker.VTable,
        Remove: fn(
            self: *const ISpellChecker2,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpellChecker.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellChecker2_Remove(self: *const T, word: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellChecker2.VTable, self.vtable).Remove(@ptrCast(*const ISpellChecker2, self), word);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckerFactory_Value = @import("zig.zig").Guid.initString("8e018a9d-2415-4677-bf08-794ea61f94bb");
pub const IID_ISpellCheckerFactory = &IID_ISpellCheckerFactory_Value;
pub const ISpellCheckerFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: fn(
            self: *const ISpellCheckerFactory,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSupported: fn(
            self: *const ISpellCheckerFactory,
            languageTag: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSpellChecker: fn(
            self: *const ISpellCheckerFactory,
            languageTag: ?[*:0]const u16,
            value: ?*?*ISpellChecker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckerFactory_get_SupportedLanguages(self: *const T, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckerFactory.VTable, self.vtable).get_SupportedLanguages(@ptrCast(*const ISpellCheckerFactory, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckerFactory_IsSupported(self: *const T, languageTag: ?[*:0]const u16, value: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckerFactory.VTable, self.vtable).IsSupported(@ptrCast(*const ISpellCheckerFactory, self), languageTag, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckerFactory_CreateSpellChecker(self: *const T, languageTag: ?[*:0]const u16, value: ?*?*ISpellChecker) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckerFactory.VTable, self.vtable).CreateSpellChecker(@ptrCast(*const ISpellCheckerFactory, self), languageTag, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUserDictionariesRegistrar_Value = @import("zig.zig").Guid.initString("aa176b85-0e12-4844-8e1a-eef1da77f586");
pub const IID_IUserDictionariesRegistrar = &IID_IUserDictionariesRegistrar_Value;
pub const IUserDictionariesRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterUserDictionary: fn(
            self: *const IUserDictionariesRegistrar,
            dictionaryPath: ?[*:0]const u16,
            languageTag: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterUserDictionary: fn(
            self: *const IUserDictionariesRegistrar,
            dictionaryPath: ?[*:0]const u16,
            languageTag: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserDictionariesRegistrar_RegisterUserDictionary(self: *const T, dictionaryPath: ?[*:0]const u16, languageTag: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserDictionariesRegistrar.VTable, self.vtable).RegisterUserDictionary(@ptrCast(*const IUserDictionariesRegistrar, self), dictionaryPath, languageTag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserDictionariesRegistrar_UnregisterUserDictionary(self: *const T, dictionaryPath: ?[*:0]const u16, languageTag: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserDictionariesRegistrar.VTable, self.vtable).UnregisterUserDictionary(@ptrCast(*const IUserDictionariesRegistrar, self), dictionaryPath, languageTag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckProvider_Value = @import("zig.zig").Guid.initString("73e976e0-8ed4-4eb1-80d7-1be0a16b0c38");
pub const IID_ISpellCheckProvider = &IID_ISpellCheckProvider_Value;
pub const ISpellCheckProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageTag: fn(
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Check: fn(
            self: *const ISpellCheckProvider,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suggest: fn(
            self: *const ISpellCheckProvider,
            word: ?[*:0]const u16,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionValue: fn(
            self: *const ISpellCheckProvider,
            optionId: ?[*:0]const u16,
            value: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOptionValue: fn(
            self: *const ISpellCheckProvider,
            optionId: ?[*:0]const u16,
            value: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OptionIds: fn(
            self: *const ISpellCheckProvider,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalizedName: fn(
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionDescription: fn(
            self: *const ISpellCheckProvider,
            optionId: ?[*:0]const u16,
            value: ?*?*IOptionDescription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeWordlist: fn(
            self: *const ISpellCheckProvider,
            wordlistType: WORDLIST_TYPE,
            words: ?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_get_LanguageTag(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).get_LanguageTag(@ptrCast(*const ISpellCheckProvider, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_Check(self: *const T, text: ?[*:0]const u16, value: ?*?*IEnumSpellingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).Check(@ptrCast(*const ISpellCheckProvider, self), text, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_Suggest(self: *const T, word: ?[*:0]const u16, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).Suggest(@ptrCast(*const ISpellCheckProvider, self), word, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_GetOptionValue(self: *const T, optionId: ?[*:0]const u16, value: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).GetOptionValue(@ptrCast(*const ISpellCheckProvider, self), optionId, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_SetOptionValue(self: *const T, optionId: ?[*:0]const u16, value: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).SetOptionValue(@ptrCast(*const ISpellCheckProvider, self), optionId, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_get_OptionIds(self: *const T, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).get_OptionIds(@ptrCast(*const ISpellCheckProvider, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_get_Id(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).get_Id(@ptrCast(*const ISpellCheckProvider, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_get_LocalizedName(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).get_LocalizedName(@ptrCast(*const ISpellCheckProvider, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_GetOptionDescription(self: *const T, optionId: ?[*:0]const u16, value: ?*?*IOptionDescription) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).GetOptionDescription(@ptrCast(*const ISpellCheckProvider, self), optionId, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProvider_InitializeWordlist(self: *const T, wordlistType: WORDLIST_TYPE, words: ?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProvider.VTable, self.vtable).InitializeWordlist(@ptrCast(*const ISpellCheckProvider, self), wordlistType, words);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IComprehensiveSpellCheckProvider_Value = @import("zig.zig").Guid.initString("0c58f8de-8e94-479e-9717-70c42c4ad2c3");
pub const IID_IComprehensiveSpellCheckProvider = &IID_IComprehensiveSpellCheckProvider_Value;
pub const IComprehensiveSpellCheckProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ComprehensiveCheck: fn(
            self: *const IComprehensiveSpellCheckProvider,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComprehensiveSpellCheckProvider_ComprehensiveCheck(self: *const T, text: ?[*:0]const u16, value: ?*?*IEnumSpellingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComprehensiveSpellCheckProvider.VTable, self.vtable).ComprehensiveCheck(@ptrCast(*const IComprehensiveSpellCheckProvider, self), text, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckProviderFactory_Value = @import("zig.zig").Guid.initString("9f671e11-77d6-4c92-aefb-615215e3a4be");
pub const IID_ISpellCheckProviderFactory = &IID_ISpellCheckProviderFactory_Value;
pub const ISpellCheckProviderFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: fn(
            self: *const ISpellCheckProviderFactory,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSupported: fn(
            self: *const ISpellCheckProviderFactory,
            languageTag: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSpellCheckProvider: fn(
            self: *const ISpellCheckProviderFactory,
            languageTag: ?[*:0]const u16,
            value: ?*?*ISpellCheckProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProviderFactory_get_SupportedLanguages(self: *const T, value: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProviderFactory.VTable, self.vtable).get_SupportedLanguages(@ptrCast(*const ISpellCheckProviderFactory, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProviderFactory_IsSupported(self: *const T, languageTag: ?[*:0]const u16, value: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProviderFactory.VTable, self.vtable).IsSupported(@ptrCast(*const ISpellCheckProviderFactory, self), languageTag, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpellCheckProviderFactory_CreateSpellCheckProvider(self: *const T, languageTag: ?[*:0]const u16, value: ?*?*ISpellCheckProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpellCheckProviderFactory.VTable, self.vtable).CreateSpellCheckProvider(@ptrCast(*const ISpellCheckProviderFactory, self), languageTag, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IFEClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IClassFactory.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEDLG = packed struct {
    cbIMEDLG: i32,
    hwnd: ?HWND,
    lpwstrWord: ?PWSTR,
    nTabId: i32,
};

const IID_IFECommon_Value = @import("zig.zig").Guid.initString("019f7151-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFECommon = &IID_IFECommon_Value;
pub const IFECommon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDefaultIME: fn(
            self: *const IFECommon,
            szName: [*:0]const u8,
            cszName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultIME: fn(
            self: *const IFECommon,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeWordRegDialog: fn(
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeDictToolDialog: fn(
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_IsDefaultIME(self: *const T, szName: [*:0]const u8, cszName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).IsDefaultIME(@ptrCast(*const IFECommon, self), szName, cszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_SetDefaultIME(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).SetDefaultIME(@ptrCast(*const IFECommon, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_InvokeWordRegDialog(self: *const T, pimedlg: ?*IMEDLG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).InvokeWordRegDialog(@ptrCast(*const IFECommon, self), pimedlg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_InvokeDictToolDialog(self: *const T, pimedlg: ?*IMEDLG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).InvokeDictToolDialog(@ptrCast(*const IFECommon, self), pimedlg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WDD = packed struct {
    wDispPos: u16,
    Anonymous1: packed union {
        wReadPos: u16,
        wCompPos: u16,
    },
    cchDisp: u16,
    Anonymous2: packed union {
        cchRead: u16,
        cchComp: u16,
    },
    WDD_nReserve1: u32,
    nPos: u16,
    _bitfield: u16,
    pReserved: ?*c_void,
};

pub const MORRSLT = packed struct {
    dwSize: u32,
    pwchOutput: ?PWSTR,
    cchOutput: u16,
    Anonymous1: packed union {
        pwchRead: ?PWSTR,
        pwchComp: ?PWSTR,
    },
    Anonymous2: packed union {
        cchRead: u16,
        cchComp: u16,
    },
    pchInputPos: ?*u16,
    pchOutputIdxWDD: ?*u16,
    Anonymous3: packed union {
        pchReadIdxWDD: ?*u16,
        pchCompIdxWDD: ?*u16,
    },
    paMonoRubyPos: ?*u16,
    pWDD: ?*WDD,
    cWDD: i32,
    pPrivate: ?*c_void,
    BLKBuff: [1]u16,
};

const IID_IFELanguage_Value = @import("zig.zig").Guid.initString("019f7152-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFELanguage = &IID_IFELanguage_Value;
pub const IFELanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJMorphResult: fn(
            self: *const IFELanguage,
            dwRequest: u32,
            dwCMode: u32,
            cwchInput: i32,
            pwchInput: ?[*:0]const u16,
            pfCInfo: ?*u32,
            ppResult: ?*?*MORRSLT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionModeCaps: fn(
            self: *const IFELanguage,
            pdwCaps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPhonetic: fn(
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            phonetic: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversion: fn(
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).Open(@ptrCast(*const IFELanguage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).Close(@ptrCast(*const IFELanguage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetJMorphResult(self: *const T, dwRequest: u32, dwCMode: u32, cwchInput: i32, pwchInput: ?[*:0]const u16, pfCInfo: ?*u32, ppResult: ?*?*MORRSLT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetJMorphResult(@ptrCast(*const IFELanguage, self), dwRequest, dwCMode, cwchInput, pwchInput, pfCInfo, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetConversionModeCaps(self: *const T, pdwCaps: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetConversionModeCaps(@ptrCast(*const IFELanguage, self), pdwCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetPhonetic(self: *const T, string: ?BSTR, start: i32, length: i32, phonetic: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetPhonetic(@ptrCast(*const IFELanguage, self), string, start, length, phonetic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetConversion(self: *const T, string: ?BSTR, start: i32, length: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetConversion(@ptrCast(*const IFELanguage, self), string, start, length, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEREG = enum(i32) {
    HEAD = 0,
    TAIL = 1,
    DEL = 2,
};
pub const IFED_REG_HEAD = IMEREG.HEAD;
pub const IFED_REG_TAIL = IMEREG.TAIL;
pub const IFED_REG_DEL = IMEREG.DEL;

pub const IMEFMT = enum(i32) {
    UNKNOWN = 0,
    MSIME2_BIN_SYSTEM = 1,
    MSIME2_BIN_USER = 2,
    MSIME2_TEXT_USER = 3,
    MSIME95_BIN_SYSTEM = 4,
    MSIME95_BIN_USER = 5,
    MSIME95_TEXT_USER = 6,
    MSIME97_BIN_SYSTEM = 7,
    MSIME97_BIN_USER = 8,
    MSIME97_TEXT_USER = 9,
    MSIME98_BIN_SYSTEM = 10,
    MSIME98_BIN_USER = 11,
    MSIME98_TEXT_USER = 12,
    ACTIVE_DICT = 13,
    ATOK9 = 14,
    ATOK10 = 15,
    NEC_AI_ = 16,
    WX_II = 17,
    WX_III = 18,
    VJE_20 = 19,
    MSIME98_SYSTEM_CE = 20,
    MSIME_BIN_SYSTEM = 21,
    MSIME_BIN_USER = 22,
    MSIME_TEXT_USER = 23,
    PIME2_BIN_USER = 24,
    PIME2_BIN_SYSTEM = 25,
    PIME2_BIN_STANDARD_SYSTEM = 26,
};
pub const IFED_UNKNOWN = IMEFMT.UNKNOWN;
pub const IFED_MSIME2_BIN_SYSTEM = IMEFMT.MSIME2_BIN_SYSTEM;
pub const IFED_MSIME2_BIN_USER = IMEFMT.MSIME2_BIN_USER;
pub const IFED_MSIME2_TEXT_USER = IMEFMT.MSIME2_TEXT_USER;
pub const IFED_MSIME95_BIN_SYSTEM = IMEFMT.MSIME95_BIN_SYSTEM;
pub const IFED_MSIME95_BIN_USER = IMEFMT.MSIME95_BIN_USER;
pub const IFED_MSIME95_TEXT_USER = IMEFMT.MSIME95_TEXT_USER;
pub const IFED_MSIME97_BIN_SYSTEM = IMEFMT.MSIME97_BIN_SYSTEM;
pub const IFED_MSIME97_BIN_USER = IMEFMT.MSIME97_BIN_USER;
pub const IFED_MSIME97_TEXT_USER = IMEFMT.MSIME97_TEXT_USER;
pub const IFED_MSIME98_BIN_SYSTEM = IMEFMT.MSIME98_BIN_SYSTEM;
pub const IFED_MSIME98_BIN_USER = IMEFMT.MSIME98_BIN_USER;
pub const IFED_MSIME98_TEXT_USER = IMEFMT.MSIME98_TEXT_USER;
pub const IFED_ACTIVE_DICT = IMEFMT.ACTIVE_DICT;
pub const IFED_ATOK9 = IMEFMT.ATOK9;
pub const IFED_ATOK10 = IMEFMT.ATOK10;
pub const IFED_NEC_AI_ = IMEFMT.NEC_AI_;
pub const IFED_WX_II = IMEFMT.WX_II;
pub const IFED_WX_III = IMEFMT.WX_III;
pub const IFED_VJE_20 = IMEFMT.VJE_20;
pub const IFED_MSIME98_SYSTEM_CE = IMEFMT.MSIME98_SYSTEM_CE;
pub const IFED_MSIME_BIN_SYSTEM = IMEFMT.MSIME_BIN_SYSTEM;
pub const IFED_MSIME_BIN_USER = IMEFMT.MSIME_BIN_USER;
pub const IFED_MSIME_TEXT_USER = IMEFMT.MSIME_TEXT_USER;
pub const IFED_PIME2_BIN_USER = IMEFMT.PIME2_BIN_USER;
pub const IFED_PIME2_BIN_SYSTEM = IMEFMT.PIME2_BIN_SYSTEM;
pub const IFED_PIME2_BIN_STANDARD_SYSTEM = IMEFMT.PIME2_BIN_STANDARD_SYSTEM;

pub const IMEUCT = enum(i32) {
    NONE = 0,
    STRING_SJIS = 1,
    STRING_UNICODE = 2,
    USER_DEFINED = 3,
    MAX = 4,
};
pub const IFED_UCT_NONE = IMEUCT.NONE;
pub const IFED_UCT_STRING_SJIS = IMEUCT.STRING_SJIS;
pub const IFED_UCT_STRING_UNICODE = IMEUCT.STRING_UNICODE;
pub const IFED_UCT_USER_DEFINED = IMEUCT.USER_DEFINED;
pub const IFED_UCT_MAX = IMEUCT.MAX;

pub const IMEWRD = packed struct {
    pwchReading: ?PWSTR,
    pwchDisplay: ?PWSTR,
    Anonymous: packed union {
        ulPos: u32,
        Anonymous: packed struct {
            nPos1: u16,
            nPos2: u16,
        },
    },
    rgulAttrs: [2]u32,
    cbComment: i32,
    uct: IMEUCT,
    pvComment: ?*c_void,
};

pub const IMESHF = packed struct {
    cbShf: u16,
    verDic: u16,
    szTitle: [48]CHAR,
    szDescription: [256]CHAR,
    szCopyright: [128]CHAR,
};

pub const POSTBL = packed struct {
    nPos: u16,
    szName: ?*u8,
};

pub const IMEREL = enum(i32) {
    NONE = 0,
    NO = 1,
    GA = 2,
    WO = 3,
    NI = 4,
    DE = 5,
    YORI = 6,
    KARA = 7,
    MADE = 8,
    HE = 9,
    TO = 10,
    IDEOM = 11,
    FUKU_YOUGEN = 12,
    KEIYOU_YOUGEN = 13,
    KEIDOU1_YOUGEN = 14,
    KEIDOU2_YOUGEN = 15,
    TAIGEN = 16,
    YOUGEN = 17,
    RENTAI_MEI = 18,
    RENSOU = 19,
    KEIYOU_TO_YOUGEN = 20,
    KEIYOU_TARU_YOUGEN = 21,
    UNKNOWN1 = 22,
    UNKNOWN2 = 23,
    ALL = 24,
};
pub const IFED_REL_NONE = IMEREL.NONE;
pub const IFED_REL_NO = IMEREL.NO;
pub const IFED_REL_GA = IMEREL.GA;
pub const IFED_REL_WO = IMEREL.WO;
pub const IFED_REL_NI = IMEREL.NI;
pub const IFED_REL_DE = IMEREL.DE;
pub const IFED_REL_YORI = IMEREL.YORI;
pub const IFED_REL_KARA = IMEREL.KARA;
pub const IFED_REL_MADE = IMEREL.MADE;
pub const IFED_REL_HE = IMEREL.HE;
pub const IFED_REL_TO = IMEREL.TO;
pub const IFED_REL_IDEOM = IMEREL.IDEOM;
pub const IFED_REL_FUKU_YOUGEN = IMEREL.FUKU_YOUGEN;
pub const IFED_REL_KEIYOU_YOUGEN = IMEREL.KEIYOU_YOUGEN;
pub const IFED_REL_KEIDOU1_YOUGEN = IMEREL.KEIDOU1_YOUGEN;
pub const IFED_REL_KEIDOU2_YOUGEN = IMEREL.KEIDOU2_YOUGEN;
pub const IFED_REL_TAIGEN = IMEREL.TAIGEN;
pub const IFED_REL_YOUGEN = IMEREL.YOUGEN;
pub const IFED_REL_RENTAI_MEI = IMEREL.RENTAI_MEI;
pub const IFED_REL_RENSOU = IMEREL.RENSOU;
pub const IFED_REL_KEIYOU_TO_YOUGEN = IMEREL.KEIYOU_TO_YOUGEN;
pub const IFED_REL_KEIYOU_TARU_YOUGEN = IMEREL.KEIYOU_TARU_YOUGEN;
pub const IFED_REL_UNKNOWN1 = IMEREL.UNKNOWN1;
pub const IFED_REL_UNKNOWN2 = IMEREL.UNKNOWN2;
pub const IFED_REL_ALL = IMEREL.ALL;

pub const IMEDP = packed struct {
    wrdModifier: IMEWRD,
    wrdModifiee: IMEWRD,
    relID: IMEREL,
};

pub const PFNLOG = fn(
    param0: ?*IMEDP,
    param1: HRESULT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IFEDictionary_Value = @import("zig.zig").Guid.initString("019f7153-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFEDictionary = &IID_IFEDictionary_Value;
pub const IFEDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IFEDictionary,
            pchDictPath: ?*[260]u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeader: fn(
            self: *const IFEDictionary,
            pchDictPath: ?*[260]u8,
            pshf: ?*IMESHF,
            pjfmt: ?*IMEFMT,
            pulType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayProperty: fn(
            self: *const IFEDictionary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosTable: fn(
            self: *const IFEDictionary,
            prgPosTbl: ?*?*POSTBL,
            pcPosTbl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: fn(
            self: *const IFEDictionary,
            pwchFirst: ?[*:0]const u16,
            pwchLast: ?[*:0]const u16,
            pwchDisplay: ?[*:0]const u16,
            ulPos: u32,
            ulSelect: u32,
            ulWordSrc: u32,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcWrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextWords: fn(
            self: *const IFEDictionary,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcWrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IFEDictionary,
            pchDictPath: ?[*:0]const u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeader: fn(
            self: *const IFEDictionary,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistWord: fn(
            self: *const IFEDictionary,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistDependency: fn(
            self: *const IFEDictionary,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: fn(
            self: *const IFEDictionary,
            reg: IMEREG,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDependency: fn(
            self: *const IFEDictionary,
            reg: IMEREG,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDependencies: fn(
            self: *const IFEDictionary,
            pwchKakariReading: ?[*:0]const u16,
            pwchKakariDisplay: ?[*:0]const u16,
            ulKakariPos: u32,
            pwchUkeReading: ?[*:0]const u16,
            pwchUkeDisplay: ?[*:0]const u16,
            ulUkePos: u32,
            jrel: IMEREL,
            ulWordSrc: u32,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcdp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextDependencies: fn(
            self: *const IFEDictionary,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcDp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromOldMSIME: fn(
            self: *const IFEDictionary,
            pchDic: ?[*:0]const u8,
            pfnLog: ?PFNLOG,
            reg: IMEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromUserToSys: fn(
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Open(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Open(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Close(@ptrCast(*const IFEDictionary, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetHeader(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF, pjfmt: ?*IMEFMT, pulType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetHeader(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf, pjfmt, pulType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_DisplayProperty(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).DisplayProperty(@ptrCast(*const IFEDictionary, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetPosTable(self: *const T, prgPosTbl: ?*?*POSTBL, pcPosTbl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetPosTable(@ptrCast(*const IFEDictionary, self), prgPosTbl, pcPosTbl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetWords(self: *const T, pwchFirst: ?[*:0]const u16, pwchLast: ?[*:0]const u16, pwchDisplay: ?[*:0]const u16, ulPos: u32, ulSelect: u32, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetWords(@ptrCast(*const IFEDictionary, self), pwchFirst, pwchLast, pwchDisplay, ulPos, ulSelect, ulWordSrc, pchBuffer, cbBuffer, pcWrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_NextWords(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).NextWords(@ptrCast(*const IFEDictionary, self), pchBuffer, cbBuffer, pcWrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Create(self: *const T, pchDictPath: ?[*:0]const u8, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Create(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_SetHeader(self: *const T, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).SetHeader(@ptrCast(*const IFEDictionary, self), pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ExistWord(self: *const T, pwrd: ?*IMEWRD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ExistWord(@ptrCast(*const IFEDictionary, self), pwrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ExistDependency(self: *const T, pdp: ?*IMEDP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ExistDependency(@ptrCast(*const IFEDictionary, self), pdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_RegisterWord(self: *const T, reg: IMEREG, pwrd: ?*IMEWRD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).RegisterWord(@ptrCast(*const IFEDictionary, self), reg, pwrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_RegisterDependency(self: *const T, reg: IMEREG, pdp: ?*IMEDP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).RegisterDependency(@ptrCast(*const IFEDictionary, self), reg, pdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetDependencies(self: *const T, pwchKakariReading: ?[*:0]const u16, pwchKakariDisplay: ?[*:0]const u16, ulKakariPos: u32, pwchUkeReading: ?[*:0]const u16, pwchUkeDisplay: ?[*:0]const u16, ulUkePos: u32, jrel: IMEREL, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcdp: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetDependencies(@ptrCast(*const IFEDictionary, self), pwchKakariReading, pwchKakariDisplay, ulKakariPos, pwchUkeReading, pwchUkeDisplay, ulUkePos, jrel, ulWordSrc, pchBuffer, cbBuffer, pcdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_NextDependencies(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcDp: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).NextDependencies(@ptrCast(*const IFEDictionary, self), pchBuffer, cbBuffer, pcDp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ConvertFromOldMSIME(self: *const T, pchDic: ?[*:0]const u8, pfnLog: ?PFNLOG, reg: IMEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ConvertFromOldMSIME(@ptrCast(*const IFEDictionary, self), pchDic, pfnLog, reg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ConvertFromUserToSys(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ConvertFromUserToSys(@ptrCast(*const IFEDictionary, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEKMSINIT = packed struct {
    cbSize: i32,
    hWnd: ?HWND,
};

pub const IMEKMSKEY = packed struct {
    dwStatus: u32,
    dwCompStatus: u32,
    dwVKEY: u32,
    Anonymous1: packed union {
        dwControl: u32,
        dwNotUsed: u32,
    },
    Anonymous2: packed union {
        pwszDscr: [31]u16,
        pwszNoUse: [31]u16,
    },
};

pub const IMEKMS = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    cKeyList: u32,
    pKeyList: ?*IMEKMSKEY,
};

pub const IMEKMSNTFY = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    fSelect: BOOL,
};

pub const IMEKMSKMP = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    idLang: u16,
    wVKStart: u16,
    wVKEnd: u16,
    cKeyList: i32,
    pKeyList: ?*IMEKMSKEY,
};

pub const IMEKMSINVK = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    dwControl: u32,
};

pub const IMEKMSFUNCDESC = packed struct {
    cbSize: i32,
    idLang: u16,
    dwControl: u32,
    pwszDescription: [128]u16,
};

pub const fpCreateIFECommonInstanceType = fn(
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFELanguageInstanceType = fn(
    clsid: ?*const Guid,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFEDictionaryInstanceType = fn(
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const COMPOSITIONSTRING = extern struct {
    dwSize: u32,
    dwCompReadAttrLen: u32,
    dwCompReadAttrOffset: u32,
    dwCompReadClauseLen: u32,
    dwCompReadClauseOffset: u32,
    dwCompReadStrLen: u32,
    dwCompReadStrOffset: u32,
    dwCompAttrLen: u32,
    dwCompAttrOffset: u32,
    dwCompClauseLen: u32,
    dwCompClauseOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwCursorPos: u32,
    dwDeltaStart: u32,
    dwResultReadClauseLen: u32,
    dwResultReadClauseOffset: u32,
    dwResultReadStrLen: u32,
    dwResultReadStrOffset: u32,
    dwResultClauseLen: u32,
    dwResultClauseOffset: u32,
    dwResultStrLen: u32,
    dwResultStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const GUIDELINE = extern struct {
    dwSize: u32,
    dwLevel: u32,
    dwIndex: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const TRANSMSG = extern struct {
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const TRANSMSGLIST = extern struct {
    uMsgCount: u32,
    TransMsg: [1]TRANSMSG,
};

pub const CANDIDATEINFO = extern struct {
    dwSize: u32,
    dwCount: u32,
    dwOffset: [32]u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const INPUTCONTEXT = extern struct {
    hWnd: ?HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: extern union {
        A: LOGFONTA,
        W: LOGFONTW,
    },
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: [4]CANDIDATEFORM,
    hCompStr: ?HIMCC,
    hCandInfo: ?HIMCC,
    hGuideLine: ?HIMCC,
    hPrivate: ?HIMCC,
    dwNumMsgBuf: u32,
    hMsgBuf: ?HIMCC,
    fdwInit: u32,
    dwReserve: [3]u32,
};

pub const IMEINFO = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};

pub const SOFTKBDDATA = extern struct {
    uCount: u32,
    wCode: [256]u16,
};

pub const APPLETIDLIST = extern struct {
    count: i32,
    pIIDList: ?*Guid,
};

pub const IMESTRINGCANDIDATE = extern struct {
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMEITEM = extern struct {
    cbSize: i32,
    iType: i32,
    lpItemData: ?*c_void,
};

pub const IMEITEMCANDIDATE = extern struct {
    uCount: u32,
    imeItem: [1]IMEITEM,
};

pub const tabIMESTRINGINFO = extern struct {
    dwFarEastId: u32,
    lpwstr: ?PWSTR,
};

pub const tabIMEFAREASTINFO = extern struct {
    dwSize: u32,
    dwType: u32,
    dwData: [1]u32,
};

pub const IMESTRINGCANDIDATEINFO = extern struct {
    dwFarEastId: u32,
    lpFarEastInfo: ?*tabIMEFAREASTINFO,
    fInfoMask: u32,
    iSelIndex: i32,
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMECOMPOSITIONSTRINGINFO = extern struct {
    iCompStrLen: i32,
    iCaretPos: i32,
    iEditStart: i32,
    iEditLen: i32,
    iTargetStart: i32,
    iTargetLen: i32,
};

pub const IMECHARINFO = extern struct {
    wch: u16,
    dwCharInfo: u32,
};

pub const IMEAPPLETCFG = extern struct {
    dwConfig: u32,
    wchTitle: [64]u16,
    wchTitleFontFace: [32]u16,
    dwCharSet: u32,
    iCategory: i32,
    hIcon: ?HICON,
    langID: u16,
    dummy: u16,
    lReserved1: LPARAM,
};

pub const IMEAPPLETUI = extern struct {
    hwnd: ?HWND,
    dwStyle: u32,
    width: i32,
    height: i32,
    minWidth: i32,
    minHeight: i32,
    maxWidth: i32,
    maxHeight: i32,
    lReserved1: LPARAM,
    lReserved2: LPARAM,
};

pub const APPLYCANDEXPARAM = extern struct {
    dwSize: u32,
    lpwstrDisplay: ?PWSTR,
    lpwstrReading: ?PWSTR,
    dwReserved: u32,
};

const IID_IImeSpecifyApplets_Value = @import("zig.zig").Guid.initString("5d8e643c-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImeSpecifyApplets = &IID_IImeSpecifyApplets_Value;
pub const IImeSpecifyApplets = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppletIIDList: fn(
            self: *const IImeSpecifyApplets,
            refiid: ?*const Guid,
            lpIIDList: ?*APPLETIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImeSpecifyApplets_GetAppletIIDList(self: *const T, refiid: ?*const Guid, lpIIDList: ?*APPLETIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImeSpecifyApplets.VTable, self.vtable).GetAppletIIDList(@ptrCast(*const IImeSpecifyApplets, self), refiid, lpIIDList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePadApplet_Value = @import("zig.zig").Guid.initString("5d8e643b-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePadApplet = &IID_IImePadApplet_Value;
pub const IImePadApplet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IImePadApplet,
            lpIImePad: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IImePadApplet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppletConfig: fn(
            self: *const IImePadApplet,
            lpAppletCfg: ?*IMEAPPLETCFG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUI: fn(
            self: *const IImePadApplet,
            hwndParent: ?HWND,
            lpImeAppletUI: ?*IMEAPPLETUI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IImePadApplet,
            lpImePad: ?*IUnknown,
            notify: i32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Initialize(self: *const T, lpIImePad: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Initialize(@ptrCast(*const IImePadApplet, self), lpIImePad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Terminate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Terminate(@ptrCast(*const IImePadApplet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_GetAppletConfig(self: *const T, lpAppletCfg: ?*IMEAPPLETCFG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).GetAppletConfig(@ptrCast(*const IImePadApplet, self), lpAppletCfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_CreateUI(self: *const T, hwndParent: ?HWND, lpImeAppletUI: ?*IMEAPPLETUI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).CreateUI(@ptrCast(*const IImePadApplet, self), hwndParent, lpImeAppletUI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Notify(self: *const T, lpImePad: ?*IUnknown, notify: i32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Notify(@ptrCast(*const IImePadApplet, self), lpImePad, notify, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePad_Value = @import("zig.zig").Guid.initString("5d8e643a-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePad = &IID_IImePad_Value;
pub const IImePad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Request: fn(
            self: *const IImePad,
            pIImePadApplet: ?*IImePadApplet,
            reqId: IME_PAD_REQUEST_FLAGS,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePad_Request(self: *const T, pIImePadApplet: ?*IImePadApplet, reqId: IME_PAD_REQUEST_FLAGS, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePad.VTable, self.vtable).Request(@ptrCast(*const IImePad, self), pIImePadApplet, reqId, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IImePlugInDictDictionaryList_Value = @import("zig.zig").Guid.initString("98752974-b0a6-489b-8f6f-bff3769c8eeb");
pub const IID_IImePlugInDictDictionaryList = &IID_IImePlugInDictDictionaryList_Value;
pub const IImePlugInDictDictionaryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDictionariesInUse: fn(
            self: *const IImePlugInDictDictionaryList,
            prgDictionaryGUID: ?*?*SAFEARRAY,
            prgDateCreated: ?*?*SAFEARRAY,
            prgfEncrypted: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDictionary: fn(
            self: *const IImePlugInDictDictionaryList,
            bstrDictionaryGUID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePlugInDictDictionaryList_GetDictionariesInUse(self: *const T, prgDictionaryGUID: ?*?*SAFEARRAY, prgDateCreated: ?*?*SAFEARRAY, prgfEncrypted: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePlugInDictDictionaryList.VTable, self.vtable).GetDictionariesInUse(@ptrCast(*const IImePlugInDictDictionaryList, self), prgDictionaryGUID, prgDateCreated, prgfEncrypted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePlugInDictDictionaryList_DeleteDictionary(self: *const T, bstrDictionaryGUID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePlugInDictDictionaryList.VTable, self.vtable).DeleteDictionary(@ptrCast(*const IImePlugInDictDictionaryList, self), bstrDictionaryGUID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_CONTROL = extern struct {
    _bitfield: u32,
};

pub const SCRIPT_STATE = extern struct {
    _bitfield: u16,
};

pub const SCRIPT_ANALYSIS = extern struct {
    _bitfield: u16,
    s: SCRIPT_STATE,
};

pub const SCRIPT_ITEM = extern struct {
    iCharPos: i32,
    a: SCRIPT_ANALYSIS,
};

pub const SCRIPT_JUSTIFY = enum(i32) {
    NONE = 0,
    ARABIC_BLANK = 1,
    CHARACTER = 2,
    RESERVED1 = 3,
    BLANK = 4,
    RESERVED2 = 5,
    RESERVED3 = 6,
    ARABIC_NORMAL = 7,
    ARABIC_KASHIDA = 8,
    ARABIC_ALEF = 9,
    ARABIC_HA = 10,
    ARABIC_RA = 11,
    ARABIC_BA = 12,
    ARABIC_BARA = 13,
    ARABIC_SEEN = 14,
    ARABIC_SEEN_M = 15,
};
pub const SCRIPT_JUSTIFY_NONE = SCRIPT_JUSTIFY.NONE;
pub const SCRIPT_JUSTIFY_ARABIC_BLANK = SCRIPT_JUSTIFY.ARABIC_BLANK;
pub const SCRIPT_JUSTIFY_CHARACTER = SCRIPT_JUSTIFY.CHARACTER;
pub const SCRIPT_JUSTIFY_RESERVED1 = SCRIPT_JUSTIFY.RESERVED1;
pub const SCRIPT_JUSTIFY_BLANK = SCRIPT_JUSTIFY.BLANK;
pub const SCRIPT_JUSTIFY_RESERVED2 = SCRIPT_JUSTIFY.RESERVED2;
pub const SCRIPT_JUSTIFY_RESERVED3 = SCRIPT_JUSTIFY.RESERVED3;
pub const SCRIPT_JUSTIFY_ARABIC_NORMAL = SCRIPT_JUSTIFY.ARABIC_NORMAL;
pub const SCRIPT_JUSTIFY_ARABIC_KASHIDA = SCRIPT_JUSTIFY.ARABIC_KASHIDA;
pub const SCRIPT_JUSTIFY_ARABIC_ALEF = SCRIPT_JUSTIFY.ARABIC_ALEF;
pub const SCRIPT_JUSTIFY_ARABIC_HA = SCRIPT_JUSTIFY.ARABIC_HA;
pub const SCRIPT_JUSTIFY_ARABIC_RA = SCRIPT_JUSTIFY.ARABIC_RA;
pub const SCRIPT_JUSTIFY_ARABIC_BA = SCRIPT_JUSTIFY.ARABIC_BA;
pub const SCRIPT_JUSTIFY_ARABIC_BARA = SCRIPT_JUSTIFY.ARABIC_BARA;
pub const SCRIPT_JUSTIFY_ARABIC_SEEN = SCRIPT_JUSTIFY.ARABIC_SEEN;
pub const SCRIPT_JUSTIFY_ARABIC_SEEN_M = SCRIPT_JUSTIFY.ARABIC_SEEN_M;

pub const SCRIPT_VISATTR = extern struct {
    _bitfield: u16,
};

pub const GOFFSET = extern struct {
    du: i32,
    dv: i32,
};

pub const SCRIPT_LOGATTR = extern struct {
    _bitfield: u8,
};

pub const SCRIPT_PROPERTIES = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
};

pub const SCRIPT_FONTPROPERTIES = extern struct {
    cBytes: i32,
    wgBlank: u16,
    wgDefault: u16,
    wgInvalid: u16,
    wgKashida: u16,
    iKashidaWidth: i32,
};

pub const SCRIPT_TABDEF = extern struct {
    cTabStops: i32,
    iScale: i32,
    pTabStops: ?*i32,
    iTabOrigin: i32,
};

pub const SCRIPT_DIGITSUBSTITUTE = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
    dwReserved: u32,
};

pub const opentype_feature_record = extern struct {
    tagFeature: u32,
    lParameter: i32,
};

pub const textrange_properties = extern struct {
    potfRecords: ?*opentype_feature_record,
    cotfRecords: i32,
};

pub const script_charprop = extern struct {
    _bitfield: u16,
};

pub const script_glyphprop = extern struct {
    sva: SCRIPT_VISATTR,
    reserved: u16,
};

pub const UErrorCode = enum(i32) {
    USING_FALLBACK_WARNING = -128,
    // ERROR_WARNING_START = -128, this enum value conflicts with USING_FALLBACK_WARNING
    USING_DEFAULT_WARNING = -127,
    SAFECLONE_ALLOCATED_WARNING = -126,
    STATE_OLD_WARNING = -125,
    STRING_NOT_TERMINATED_WARNING = -124,
    SORT_KEY_TOO_SHORT_WARNING = -123,
    AMBIGUOUS_ALIAS_WARNING = -122,
    DIFFERENT_UCA_VERSION = -121,
    PLUGIN_CHANGED_LEVEL_WARNING = -120,
    ZERO_ERROR = 0,
    ILLEGAL_ARGUMENT_ERROR = 1,
    MISSING_RESOURCE_ERROR = 2,
    INVALID_FORMAT_ERROR = 3,
    FILE_ACCESS_ERROR = 4,
    INTERNAL_PROGRAM_ERROR = 5,
    MESSAGE_PARSE_ERROR = 6,
    MEMORY_ALLOCATION_ERROR = 7,
    INDEX_OUTOFBOUNDS_ERROR = 8,
    PARSE_ERROR = 9,
    INVALID_CHAR_FOUND = 10,
    TRUNCATED_CHAR_FOUND = 11,
    ILLEGAL_CHAR_FOUND = 12,
    INVALID_TABLE_FORMAT = 13,
    INVALID_TABLE_FILE = 14,
    BUFFER_OVERFLOW_ERROR = 15,
    UNSUPPORTED_ERROR = 16,
    RESOURCE_TYPE_MISMATCH = 17,
    ILLEGAL_ESCAPE_SEQUENCE = 18,
    UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    NO_SPACE_AVAILABLE = 20,
    CE_NOT_FOUND_ERROR = 21,
    PRIMARY_TOO_LONG_ERROR = 22,
    STATE_TOO_OLD_ERROR = 23,
    TOO_MANY_ALIASES_ERROR = 24,
    ENUM_OUT_OF_SYNC_ERROR = 25,
    INVARIANT_CONVERSION_ERROR = 26,
    INVALID_STATE_ERROR = 27,
    COLLATOR_VERSION_MISMATCH = 28,
    USELESS_COLLATOR_ERROR = 29,
    NO_WRITE_PERMISSION = 30,
    BAD_VARIABLE_DEFINITION = 65536,
    // PARSE_ERROR_START = 65536, this enum value conflicts with BAD_VARIABLE_DEFINITION
    MALFORMED_RULE = 65537,
    MALFORMED_SET = 65538,
    MALFORMED_SYMBOL_REFERENCE = 65539,
    MALFORMED_UNICODE_ESCAPE = 65540,
    MALFORMED_VARIABLE_DEFINITION = 65541,
    MALFORMED_VARIABLE_REFERENCE = 65542,
    MISMATCHED_SEGMENT_DELIMITERS = 65543,
    MISPLACED_ANCHOR_START = 65544,
    MISPLACED_CURSOR_OFFSET = 65545,
    MISPLACED_QUANTIFIER = 65546,
    MISSING_OPERATOR = 65547,
    MISSING_SEGMENT_CLOSE = 65548,
    MULTIPLE_ANTE_CONTEXTS = 65549,
    MULTIPLE_CURSORS = 65550,
    MULTIPLE_POST_CONTEXTS = 65551,
    TRAILING_BACKSLASH = 65552,
    UNDEFINED_SEGMENT_REFERENCE = 65553,
    UNDEFINED_VARIABLE = 65554,
    UNQUOTED_SPECIAL = 65555,
    UNTERMINATED_QUOTE = 65556,
    RULE_MASK_ERROR = 65557,
    MISPLACED_COMPOUND_FILTER = 65558,
    MULTIPLE_COMPOUND_FILTERS = 65559,
    INVALID_RBT_SYNTAX = 65560,
    INVALID_PROPERTY_PATTERN = 65561,
    MALFORMED_PRAGMA = 65562,
    UNCLOSED_SEGMENT = 65563,
    ILLEGAL_CHAR_IN_SEGMENT = 65564,
    VARIABLE_RANGE_EXHAUSTED = 65565,
    VARIABLE_RANGE_OVERLAP = 65566,
    ILLEGAL_CHARACTER = 65567,
    INTERNAL_TRANSLITERATOR_ERROR = 65568,
    INVALID_ID = 65569,
    INVALID_FUNCTION = 65570,
    UNEXPECTED_TOKEN = 65792,
    // FMT_PARSE_ERROR_START = 65792, this enum value conflicts with UNEXPECTED_TOKEN
    MULTIPLE_DECIMAL_SEPARATORS = 65793,
    // MULTIPLE_DECIMAL_SEPERATORS = 65793, this enum value conflicts with MULTIPLE_DECIMAL_SEPARATORS
    MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    MALFORMED_EXPONENTIAL_PATTERN = 65795,
    MULTIPLE_PERCENT_SYMBOLS = 65796,
    MULTIPLE_PERMILL_SYMBOLS = 65797,
    MULTIPLE_PAD_SPECIFIERS = 65798,
    PATTERN_SYNTAX_ERROR = 65799,
    ILLEGAL_PAD_POSITION = 65800,
    UNMATCHED_BRACES = 65801,
    UNSUPPORTED_PROPERTY = 65802,
    UNSUPPORTED_ATTRIBUTE = 65803,
    ARGUMENT_TYPE_MISMATCH = 65804,
    DUPLICATE_KEYWORD = 65805,
    UNDEFINED_KEYWORD = 65806,
    DEFAULT_KEYWORD_MISSING = 65807,
    DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    FORMAT_INEXACT_ERROR = 65809,
    NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    BRK_INTERNAL_ERROR = 66048,
    // BRK_ERROR_START = 66048, this enum value conflicts with BRK_INTERNAL_ERROR
    BRK_HEX_DIGITS_EXPECTED = 66049,
    BRK_SEMICOLON_EXPECTED = 66050,
    BRK_RULE_SYNTAX = 66051,
    BRK_UNCLOSED_SET = 66052,
    BRK_ASSIGN_ERROR = 66053,
    BRK_VARIABLE_REDFINITION = 66054,
    BRK_MISMATCHED_PAREN = 66055,
    BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    BRK_UNDEFINED_VARIABLE = 66057,
    BRK_INIT_ERROR = 66058,
    BRK_RULE_EMPTY_SET = 66059,
    BRK_UNRECOGNIZED_OPTION = 66060,
    BRK_MALFORMED_RULE_TAG = 66061,
    REGEX_INTERNAL_ERROR = 66304,
    // REGEX_ERROR_START = 66304, this enum value conflicts with REGEX_INTERNAL_ERROR
    REGEX_RULE_SYNTAX = 66305,
    REGEX_INVALID_STATE = 66306,
    REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    REGEX_PROPERTY_SYNTAX = 66308,
    REGEX_UNIMPLEMENTED = 66309,
    REGEX_MISMATCHED_PAREN = 66310,
    REGEX_NUMBER_TOO_BIG = 66311,
    REGEX_BAD_INTERVAL = 66312,
    REGEX_MAX_LT_MIN = 66313,
    REGEX_INVALID_BACK_REF = 66314,
    REGEX_INVALID_FLAG = 66315,
    REGEX_LOOK_BEHIND_LIMIT = 66316,
    REGEX_SET_CONTAINS_STRING = 66317,
    REGEX_MISSING_CLOSE_BRACKET = 66319,
    REGEX_INVALID_RANGE = 66320,
    REGEX_STACK_OVERFLOW = 66321,
    REGEX_TIME_OUT = 66322,
    REGEX_STOPPED_BY_CALLER = 66323,
    REGEX_PATTERN_TOO_BIG = 66324,
    REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    IDNA_PROHIBITED_ERROR = 66560,
    // IDNA_ERROR_START = 66560, this enum value conflicts with IDNA_PROHIBITED_ERROR
    IDNA_UNASSIGNED_ERROR = 66561,
    IDNA_CHECK_BIDI_ERROR = 66562,
    IDNA_STD3_ASCII_RULES_ERROR = 66563,
    IDNA_ACE_PREFIX_ERROR = 66564,
    IDNA_VERIFICATION_ERROR = 66565,
    IDNA_LABEL_TOO_LONG_ERROR = 66566,
    IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    // STRINGPREP_PROHIBITED_ERROR = 66560, this enum value conflicts with IDNA_PROHIBITED_ERROR
    // STRINGPREP_UNASSIGNED_ERROR = 66561, this enum value conflicts with IDNA_UNASSIGNED_ERROR
    // STRINGPREP_CHECK_BIDI_ERROR = 66562, this enum value conflicts with IDNA_CHECK_BIDI_ERROR
    PLUGIN_ERROR_START = 66816,
    // PLUGIN_TOO_HIGH = 66816, this enum value conflicts with PLUGIN_ERROR_START
    PLUGIN_DIDNT_SET_LEVEL = 66817,
};
pub const U_USING_FALLBACK_WARNING = UErrorCode.USING_FALLBACK_WARNING;
pub const U_ERROR_WARNING_START = UErrorCode.USING_FALLBACK_WARNING;
pub const U_USING_DEFAULT_WARNING = UErrorCode.USING_DEFAULT_WARNING;
pub const U_SAFECLONE_ALLOCATED_WARNING = UErrorCode.SAFECLONE_ALLOCATED_WARNING;
pub const U_STATE_OLD_WARNING = UErrorCode.STATE_OLD_WARNING;
pub const U_STRING_NOT_TERMINATED_WARNING = UErrorCode.STRING_NOT_TERMINATED_WARNING;
pub const U_SORT_KEY_TOO_SHORT_WARNING = UErrorCode.SORT_KEY_TOO_SHORT_WARNING;
pub const U_AMBIGUOUS_ALIAS_WARNING = UErrorCode.AMBIGUOUS_ALIAS_WARNING;
pub const U_DIFFERENT_UCA_VERSION = UErrorCode.DIFFERENT_UCA_VERSION;
pub const U_PLUGIN_CHANGED_LEVEL_WARNING = UErrorCode.PLUGIN_CHANGED_LEVEL_WARNING;
pub const U_ZERO_ERROR = UErrorCode.ZERO_ERROR;
pub const U_ILLEGAL_ARGUMENT_ERROR = UErrorCode.ILLEGAL_ARGUMENT_ERROR;
pub const U_MISSING_RESOURCE_ERROR = UErrorCode.MISSING_RESOURCE_ERROR;
pub const U_INVALID_FORMAT_ERROR = UErrorCode.INVALID_FORMAT_ERROR;
pub const U_FILE_ACCESS_ERROR = UErrorCode.FILE_ACCESS_ERROR;
pub const U_INTERNAL_PROGRAM_ERROR = UErrorCode.INTERNAL_PROGRAM_ERROR;
pub const U_MESSAGE_PARSE_ERROR = UErrorCode.MESSAGE_PARSE_ERROR;
pub const U_MEMORY_ALLOCATION_ERROR = UErrorCode.MEMORY_ALLOCATION_ERROR;
pub const U_INDEX_OUTOFBOUNDS_ERROR = UErrorCode.INDEX_OUTOFBOUNDS_ERROR;
pub const U_PARSE_ERROR = UErrorCode.PARSE_ERROR;
pub const U_INVALID_CHAR_FOUND = UErrorCode.INVALID_CHAR_FOUND;
pub const U_TRUNCATED_CHAR_FOUND = UErrorCode.TRUNCATED_CHAR_FOUND;
pub const U_ILLEGAL_CHAR_FOUND = UErrorCode.ILLEGAL_CHAR_FOUND;
pub const U_INVALID_TABLE_FORMAT = UErrorCode.INVALID_TABLE_FORMAT;
pub const U_INVALID_TABLE_FILE = UErrorCode.INVALID_TABLE_FILE;
pub const U_BUFFER_OVERFLOW_ERROR = UErrorCode.BUFFER_OVERFLOW_ERROR;
pub const U_UNSUPPORTED_ERROR = UErrorCode.UNSUPPORTED_ERROR;
pub const U_RESOURCE_TYPE_MISMATCH = UErrorCode.RESOURCE_TYPE_MISMATCH;
pub const U_ILLEGAL_ESCAPE_SEQUENCE = UErrorCode.ILLEGAL_ESCAPE_SEQUENCE;
pub const U_UNSUPPORTED_ESCAPE_SEQUENCE = UErrorCode.UNSUPPORTED_ESCAPE_SEQUENCE;
pub const U_NO_SPACE_AVAILABLE = UErrorCode.NO_SPACE_AVAILABLE;
pub const U_CE_NOT_FOUND_ERROR = UErrorCode.CE_NOT_FOUND_ERROR;
pub const U_PRIMARY_TOO_LONG_ERROR = UErrorCode.PRIMARY_TOO_LONG_ERROR;
pub const U_STATE_TOO_OLD_ERROR = UErrorCode.STATE_TOO_OLD_ERROR;
pub const U_TOO_MANY_ALIASES_ERROR = UErrorCode.TOO_MANY_ALIASES_ERROR;
pub const U_ENUM_OUT_OF_SYNC_ERROR = UErrorCode.ENUM_OUT_OF_SYNC_ERROR;
pub const U_INVARIANT_CONVERSION_ERROR = UErrorCode.INVARIANT_CONVERSION_ERROR;
pub const U_INVALID_STATE_ERROR = UErrorCode.INVALID_STATE_ERROR;
pub const U_COLLATOR_VERSION_MISMATCH = UErrorCode.COLLATOR_VERSION_MISMATCH;
pub const U_USELESS_COLLATOR_ERROR = UErrorCode.USELESS_COLLATOR_ERROR;
pub const U_NO_WRITE_PERMISSION = UErrorCode.NO_WRITE_PERMISSION;
pub const U_BAD_VARIABLE_DEFINITION = UErrorCode.BAD_VARIABLE_DEFINITION;
pub const U_PARSE_ERROR_START = UErrorCode.BAD_VARIABLE_DEFINITION;
pub const U_MALFORMED_RULE = UErrorCode.MALFORMED_RULE;
pub const U_MALFORMED_SET = UErrorCode.MALFORMED_SET;
pub const U_MALFORMED_SYMBOL_REFERENCE = UErrorCode.MALFORMED_SYMBOL_REFERENCE;
pub const U_MALFORMED_UNICODE_ESCAPE = UErrorCode.MALFORMED_UNICODE_ESCAPE;
pub const U_MALFORMED_VARIABLE_DEFINITION = UErrorCode.MALFORMED_VARIABLE_DEFINITION;
pub const U_MALFORMED_VARIABLE_REFERENCE = UErrorCode.MALFORMED_VARIABLE_REFERENCE;
pub const U_MISMATCHED_SEGMENT_DELIMITERS = UErrorCode.MISMATCHED_SEGMENT_DELIMITERS;
pub const U_MISPLACED_ANCHOR_START = UErrorCode.MISPLACED_ANCHOR_START;
pub const U_MISPLACED_CURSOR_OFFSET = UErrorCode.MISPLACED_CURSOR_OFFSET;
pub const U_MISPLACED_QUANTIFIER = UErrorCode.MISPLACED_QUANTIFIER;
pub const U_MISSING_OPERATOR = UErrorCode.MISSING_OPERATOR;
pub const U_MISSING_SEGMENT_CLOSE = UErrorCode.MISSING_SEGMENT_CLOSE;
pub const U_MULTIPLE_ANTE_CONTEXTS = UErrorCode.MULTIPLE_ANTE_CONTEXTS;
pub const U_MULTIPLE_CURSORS = UErrorCode.MULTIPLE_CURSORS;
pub const U_MULTIPLE_POST_CONTEXTS = UErrorCode.MULTIPLE_POST_CONTEXTS;
pub const U_TRAILING_BACKSLASH = UErrorCode.TRAILING_BACKSLASH;
pub const U_UNDEFINED_SEGMENT_REFERENCE = UErrorCode.UNDEFINED_SEGMENT_REFERENCE;
pub const U_UNDEFINED_VARIABLE = UErrorCode.UNDEFINED_VARIABLE;
pub const U_UNQUOTED_SPECIAL = UErrorCode.UNQUOTED_SPECIAL;
pub const U_UNTERMINATED_QUOTE = UErrorCode.UNTERMINATED_QUOTE;
pub const U_RULE_MASK_ERROR = UErrorCode.RULE_MASK_ERROR;
pub const U_MISPLACED_COMPOUND_FILTER = UErrorCode.MISPLACED_COMPOUND_FILTER;
pub const U_MULTIPLE_COMPOUND_FILTERS = UErrorCode.MULTIPLE_COMPOUND_FILTERS;
pub const U_INVALID_RBT_SYNTAX = UErrorCode.INVALID_RBT_SYNTAX;
pub const U_INVALID_PROPERTY_PATTERN = UErrorCode.INVALID_PROPERTY_PATTERN;
pub const U_MALFORMED_PRAGMA = UErrorCode.MALFORMED_PRAGMA;
pub const U_UNCLOSED_SEGMENT = UErrorCode.UNCLOSED_SEGMENT;
pub const U_ILLEGAL_CHAR_IN_SEGMENT = UErrorCode.ILLEGAL_CHAR_IN_SEGMENT;
pub const U_VARIABLE_RANGE_EXHAUSTED = UErrorCode.VARIABLE_RANGE_EXHAUSTED;
pub const U_VARIABLE_RANGE_OVERLAP = UErrorCode.VARIABLE_RANGE_OVERLAP;
pub const U_ILLEGAL_CHARACTER = UErrorCode.ILLEGAL_CHARACTER;
pub const U_INTERNAL_TRANSLITERATOR_ERROR = UErrorCode.INTERNAL_TRANSLITERATOR_ERROR;
pub const U_INVALID_ID = UErrorCode.INVALID_ID;
pub const U_INVALID_FUNCTION = UErrorCode.INVALID_FUNCTION;
pub const U_UNEXPECTED_TOKEN = UErrorCode.UNEXPECTED_TOKEN;
pub const U_FMT_PARSE_ERROR_START = UErrorCode.UNEXPECTED_TOKEN;
pub const U_MULTIPLE_DECIMAL_SEPARATORS = UErrorCode.MULTIPLE_DECIMAL_SEPARATORS;
pub const U_MULTIPLE_DECIMAL_SEPERATORS = UErrorCode.MULTIPLE_DECIMAL_SEPARATORS;
pub const U_MULTIPLE_EXPONENTIAL_SYMBOLS = UErrorCode.MULTIPLE_EXPONENTIAL_SYMBOLS;
pub const U_MALFORMED_EXPONENTIAL_PATTERN = UErrorCode.MALFORMED_EXPONENTIAL_PATTERN;
pub const U_MULTIPLE_PERCENT_SYMBOLS = UErrorCode.MULTIPLE_PERCENT_SYMBOLS;
pub const U_MULTIPLE_PERMILL_SYMBOLS = UErrorCode.MULTIPLE_PERMILL_SYMBOLS;
pub const U_MULTIPLE_PAD_SPECIFIERS = UErrorCode.MULTIPLE_PAD_SPECIFIERS;
pub const U_PATTERN_SYNTAX_ERROR = UErrorCode.PATTERN_SYNTAX_ERROR;
pub const U_ILLEGAL_PAD_POSITION = UErrorCode.ILLEGAL_PAD_POSITION;
pub const U_UNMATCHED_BRACES = UErrorCode.UNMATCHED_BRACES;
pub const U_UNSUPPORTED_PROPERTY = UErrorCode.UNSUPPORTED_PROPERTY;
pub const U_UNSUPPORTED_ATTRIBUTE = UErrorCode.UNSUPPORTED_ATTRIBUTE;
pub const U_ARGUMENT_TYPE_MISMATCH = UErrorCode.ARGUMENT_TYPE_MISMATCH;
pub const U_DUPLICATE_KEYWORD = UErrorCode.DUPLICATE_KEYWORD;
pub const U_UNDEFINED_KEYWORD = UErrorCode.UNDEFINED_KEYWORD;
pub const U_DEFAULT_KEYWORD_MISSING = UErrorCode.DEFAULT_KEYWORD_MISSING;
pub const U_DECIMAL_NUMBER_SYNTAX_ERROR = UErrorCode.DECIMAL_NUMBER_SYNTAX_ERROR;
pub const U_FORMAT_INEXACT_ERROR = UErrorCode.FORMAT_INEXACT_ERROR;
pub const U_NUMBER_ARG_OUTOFBOUNDS_ERROR = UErrorCode.NUMBER_ARG_OUTOFBOUNDS_ERROR;
pub const U_NUMBER_SKELETON_SYNTAX_ERROR = UErrorCode.NUMBER_SKELETON_SYNTAX_ERROR;
pub const U_BRK_INTERNAL_ERROR = UErrorCode.BRK_INTERNAL_ERROR;
pub const U_BRK_ERROR_START = UErrorCode.BRK_INTERNAL_ERROR;
pub const U_BRK_HEX_DIGITS_EXPECTED = UErrorCode.BRK_HEX_DIGITS_EXPECTED;
pub const U_BRK_SEMICOLON_EXPECTED = UErrorCode.BRK_SEMICOLON_EXPECTED;
pub const U_BRK_RULE_SYNTAX = UErrorCode.BRK_RULE_SYNTAX;
pub const U_BRK_UNCLOSED_SET = UErrorCode.BRK_UNCLOSED_SET;
pub const U_BRK_ASSIGN_ERROR = UErrorCode.BRK_ASSIGN_ERROR;
pub const U_BRK_VARIABLE_REDFINITION = UErrorCode.BRK_VARIABLE_REDFINITION;
pub const U_BRK_MISMATCHED_PAREN = UErrorCode.BRK_MISMATCHED_PAREN;
pub const U_BRK_NEW_LINE_IN_QUOTED_STRING = UErrorCode.BRK_NEW_LINE_IN_QUOTED_STRING;
pub const U_BRK_UNDEFINED_VARIABLE = UErrorCode.BRK_UNDEFINED_VARIABLE;
pub const U_BRK_INIT_ERROR = UErrorCode.BRK_INIT_ERROR;
pub const U_BRK_RULE_EMPTY_SET = UErrorCode.BRK_RULE_EMPTY_SET;
pub const U_BRK_UNRECOGNIZED_OPTION = UErrorCode.BRK_UNRECOGNIZED_OPTION;
pub const U_BRK_MALFORMED_RULE_TAG = UErrorCode.BRK_MALFORMED_RULE_TAG;
pub const U_REGEX_INTERNAL_ERROR = UErrorCode.REGEX_INTERNAL_ERROR;
pub const U_REGEX_ERROR_START = UErrorCode.REGEX_INTERNAL_ERROR;
pub const U_REGEX_RULE_SYNTAX = UErrorCode.REGEX_RULE_SYNTAX;
pub const U_REGEX_INVALID_STATE = UErrorCode.REGEX_INVALID_STATE;
pub const U_REGEX_BAD_ESCAPE_SEQUENCE = UErrorCode.REGEX_BAD_ESCAPE_SEQUENCE;
pub const U_REGEX_PROPERTY_SYNTAX = UErrorCode.REGEX_PROPERTY_SYNTAX;
pub const U_REGEX_UNIMPLEMENTED = UErrorCode.REGEX_UNIMPLEMENTED;
pub const U_REGEX_MISMATCHED_PAREN = UErrorCode.REGEX_MISMATCHED_PAREN;
pub const U_REGEX_NUMBER_TOO_BIG = UErrorCode.REGEX_NUMBER_TOO_BIG;
pub const U_REGEX_BAD_INTERVAL = UErrorCode.REGEX_BAD_INTERVAL;
pub const U_REGEX_MAX_LT_MIN = UErrorCode.REGEX_MAX_LT_MIN;
pub const U_REGEX_INVALID_BACK_REF = UErrorCode.REGEX_INVALID_BACK_REF;
pub const U_REGEX_INVALID_FLAG = UErrorCode.REGEX_INVALID_FLAG;
pub const U_REGEX_LOOK_BEHIND_LIMIT = UErrorCode.REGEX_LOOK_BEHIND_LIMIT;
pub const U_REGEX_SET_CONTAINS_STRING = UErrorCode.REGEX_SET_CONTAINS_STRING;
pub const U_REGEX_MISSING_CLOSE_BRACKET = UErrorCode.REGEX_MISSING_CLOSE_BRACKET;
pub const U_REGEX_INVALID_RANGE = UErrorCode.REGEX_INVALID_RANGE;
pub const U_REGEX_STACK_OVERFLOW = UErrorCode.REGEX_STACK_OVERFLOW;
pub const U_REGEX_TIME_OUT = UErrorCode.REGEX_TIME_OUT;
pub const U_REGEX_STOPPED_BY_CALLER = UErrorCode.REGEX_STOPPED_BY_CALLER;
pub const U_REGEX_PATTERN_TOO_BIG = UErrorCode.REGEX_PATTERN_TOO_BIG;
pub const U_REGEX_INVALID_CAPTURE_GROUP_NAME = UErrorCode.REGEX_INVALID_CAPTURE_GROUP_NAME;
pub const U_IDNA_PROHIBITED_ERROR = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_IDNA_ERROR_START = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_IDNA_UNASSIGNED_ERROR = UErrorCode.IDNA_UNASSIGNED_ERROR;
pub const U_IDNA_CHECK_BIDI_ERROR = UErrorCode.IDNA_CHECK_BIDI_ERROR;
pub const U_IDNA_STD3_ASCII_RULES_ERROR = UErrorCode.IDNA_STD3_ASCII_RULES_ERROR;
pub const U_IDNA_ACE_PREFIX_ERROR = UErrorCode.IDNA_ACE_PREFIX_ERROR;
pub const U_IDNA_VERIFICATION_ERROR = UErrorCode.IDNA_VERIFICATION_ERROR;
pub const U_IDNA_LABEL_TOO_LONG_ERROR = UErrorCode.IDNA_LABEL_TOO_LONG_ERROR;
pub const U_IDNA_ZERO_LENGTH_LABEL_ERROR = UErrorCode.IDNA_ZERO_LENGTH_LABEL_ERROR;
pub const U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = UErrorCode.IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
pub const U_STRINGPREP_PROHIBITED_ERROR = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_STRINGPREP_UNASSIGNED_ERROR = UErrorCode.IDNA_UNASSIGNED_ERROR;
pub const U_STRINGPREP_CHECK_BIDI_ERROR = UErrorCode.IDNA_CHECK_BIDI_ERROR;
pub const U_PLUGIN_ERROR_START = UErrorCode.PLUGIN_ERROR_START;
pub const U_PLUGIN_TOO_HIGH = UErrorCode.PLUGIN_ERROR_START;
pub const U_PLUGIN_DIDNT_SET_LEVEL = UErrorCode.PLUGIN_DIDNT_SET_LEVEL;

pub const UTraceLevel = enum(i32) {
    OFF = -1,
    ERROR = 0,
    WARNING = 3,
    OPEN_CLOSE = 5,
    INFO = 7,
    VERBOSE = 9,
};
pub const UTRACE_OFF = UTraceLevel.OFF;
pub const UTRACE_ERROR = UTraceLevel.ERROR;
pub const UTRACE_WARNING = UTraceLevel.WARNING;
pub const UTRACE_OPEN_CLOSE = UTraceLevel.OPEN_CLOSE;
pub const UTRACE_INFO = UTraceLevel.INFO;
pub const UTRACE_VERBOSE = UTraceLevel.VERBOSE;

pub const UTraceFunctionNumber = enum(i32) {
    FUNCTION_START = 0,
    // U_INIT = 0, this enum value conflicts with FUNCTION_START
    U_CLEANUP = 1,
    CONVERSION_START = 4096,
    // UCNV_OPEN = 4096, this enum value conflicts with CONVERSION_START
    UCNV_OPEN_PACKAGE = 4097,
    UCNV_OPEN_ALGORITHMIC = 4098,
    UCNV_CLONE = 4099,
    UCNV_CLOSE = 4100,
    UCNV_FLUSH_CACHE = 4101,
    UCNV_LOAD = 4102,
    UCNV_UNLOAD = 4103,
    COLLATION_START = 8192,
    // UCOL_OPEN = 8192, this enum value conflicts with COLLATION_START
    UCOL_CLOSE = 8193,
    UCOL_STRCOLL = 8194,
    UCOL_GET_SORTKEY = 8195,
    UCOL_GETLOCALE = 8196,
    UCOL_NEXTSORTKEYPART = 8197,
    UCOL_STRCOLLITER = 8198,
    UCOL_OPEN_FROM_SHORT_STRING = 8199,
    UCOL_STRCOLLUTF8 = 8200,
};
pub const UTRACE_FUNCTION_START = UTraceFunctionNumber.FUNCTION_START;
pub const UTRACE_U_INIT = UTraceFunctionNumber.FUNCTION_START;
pub const UTRACE_U_CLEANUP = UTraceFunctionNumber.U_CLEANUP;
pub const UTRACE_CONVERSION_START = UTraceFunctionNumber.CONVERSION_START;
pub const UTRACE_UCNV_OPEN = UTraceFunctionNumber.CONVERSION_START;
pub const UTRACE_UCNV_OPEN_PACKAGE = UTraceFunctionNumber.UCNV_OPEN_PACKAGE;
pub const UTRACE_UCNV_OPEN_ALGORITHMIC = UTraceFunctionNumber.UCNV_OPEN_ALGORITHMIC;
pub const UTRACE_UCNV_CLONE = UTraceFunctionNumber.UCNV_CLONE;
pub const UTRACE_UCNV_CLOSE = UTraceFunctionNumber.UCNV_CLOSE;
pub const UTRACE_UCNV_FLUSH_CACHE = UTraceFunctionNumber.UCNV_FLUSH_CACHE;
pub const UTRACE_UCNV_LOAD = UTraceFunctionNumber.UCNV_LOAD;
pub const UTRACE_UCNV_UNLOAD = UTraceFunctionNumber.UCNV_UNLOAD;
pub const UTRACE_COLLATION_START = UTraceFunctionNumber.COLLATION_START;
pub const UTRACE_UCOL_OPEN = UTraceFunctionNumber.COLLATION_START;
pub const UTRACE_UCOL_CLOSE = UTraceFunctionNumber.UCOL_CLOSE;
pub const UTRACE_UCOL_STRCOLL = UTraceFunctionNumber.UCOL_STRCOLL;
pub const UTRACE_UCOL_GET_SORTKEY = UTraceFunctionNumber.UCOL_GET_SORTKEY;
pub const UTRACE_UCOL_GETLOCALE = UTraceFunctionNumber.UCOL_GETLOCALE;
pub const UTRACE_UCOL_NEXTSORTKEYPART = UTraceFunctionNumber.UCOL_NEXTSORTKEYPART;
pub const UTRACE_UCOL_STRCOLLITER = UTraceFunctionNumber.UCOL_STRCOLLITER;
pub const UTRACE_UCOL_OPEN_FROM_SHORT_STRING = UTraceFunctionNumber.UCOL_OPEN_FROM_SHORT_STRING;
pub const UTRACE_UCOL_STRCOLLUTF8 = UTraceFunctionNumber.UCOL_STRCOLLUTF8;

pub const UTraceEntry = fn(
    context: ?*const c_void,
    fnNumber: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTraceExit = fn(
    context: ?*const c_void,
    fnNumber: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTraceData = fn(
    context: ?*const c_void,
    fnNumber: i32,
    level: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UStringTrieResult = enum(i32) {
    NO_MATCH = 0,
    NO_VALUE = 1,
    FINAL_VALUE = 2,
    INTERMEDIATE_VALUE = 3,
};
pub const USTRINGTRIE_NO_MATCH = UStringTrieResult.NO_MATCH;
pub const USTRINGTRIE_NO_VALUE = UStringTrieResult.NO_VALUE;
pub const USTRINGTRIE_FINAL_VALUE = UStringTrieResult.FINAL_VALUE;
pub const USTRINGTRIE_INTERMEDIATE_VALUE = UStringTrieResult.INTERMEDIATE_VALUE;

pub const UScriptCode = enum(i32) {
    INVALID_CODE = -1,
    COMMON = 0,
    INHERITED = 1,
    ARABIC = 2,
    ARMENIAN = 3,
    BENGALI = 4,
    BOPOMOFO = 5,
    CHEROKEE = 6,
    COPTIC = 7,
    CYRILLIC = 8,
    DESERET = 9,
    DEVANAGARI = 10,
    ETHIOPIC = 11,
    GEORGIAN = 12,
    GOTHIC = 13,
    GREEK = 14,
    GUJARATI = 15,
    GURMUKHI = 16,
    HAN = 17,
    HANGUL = 18,
    HEBREW = 19,
    HIRAGANA = 20,
    KANNADA = 21,
    KATAKANA = 22,
    KHMER = 23,
    LAO = 24,
    LATIN = 25,
    MALAYALAM = 26,
    MONGOLIAN = 27,
    MYANMAR = 28,
    OGHAM = 29,
    OLD_ITALIC = 30,
    ORIYA = 31,
    RUNIC = 32,
    SINHALA = 33,
    SYRIAC = 34,
    TAMIL = 35,
    TELUGU = 36,
    THAANA = 37,
    THAI = 38,
    TIBETAN = 39,
    CANADIAN_ABORIGINAL = 40,
    // UCAS = 40, this enum value conflicts with CANADIAN_ABORIGINAL
    YI = 41,
    TAGALOG = 42,
    HANUNOO = 43,
    BUHID = 44,
    TAGBANWA = 45,
    BRAILLE = 46,
    CYPRIOT = 47,
    LIMBU = 48,
    LINEAR_B = 49,
    OSMANYA = 50,
    SHAVIAN = 51,
    TAI_LE = 52,
    UGARITIC = 53,
    KATAKANA_OR_HIRAGANA = 54,
    BUGINESE = 55,
    GLAGOLITIC = 56,
    KHAROSHTHI = 57,
    SYLOTI_NAGRI = 58,
    NEW_TAI_LUE = 59,
    TIFINAGH = 60,
    OLD_PERSIAN = 61,
    BALINESE = 62,
    BATAK = 63,
    BLISSYMBOLS = 64,
    BRAHMI = 65,
    CHAM = 66,
    CIRTH = 67,
    OLD_CHURCH_SLAVONIC_CYRILLIC = 68,
    DEMOTIC_EGYPTIAN = 69,
    HIERATIC_EGYPTIAN = 70,
    EGYPTIAN_HIEROGLYPHS = 71,
    KHUTSURI = 72,
    SIMPLIFIED_HAN = 73,
    TRADITIONAL_HAN = 74,
    PAHAWH_HMONG = 75,
    OLD_HUNGARIAN = 76,
    HARAPPAN_INDUS = 77,
    JAVANESE = 78,
    KAYAH_LI = 79,
    LATIN_FRAKTUR = 80,
    LATIN_GAELIC = 81,
    LEPCHA = 82,
    LINEAR_A = 83,
    MANDAIC = 84,
    // MANDAEAN = 84, this enum value conflicts with MANDAIC
    MAYAN_HIEROGLYPHS = 85,
    MEROITIC_HIEROGLYPHS = 86,
    // MEROITIC = 86, this enum value conflicts with MEROITIC_HIEROGLYPHS
    NKO = 87,
    ORKHON = 88,
    OLD_PERMIC = 89,
    PHAGS_PA = 90,
    PHOENICIAN = 91,
    MIAO = 92,
    // PHONETIC_POLLARD = 92, this enum value conflicts with MIAO
    RONGORONGO = 93,
    SARATI = 94,
    ESTRANGELO_SYRIAC = 95,
    WESTERN_SYRIAC = 96,
    EASTERN_SYRIAC = 97,
    TENGWAR = 98,
    VAI = 99,
    VISIBLE_SPEECH = 100,
    CUNEIFORM = 101,
    UNWRITTEN_LANGUAGES = 102,
    UNKNOWN = 103,
    CARIAN = 104,
    JAPANESE = 105,
    LANNA = 106,
    LYCIAN = 107,
    LYDIAN = 108,
    OL_CHIKI = 109,
    REJANG = 110,
    SAURASHTRA = 111,
    SIGN_WRITING = 112,
    SUNDANESE = 113,
    MOON = 114,
    MEITEI_MAYEK = 115,
    IMPERIAL_ARAMAIC = 116,
    AVESTAN = 117,
    CHAKMA = 118,
    KOREAN = 119,
    KAITHI = 120,
    MANICHAEAN = 121,
    INSCRIPTIONAL_PAHLAVI = 122,
    PSALTER_PAHLAVI = 123,
    BOOK_PAHLAVI = 124,
    INSCRIPTIONAL_PARTHIAN = 125,
    SAMARITAN = 126,
    TAI_VIET = 127,
    MATHEMATICAL_NOTATION = 128,
    SYMBOLS = 129,
    BAMUM = 130,
    LISU = 131,
    NAKHI_GEBA = 132,
    OLD_SOUTH_ARABIAN = 133,
    BASSA_VAH = 134,
    DUPLOYAN = 135,
    ELBASAN = 136,
    GRANTHA = 137,
    KPELLE = 138,
    LOMA = 139,
    MENDE = 140,
    MEROITIC_CURSIVE = 141,
    OLD_NORTH_ARABIAN = 142,
    NABATAEAN = 143,
    PALMYRENE = 144,
    KHUDAWADI = 145,
    // SINDHI = 145, this enum value conflicts with KHUDAWADI
    WARANG_CITI = 146,
    AFAKA = 147,
    JURCHEN = 148,
    MRO = 149,
    NUSHU = 150,
    SHARADA = 151,
    SORA_SOMPENG = 152,
    TAKRI = 153,
    TANGUT = 154,
    WOLEAI = 155,
    ANATOLIAN_HIEROGLYPHS = 156,
    KHOJKI = 157,
    TIRHUTA = 158,
    CAUCASIAN_ALBANIAN = 159,
    MAHAJANI = 160,
    AHOM = 161,
    HATRAN = 162,
    MODI = 163,
    MULTANI = 164,
    PAU_CIN_HAU = 165,
    SIDDHAM = 166,
    ADLAM = 167,
    BHAIKSUKI = 168,
    MARCHEN = 169,
    NEWA = 170,
    OSAGE = 171,
    HAN_WITH_BOPOMOFO = 172,
    JAMO = 173,
    SYMBOLS_EMOJI = 174,
    MASARAM_GONDI = 175,
    SOYOMBO = 176,
    ZANABAZAR_SQUARE = 177,
    DOGRA = 178,
    GUNJALA_GONDI = 179,
    MAKASAR = 180,
    MEDEFAIDRIN = 181,
    HANIFI_ROHINGYA = 182,
    SOGDIAN = 183,
    OLD_SOGDIAN = 184,
    ELYMAIC = 185,
    NYIAKENG_PUACHUE_HMONG = 186,
    NANDINAGARI = 187,
    WANCHO = 188,
};
pub const USCRIPT_INVALID_CODE = UScriptCode.INVALID_CODE;
pub const USCRIPT_COMMON = UScriptCode.COMMON;
pub const USCRIPT_INHERITED = UScriptCode.INHERITED;
pub const USCRIPT_ARABIC = UScriptCode.ARABIC;
pub const USCRIPT_ARMENIAN = UScriptCode.ARMENIAN;
pub const USCRIPT_BENGALI = UScriptCode.BENGALI;
pub const USCRIPT_BOPOMOFO = UScriptCode.BOPOMOFO;
pub const USCRIPT_CHEROKEE = UScriptCode.CHEROKEE;
pub const USCRIPT_COPTIC = UScriptCode.COPTIC;
pub const USCRIPT_CYRILLIC = UScriptCode.CYRILLIC;
pub const USCRIPT_DESERET = UScriptCode.DESERET;
pub const USCRIPT_DEVANAGARI = UScriptCode.DEVANAGARI;
pub const USCRIPT_ETHIOPIC = UScriptCode.ETHIOPIC;
pub const USCRIPT_GEORGIAN = UScriptCode.GEORGIAN;
pub const USCRIPT_GOTHIC = UScriptCode.GOTHIC;
pub const USCRIPT_GREEK = UScriptCode.GREEK;
pub const USCRIPT_GUJARATI = UScriptCode.GUJARATI;
pub const USCRIPT_GURMUKHI = UScriptCode.GURMUKHI;
pub const USCRIPT_HAN = UScriptCode.HAN;
pub const USCRIPT_HANGUL = UScriptCode.HANGUL;
pub const USCRIPT_HEBREW = UScriptCode.HEBREW;
pub const USCRIPT_HIRAGANA = UScriptCode.HIRAGANA;
pub const USCRIPT_KANNADA = UScriptCode.KANNADA;
pub const USCRIPT_KATAKANA = UScriptCode.KATAKANA;
pub const USCRIPT_KHMER = UScriptCode.KHMER;
pub const USCRIPT_LAO = UScriptCode.LAO;
pub const USCRIPT_LATIN = UScriptCode.LATIN;
pub const USCRIPT_MALAYALAM = UScriptCode.MALAYALAM;
pub const USCRIPT_MONGOLIAN = UScriptCode.MONGOLIAN;
pub const USCRIPT_MYANMAR = UScriptCode.MYANMAR;
pub const USCRIPT_OGHAM = UScriptCode.OGHAM;
pub const USCRIPT_OLD_ITALIC = UScriptCode.OLD_ITALIC;
pub const USCRIPT_ORIYA = UScriptCode.ORIYA;
pub const USCRIPT_RUNIC = UScriptCode.RUNIC;
pub const USCRIPT_SINHALA = UScriptCode.SINHALA;
pub const USCRIPT_SYRIAC = UScriptCode.SYRIAC;
pub const USCRIPT_TAMIL = UScriptCode.TAMIL;
pub const USCRIPT_TELUGU = UScriptCode.TELUGU;
pub const USCRIPT_THAANA = UScriptCode.THAANA;
pub const USCRIPT_THAI = UScriptCode.THAI;
pub const USCRIPT_TIBETAN = UScriptCode.TIBETAN;
pub const USCRIPT_CANADIAN_ABORIGINAL = UScriptCode.CANADIAN_ABORIGINAL;
pub const USCRIPT_UCAS = UScriptCode.CANADIAN_ABORIGINAL;
pub const USCRIPT_YI = UScriptCode.YI;
pub const USCRIPT_TAGALOG = UScriptCode.TAGALOG;
pub const USCRIPT_HANUNOO = UScriptCode.HANUNOO;
pub const USCRIPT_BUHID = UScriptCode.BUHID;
pub const USCRIPT_TAGBANWA = UScriptCode.TAGBANWA;
pub const USCRIPT_BRAILLE = UScriptCode.BRAILLE;
pub const USCRIPT_CYPRIOT = UScriptCode.CYPRIOT;
pub const USCRIPT_LIMBU = UScriptCode.LIMBU;
pub const USCRIPT_LINEAR_B = UScriptCode.LINEAR_B;
pub const USCRIPT_OSMANYA = UScriptCode.OSMANYA;
pub const USCRIPT_SHAVIAN = UScriptCode.SHAVIAN;
pub const USCRIPT_TAI_LE = UScriptCode.TAI_LE;
pub const USCRIPT_UGARITIC = UScriptCode.UGARITIC;
pub const USCRIPT_KATAKANA_OR_HIRAGANA = UScriptCode.KATAKANA_OR_HIRAGANA;
pub const USCRIPT_BUGINESE = UScriptCode.BUGINESE;
pub const USCRIPT_GLAGOLITIC = UScriptCode.GLAGOLITIC;
pub const USCRIPT_KHAROSHTHI = UScriptCode.KHAROSHTHI;
pub const USCRIPT_SYLOTI_NAGRI = UScriptCode.SYLOTI_NAGRI;
pub const USCRIPT_NEW_TAI_LUE = UScriptCode.NEW_TAI_LUE;
pub const USCRIPT_TIFINAGH = UScriptCode.TIFINAGH;
pub const USCRIPT_OLD_PERSIAN = UScriptCode.OLD_PERSIAN;
pub const USCRIPT_BALINESE = UScriptCode.BALINESE;
pub const USCRIPT_BATAK = UScriptCode.BATAK;
pub const USCRIPT_BLISSYMBOLS = UScriptCode.BLISSYMBOLS;
pub const USCRIPT_BRAHMI = UScriptCode.BRAHMI;
pub const USCRIPT_CHAM = UScriptCode.CHAM;
pub const USCRIPT_CIRTH = UScriptCode.CIRTH;
pub const USCRIPT_OLD_CHURCH_SLAVONIC_CYRILLIC = UScriptCode.OLD_CHURCH_SLAVONIC_CYRILLIC;
pub const USCRIPT_DEMOTIC_EGYPTIAN = UScriptCode.DEMOTIC_EGYPTIAN;
pub const USCRIPT_HIERATIC_EGYPTIAN = UScriptCode.HIERATIC_EGYPTIAN;
pub const USCRIPT_EGYPTIAN_HIEROGLYPHS = UScriptCode.EGYPTIAN_HIEROGLYPHS;
pub const USCRIPT_KHUTSURI = UScriptCode.KHUTSURI;
pub const USCRIPT_SIMPLIFIED_HAN = UScriptCode.SIMPLIFIED_HAN;
pub const USCRIPT_TRADITIONAL_HAN = UScriptCode.TRADITIONAL_HAN;
pub const USCRIPT_PAHAWH_HMONG = UScriptCode.PAHAWH_HMONG;
pub const USCRIPT_OLD_HUNGARIAN = UScriptCode.OLD_HUNGARIAN;
pub const USCRIPT_HARAPPAN_INDUS = UScriptCode.HARAPPAN_INDUS;
pub const USCRIPT_JAVANESE = UScriptCode.JAVANESE;
pub const USCRIPT_KAYAH_LI = UScriptCode.KAYAH_LI;
pub const USCRIPT_LATIN_FRAKTUR = UScriptCode.LATIN_FRAKTUR;
pub const USCRIPT_LATIN_GAELIC = UScriptCode.LATIN_GAELIC;
pub const USCRIPT_LEPCHA = UScriptCode.LEPCHA;
pub const USCRIPT_LINEAR_A = UScriptCode.LINEAR_A;
pub const USCRIPT_MANDAIC = UScriptCode.MANDAIC;
pub const USCRIPT_MANDAEAN = UScriptCode.MANDAIC;
pub const USCRIPT_MAYAN_HIEROGLYPHS = UScriptCode.MAYAN_HIEROGLYPHS;
pub const USCRIPT_MEROITIC_HIEROGLYPHS = UScriptCode.MEROITIC_HIEROGLYPHS;
pub const USCRIPT_MEROITIC = UScriptCode.MEROITIC_HIEROGLYPHS;
pub const USCRIPT_NKO = UScriptCode.NKO;
pub const USCRIPT_ORKHON = UScriptCode.ORKHON;
pub const USCRIPT_OLD_PERMIC = UScriptCode.OLD_PERMIC;
pub const USCRIPT_PHAGS_PA = UScriptCode.PHAGS_PA;
pub const USCRIPT_PHOENICIAN = UScriptCode.PHOENICIAN;
pub const USCRIPT_MIAO = UScriptCode.MIAO;
pub const USCRIPT_PHONETIC_POLLARD = UScriptCode.MIAO;
pub const USCRIPT_RONGORONGO = UScriptCode.RONGORONGO;
pub const USCRIPT_SARATI = UScriptCode.SARATI;
pub const USCRIPT_ESTRANGELO_SYRIAC = UScriptCode.ESTRANGELO_SYRIAC;
pub const USCRIPT_WESTERN_SYRIAC = UScriptCode.WESTERN_SYRIAC;
pub const USCRIPT_EASTERN_SYRIAC = UScriptCode.EASTERN_SYRIAC;
pub const USCRIPT_TENGWAR = UScriptCode.TENGWAR;
pub const USCRIPT_VAI = UScriptCode.VAI;
pub const USCRIPT_VISIBLE_SPEECH = UScriptCode.VISIBLE_SPEECH;
pub const USCRIPT_CUNEIFORM = UScriptCode.CUNEIFORM;
pub const USCRIPT_UNWRITTEN_LANGUAGES = UScriptCode.UNWRITTEN_LANGUAGES;
pub const USCRIPT_UNKNOWN = UScriptCode.UNKNOWN;
pub const USCRIPT_CARIAN = UScriptCode.CARIAN;
pub const USCRIPT_JAPANESE = UScriptCode.JAPANESE;
pub const USCRIPT_LANNA = UScriptCode.LANNA;
pub const USCRIPT_LYCIAN = UScriptCode.LYCIAN;
pub const USCRIPT_LYDIAN = UScriptCode.LYDIAN;
pub const USCRIPT_OL_CHIKI = UScriptCode.OL_CHIKI;
pub const USCRIPT_REJANG = UScriptCode.REJANG;
pub const USCRIPT_SAURASHTRA = UScriptCode.SAURASHTRA;
pub const USCRIPT_SIGN_WRITING = UScriptCode.SIGN_WRITING;
pub const USCRIPT_SUNDANESE = UScriptCode.SUNDANESE;
pub const USCRIPT_MOON = UScriptCode.MOON;
pub const USCRIPT_MEITEI_MAYEK = UScriptCode.MEITEI_MAYEK;
pub const USCRIPT_IMPERIAL_ARAMAIC = UScriptCode.IMPERIAL_ARAMAIC;
pub const USCRIPT_AVESTAN = UScriptCode.AVESTAN;
pub const USCRIPT_CHAKMA = UScriptCode.CHAKMA;
pub const USCRIPT_KOREAN = UScriptCode.KOREAN;
pub const USCRIPT_KAITHI = UScriptCode.KAITHI;
pub const USCRIPT_MANICHAEAN = UScriptCode.MANICHAEAN;
pub const USCRIPT_INSCRIPTIONAL_PAHLAVI = UScriptCode.INSCRIPTIONAL_PAHLAVI;
pub const USCRIPT_PSALTER_PAHLAVI = UScriptCode.PSALTER_PAHLAVI;
pub const USCRIPT_BOOK_PAHLAVI = UScriptCode.BOOK_PAHLAVI;
pub const USCRIPT_INSCRIPTIONAL_PARTHIAN = UScriptCode.INSCRIPTIONAL_PARTHIAN;
pub const USCRIPT_SAMARITAN = UScriptCode.SAMARITAN;
pub const USCRIPT_TAI_VIET = UScriptCode.TAI_VIET;
pub const USCRIPT_MATHEMATICAL_NOTATION = UScriptCode.MATHEMATICAL_NOTATION;
pub const USCRIPT_SYMBOLS = UScriptCode.SYMBOLS;
pub const USCRIPT_BAMUM = UScriptCode.BAMUM;
pub const USCRIPT_LISU = UScriptCode.LISU;
pub const USCRIPT_NAKHI_GEBA = UScriptCode.NAKHI_GEBA;
pub const USCRIPT_OLD_SOUTH_ARABIAN = UScriptCode.OLD_SOUTH_ARABIAN;
pub const USCRIPT_BASSA_VAH = UScriptCode.BASSA_VAH;
pub const USCRIPT_DUPLOYAN = UScriptCode.DUPLOYAN;
pub const USCRIPT_ELBASAN = UScriptCode.ELBASAN;
pub const USCRIPT_GRANTHA = UScriptCode.GRANTHA;
pub const USCRIPT_KPELLE = UScriptCode.KPELLE;
pub const USCRIPT_LOMA = UScriptCode.LOMA;
pub const USCRIPT_MENDE = UScriptCode.MENDE;
pub const USCRIPT_MEROITIC_CURSIVE = UScriptCode.MEROITIC_CURSIVE;
pub const USCRIPT_OLD_NORTH_ARABIAN = UScriptCode.OLD_NORTH_ARABIAN;
pub const USCRIPT_NABATAEAN = UScriptCode.NABATAEAN;
pub const USCRIPT_PALMYRENE = UScriptCode.PALMYRENE;
pub const USCRIPT_KHUDAWADI = UScriptCode.KHUDAWADI;
pub const USCRIPT_SINDHI = UScriptCode.KHUDAWADI;
pub const USCRIPT_WARANG_CITI = UScriptCode.WARANG_CITI;
pub const USCRIPT_AFAKA = UScriptCode.AFAKA;
pub const USCRIPT_JURCHEN = UScriptCode.JURCHEN;
pub const USCRIPT_MRO = UScriptCode.MRO;
pub const USCRIPT_NUSHU = UScriptCode.NUSHU;
pub const USCRIPT_SHARADA = UScriptCode.SHARADA;
pub const USCRIPT_SORA_SOMPENG = UScriptCode.SORA_SOMPENG;
pub const USCRIPT_TAKRI = UScriptCode.TAKRI;
pub const USCRIPT_TANGUT = UScriptCode.TANGUT;
pub const USCRIPT_WOLEAI = UScriptCode.WOLEAI;
pub const USCRIPT_ANATOLIAN_HIEROGLYPHS = UScriptCode.ANATOLIAN_HIEROGLYPHS;
pub const USCRIPT_KHOJKI = UScriptCode.KHOJKI;
pub const USCRIPT_TIRHUTA = UScriptCode.TIRHUTA;
pub const USCRIPT_CAUCASIAN_ALBANIAN = UScriptCode.CAUCASIAN_ALBANIAN;
pub const USCRIPT_MAHAJANI = UScriptCode.MAHAJANI;
pub const USCRIPT_AHOM = UScriptCode.AHOM;
pub const USCRIPT_HATRAN = UScriptCode.HATRAN;
pub const USCRIPT_MODI = UScriptCode.MODI;
pub const USCRIPT_MULTANI = UScriptCode.MULTANI;
pub const USCRIPT_PAU_CIN_HAU = UScriptCode.PAU_CIN_HAU;
pub const USCRIPT_SIDDHAM = UScriptCode.SIDDHAM;
pub const USCRIPT_ADLAM = UScriptCode.ADLAM;
pub const USCRIPT_BHAIKSUKI = UScriptCode.BHAIKSUKI;
pub const USCRIPT_MARCHEN = UScriptCode.MARCHEN;
pub const USCRIPT_NEWA = UScriptCode.NEWA;
pub const USCRIPT_OSAGE = UScriptCode.OSAGE;
pub const USCRIPT_HAN_WITH_BOPOMOFO = UScriptCode.HAN_WITH_BOPOMOFO;
pub const USCRIPT_JAMO = UScriptCode.JAMO;
pub const USCRIPT_SYMBOLS_EMOJI = UScriptCode.SYMBOLS_EMOJI;
pub const USCRIPT_MASARAM_GONDI = UScriptCode.MASARAM_GONDI;
pub const USCRIPT_SOYOMBO = UScriptCode.SOYOMBO;
pub const USCRIPT_ZANABAZAR_SQUARE = UScriptCode.ZANABAZAR_SQUARE;
pub const USCRIPT_DOGRA = UScriptCode.DOGRA;
pub const USCRIPT_GUNJALA_GONDI = UScriptCode.GUNJALA_GONDI;
pub const USCRIPT_MAKASAR = UScriptCode.MAKASAR;
pub const USCRIPT_MEDEFAIDRIN = UScriptCode.MEDEFAIDRIN;
pub const USCRIPT_HANIFI_ROHINGYA = UScriptCode.HANIFI_ROHINGYA;
pub const USCRIPT_SOGDIAN = UScriptCode.SOGDIAN;
pub const USCRIPT_OLD_SOGDIAN = UScriptCode.OLD_SOGDIAN;
pub const USCRIPT_ELYMAIC = UScriptCode.ELYMAIC;
pub const USCRIPT_NYIAKENG_PUACHUE_HMONG = UScriptCode.NYIAKENG_PUACHUE_HMONG;
pub const USCRIPT_NANDINAGARI = UScriptCode.NANDINAGARI;
pub const USCRIPT_WANCHO = UScriptCode.WANCHO;

pub const UScriptUsage = enum(i32) {
    NOT_ENCODED = 0,
    UNKNOWN = 1,
    EXCLUDED = 2,
    LIMITED_USE = 3,
    ASPIRATIONAL = 4,
    RECOMMENDED = 5,
};
pub const USCRIPT_USAGE_NOT_ENCODED = UScriptUsage.NOT_ENCODED;
pub const USCRIPT_USAGE_UNKNOWN = UScriptUsage.UNKNOWN;
pub const USCRIPT_USAGE_EXCLUDED = UScriptUsage.EXCLUDED;
pub const USCRIPT_USAGE_LIMITED_USE = UScriptUsage.LIMITED_USE;
pub const USCRIPT_USAGE_ASPIRATIONAL = UScriptUsage.ASPIRATIONAL;
pub const USCRIPT_USAGE_RECOMMENDED = UScriptUsage.RECOMMENDED;

pub const UReplaceableCallbacks = extern struct {
    length: isize,
    charAt: isize,
    char32At: isize,
    replace: isize,
    extract: isize,
    copy: isize,
};

pub const UFieldPosition = extern struct {
    field: i32,
    beginIndex: i32,
    endIndex: i32,
};

pub const UCharIteratorOrigin = enum(i32) {
    START = 0,
    CURRENT = 1,
    LIMIT = 2,
    ZERO = 3,
    LENGTH = 4,
};
pub const UITER_START = UCharIteratorOrigin.START;
pub const UITER_CURRENT = UCharIteratorOrigin.CURRENT;
pub const UITER_LIMIT = UCharIteratorOrigin.LIMIT;
pub const UITER_ZERO = UCharIteratorOrigin.ZERO;
pub const UITER_LENGTH = UCharIteratorOrigin.LENGTH;

pub const UCharIteratorGetIndex = fn(
    iter: ?*UCharIterator,
    origin: UCharIteratorOrigin,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorMove = fn(
    iter: ?*UCharIterator,
    delta: i32,
    origin: UCharIteratorOrigin,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorHasNext = fn(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UCharIteratorHasPrevious = fn(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UCharIteratorCurrent = fn(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorNext = fn(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorPrevious = fn(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorReserved = fn(
    iter: ?*UCharIterator,
    something: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UCharIteratorGetState = fn(
    iter: ?*const UCharIterator,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const UCharIteratorSetState = fn(
    iter: ?*UCharIterator,
    state: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UCharIterator = extern struct {
    context: ?*const c_void,
    length: i32,
    start: i32,
    index: i32,
    limit: i32,
    reservedField: i32,
    getIndex: ?UCharIteratorGetIndex,
    move: ?UCharIteratorMove,
    hasNext: ?UCharIteratorHasNext,
    hasPrevious: ?UCharIteratorHasPrevious,
    current: ?UCharIteratorCurrent,
    next: ?UCharIteratorNext,
    previous: ?UCharIteratorPrevious,
    reservedFn: ?UCharIteratorReserved,
    getState: ?UCharIteratorGetState,
    setState: ?UCharIteratorSetState,
};

pub const ULocDataLocaleType = enum(i32) {
    ACTUAL_LOCALE = 0,
    VALID_LOCALE = 1,
};
pub const ULOC_ACTUAL_LOCALE = ULocDataLocaleType.ACTUAL_LOCALE;
pub const ULOC_VALID_LOCALE = ULocDataLocaleType.VALID_LOCALE;

pub const ULayoutType = enum(i32) {
    LTR = 0,
    RTL = 1,
    TTB = 2,
    BTT = 3,
    UNKNOWN = 4,
};
pub const ULOC_LAYOUT_LTR = ULayoutType.LTR;
pub const ULOC_LAYOUT_RTL = ULayoutType.RTL;
pub const ULOC_LAYOUT_TTB = ULayoutType.TTB;
pub const ULOC_LAYOUT_BTT = ULayoutType.BTT;
pub const ULOC_LAYOUT_UNKNOWN = ULayoutType.UNKNOWN;

pub const UAcceptResult = enum(i32) {
    FAILED = 0,
    VALID = 1,
    FALLBACK = 2,
};
pub const ULOC_ACCEPT_FAILED = UAcceptResult.FAILED;
pub const ULOC_ACCEPT_VALID = UAcceptResult.VALID;
pub const ULOC_ACCEPT_FALLBACK = UAcceptResult.FALLBACK;

pub const UResType = enum(i32) {
    NONE = -1,
    STRING = 0,
    BINARY = 1,
    TABLE = 2,
    ALIAS = 3,
    INT = 7,
    ARRAY = 8,
    INT_VECTOR = 14,
};
pub const URES_NONE = UResType.NONE;
pub const URES_STRING = UResType.STRING;
pub const URES_BINARY = UResType.BINARY;
pub const URES_TABLE = UResType.TABLE;
pub const URES_ALIAS = UResType.ALIAS;
pub const URES_INT = UResType.INT;
pub const URES_ARRAY = UResType.ARRAY;
pub const URES_INT_VECTOR = UResType.INT_VECTOR;

pub const UDisplayContextType = enum(i32) {
    DIALECT_HANDLING = 0,
    CAPITALIZATION = 1,
    DISPLAY_LENGTH = 2,
    SUBSTITUTE_HANDLING = 3,
};
pub const UDISPCTX_TYPE_DIALECT_HANDLING = UDisplayContextType.DIALECT_HANDLING;
pub const UDISPCTX_TYPE_CAPITALIZATION = UDisplayContextType.CAPITALIZATION;
pub const UDISPCTX_TYPE_DISPLAY_LENGTH = UDisplayContextType.DISPLAY_LENGTH;
pub const UDISPCTX_TYPE_SUBSTITUTE_HANDLING = UDisplayContextType.SUBSTITUTE_HANDLING;

pub const UDisplayContext = enum(i32) {
    STANDARD_NAMES = 0,
    DIALECT_NAMES = 1,
    CAPITALIZATION_NONE = 256,
    CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    CAPITALIZATION_FOR_STANDALONE = 260,
    LENGTH_FULL = 512,
    LENGTH_SHORT = 513,
    SUBSTITUTE = 768,
    NO_SUBSTITUTE = 769,
};
pub const UDISPCTX_STANDARD_NAMES = UDisplayContext.STANDARD_NAMES;
pub const UDISPCTX_DIALECT_NAMES = UDisplayContext.DIALECT_NAMES;
pub const UDISPCTX_CAPITALIZATION_NONE = UDisplayContext.CAPITALIZATION_NONE;
pub const UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = UDisplayContext.CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE;
pub const UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = UDisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE;
pub const UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = UDisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU;
pub const UDISPCTX_CAPITALIZATION_FOR_STANDALONE = UDisplayContext.CAPITALIZATION_FOR_STANDALONE;
pub const UDISPCTX_LENGTH_FULL = UDisplayContext.LENGTH_FULL;
pub const UDISPCTX_LENGTH_SHORT = UDisplayContext.LENGTH_SHORT;
pub const UDISPCTX_SUBSTITUTE = UDisplayContext.SUBSTITUTE;
pub const UDISPCTX_NO_SUBSTITUTE = UDisplayContext.NO_SUBSTITUTE;

pub const UDialectHandling = enum(i32) {
    STANDARD_NAMES = 0,
    DIALECT_NAMES = 1,
};
pub const ULDN_STANDARD_NAMES = UDialectHandling.STANDARD_NAMES;
pub const ULDN_DIALECT_NAMES = UDialectHandling.DIALECT_NAMES;

pub const UCurrencyUsage = enum(i32) {
    STANDARD = 0,
    CASH = 1,
};
pub const UCURR_USAGE_STANDARD = UCurrencyUsage.STANDARD;
pub const UCURR_USAGE_CASH = UCurrencyUsage.CASH;

pub const UCurrNameStyle = enum(i32) {
    SYMBOL_NAME = 0,
    LONG_NAME = 1,
    NARROW_SYMBOL_NAME = 2,
};
pub const UCURR_SYMBOL_NAME = UCurrNameStyle.SYMBOL_NAME;
pub const UCURR_LONG_NAME = UCurrNameStyle.LONG_NAME;
pub const UCURR_NARROW_SYMBOL_NAME = UCurrNameStyle.NARROW_SYMBOL_NAME;

pub const UCurrCurrencyType = enum(i32) {
    ALL = 2147483647,
    COMMON = 1,
    UNCOMMON = 2,
    DEPRECATED = 4,
    NON_DEPRECATED = 8,
};
pub const UCURR_ALL = UCurrCurrencyType.ALL;
pub const UCURR_COMMON = UCurrCurrencyType.COMMON;
pub const UCURR_UNCOMMON = UCurrCurrencyType.UNCOMMON;
pub const UCURR_DEPRECATED = UCurrCurrencyType.DEPRECATED;
pub const UCURR_NON_DEPRECATED = UCurrCurrencyType.NON_DEPRECATED;

pub const UConverterCallbackReason = enum(i32) {
    UNASSIGNED = 0,
    ILLEGAL = 1,
    IRREGULAR = 2,
    RESET = 3,
    CLOSE = 4,
    CLONE = 5,
};
pub const UCNV_UNASSIGNED = UConverterCallbackReason.UNASSIGNED;
pub const UCNV_ILLEGAL = UConverterCallbackReason.ILLEGAL;
pub const UCNV_IRREGULAR = UConverterCallbackReason.IRREGULAR;
pub const UCNV_RESET = UConverterCallbackReason.RESET;
pub const UCNV_CLOSE = UConverterCallbackReason.CLOSE;
pub const UCNV_CLONE = UConverterCallbackReason.CLONE;

pub const UConverterFromUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?*const u16,
    sourceLimit: ?*const u16,
    target: ?PSTR,
    targetLimit: ?[*:0]const u8,
    offsets: ?*i32,
};

pub const UConverterToUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?[*:0]const u8,
    sourceLimit: ?[*:0]const u8,
    target: ?*u16,
    targetLimit: ?*const u16,
    offsets: ?*i32,
};

pub const UConverterType = enum(i32) {
    UNSUPPORTED_CONVERTER = -1,
    SBCS = 0,
    DBCS = 1,
    MBCS = 2,
    LATIN_1 = 3,
    UTF8 = 4,
    UTF16_BigEndian = 5,
    UTF16_LittleEndian = 6,
    UTF32_BigEndian = 7,
    UTF32_LittleEndian = 8,
    EBCDIC_STATEFUL = 9,
    ISO_2022 = 10,
    LMBCS_1 = 11,
    LMBCS_2 = 12,
    LMBCS_3 = 13,
    LMBCS_4 = 14,
    LMBCS_5 = 15,
    LMBCS_6 = 16,
    LMBCS_8 = 17,
    LMBCS_11 = 18,
    LMBCS_16 = 19,
    LMBCS_17 = 20,
    LMBCS_18 = 21,
    LMBCS_19 = 22,
    // LMBCS_LAST = 22, this enum value conflicts with LMBCS_19
    HZ = 23,
    SCSU = 24,
    ISCII = 25,
    US_ASCII = 26,
    UTF7 = 27,
    BOCU1 = 28,
    UTF16 = 29,
    UTF32 = 30,
    CESU8 = 31,
    IMAP_MAILBOX = 32,
    COMPOUND_TEXT = 33,
    NUMBER_OF_SUPPORTED_CONVERTER_TYPES = 34,
};
pub const UCNV_UNSUPPORTED_CONVERTER = UConverterType.UNSUPPORTED_CONVERTER;
pub const UCNV_SBCS = UConverterType.SBCS;
pub const UCNV_DBCS = UConverterType.DBCS;
pub const UCNV_MBCS = UConverterType.MBCS;
pub const UCNV_LATIN_1 = UConverterType.LATIN_1;
pub const UCNV_UTF8 = UConverterType.UTF8;
pub const UCNV_UTF16_BigEndian = UConverterType.UTF16_BigEndian;
pub const UCNV_UTF16_LittleEndian = UConverterType.UTF16_LittleEndian;
pub const UCNV_UTF32_BigEndian = UConverterType.UTF32_BigEndian;
pub const UCNV_UTF32_LittleEndian = UConverterType.UTF32_LittleEndian;
pub const UCNV_EBCDIC_STATEFUL = UConverterType.EBCDIC_STATEFUL;
pub const UCNV_ISO_2022 = UConverterType.ISO_2022;
pub const UCNV_LMBCS_1 = UConverterType.LMBCS_1;
pub const UCNV_LMBCS_2 = UConverterType.LMBCS_2;
pub const UCNV_LMBCS_3 = UConverterType.LMBCS_3;
pub const UCNV_LMBCS_4 = UConverterType.LMBCS_4;
pub const UCNV_LMBCS_5 = UConverterType.LMBCS_5;
pub const UCNV_LMBCS_6 = UConverterType.LMBCS_6;
pub const UCNV_LMBCS_8 = UConverterType.LMBCS_8;
pub const UCNV_LMBCS_11 = UConverterType.LMBCS_11;
pub const UCNV_LMBCS_16 = UConverterType.LMBCS_16;
pub const UCNV_LMBCS_17 = UConverterType.LMBCS_17;
pub const UCNV_LMBCS_18 = UConverterType.LMBCS_18;
pub const UCNV_LMBCS_19 = UConverterType.LMBCS_19;
pub const UCNV_LMBCS_LAST = UConverterType.LMBCS_19;
pub const UCNV_HZ = UConverterType.HZ;
pub const UCNV_SCSU = UConverterType.SCSU;
pub const UCNV_ISCII = UConverterType.ISCII;
pub const UCNV_US_ASCII = UConverterType.US_ASCII;
pub const UCNV_UTF7 = UConverterType.UTF7;
pub const UCNV_BOCU1 = UConverterType.BOCU1;
pub const UCNV_UTF16 = UConverterType.UTF16;
pub const UCNV_UTF32 = UConverterType.UTF32;
pub const UCNV_CESU8 = UConverterType.CESU8;
pub const UCNV_IMAP_MAILBOX = UConverterType.IMAP_MAILBOX;
pub const UCNV_COMPOUND_TEXT = UConverterType.COMPOUND_TEXT;
pub const UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES = UConverterType.NUMBER_OF_SUPPORTED_CONVERTER_TYPES;

pub const UConverterPlatform = enum(i32) {
    UNKNOWN = -1,
    IBM = 0,
};
pub const UCNV_UNKNOWN = UConverterPlatform.UNKNOWN;
pub const UCNV_IBM = UConverterPlatform.IBM;

pub const UConverterToUCallback = fn(
    context: ?*const c_void,
    args: ?*UConverterToUnicodeArgs,
    codeUnits: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UConverterFromUCallback = fn(
    context: ?*const c_void,
    args: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*const u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UConverterUnicodeSet = enum(i32) {
    SET = 0,
    AND_FALLBACK_SET = 1,
};
pub const UCNV_ROUNDTRIP_SET = UConverterUnicodeSet.SET;
pub const UCNV_ROUNDTRIP_AND_FALLBACK_SET = UConverterUnicodeSet.AND_FALLBACK_SET;

pub const UMemAllocFn = fn(
    context: ?*const c_void,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const UMemReallocFn = fn(
    context: ?*const c_void,
    mem: ?*c_void,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const UMemFreeFn = fn(
    context: ?*const c_void,
    mem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UProperty = enum(i32) {
    ALPHABETIC = 0,
    // BINARY_START = 0, this enum value conflicts with ALPHABETIC
    ASCII_HEX_DIGIT = 1,
    BIDI_CONTROL = 2,
    BIDI_MIRRORED = 3,
    DASH = 4,
    DEFAULT_IGNORABLE_CODE_POINT = 5,
    DEPRECATED = 6,
    DIACRITIC = 7,
    EXTENDER = 8,
    FULL_COMPOSITION_EXCLUSION = 9,
    GRAPHEME_BASE = 10,
    GRAPHEME_EXTEND = 11,
    GRAPHEME_LINK = 12,
    HEX_DIGIT = 13,
    HYPHEN = 14,
    ID_CONTINUE = 15,
    ID_START = 16,
    IDEOGRAPHIC = 17,
    IDS_BINARY_OPERATOR = 18,
    IDS_TRINARY_OPERATOR = 19,
    JOIN_CONTROL = 20,
    LOGICAL_ORDER_EXCEPTION = 21,
    LOWERCASE = 22,
    MATH = 23,
    NONCHARACTER_CODE_POINT = 24,
    QUOTATION_MARK = 25,
    RADICAL = 26,
    SOFT_DOTTED = 27,
    TERMINAL_PUNCTUATION = 28,
    UNIFIED_IDEOGRAPH = 29,
    UPPERCASE = 30,
    WHITE_SPACE = 31,
    XID_CONTINUE = 32,
    XID_START = 33,
    CASE_SENSITIVE = 34,
    S_TERM = 35,
    VARIATION_SELECTOR = 36,
    NFD_INERT = 37,
    NFKD_INERT = 38,
    NFC_INERT = 39,
    NFKC_INERT = 40,
    SEGMENT_STARTER = 41,
    PATTERN_SYNTAX = 42,
    PATTERN_WHITE_SPACE = 43,
    POSIX_ALNUM = 44,
    POSIX_BLANK = 45,
    POSIX_GRAPH = 46,
    POSIX_PRINT = 47,
    POSIX_XDIGIT = 48,
    CASED = 49,
    CASE_IGNORABLE = 50,
    CHANGES_WHEN_LOWERCASED = 51,
    CHANGES_WHEN_UPPERCASED = 52,
    CHANGES_WHEN_TITLECASED = 53,
    CHANGES_WHEN_CASEFOLDED = 54,
    CHANGES_WHEN_CASEMAPPED = 55,
    CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    EMOJI = 57,
    EMOJI_PRESENTATION = 58,
    EMOJI_MODIFIER = 59,
    EMOJI_MODIFIER_BASE = 60,
    EMOJI_COMPONENT = 61,
    REGIONAL_INDICATOR = 62,
    PREPENDED_CONCATENATION_MARK = 63,
    EXTENDED_PICTOGRAPHIC = 64,
    BIDI_CLASS = 4096,
    // INT_START = 4096, this enum value conflicts with BIDI_CLASS
    BLOCK = 4097,
    CANONICAL_COMBINING_CLASS = 4098,
    DECOMPOSITION_TYPE = 4099,
    EAST_ASIAN_WIDTH = 4100,
    GENERAL_CATEGORY = 4101,
    JOINING_GROUP = 4102,
    JOINING_TYPE = 4103,
    LINE_BREAK = 4104,
    NUMERIC_TYPE = 4105,
    SCRIPT = 4106,
    HANGUL_SYLLABLE_TYPE = 4107,
    NFD_QUICK_CHECK = 4108,
    NFKD_QUICK_CHECK = 4109,
    NFC_QUICK_CHECK = 4110,
    NFKC_QUICK_CHECK = 4111,
    LEAD_CANONICAL_COMBINING_CLASS = 4112,
    TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    GRAPHEME_CLUSTER_BREAK = 4114,
    SENTENCE_BREAK = 4115,
    WORD_BREAK = 4116,
    BIDI_PAIRED_BRACKET_TYPE = 4117,
    INDIC_POSITIONAL_CATEGORY = 4118,
    INDIC_SYLLABIC_CATEGORY = 4119,
    VERTICAL_ORIENTATION = 4120,
    GENERAL_CATEGORY_MASK = 8192,
    // MASK_START = 8192, this enum value conflicts with GENERAL_CATEGORY_MASK
    NUMERIC_VALUE = 12288,
    // DOUBLE_START = 12288, this enum value conflicts with NUMERIC_VALUE
    AGE = 16384,
    // STRING_START = 16384, this enum value conflicts with AGE
    BIDI_MIRRORING_GLYPH = 16385,
    CASE_FOLDING = 16386,
    LOWERCASE_MAPPING = 16388,
    NAME = 16389,
    SIMPLE_CASE_FOLDING = 16390,
    SIMPLE_LOWERCASE_MAPPING = 16391,
    SIMPLE_TITLECASE_MAPPING = 16392,
    SIMPLE_UPPERCASE_MAPPING = 16393,
    TITLECASE_MAPPING = 16394,
    UPPERCASE_MAPPING = 16396,
    BIDI_PAIRED_BRACKET = 16397,
    SCRIPT_EXTENSIONS = 28672,
    // OTHER_PROPERTY_START = 28672, this enum value conflicts with SCRIPT_EXTENSIONS
    INVALID_CODE = -1,
};
pub const UCHAR_ALPHABETIC = UProperty.ALPHABETIC;
pub const UCHAR_BINARY_START = UProperty.ALPHABETIC;
pub const UCHAR_ASCII_HEX_DIGIT = UProperty.ASCII_HEX_DIGIT;
pub const UCHAR_BIDI_CONTROL = UProperty.BIDI_CONTROL;
pub const UCHAR_BIDI_MIRRORED = UProperty.BIDI_MIRRORED;
pub const UCHAR_DASH = UProperty.DASH;
pub const UCHAR_DEFAULT_IGNORABLE_CODE_POINT = UProperty.DEFAULT_IGNORABLE_CODE_POINT;
pub const UCHAR_DEPRECATED = UProperty.DEPRECATED;
pub const UCHAR_DIACRITIC = UProperty.DIACRITIC;
pub const UCHAR_EXTENDER = UProperty.EXTENDER;
pub const UCHAR_FULL_COMPOSITION_EXCLUSION = UProperty.FULL_COMPOSITION_EXCLUSION;
pub const UCHAR_GRAPHEME_BASE = UProperty.GRAPHEME_BASE;
pub const UCHAR_GRAPHEME_EXTEND = UProperty.GRAPHEME_EXTEND;
pub const UCHAR_GRAPHEME_LINK = UProperty.GRAPHEME_LINK;
pub const UCHAR_HEX_DIGIT = UProperty.HEX_DIGIT;
pub const UCHAR_HYPHEN = UProperty.HYPHEN;
pub const UCHAR_ID_CONTINUE = UProperty.ID_CONTINUE;
pub const UCHAR_ID_START = UProperty.ID_START;
pub const UCHAR_IDEOGRAPHIC = UProperty.IDEOGRAPHIC;
pub const UCHAR_IDS_BINARY_OPERATOR = UProperty.IDS_BINARY_OPERATOR;
pub const UCHAR_IDS_TRINARY_OPERATOR = UProperty.IDS_TRINARY_OPERATOR;
pub const UCHAR_JOIN_CONTROL = UProperty.JOIN_CONTROL;
pub const UCHAR_LOGICAL_ORDER_EXCEPTION = UProperty.LOGICAL_ORDER_EXCEPTION;
pub const UCHAR_LOWERCASE = UProperty.LOWERCASE;
pub const UCHAR_MATH = UProperty.MATH;
pub const UCHAR_NONCHARACTER_CODE_POINT = UProperty.NONCHARACTER_CODE_POINT;
pub const UCHAR_QUOTATION_MARK = UProperty.QUOTATION_MARK;
pub const UCHAR_RADICAL = UProperty.RADICAL;
pub const UCHAR_SOFT_DOTTED = UProperty.SOFT_DOTTED;
pub const UCHAR_TERMINAL_PUNCTUATION = UProperty.TERMINAL_PUNCTUATION;
pub const UCHAR_UNIFIED_IDEOGRAPH = UProperty.UNIFIED_IDEOGRAPH;
pub const UCHAR_UPPERCASE = UProperty.UPPERCASE;
pub const UCHAR_WHITE_SPACE = UProperty.WHITE_SPACE;
pub const UCHAR_XID_CONTINUE = UProperty.XID_CONTINUE;
pub const UCHAR_XID_START = UProperty.XID_START;
pub const UCHAR_CASE_SENSITIVE = UProperty.CASE_SENSITIVE;
pub const UCHAR_S_TERM = UProperty.S_TERM;
pub const UCHAR_VARIATION_SELECTOR = UProperty.VARIATION_SELECTOR;
pub const UCHAR_NFD_INERT = UProperty.NFD_INERT;
pub const UCHAR_NFKD_INERT = UProperty.NFKD_INERT;
pub const UCHAR_NFC_INERT = UProperty.NFC_INERT;
pub const UCHAR_NFKC_INERT = UProperty.NFKC_INERT;
pub const UCHAR_SEGMENT_STARTER = UProperty.SEGMENT_STARTER;
pub const UCHAR_PATTERN_SYNTAX = UProperty.PATTERN_SYNTAX;
pub const UCHAR_PATTERN_WHITE_SPACE = UProperty.PATTERN_WHITE_SPACE;
pub const UCHAR_POSIX_ALNUM = UProperty.POSIX_ALNUM;
pub const UCHAR_POSIX_BLANK = UProperty.POSIX_BLANK;
pub const UCHAR_POSIX_GRAPH = UProperty.POSIX_GRAPH;
pub const UCHAR_POSIX_PRINT = UProperty.POSIX_PRINT;
pub const UCHAR_POSIX_XDIGIT = UProperty.POSIX_XDIGIT;
pub const UCHAR_CASED = UProperty.CASED;
pub const UCHAR_CASE_IGNORABLE = UProperty.CASE_IGNORABLE;
pub const UCHAR_CHANGES_WHEN_LOWERCASED = UProperty.CHANGES_WHEN_LOWERCASED;
pub const UCHAR_CHANGES_WHEN_UPPERCASED = UProperty.CHANGES_WHEN_UPPERCASED;
pub const UCHAR_CHANGES_WHEN_TITLECASED = UProperty.CHANGES_WHEN_TITLECASED;
pub const UCHAR_CHANGES_WHEN_CASEFOLDED = UProperty.CHANGES_WHEN_CASEFOLDED;
pub const UCHAR_CHANGES_WHEN_CASEMAPPED = UProperty.CHANGES_WHEN_CASEMAPPED;
pub const UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = UProperty.CHANGES_WHEN_NFKC_CASEFOLDED;
pub const UCHAR_EMOJI = UProperty.EMOJI;
pub const UCHAR_EMOJI_PRESENTATION = UProperty.EMOJI_PRESENTATION;
pub const UCHAR_EMOJI_MODIFIER = UProperty.EMOJI_MODIFIER;
pub const UCHAR_EMOJI_MODIFIER_BASE = UProperty.EMOJI_MODIFIER_BASE;
pub const UCHAR_EMOJI_COMPONENT = UProperty.EMOJI_COMPONENT;
pub const UCHAR_REGIONAL_INDICATOR = UProperty.REGIONAL_INDICATOR;
pub const UCHAR_PREPENDED_CONCATENATION_MARK = UProperty.PREPENDED_CONCATENATION_MARK;
pub const UCHAR_EXTENDED_PICTOGRAPHIC = UProperty.EXTENDED_PICTOGRAPHIC;
pub const UCHAR_BIDI_CLASS = UProperty.BIDI_CLASS;
pub const UCHAR_INT_START = UProperty.BIDI_CLASS;
pub const UCHAR_BLOCK = UProperty.BLOCK;
pub const UCHAR_CANONICAL_COMBINING_CLASS = UProperty.CANONICAL_COMBINING_CLASS;
pub const UCHAR_DECOMPOSITION_TYPE = UProperty.DECOMPOSITION_TYPE;
pub const UCHAR_EAST_ASIAN_WIDTH = UProperty.EAST_ASIAN_WIDTH;
pub const UCHAR_GENERAL_CATEGORY = UProperty.GENERAL_CATEGORY;
pub const UCHAR_JOINING_GROUP = UProperty.JOINING_GROUP;
pub const UCHAR_JOINING_TYPE = UProperty.JOINING_TYPE;
pub const UCHAR_LINE_BREAK = UProperty.LINE_BREAK;
pub const UCHAR_NUMERIC_TYPE = UProperty.NUMERIC_TYPE;
pub const UCHAR_SCRIPT = UProperty.SCRIPT;
pub const UCHAR_HANGUL_SYLLABLE_TYPE = UProperty.HANGUL_SYLLABLE_TYPE;
pub const UCHAR_NFD_QUICK_CHECK = UProperty.NFD_QUICK_CHECK;
pub const UCHAR_NFKD_QUICK_CHECK = UProperty.NFKD_QUICK_CHECK;
pub const UCHAR_NFC_QUICK_CHECK = UProperty.NFC_QUICK_CHECK;
pub const UCHAR_NFKC_QUICK_CHECK = UProperty.NFKC_QUICK_CHECK;
pub const UCHAR_LEAD_CANONICAL_COMBINING_CLASS = UProperty.LEAD_CANONICAL_COMBINING_CLASS;
pub const UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = UProperty.TRAIL_CANONICAL_COMBINING_CLASS;
pub const UCHAR_GRAPHEME_CLUSTER_BREAK = UProperty.GRAPHEME_CLUSTER_BREAK;
pub const UCHAR_SENTENCE_BREAK = UProperty.SENTENCE_BREAK;
pub const UCHAR_WORD_BREAK = UProperty.WORD_BREAK;
pub const UCHAR_BIDI_PAIRED_BRACKET_TYPE = UProperty.BIDI_PAIRED_BRACKET_TYPE;
pub const UCHAR_INDIC_POSITIONAL_CATEGORY = UProperty.INDIC_POSITIONAL_CATEGORY;
pub const UCHAR_INDIC_SYLLABIC_CATEGORY = UProperty.INDIC_SYLLABIC_CATEGORY;
pub const UCHAR_VERTICAL_ORIENTATION = UProperty.VERTICAL_ORIENTATION;
pub const UCHAR_GENERAL_CATEGORY_MASK = UProperty.GENERAL_CATEGORY_MASK;
pub const UCHAR_MASK_START = UProperty.GENERAL_CATEGORY_MASK;
pub const UCHAR_NUMERIC_VALUE = UProperty.NUMERIC_VALUE;
pub const UCHAR_DOUBLE_START = UProperty.NUMERIC_VALUE;
pub const UCHAR_AGE = UProperty.AGE;
pub const UCHAR_STRING_START = UProperty.AGE;
pub const UCHAR_BIDI_MIRRORING_GLYPH = UProperty.BIDI_MIRRORING_GLYPH;
pub const UCHAR_CASE_FOLDING = UProperty.CASE_FOLDING;
pub const UCHAR_LOWERCASE_MAPPING = UProperty.LOWERCASE_MAPPING;
pub const UCHAR_NAME = UProperty.NAME;
pub const UCHAR_SIMPLE_CASE_FOLDING = UProperty.SIMPLE_CASE_FOLDING;
pub const UCHAR_SIMPLE_LOWERCASE_MAPPING = UProperty.SIMPLE_LOWERCASE_MAPPING;
pub const UCHAR_SIMPLE_TITLECASE_MAPPING = UProperty.SIMPLE_TITLECASE_MAPPING;
pub const UCHAR_SIMPLE_UPPERCASE_MAPPING = UProperty.SIMPLE_UPPERCASE_MAPPING;
pub const UCHAR_TITLECASE_MAPPING = UProperty.TITLECASE_MAPPING;
pub const UCHAR_UPPERCASE_MAPPING = UProperty.UPPERCASE_MAPPING;
pub const UCHAR_BIDI_PAIRED_BRACKET = UProperty.BIDI_PAIRED_BRACKET;
pub const UCHAR_SCRIPT_EXTENSIONS = UProperty.SCRIPT_EXTENSIONS;
pub const UCHAR_OTHER_PROPERTY_START = UProperty.SCRIPT_EXTENSIONS;
pub const UCHAR_INVALID_CODE = UProperty.INVALID_CODE;

pub const UCharCategory = enum(i32) {
    UNASSIGNED = 0,
    // GENERAL_OTHER_TYPES = 0, this enum value conflicts with UNASSIGNED
    UPPERCASE_LETTER = 1,
    LOWERCASE_LETTER = 2,
    TITLECASE_LETTER = 3,
    MODIFIER_LETTER = 4,
    OTHER_LETTER = 5,
    NON_SPACING_MARK = 6,
    ENCLOSING_MARK = 7,
    COMBINING_SPACING_MARK = 8,
    DECIMAL_DIGIT_NUMBER = 9,
    LETTER_NUMBER = 10,
    OTHER_NUMBER = 11,
    SPACE_SEPARATOR = 12,
    LINE_SEPARATOR = 13,
    PARAGRAPH_SEPARATOR = 14,
    CONTROL_CHAR = 15,
    FORMAT_CHAR = 16,
    PRIVATE_USE_CHAR = 17,
    SURROGATE = 18,
    DASH_PUNCTUATION = 19,
    START_PUNCTUATION = 20,
    END_PUNCTUATION = 21,
    CONNECTOR_PUNCTUATION = 22,
    OTHER_PUNCTUATION = 23,
    MATH_SYMBOL = 24,
    CURRENCY_SYMBOL = 25,
    MODIFIER_SYMBOL = 26,
    OTHER_SYMBOL = 27,
    INITIAL_PUNCTUATION = 28,
    FINAL_PUNCTUATION = 29,
    CHAR_CATEGORY_COUNT = 30,
};
pub const U_UNASSIGNED = UCharCategory.UNASSIGNED;
pub const U_GENERAL_OTHER_TYPES = UCharCategory.UNASSIGNED;
pub const U_UPPERCASE_LETTER = UCharCategory.UPPERCASE_LETTER;
pub const U_LOWERCASE_LETTER = UCharCategory.LOWERCASE_LETTER;
pub const U_TITLECASE_LETTER = UCharCategory.TITLECASE_LETTER;
pub const U_MODIFIER_LETTER = UCharCategory.MODIFIER_LETTER;
pub const U_OTHER_LETTER = UCharCategory.OTHER_LETTER;
pub const U_NON_SPACING_MARK = UCharCategory.NON_SPACING_MARK;
pub const U_ENCLOSING_MARK = UCharCategory.ENCLOSING_MARK;
pub const U_COMBINING_SPACING_MARK = UCharCategory.COMBINING_SPACING_MARK;
pub const U_DECIMAL_DIGIT_NUMBER = UCharCategory.DECIMAL_DIGIT_NUMBER;
pub const U_LETTER_NUMBER = UCharCategory.LETTER_NUMBER;
pub const U_OTHER_NUMBER = UCharCategory.OTHER_NUMBER;
pub const U_SPACE_SEPARATOR = UCharCategory.SPACE_SEPARATOR;
pub const U_LINE_SEPARATOR = UCharCategory.LINE_SEPARATOR;
pub const U_PARAGRAPH_SEPARATOR = UCharCategory.PARAGRAPH_SEPARATOR;
pub const U_CONTROL_CHAR = UCharCategory.CONTROL_CHAR;
pub const U_FORMAT_CHAR = UCharCategory.FORMAT_CHAR;
pub const U_PRIVATE_USE_CHAR = UCharCategory.PRIVATE_USE_CHAR;
pub const U_SURROGATE = UCharCategory.SURROGATE;
pub const U_DASH_PUNCTUATION = UCharCategory.DASH_PUNCTUATION;
pub const U_START_PUNCTUATION = UCharCategory.START_PUNCTUATION;
pub const U_END_PUNCTUATION = UCharCategory.END_PUNCTUATION;
pub const U_CONNECTOR_PUNCTUATION = UCharCategory.CONNECTOR_PUNCTUATION;
pub const U_OTHER_PUNCTUATION = UCharCategory.OTHER_PUNCTUATION;
pub const U_MATH_SYMBOL = UCharCategory.MATH_SYMBOL;
pub const U_CURRENCY_SYMBOL = UCharCategory.CURRENCY_SYMBOL;
pub const U_MODIFIER_SYMBOL = UCharCategory.MODIFIER_SYMBOL;
pub const U_OTHER_SYMBOL = UCharCategory.OTHER_SYMBOL;
pub const U_INITIAL_PUNCTUATION = UCharCategory.INITIAL_PUNCTUATION;
pub const U_FINAL_PUNCTUATION = UCharCategory.FINAL_PUNCTUATION;
pub const U_CHAR_CATEGORY_COUNT = UCharCategory.CHAR_CATEGORY_COUNT;

pub const UCharDirection = enum(i32) {
    LEFT_TO_RIGHT = 0,
    RIGHT_TO_LEFT = 1,
    EUROPEAN_NUMBER = 2,
    EUROPEAN_NUMBER_SEPARATOR = 3,
    EUROPEAN_NUMBER_TERMINATOR = 4,
    ARABIC_NUMBER = 5,
    COMMON_NUMBER_SEPARATOR = 6,
    BLOCK_SEPARATOR = 7,
    SEGMENT_SEPARATOR = 8,
    WHITE_SPACE_NEUTRAL = 9,
    OTHER_NEUTRAL = 10,
    LEFT_TO_RIGHT_EMBEDDING = 11,
    LEFT_TO_RIGHT_OVERRIDE = 12,
    RIGHT_TO_LEFT_ARABIC = 13,
    RIGHT_TO_LEFT_EMBEDDING = 14,
    RIGHT_TO_LEFT_OVERRIDE = 15,
    POP_DIRECTIONAL_FORMAT = 16,
    DIR_NON_SPACING_MARK = 17,
    BOUNDARY_NEUTRAL = 18,
    FIRST_STRONG_ISOLATE = 19,
    LEFT_TO_RIGHT_ISOLATE = 20,
    RIGHT_TO_LEFT_ISOLATE = 21,
    POP_DIRECTIONAL_ISOLATE = 22,
};
pub const U_LEFT_TO_RIGHT = UCharDirection.LEFT_TO_RIGHT;
pub const U_RIGHT_TO_LEFT = UCharDirection.RIGHT_TO_LEFT;
pub const U_EUROPEAN_NUMBER = UCharDirection.EUROPEAN_NUMBER;
pub const U_EUROPEAN_NUMBER_SEPARATOR = UCharDirection.EUROPEAN_NUMBER_SEPARATOR;
pub const U_EUROPEAN_NUMBER_TERMINATOR = UCharDirection.EUROPEAN_NUMBER_TERMINATOR;
pub const U_ARABIC_NUMBER = UCharDirection.ARABIC_NUMBER;
pub const U_COMMON_NUMBER_SEPARATOR = UCharDirection.COMMON_NUMBER_SEPARATOR;
pub const U_BLOCK_SEPARATOR = UCharDirection.BLOCK_SEPARATOR;
pub const U_SEGMENT_SEPARATOR = UCharDirection.SEGMENT_SEPARATOR;
pub const U_WHITE_SPACE_NEUTRAL = UCharDirection.WHITE_SPACE_NEUTRAL;
pub const U_OTHER_NEUTRAL = UCharDirection.OTHER_NEUTRAL;
pub const U_LEFT_TO_RIGHT_EMBEDDING = UCharDirection.LEFT_TO_RIGHT_EMBEDDING;
pub const U_LEFT_TO_RIGHT_OVERRIDE = UCharDirection.LEFT_TO_RIGHT_OVERRIDE;
pub const U_RIGHT_TO_LEFT_ARABIC = UCharDirection.RIGHT_TO_LEFT_ARABIC;
pub const U_RIGHT_TO_LEFT_EMBEDDING = UCharDirection.RIGHT_TO_LEFT_EMBEDDING;
pub const U_RIGHT_TO_LEFT_OVERRIDE = UCharDirection.RIGHT_TO_LEFT_OVERRIDE;
pub const U_POP_DIRECTIONAL_FORMAT = UCharDirection.POP_DIRECTIONAL_FORMAT;
pub const U_DIR_NON_SPACING_MARK = UCharDirection.DIR_NON_SPACING_MARK;
pub const U_BOUNDARY_NEUTRAL = UCharDirection.BOUNDARY_NEUTRAL;
pub const U_FIRST_STRONG_ISOLATE = UCharDirection.FIRST_STRONG_ISOLATE;
pub const U_LEFT_TO_RIGHT_ISOLATE = UCharDirection.LEFT_TO_RIGHT_ISOLATE;
pub const U_RIGHT_TO_LEFT_ISOLATE = UCharDirection.RIGHT_TO_LEFT_ISOLATE;
pub const U_POP_DIRECTIONAL_ISOLATE = UCharDirection.POP_DIRECTIONAL_ISOLATE;

pub const UBidiPairedBracketType = enum(i32) {
    NONE = 0,
    OPEN = 1,
    CLOSE = 2,
};
pub const U_BPT_NONE = UBidiPairedBracketType.NONE;
pub const U_BPT_OPEN = UBidiPairedBracketType.OPEN;
pub const U_BPT_CLOSE = UBidiPairedBracketType.CLOSE;

pub const UBlockCode = enum(i32) {
    NO_BLOCK = 0,
    BASIC_LATIN = 1,
    LATIN_1_SUPPLEMENT = 2,
    LATIN_EXTENDED_A = 3,
    LATIN_EXTENDED_B = 4,
    IPA_EXTENSIONS = 5,
    SPACING_MODIFIER_LETTERS = 6,
    COMBINING_DIACRITICAL_MARKS = 7,
    GREEK = 8,
    CYRILLIC = 9,
    ARMENIAN = 10,
    HEBREW = 11,
    ARABIC = 12,
    SYRIAC = 13,
    THAANA = 14,
    DEVANAGARI = 15,
    BENGALI = 16,
    GURMUKHI = 17,
    GUJARATI = 18,
    ORIYA = 19,
    TAMIL = 20,
    TELUGU = 21,
    KANNADA = 22,
    MALAYALAM = 23,
    SINHALA = 24,
    THAI = 25,
    LAO = 26,
    TIBETAN = 27,
    MYANMAR = 28,
    GEORGIAN = 29,
    HANGUL_JAMO = 30,
    ETHIOPIC = 31,
    CHEROKEE = 32,
    UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = 33,
    OGHAM = 34,
    RUNIC = 35,
    KHMER = 36,
    MONGOLIAN = 37,
    LATIN_EXTENDED_ADDITIONAL = 38,
    GREEK_EXTENDED = 39,
    GENERAL_PUNCTUATION = 40,
    SUPERSCRIPTS_AND_SUBSCRIPTS = 41,
    CURRENCY_SYMBOLS = 42,
    COMBINING_MARKS_FOR_SYMBOLS = 43,
    LETTERLIKE_SYMBOLS = 44,
    NUMBER_FORMS = 45,
    ARROWS = 46,
    MATHEMATICAL_OPERATORS = 47,
    MISCELLANEOUS_TECHNICAL = 48,
    CONTROL_PICTURES = 49,
    OPTICAL_CHARACTER_RECOGNITION = 50,
    ENCLOSED_ALPHANUMERICS = 51,
    BOX_DRAWING = 52,
    BLOCK_ELEMENTS = 53,
    GEOMETRIC_SHAPES = 54,
    MISCELLANEOUS_SYMBOLS = 55,
    DINGBATS = 56,
    BRAILLE_PATTERNS = 57,
    CJK_RADICALS_SUPPLEMENT = 58,
    KANGXI_RADICALS = 59,
    IDEOGRAPHIC_DESCRIPTION_CHARACTERS = 60,
    CJK_SYMBOLS_AND_PUNCTUATION = 61,
    HIRAGANA = 62,
    KATAKANA = 63,
    BOPOMOFO = 64,
    HANGUL_COMPATIBILITY_JAMO = 65,
    KANBUN = 66,
    BOPOMOFO_EXTENDED = 67,
    ENCLOSED_CJK_LETTERS_AND_MONTHS = 68,
    CJK_COMPATIBILITY = 69,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = 70,
    CJK_UNIFIED_IDEOGRAPHS = 71,
    YI_SYLLABLES = 72,
    YI_RADICALS = 73,
    HANGUL_SYLLABLES = 74,
    HIGH_SURROGATES = 75,
    HIGH_PRIVATE_USE_SURROGATES = 76,
    LOW_SURROGATES = 77,
    PRIVATE_USE_AREA = 78,
    // PRIVATE_USE = 78, this enum value conflicts with PRIVATE_USE_AREA
    CJK_COMPATIBILITY_IDEOGRAPHS = 79,
    ALPHABETIC_PRESENTATION_FORMS = 80,
    ARABIC_PRESENTATION_FORMS_A = 81,
    COMBINING_HALF_MARKS = 82,
    CJK_COMPATIBILITY_FORMS = 83,
    SMALL_FORM_VARIANTS = 84,
    ARABIC_PRESENTATION_FORMS_B = 85,
    SPECIALS = 86,
    HALFWIDTH_AND_FULLWIDTH_FORMS = 87,
    OLD_ITALIC = 88,
    GOTHIC = 89,
    DESERET = 90,
    BYZANTINE_MUSICAL_SYMBOLS = 91,
    MUSICAL_SYMBOLS = 92,
    MATHEMATICAL_ALPHANUMERIC_SYMBOLS = 93,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = 94,
    CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = 95,
    TAGS = 96,
    CYRILLIC_SUPPLEMENT = 97,
    // CYRILLIC_SUPPLEMENTARY = 97, this enum value conflicts with CYRILLIC_SUPPLEMENT
    TAGALOG = 98,
    HANUNOO = 99,
    BUHID = 100,
    TAGBANWA = 101,
    MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = 102,
    SUPPLEMENTAL_ARROWS_A = 103,
    SUPPLEMENTAL_ARROWS_B = 104,
    MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = 105,
    SUPPLEMENTAL_MATHEMATICAL_OPERATORS = 106,
    KATAKANA_PHONETIC_EXTENSIONS = 107,
    VARIATION_SELECTORS = 108,
    SUPPLEMENTARY_PRIVATE_USE_AREA_A = 109,
    SUPPLEMENTARY_PRIVATE_USE_AREA_B = 110,
    LIMBU = 111,
    TAI_LE = 112,
    KHMER_SYMBOLS = 113,
    PHONETIC_EXTENSIONS = 114,
    MISCELLANEOUS_SYMBOLS_AND_ARROWS = 115,
    YIJING_HEXAGRAM_SYMBOLS = 116,
    LINEAR_B_SYLLABARY = 117,
    LINEAR_B_IDEOGRAMS = 118,
    AEGEAN_NUMBERS = 119,
    UGARITIC = 120,
    SHAVIAN = 121,
    OSMANYA = 122,
    CYPRIOT_SYLLABARY = 123,
    TAI_XUAN_JING_SYMBOLS = 124,
    VARIATION_SELECTORS_SUPPLEMENT = 125,
    ANCIENT_GREEK_MUSICAL_NOTATION = 126,
    ANCIENT_GREEK_NUMBERS = 127,
    ARABIC_SUPPLEMENT = 128,
    BUGINESE = 129,
    CJK_STROKES = 130,
    COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = 131,
    COPTIC = 132,
    ETHIOPIC_EXTENDED = 133,
    ETHIOPIC_SUPPLEMENT = 134,
    GEORGIAN_SUPPLEMENT = 135,
    GLAGOLITIC = 136,
    KHAROSHTHI = 137,
    MODIFIER_TONE_LETTERS = 138,
    NEW_TAI_LUE = 139,
    OLD_PERSIAN = 140,
    PHONETIC_EXTENSIONS_SUPPLEMENT = 141,
    SUPPLEMENTAL_PUNCTUATION = 142,
    SYLOTI_NAGRI = 143,
    TIFINAGH = 144,
    VERTICAL_FORMS = 145,
    NKO = 146,
    BALINESE = 147,
    LATIN_EXTENDED_C = 148,
    LATIN_EXTENDED_D = 149,
    PHAGS_PA = 150,
    PHOENICIAN = 151,
    CUNEIFORM = 152,
    CUNEIFORM_NUMBERS_AND_PUNCTUATION = 153,
    COUNTING_ROD_NUMERALS = 154,
    SUNDANESE = 155,
    LEPCHA = 156,
    OL_CHIKI = 157,
    CYRILLIC_EXTENDED_A = 158,
    VAI = 159,
    CYRILLIC_EXTENDED_B = 160,
    SAURASHTRA = 161,
    KAYAH_LI = 162,
    REJANG = 163,
    CHAM = 164,
    ANCIENT_SYMBOLS = 165,
    PHAISTOS_DISC = 166,
    LYCIAN = 167,
    CARIAN = 168,
    LYDIAN = 169,
    MAHJONG_TILES = 170,
    DOMINO_TILES = 171,
    SAMARITAN = 172,
    UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = 173,
    TAI_THAM = 174,
    VEDIC_EXTENSIONS = 175,
    LISU = 176,
    BAMUM = 177,
    COMMON_INDIC_NUMBER_FORMS = 178,
    DEVANAGARI_EXTENDED = 179,
    HANGUL_JAMO_EXTENDED_A = 180,
    JAVANESE = 181,
    MYANMAR_EXTENDED_A = 182,
    TAI_VIET = 183,
    MEETEI_MAYEK = 184,
    HANGUL_JAMO_EXTENDED_B = 185,
    IMPERIAL_ARAMAIC = 186,
    OLD_SOUTH_ARABIAN = 187,
    AVESTAN = 188,
    INSCRIPTIONAL_PARTHIAN = 189,
    INSCRIPTIONAL_PAHLAVI = 190,
    OLD_TURKIC = 191,
    RUMI_NUMERAL_SYMBOLS = 192,
    KAITHI = 193,
    EGYPTIAN_HIEROGLYPHS = 194,
    ENCLOSED_ALPHANUMERIC_SUPPLEMENT = 195,
    ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = 196,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = 197,
    MANDAIC = 198,
    BATAK = 199,
    ETHIOPIC_EXTENDED_A = 200,
    BRAHMI = 201,
    BAMUM_SUPPLEMENT = 202,
    KANA_SUPPLEMENT = 203,
    PLAYING_CARDS = 204,
    MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = 205,
    EMOTICONS = 206,
    TRANSPORT_AND_MAP_SYMBOLS = 207,
    ALCHEMICAL_SYMBOLS = 208,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = 209,
    ARABIC_EXTENDED_A = 210,
    ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS = 211,
    CHAKMA = 212,
    MEETEI_MAYEK_EXTENSIONS = 213,
    MEROITIC_CURSIVE = 214,
    MEROITIC_HIEROGLYPHS = 215,
    MIAO = 216,
    SHARADA = 217,
    SORA_SOMPENG = 218,
    SUNDANESE_SUPPLEMENT = 219,
    TAKRI = 220,
    BASSA_VAH = 221,
    CAUCASIAN_ALBANIAN = 222,
    COPTIC_EPACT_NUMBERS = 223,
    COMBINING_DIACRITICAL_MARKS_EXTENDED = 224,
    DUPLOYAN = 225,
    ELBASAN = 226,
    GEOMETRIC_SHAPES_EXTENDED = 227,
    GRANTHA = 228,
    KHOJKI = 229,
    KHUDAWADI = 230,
    LATIN_EXTENDED_E = 231,
    LINEAR_A = 232,
    MAHAJANI = 233,
    MANICHAEAN = 234,
    MENDE_KIKAKUI = 235,
    MODI = 236,
    MRO = 237,
    MYANMAR_EXTENDED_B = 238,
    NABATAEAN = 239,
    OLD_NORTH_ARABIAN = 240,
    OLD_PERMIC = 241,
    ORNAMENTAL_DINGBATS = 242,
    PAHAWH_HMONG = 243,
    PALMYRENE = 244,
    PAU_CIN_HAU = 245,
    PSALTER_PAHLAVI = 246,
    SHORTHAND_FORMAT_CONTROLS = 247,
    SIDDHAM = 248,
    SINHALA_ARCHAIC_NUMBERS = 249,
    SUPPLEMENTAL_ARROWS_C = 250,
    TIRHUTA = 251,
    WARANG_CITI = 252,
    AHOM = 253,
    ANATOLIAN_HIEROGLYPHS = 254,
    CHEROKEE_SUPPLEMENT = 255,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E = 256,
    EARLY_DYNASTIC_CUNEIFORM = 257,
    HATRAN = 258,
    MULTANI = 259,
    OLD_HUNGARIAN = 260,
    SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS = 261,
    SUTTON_SIGNWRITING = 262,
    ADLAM = 263,
    BHAIKSUKI = 264,
    CYRILLIC_EXTENDED_C = 265,
    GLAGOLITIC_SUPPLEMENT = 266,
    IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION = 267,
    MARCHEN = 268,
    MONGOLIAN_SUPPLEMENT = 269,
    NEWA = 270,
    OSAGE = 271,
    TANGUT = 272,
    TANGUT_COMPONENTS = 273,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F = 274,
    KANA_EXTENDED_A = 275,
    MASARAM_GONDI = 276,
    NUSHU = 277,
    SOYOMBO = 278,
    SYRIAC_SUPPLEMENT = 279,
    ZANABAZAR_SQUARE = 280,
    CHESS_SYMBOLS = 281,
    DOGRA = 282,
    GEORGIAN_EXTENDED = 283,
    GUNJALA_GONDI = 284,
    HANIFI_ROHINGYA = 285,
    INDIC_SIYAQ_NUMBERS = 286,
    MAKASAR = 287,
    MAYAN_NUMERALS = 288,
    MEDEFAIDRIN = 289,
    OLD_SOGDIAN = 290,
    SOGDIAN = 291,
    EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS = 292,
    ELYMAIC = 293,
    NANDINAGARI = 294,
    NYIAKENG_PUACHUE_HMONG = 295,
    OTTOMAN_SIYAQ_NUMBERS = 296,
    SMALL_KANA_EXTENSION = 297,
    SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A = 298,
    TAMIL_SUPPLEMENT = 299,
    WANCHO = 300,
    INVALID_CODE = -1,
};
pub const UBLOCK_NO_BLOCK = UBlockCode.NO_BLOCK;
pub const UBLOCK_BASIC_LATIN = UBlockCode.BASIC_LATIN;
pub const UBLOCK_LATIN_1_SUPPLEMENT = UBlockCode.LATIN_1_SUPPLEMENT;
pub const UBLOCK_LATIN_EXTENDED_A = UBlockCode.LATIN_EXTENDED_A;
pub const UBLOCK_LATIN_EXTENDED_B = UBlockCode.LATIN_EXTENDED_B;
pub const UBLOCK_IPA_EXTENSIONS = UBlockCode.IPA_EXTENSIONS;
pub const UBLOCK_SPACING_MODIFIER_LETTERS = UBlockCode.SPACING_MODIFIER_LETTERS;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS = UBlockCode.COMBINING_DIACRITICAL_MARKS;
pub const UBLOCK_GREEK = UBlockCode.GREEK;
pub const UBLOCK_CYRILLIC = UBlockCode.CYRILLIC;
pub const UBLOCK_ARMENIAN = UBlockCode.ARMENIAN;
pub const UBLOCK_HEBREW = UBlockCode.HEBREW;
pub const UBLOCK_ARABIC = UBlockCode.ARABIC;
pub const UBLOCK_SYRIAC = UBlockCode.SYRIAC;
pub const UBLOCK_THAANA = UBlockCode.THAANA;
pub const UBLOCK_DEVANAGARI = UBlockCode.DEVANAGARI;
pub const UBLOCK_BENGALI = UBlockCode.BENGALI;
pub const UBLOCK_GURMUKHI = UBlockCode.GURMUKHI;
pub const UBLOCK_GUJARATI = UBlockCode.GUJARATI;
pub const UBLOCK_ORIYA = UBlockCode.ORIYA;
pub const UBLOCK_TAMIL = UBlockCode.TAMIL;
pub const UBLOCK_TELUGU = UBlockCode.TELUGU;
pub const UBLOCK_KANNADA = UBlockCode.KANNADA;
pub const UBLOCK_MALAYALAM = UBlockCode.MALAYALAM;
pub const UBLOCK_SINHALA = UBlockCode.SINHALA;
pub const UBLOCK_THAI = UBlockCode.THAI;
pub const UBLOCK_LAO = UBlockCode.LAO;
pub const UBLOCK_TIBETAN = UBlockCode.TIBETAN;
pub const UBLOCK_MYANMAR = UBlockCode.MYANMAR;
pub const UBLOCK_GEORGIAN = UBlockCode.GEORGIAN;
pub const UBLOCK_HANGUL_JAMO = UBlockCode.HANGUL_JAMO;
pub const UBLOCK_ETHIOPIC = UBlockCode.ETHIOPIC;
pub const UBLOCK_CHEROKEE = UBlockCode.CHEROKEE;
pub const UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = UBlockCode.UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS;
pub const UBLOCK_OGHAM = UBlockCode.OGHAM;
pub const UBLOCK_RUNIC = UBlockCode.RUNIC;
pub const UBLOCK_KHMER = UBlockCode.KHMER;
pub const UBLOCK_MONGOLIAN = UBlockCode.MONGOLIAN;
pub const UBLOCK_LATIN_EXTENDED_ADDITIONAL = UBlockCode.LATIN_EXTENDED_ADDITIONAL;
pub const UBLOCK_GREEK_EXTENDED = UBlockCode.GREEK_EXTENDED;
pub const UBLOCK_GENERAL_PUNCTUATION = UBlockCode.GENERAL_PUNCTUATION;
pub const UBLOCK_SUPERSCRIPTS_AND_SUBSCRIPTS = UBlockCode.SUPERSCRIPTS_AND_SUBSCRIPTS;
pub const UBLOCK_CURRENCY_SYMBOLS = UBlockCode.CURRENCY_SYMBOLS;
pub const UBLOCK_COMBINING_MARKS_FOR_SYMBOLS = UBlockCode.COMBINING_MARKS_FOR_SYMBOLS;
pub const UBLOCK_LETTERLIKE_SYMBOLS = UBlockCode.LETTERLIKE_SYMBOLS;
pub const UBLOCK_NUMBER_FORMS = UBlockCode.NUMBER_FORMS;
pub const UBLOCK_ARROWS = UBlockCode.ARROWS;
pub const UBLOCK_MATHEMATICAL_OPERATORS = UBlockCode.MATHEMATICAL_OPERATORS;
pub const UBLOCK_MISCELLANEOUS_TECHNICAL = UBlockCode.MISCELLANEOUS_TECHNICAL;
pub const UBLOCK_CONTROL_PICTURES = UBlockCode.CONTROL_PICTURES;
pub const UBLOCK_OPTICAL_CHARACTER_RECOGNITION = UBlockCode.OPTICAL_CHARACTER_RECOGNITION;
pub const UBLOCK_ENCLOSED_ALPHANUMERICS = UBlockCode.ENCLOSED_ALPHANUMERICS;
pub const UBLOCK_BOX_DRAWING = UBlockCode.BOX_DRAWING;
pub const UBLOCK_BLOCK_ELEMENTS = UBlockCode.BLOCK_ELEMENTS;
pub const UBLOCK_GEOMETRIC_SHAPES = UBlockCode.GEOMETRIC_SHAPES;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS = UBlockCode.MISCELLANEOUS_SYMBOLS;
pub const UBLOCK_DINGBATS = UBlockCode.DINGBATS;
pub const UBLOCK_BRAILLE_PATTERNS = UBlockCode.BRAILLE_PATTERNS;
pub const UBLOCK_CJK_RADICALS_SUPPLEMENT = UBlockCode.CJK_RADICALS_SUPPLEMENT;
pub const UBLOCK_KANGXI_RADICALS = UBlockCode.KANGXI_RADICALS;
pub const UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS = UBlockCode.IDEOGRAPHIC_DESCRIPTION_CHARACTERS;
pub const UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION = UBlockCode.CJK_SYMBOLS_AND_PUNCTUATION;
pub const UBLOCK_HIRAGANA = UBlockCode.HIRAGANA;
pub const UBLOCK_KATAKANA = UBlockCode.KATAKANA;
pub const UBLOCK_BOPOMOFO = UBlockCode.BOPOMOFO;
pub const UBLOCK_HANGUL_COMPATIBILITY_JAMO = UBlockCode.HANGUL_COMPATIBILITY_JAMO;
pub const UBLOCK_KANBUN = UBlockCode.KANBUN;
pub const UBLOCK_BOPOMOFO_EXTENDED = UBlockCode.BOPOMOFO_EXTENDED;
pub const UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS = UBlockCode.ENCLOSED_CJK_LETTERS_AND_MONTHS;
pub const UBLOCK_CJK_COMPATIBILITY = UBlockCode.CJK_COMPATIBILITY;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS = UBlockCode.CJK_UNIFIED_IDEOGRAPHS;
pub const UBLOCK_YI_SYLLABLES = UBlockCode.YI_SYLLABLES;
pub const UBLOCK_YI_RADICALS = UBlockCode.YI_RADICALS;
pub const UBLOCK_HANGUL_SYLLABLES = UBlockCode.HANGUL_SYLLABLES;
pub const UBLOCK_HIGH_SURROGATES = UBlockCode.HIGH_SURROGATES;
pub const UBLOCK_HIGH_PRIVATE_USE_SURROGATES = UBlockCode.HIGH_PRIVATE_USE_SURROGATES;
pub const UBLOCK_LOW_SURROGATES = UBlockCode.LOW_SURROGATES;
pub const UBLOCK_PRIVATE_USE_AREA = UBlockCode.PRIVATE_USE_AREA;
pub const UBLOCK_PRIVATE_USE = UBlockCode.PRIVATE_USE_AREA;
pub const UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS = UBlockCode.CJK_COMPATIBILITY_IDEOGRAPHS;
pub const UBLOCK_ALPHABETIC_PRESENTATION_FORMS = UBlockCode.ALPHABETIC_PRESENTATION_FORMS;
pub const UBLOCK_ARABIC_PRESENTATION_FORMS_A = UBlockCode.ARABIC_PRESENTATION_FORMS_A;
pub const UBLOCK_COMBINING_HALF_MARKS = UBlockCode.COMBINING_HALF_MARKS;
pub const UBLOCK_CJK_COMPATIBILITY_FORMS = UBlockCode.CJK_COMPATIBILITY_FORMS;
pub const UBLOCK_SMALL_FORM_VARIANTS = UBlockCode.SMALL_FORM_VARIANTS;
pub const UBLOCK_ARABIC_PRESENTATION_FORMS_B = UBlockCode.ARABIC_PRESENTATION_FORMS_B;
pub const UBLOCK_SPECIALS = UBlockCode.SPECIALS;
pub const UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS = UBlockCode.HALFWIDTH_AND_FULLWIDTH_FORMS;
pub const UBLOCK_OLD_ITALIC = UBlockCode.OLD_ITALIC;
pub const UBLOCK_GOTHIC = UBlockCode.GOTHIC;
pub const UBLOCK_DESERET = UBlockCode.DESERET;
pub const UBLOCK_BYZANTINE_MUSICAL_SYMBOLS = UBlockCode.BYZANTINE_MUSICAL_SYMBOLS;
pub const UBLOCK_MUSICAL_SYMBOLS = UBlockCode.MUSICAL_SYMBOLS;
pub const UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS = UBlockCode.MATHEMATICAL_ALPHANUMERIC_SYMBOLS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B;
pub const UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = UBlockCode.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT;
pub const UBLOCK_TAGS = UBlockCode.TAGS;
pub const UBLOCK_CYRILLIC_SUPPLEMENT = UBlockCode.CYRILLIC_SUPPLEMENT;
pub const UBLOCK_CYRILLIC_SUPPLEMENTARY = UBlockCode.CYRILLIC_SUPPLEMENT;
pub const UBLOCK_TAGALOG = UBlockCode.TAGALOG;
pub const UBLOCK_HANUNOO = UBlockCode.HANUNOO;
pub const UBLOCK_BUHID = UBlockCode.BUHID;
pub const UBLOCK_TAGBANWA = UBlockCode.TAGBANWA;
pub const UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = UBlockCode.MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_A = UBlockCode.SUPPLEMENTAL_ARROWS_A;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_B = UBlockCode.SUPPLEMENTAL_ARROWS_B;
pub const UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = UBlockCode.MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B;
pub const UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS = UBlockCode.SUPPLEMENTAL_MATHEMATICAL_OPERATORS;
pub const UBLOCK_KATAKANA_PHONETIC_EXTENSIONS = UBlockCode.KATAKANA_PHONETIC_EXTENSIONS;
pub const UBLOCK_VARIATION_SELECTORS = UBlockCode.VARIATION_SELECTORS;
pub const UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A = UBlockCode.SUPPLEMENTARY_PRIVATE_USE_AREA_A;
pub const UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B = UBlockCode.SUPPLEMENTARY_PRIVATE_USE_AREA_B;
pub const UBLOCK_LIMBU = UBlockCode.LIMBU;
pub const UBLOCK_TAI_LE = UBlockCode.TAI_LE;
pub const UBLOCK_KHMER_SYMBOLS = UBlockCode.KHMER_SYMBOLS;
pub const UBLOCK_PHONETIC_EXTENSIONS = UBlockCode.PHONETIC_EXTENSIONS;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS = UBlockCode.MISCELLANEOUS_SYMBOLS_AND_ARROWS;
pub const UBLOCK_YIJING_HEXAGRAM_SYMBOLS = UBlockCode.YIJING_HEXAGRAM_SYMBOLS;
pub const UBLOCK_LINEAR_B_SYLLABARY = UBlockCode.LINEAR_B_SYLLABARY;
pub const UBLOCK_LINEAR_B_IDEOGRAMS = UBlockCode.LINEAR_B_IDEOGRAMS;
pub const UBLOCK_AEGEAN_NUMBERS = UBlockCode.AEGEAN_NUMBERS;
pub const UBLOCK_UGARITIC = UBlockCode.UGARITIC;
pub const UBLOCK_SHAVIAN = UBlockCode.SHAVIAN;
pub const UBLOCK_OSMANYA = UBlockCode.OSMANYA;
pub const UBLOCK_CYPRIOT_SYLLABARY = UBlockCode.CYPRIOT_SYLLABARY;
pub const UBLOCK_TAI_XUAN_JING_SYMBOLS = UBlockCode.TAI_XUAN_JING_SYMBOLS;
pub const UBLOCK_VARIATION_SELECTORS_SUPPLEMENT = UBlockCode.VARIATION_SELECTORS_SUPPLEMENT;
pub const UBLOCK_ANCIENT_GREEK_MUSICAL_NOTATION = UBlockCode.ANCIENT_GREEK_MUSICAL_NOTATION;
pub const UBLOCK_ANCIENT_GREEK_NUMBERS = UBlockCode.ANCIENT_GREEK_NUMBERS;
pub const UBLOCK_ARABIC_SUPPLEMENT = UBlockCode.ARABIC_SUPPLEMENT;
pub const UBLOCK_BUGINESE = UBlockCode.BUGINESE;
pub const UBLOCK_CJK_STROKES = UBlockCode.CJK_STROKES;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = UBlockCode.COMBINING_DIACRITICAL_MARKS_SUPPLEMENT;
pub const UBLOCK_COPTIC = UBlockCode.COPTIC;
pub const UBLOCK_ETHIOPIC_EXTENDED = UBlockCode.ETHIOPIC_EXTENDED;
pub const UBLOCK_ETHIOPIC_SUPPLEMENT = UBlockCode.ETHIOPIC_SUPPLEMENT;
pub const UBLOCK_GEORGIAN_SUPPLEMENT = UBlockCode.GEORGIAN_SUPPLEMENT;
pub const UBLOCK_GLAGOLITIC = UBlockCode.GLAGOLITIC;
pub const UBLOCK_KHAROSHTHI = UBlockCode.KHAROSHTHI;
pub const UBLOCK_MODIFIER_TONE_LETTERS = UBlockCode.MODIFIER_TONE_LETTERS;
pub const UBLOCK_NEW_TAI_LUE = UBlockCode.NEW_TAI_LUE;
pub const UBLOCK_OLD_PERSIAN = UBlockCode.OLD_PERSIAN;
pub const UBLOCK_PHONETIC_EXTENSIONS_SUPPLEMENT = UBlockCode.PHONETIC_EXTENSIONS_SUPPLEMENT;
pub const UBLOCK_SUPPLEMENTAL_PUNCTUATION = UBlockCode.SUPPLEMENTAL_PUNCTUATION;
pub const UBLOCK_SYLOTI_NAGRI = UBlockCode.SYLOTI_NAGRI;
pub const UBLOCK_TIFINAGH = UBlockCode.TIFINAGH;
pub const UBLOCK_VERTICAL_FORMS = UBlockCode.VERTICAL_FORMS;
pub const UBLOCK_NKO = UBlockCode.NKO;
pub const UBLOCK_BALINESE = UBlockCode.BALINESE;
pub const UBLOCK_LATIN_EXTENDED_C = UBlockCode.LATIN_EXTENDED_C;
pub const UBLOCK_LATIN_EXTENDED_D = UBlockCode.LATIN_EXTENDED_D;
pub const UBLOCK_PHAGS_PA = UBlockCode.PHAGS_PA;
pub const UBLOCK_PHOENICIAN = UBlockCode.PHOENICIAN;
pub const UBLOCK_CUNEIFORM = UBlockCode.CUNEIFORM;
pub const UBLOCK_CUNEIFORM_NUMBERS_AND_PUNCTUATION = UBlockCode.CUNEIFORM_NUMBERS_AND_PUNCTUATION;
pub const UBLOCK_COUNTING_ROD_NUMERALS = UBlockCode.COUNTING_ROD_NUMERALS;
pub const UBLOCK_SUNDANESE = UBlockCode.SUNDANESE;
pub const UBLOCK_LEPCHA = UBlockCode.LEPCHA;
pub const UBLOCK_OL_CHIKI = UBlockCode.OL_CHIKI;
pub const UBLOCK_CYRILLIC_EXTENDED_A = UBlockCode.CYRILLIC_EXTENDED_A;
pub const UBLOCK_VAI = UBlockCode.VAI;
pub const UBLOCK_CYRILLIC_EXTENDED_B = UBlockCode.CYRILLIC_EXTENDED_B;
pub const UBLOCK_SAURASHTRA = UBlockCode.SAURASHTRA;
pub const UBLOCK_KAYAH_LI = UBlockCode.KAYAH_LI;
pub const UBLOCK_REJANG = UBlockCode.REJANG;
pub const UBLOCK_CHAM = UBlockCode.CHAM;
pub const UBLOCK_ANCIENT_SYMBOLS = UBlockCode.ANCIENT_SYMBOLS;
pub const UBLOCK_PHAISTOS_DISC = UBlockCode.PHAISTOS_DISC;
pub const UBLOCK_LYCIAN = UBlockCode.LYCIAN;
pub const UBLOCK_CARIAN = UBlockCode.CARIAN;
pub const UBLOCK_LYDIAN = UBlockCode.LYDIAN;
pub const UBLOCK_MAHJONG_TILES = UBlockCode.MAHJONG_TILES;
pub const UBLOCK_DOMINO_TILES = UBlockCode.DOMINO_TILES;
pub const UBLOCK_SAMARITAN = UBlockCode.SAMARITAN;
pub const UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = UBlockCode.UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED;
pub const UBLOCK_TAI_THAM = UBlockCode.TAI_THAM;
pub const UBLOCK_VEDIC_EXTENSIONS = UBlockCode.VEDIC_EXTENSIONS;
pub const UBLOCK_LISU = UBlockCode.LISU;
pub const UBLOCK_BAMUM = UBlockCode.BAMUM;
pub const UBLOCK_COMMON_INDIC_NUMBER_FORMS = UBlockCode.COMMON_INDIC_NUMBER_FORMS;
pub const UBLOCK_DEVANAGARI_EXTENDED = UBlockCode.DEVANAGARI_EXTENDED;
pub const UBLOCK_HANGUL_JAMO_EXTENDED_A = UBlockCode.HANGUL_JAMO_EXTENDED_A;
pub const UBLOCK_JAVANESE = UBlockCode.JAVANESE;
pub const UBLOCK_MYANMAR_EXTENDED_A = UBlockCode.MYANMAR_EXTENDED_A;
pub const UBLOCK_TAI_VIET = UBlockCode.TAI_VIET;
pub const UBLOCK_MEETEI_MAYEK = UBlockCode.MEETEI_MAYEK;
pub const UBLOCK_HANGUL_JAMO_EXTENDED_B = UBlockCode.HANGUL_JAMO_EXTENDED_B;
pub const UBLOCK_IMPERIAL_ARAMAIC = UBlockCode.IMPERIAL_ARAMAIC;
pub const UBLOCK_OLD_SOUTH_ARABIAN = UBlockCode.OLD_SOUTH_ARABIAN;
pub const UBLOCK_AVESTAN = UBlockCode.AVESTAN;
pub const UBLOCK_INSCRIPTIONAL_PARTHIAN = UBlockCode.INSCRIPTIONAL_PARTHIAN;
pub const UBLOCK_INSCRIPTIONAL_PAHLAVI = UBlockCode.INSCRIPTIONAL_PAHLAVI;
pub const UBLOCK_OLD_TURKIC = UBlockCode.OLD_TURKIC;
pub const UBLOCK_RUMI_NUMERAL_SYMBOLS = UBlockCode.RUMI_NUMERAL_SYMBOLS;
pub const UBLOCK_KAITHI = UBlockCode.KAITHI;
pub const UBLOCK_EGYPTIAN_HIEROGLYPHS = UBlockCode.EGYPTIAN_HIEROGLYPHS;
pub const UBLOCK_ENCLOSED_ALPHANUMERIC_SUPPLEMENT = UBlockCode.ENCLOSED_ALPHANUMERIC_SUPPLEMENT;
pub const UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = UBlockCode.ENCLOSED_IDEOGRAPHIC_SUPPLEMENT;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C;
pub const UBLOCK_MANDAIC = UBlockCode.MANDAIC;
pub const UBLOCK_BATAK = UBlockCode.BATAK;
pub const UBLOCK_ETHIOPIC_EXTENDED_A = UBlockCode.ETHIOPIC_EXTENDED_A;
pub const UBLOCK_BRAHMI = UBlockCode.BRAHMI;
pub const UBLOCK_BAMUM_SUPPLEMENT = UBlockCode.BAMUM_SUPPLEMENT;
pub const UBLOCK_KANA_SUPPLEMENT = UBlockCode.KANA_SUPPLEMENT;
pub const UBLOCK_PLAYING_CARDS = UBlockCode.PLAYING_CARDS;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = UBlockCode.MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS;
pub const UBLOCK_EMOTICONS = UBlockCode.EMOTICONS;
pub const UBLOCK_TRANSPORT_AND_MAP_SYMBOLS = UBlockCode.TRANSPORT_AND_MAP_SYMBOLS;
pub const UBLOCK_ALCHEMICAL_SYMBOLS = UBlockCode.ALCHEMICAL_SYMBOLS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D;
pub const UBLOCK_ARABIC_EXTENDED_A = UBlockCode.ARABIC_EXTENDED_A;
pub const UBLOCK_ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS = UBlockCode.ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS;
pub const UBLOCK_CHAKMA = UBlockCode.CHAKMA;
pub const UBLOCK_MEETEI_MAYEK_EXTENSIONS = UBlockCode.MEETEI_MAYEK_EXTENSIONS;
pub const UBLOCK_MEROITIC_CURSIVE = UBlockCode.MEROITIC_CURSIVE;
pub const UBLOCK_MEROITIC_HIEROGLYPHS = UBlockCode.MEROITIC_HIEROGLYPHS;
pub const UBLOCK_MIAO = UBlockCode.MIAO;
pub const UBLOCK_SHARADA = UBlockCode.SHARADA;
pub const UBLOCK_SORA_SOMPENG = UBlockCode.SORA_SOMPENG;
pub const UBLOCK_SUNDANESE_SUPPLEMENT = UBlockCode.SUNDANESE_SUPPLEMENT;
pub const UBLOCK_TAKRI = UBlockCode.TAKRI;
pub const UBLOCK_BASSA_VAH = UBlockCode.BASSA_VAH;
pub const UBLOCK_CAUCASIAN_ALBANIAN = UBlockCode.CAUCASIAN_ALBANIAN;
pub const UBLOCK_COPTIC_EPACT_NUMBERS = UBlockCode.COPTIC_EPACT_NUMBERS;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS_EXTENDED = UBlockCode.COMBINING_DIACRITICAL_MARKS_EXTENDED;
pub const UBLOCK_DUPLOYAN = UBlockCode.DUPLOYAN;
pub const UBLOCK_ELBASAN = UBlockCode.ELBASAN;
pub const UBLOCK_GEOMETRIC_SHAPES_EXTENDED = UBlockCode.GEOMETRIC_SHAPES_EXTENDED;
pub const UBLOCK_GRANTHA = UBlockCode.GRANTHA;
pub const UBLOCK_KHOJKI = UBlockCode.KHOJKI;
pub const UBLOCK_KHUDAWADI = UBlockCode.KHUDAWADI;
pub const UBLOCK_LATIN_EXTENDED_E = UBlockCode.LATIN_EXTENDED_E;
pub const UBLOCK_LINEAR_A = UBlockCode.LINEAR_A;
pub const UBLOCK_MAHAJANI = UBlockCode.MAHAJANI;
pub const UBLOCK_MANICHAEAN = UBlockCode.MANICHAEAN;
pub const UBLOCK_MENDE_KIKAKUI = UBlockCode.MENDE_KIKAKUI;
pub const UBLOCK_MODI = UBlockCode.MODI;
pub const UBLOCK_MRO = UBlockCode.MRO;
pub const UBLOCK_MYANMAR_EXTENDED_B = UBlockCode.MYANMAR_EXTENDED_B;
pub const UBLOCK_NABATAEAN = UBlockCode.NABATAEAN;
pub const UBLOCK_OLD_NORTH_ARABIAN = UBlockCode.OLD_NORTH_ARABIAN;
pub const UBLOCK_OLD_PERMIC = UBlockCode.OLD_PERMIC;
pub const UBLOCK_ORNAMENTAL_DINGBATS = UBlockCode.ORNAMENTAL_DINGBATS;
pub const UBLOCK_PAHAWH_HMONG = UBlockCode.PAHAWH_HMONG;
pub const UBLOCK_PALMYRENE = UBlockCode.PALMYRENE;
pub const UBLOCK_PAU_CIN_HAU = UBlockCode.PAU_CIN_HAU;
pub const UBLOCK_PSALTER_PAHLAVI = UBlockCode.PSALTER_PAHLAVI;
pub const UBLOCK_SHORTHAND_FORMAT_CONTROLS = UBlockCode.SHORTHAND_FORMAT_CONTROLS;
pub const UBLOCK_SIDDHAM = UBlockCode.SIDDHAM;
pub const UBLOCK_SINHALA_ARCHAIC_NUMBERS = UBlockCode.SINHALA_ARCHAIC_NUMBERS;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_C = UBlockCode.SUPPLEMENTAL_ARROWS_C;
pub const UBLOCK_TIRHUTA = UBlockCode.TIRHUTA;
pub const UBLOCK_WARANG_CITI = UBlockCode.WARANG_CITI;
pub const UBLOCK_AHOM = UBlockCode.AHOM;
pub const UBLOCK_ANATOLIAN_HIEROGLYPHS = UBlockCode.ANATOLIAN_HIEROGLYPHS;
pub const UBLOCK_CHEROKEE_SUPPLEMENT = UBlockCode.CHEROKEE_SUPPLEMENT;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E;
pub const UBLOCK_EARLY_DYNASTIC_CUNEIFORM = UBlockCode.EARLY_DYNASTIC_CUNEIFORM;
pub const UBLOCK_HATRAN = UBlockCode.HATRAN;
pub const UBLOCK_MULTANI = UBlockCode.MULTANI;
pub const UBLOCK_OLD_HUNGARIAN = UBlockCode.OLD_HUNGARIAN;
pub const UBLOCK_SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS = UBlockCode.SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS;
pub const UBLOCK_SUTTON_SIGNWRITING = UBlockCode.SUTTON_SIGNWRITING;
pub const UBLOCK_ADLAM = UBlockCode.ADLAM;
pub const UBLOCK_BHAIKSUKI = UBlockCode.BHAIKSUKI;
pub const UBLOCK_CYRILLIC_EXTENDED_C = UBlockCode.CYRILLIC_EXTENDED_C;
pub const UBLOCK_GLAGOLITIC_SUPPLEMENT = UBlockCode.GLAGOLITIC_SUPPLEMENT;
pub const UBLOCK_IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION = UBlockCode.IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION;
pub const UBLOCK_MARCHEN = UBlockCode.MARCHEN;
pub const UBLOCK_MONGOLIAN_SUPPLEMENT = UBlockCode.MONGOLIAN_SUPPLEMENT;
pub const UBLOCK_NEWA = UBlockCode.NEWA;
pub const UBLOCK_OSAGE = UBlockCode.OSAGE;
pub const UBLOCK_TANGUT = UBlockCode.TANGUT;
pub const UBLOCK_TANGUT_COMPONENTS = UBlockCode.TANGUT_COMPONENTS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F;
pub const UBLOCK_KANA_EXTENDED_A = UBlockCode.KANA_EXTENDED_A;
pub const UBLOCK_MASARAM_GONDI = UBlockCode.MASARAM_GONDI;
pub const UBLOCK_NUSHU = UBlockCode.NUSHU;
pub const UBLOCK_SOYOMBO = UBlockCode.SOYOMBO;
pub const UBLOCK_SYRIAC_SUPPLEMENT = UBlockCode.SYRIAC_SUPPLEMENT;
pub const UBLOCK_ZANABAZAR_SQUARE = UBlockCode.ZANABAZAR_SQUARE;
pub const UBLOCK_CHESS_SYMBOLS = UBlockCode.CHESS_SYMBOLS;
pub const UBLOCK_DOGRA = UBlockCode.DOGRA;
pub const UBLOCK_GEORGIAN_EXTENDED = UBlockCode.GEORGIAN_EXTENDED;
pub const UBLOCK_GUNJALA_GONDI = UBlockCode.GUNJALA_GONDI;
pub const UBLOCK_HANIFI_ROHINGYA = UBlockCode.HANIFI_ROHINGYA;
pub const UBLOCK_INDIC_SIYAQ_NUMBERS = UBlockCode.INDIC_SIYAQ_NUMBERS;
pub const UBLOCK_MAKASAR = UBlockCode.MAKASAR;
pub const UBLOCK_MAYAN_NUMERALS = UBlockCode.MAYAN_NUMERALS;
pub const UBLOCK_MEDEFAIDRIN = UBlockCode.MEDEFAIDRIN;
pub const UBLOCK_OLD_SOGDIAN = UBlockCode.OLD_SOGDIAN;
pub const UBLOCK_SOGDIAN = UBlockCode.SOGDIAN;
pub const UBLOCK_EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS = UBlockCode.EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS;
pub const UBLOCK_ELYMAIC = UBlockCode.ELYMAIC;
pub const UBLOCK_NANDINAGARI = UBlockCode.NANDINAGARI;
pub const UBLOCK_NYIAKENG_PUACHUE_HMONG = UBlockCode.NYIAKENG_PUACHUE_HMONG;
pub const UBLOCK_OTTOMAN_SIYAQ_NUMBERS = UBlockCode.OTTOMAN_SIYAQ_NUMBERS;
pub const UBLOCK_SMALL_KANA_EXTENSION = UBlockCode.SMALL_KANA_EXTENSION;
pub const UBLOCK_SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A = UBlockCode.SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A;
pub const UBLOCK_TAMIL_SUPPLEMENT = UBlockCode.TAMIL_SUPPLEMENT;
pub const UBLOCK_WANCHO = UBlockCode.WANCHO;
pub const UBLOCK_INVALID_CODE = UBlockCode.INVALID_CODE;

pub const UEastAsianWidth = enum(i32) {
    NEUTRAL = 0,
    AMBIGUOUS = 1,
    HALFWIDTH = 2,
    FULLWIDTH = 3,
    NARROW = 4,
    WIDE = 5,
};
pub const U_EA_NEUTRAL = UEastAsianWidth.NEUTRAL;
pub const U_EA_AMBIGUOUS = UEastAsianWidth.AMBIGUOUS;
pub const U_EA_HALFWIDTH = UEastAsianWidth.HALFWIDTH;
pub const U_EA_FULLWIDTH = UEastAsianWidth.FULLWIDTH;
pub const U_EA_NARROW = UEastAsianWidth.NARROW;
pub const U_EA_WIDE = UEastAsianWidth.WIDE;

pub const UCharNameChoice = enum(i32) {
    UNICODE_CHAR_NAME = 0,
    EXTENDED_CHAR_NAME = 2,
    CHAR_NAME_ALIAS = 3,
};
pub const U_UNICODE_CHAR_NAME = UCharNameChoice.UNICODE_CHAR_NAME;
pub const U_EXTENDED_CHAR_NAME = UCharNameChoice.EXTENDED_CHAR_NAME;
pub const U_CHAR_NAME_ALIAS = UCharNameChoice.CHAR_NAME_ALIAS;

pub const UPropertyNameChoice = enum(i32) {
    SHORT_PROPERTY_NAME = 0,
    LONG_PROPERTY_NAME = 1,
};
pub const U_SHORT_PROPERTY_NAME = UPropertyNameChoice.SHORT_PROPERTY_NAME;
pub const U_LONG_PROPERTY_NAME = UPropertyNameChoice.LONG_PROPERTY_NAME;

pub const UDecompositionType = enum(i32) {
    NONE = 0,
    CANONICAL = 1,
    COMPAT = 2,
    CIRCLE = 3,
    FINAL = 4,
    FONT = 5,
    FRACTION = 6,
    INITIAL = 7,
    ISOLATED = 8,
    MEDIAL = 9,
    NARROW = 10,
    NOBREAK = 11,
    SMALL = 12,
    SQUARE = 13,
    SUB = 14,
    SUPER = 15,
    VERTICAL = 16,
    WIDE = 17,
};
pub const U_DT_NONE = UDecompositionType.NONE;
pub const U_DT_CANONICAL = UDecompositionType.CANONICAL;
pub const U_DT_COMPAT = UDecompositionType.COMPAT;
pub const U_DT_CIRCLE = UDecompositionType.CIRCLE;
pub const U_DT_FINAL = UDecompositionType.FINAL;
pub const U_DT_FONT = UDecompositionType.FONT;
pub const U_DT_FRACTION = UDecompositionType.FRACTION;
pub const U_DT_INITIAL = UDecompositionType.INITIAL;
pub const U_DT_ISOLATED = UDecompositionType.ISOLATED;
pub const U_DT_MEDIAL = UDecompositionType.MEDIAL;
pub const U_DT_NARROW = UDecompositionType.NARROW;
pub const U_DT_NOBREAK = UDecompositionType.NOBREAK;
pub const U_DT_SMALL = UDecompositionType.SMALL;
pub const U_DT_SQUARE = UDecompositionType.SQUARE;
pub const U_DT_SUB = UDecompositionType.SUB;
pub const U_DT_SUPER = UDecompositionType.SUPER;
pub const U_DT_VERTICAL = UDecompositionType.VERTICAL;
pub const U_DT_WIDE = UDecompositionType.WIDE;

pub const UJoiningType = enum(i32) {
    NON_JOINING = 0,
    JOIN_CAUSING = 1,
    DUAL_JOINING = 2,
    LEFT_JOINING = 3,
    RIGHT_JOINING = 4,
    TRANSPARENT = 5,
};
pub const U_JT_NON_JOINING = UJoiningType.NON_JOINING;
pub const U_JT_JOIN_CAUSING = UJoiningType.JOIN_CAUSING;
pub const U_JT_DUAL_JOINING = UJoiningType.DUAL_JOINING;
pub const U_JT_LEFT_JOINING = UJoiningType.LEFT_JOINING;
pub const U_JT_RIGHT_JOINING = UJoiningType.RIGHT_JOINING;
pub const U_JT_TRANSPARENT = UJoiningType.TRANSPARENT;

pub const UJoiningGroup = enum(i32) {
    NO_JOINING_GROUP = 0,
    AIN = 1,
    ALAPH = 2,
    ALEF = 3,
    BEH = 4,
    BETH = 5,
    DAL = 6,
    DALATH_RISH = 7,
    E = 8,
    FEH = 9,
    FINAL_SEMKATH = 10,
    GAF = 11,
    GAMAL = 12,
    HAH = 13,
    TEH_MARBUTA_GOAL = 14,
    // HAMZA_ON_HEH_GOAL = 14, this enum value conflicts with TEH_MARBUTA_GOAL
    HE = 15,
    HEH = 16,
    HEH_GOAL = 17,
    HETH = 18,
    KAF = 19,
    KAPH = 20,
    KNOTTED_HEH = 21,
    LAM = 22,
    LAMADH = 23,
    MEEM = 24,
    MIM = 25,
    NOON = 26,
    NUN = 27,
    PE = 28,
    QAF = 29,
    QAPH = 30,
    REH = 31,
    REVERSED_PE = 32,
    SAD = 33,
    SADHE = 34,
    SEEN = 35,
    SEMKATH = 36,
    SHIN = 37,
    SWASH_KAF = 38,
    SYRIAC_WAW = 39,
    TAH = 40,
    TAW = 41,
    TEH_MARBUTA = 42,
    TETH = 43,
    WAW = 44,
    YEH = 45,
    YEH_BARREE = 46,
    YEH_WITH_TAIL = 47,
    YUDH = 48,
    YUDH_HE = 49,
    ZAIN = 50,
    FE = 51,
    KHAPH = 52,
    ZHAIN = 53,
    BURUSHASKI_YEH_BARREE = 54,
    FARSI_YEH = 55,
    NYA = 56,
    ROHINGYA_YEH = 57,
    MANICHAEAN_ALEPH = 58,
    MANICHAEAN_AYIN = 59,
    MANICHAEAN_BETH = 60,
    MANICHAEAN_DALETH = 61,
    MANICHAEAN_DHAMEDH = 62,
    MANICHAEAN_FIVE = 63,
    MANICHAEAN_GIMEL = 64,
    MANICHAEAN_HETH = 65,
    MANICHAEAN_HUNDRED = 66,
    MANICHAEAN_KAPH = 67,
    MANICHAEAN_LAMEDH = 68,
    MANICHAEAN_MEM = 69,
    MANICHAEAN_NUN = 70,
    MANICHAEAN_ONE = 71,
    MANICHAEAN_PE = 72,
    MANICHAEAN_QOPH = 73,
    MANICHAEAN_RESH = 74,
    MANICHAEAN_SADHE = 75,
    MANICHAEAN_SAMEKH = 76,
    MANICHAEAN_TAW = 77,
    MANICHAEAN_TEN = 78,
    MANICHAEAN_TETH = 79,
    MANICHAEAN_THAMEDH = 80,
    MANICHAEAN_TWENTY = 81,
    MANICHAEAN_WAW = 82,
    MANICHAEAN_YODH = 83,
    MANICHAEAN_ZAYIN = 84,
    STRAIGHT_WAW = 85,
    AFRICAN_FEH = 86,
    AFRICAN_NOON = 87,
    AFRICAN_QAF = 88,
    MALAYALAM_BHA = 89,
    MALAYALAM_JA = 90,
    MALAYALAM_LLA = 91,
    MALAYALAM_LLLA = 92,
    MALAYALAM_NGA = 93,
    MALAYALAM_NNA = 94,
    MALAYALAM_NNNA = 95,
    MALAYALAM_NYA = 96,
    MALAYALAM_RA = 97,
    MALAYALAM_SSA = 98,
    MALAYALAM_TTA = 99,
    HANIFI_ROHINGYA_KINNA_YA = 100,
    HANIFI_ROHINGYA_PA = 101,
};
pub const U_JG_NO_JOINING_GROUP = UJoiningGroup.NO_JOINING_GROUP;
pub const U_JG_AIN = UJoiningGroup.AIN;
pub const U_JG_ALAPH = UJoiningGroup.ALAPH;
pub const U_JG_ALEF = UJoiningGroup.ALEF;
pub const U_JG_BEH = UJoiningGroup.BEH;
pub const U_JG_BETH = UJoiningGroup.BETH;
pub const U_JG_DAL = UJoiningGroup.DAL;
pub const U_JG_DALATH_RISH = UJoiningGroup.DALATH_RISH;
pub const U_JG_E = UJoiningGroup.E;
pub const U_JG_FEH = UJoiningGroup.FEH;
pub const U_JG_FINAL_SEMKATH = UJoiningGroup.FINAL_SEMKATH;
pub const U_JG_GAF = UJoiningGroup.GAF;
pub const U_JG_GAMAL = UJoiningGroup.GAMAL;
pub const U_JG_HAH = UJoiningGroup.HAH;
pub const U_JG_TEH_MARBUTA_GOAL = UJoiningGroup.TEH_MARBUTA_GOAL;
pub const U_JG_HAMZA_ON_HEH_GOAL = UJoiningGroup.TEH_MARBUTA_GOAL;
pub const U_JG_HE = UJoiningGroup.HE;
pub const U_JG_HEH = UJoiningGroup.HEH;
pub const U_JG_HEH_GOAL = UJoiningGroup.HEH_GOAL;
pub const U_JG_HETH = UJoiningGroup.HETH;
pub const U_JG_KAF = UJoiningGroup.KAF;
pub const U_JG_KAPH = UJoiningGroup.KAPH;
pub const U_JG_KNOTTED_HEH = UJoiningGroup.KNOTTED_HEH;
pub const U_JG_LAM = UJoiningGroup.LAM;
pub const U_JG_LAMADH = UJoiningGroup.LAMADH;
pub const U_JG_MEEM = UJoiningGroup.MEEM;
pub const U_JG_MIM = UJoiningGroup.MIM;
pub const U_JG_NOON = UJoiningGroup.NOON;
pub const U_JG_NUN = UJoiningGroup.NUN;
pub const U_JG_PE = UJoiningGroup.PE;
pub const U_JG_QAF = UJoiningGroup.QAF;
pub const U_JG_QAPH = UJoiningGroup.QAPH;
pub const U_JG_REH = UJoiningGroup.REH;
pub const U_JG_REVERSED_PE = UJoiningGroup.REVERSED_PE;
pub const U_JG_SAD = UJoiningGroup.SAD;
pub const U_JG_SADHE = UJoiningGroup.SADHE;
pub const U_JG_SEEN = UJoiningGroup.SEEN;
pub const U_JG_SEMKATH = UJoiningGroup.SEMKATH;
pub const U_JG_SHIN = UJoiningGroup.SHIN;
pub const U_JG_SWASH_KAF = UJoiningGroup.SWASH_KAF;
pub const U_JG_SYRIAC_WAW = UJoiningGroup.SYRIAC_WAW;
pub const U_JG_TAH = UJoiningGroup.TAH;
pub const U_JG_TAW = UJoiningGroup.TAW;
pub const U_JG_TEH_MARBUTA = UJoiningGroup.TEH_MARBUTA;
pub const U_JG_TETH = UJoiningGroup.TETH;
pub const U_JG_WAW = UJoiningGroup.WAW;
pub const U_JG_YEH = UJoiningGroup.YEH;
pub const U_JG_YEH_BARREE = UJoiningGroup.YEH_BARREE;
pub const U_JG_YEH_WITH_TAIL = UJoiningGroup.YEH_WITH_TAIL;
pub const U_JG_YUDH = UJoiningGroup.YUDH;
pub const U_JG_YUDH_HE = UJoiningGroup.YUDH_HE;
pub const U_JG_ZAIN = UJoiningGroup.ZAIN;
pub const U_JG_FE = UJoiningGroup.FE;
pub const U_JG_KHAPH = UJoiningGroup.KHAPH;
pub const U_JG_ZHAIN = UJoiningGroup.ZHAIN;
pub const U_JG_BURUSHASKI_YEH_BARREE = UJoiningGroup.BURUSHASKI_YEH_BARREE;
pub const U_JG_FARSI_YEH = UJoiningGroup.FARSI_YEH;
pub const U_JG_NYA = UJoiningGroup.NYA;
pub const U_JG_ROHINGYA_YEH = UJoiningGroup.ROHINGYA_YEH;
pub const U_JG_MANICHAEAN_ALEPH = UJoiningGroup.MANICHAEAN_ALEPH;
pub const U_JG_MANICHAEAN_AYIN = UJoiningGroup.MANICHAEAN_AYIN;
pub const U_JG_MANICHAEAN_BETH = UJoiningGroup.MANICHAEAN_BETH;
pub const U_JG_MANICHAEAN_DALETH = UJoiningGroup.MANICHAEAN_DALETH;
pub const U_JG_MANICHAEAN_DHAMEDH = UJoiningGroup.MANICHAEAN_DHAMEDH;
pub const U_JG_MANICHAEAN_FIVE = UJoiningGroup.MANICHAEAN_FIVE;
pub const U_JG_MANICHAEAN_GIMEL = UJoiningGroup.MANICHAEAN_GIMEL;
pub const U_JG_MANICHAEAN_HETH = UJoiningGroup.MANICHAEAN_HETH;
pub const U_JG_MANICHAEAN_HUNDRED = UJoiningGroup.MANICHAEAN_HUNDRED;
pub const U_JG_MANICHAEAN_KAPH = UJoiningGroup.MANICHAEAN_KAPH;
pub const U_JG_MANICHAEAN_LAMEDH = UJoiningGroup.MANICHAEAN_LAMEDH;
pub const U_JG_MANICHAEAN_MEM = UJoiningGroup.MANICHAEAN_MEM;
pub const U_JG_MANICHAEAN_NUN = UJoiningGroup.MANICHAEAN_NUN;
pub const U_JG_MANICHAEAN_ONE = UJoiningGroup.MANICHAEAN_ONE;
pub const U_JG_MANICHAEAN_PE = UJoiningGroup.MANICHAEAN_PE;
pub const U_JG_MANICHAEAN_QOPH = UJoiningGroup.MANICHAEAN_QOPH;
pub const U_JG_MANICHAEAN_RESH = UJoiningGroup.MANICHAEAN_RESH;
pub const U_JG_MANICHAEAN_SADHE = UJoiningGroup.MANICHAEAN_SADHE;
pub const U_JG_MANICHAEAN_SAMEKH = UJoiningGroup.MANICHAEAN_SAMEKH;
pub const U_JG_MANICHAEAN_TAW = UJoiningGroup.MANICHAEAN_TAW;
pub const U_JG_MANICHAEAN_TEN = UJoiningGroup.MANICHAEAN_TEN;
pub const U_JG_MANICHAEAN_TETH = UJoiningGroup.MANICHAEAN_TETH;
pub const U_JG_MANICHAEAN_THAMEDH = UJoiningGroup.MANICHAEAN_THAMEDH;
pub const U_JG_MANICHAEAN_TWENTY = UJoiningGroup.MANICHAEAN_TWENTY;
pub const U_JG_MANICHAEAN_WAW = UJoiningGroup.MANICHAEAN_WAW;
pub const U_JG_MANICHAEAN_YODH = UJoiningGroup.MANICHAEAN_YODH;
pub const U_JG_MANICHAEAN_ZAYIN = UJoiningGroup.MANICHAEAN_ZAYIN;
pub const U_JG_STRAIGHT_WAW = UJoiningGroup.STRAIGHT_WAW;
pub const U_JG_AFRICAN_FEH = UJoiningGroup.AFRICAN_FEH;
pub const U_JG_AFRICAN_NOON = UJoiningGroup.AFRICAN_NOON;
pub const U_JG_AFRICAN_QAF = UJoiningGroup.AFRICAN_QAF;
pub const U_JG_MALAYALAM_BHA = UJoiningGroup.MALAYALAM_BHA;
pub const U_JG_MALAYALAM_JA = UJoiningGroup.MALAYALAM_JA;
pub const U_JG_MALAYALAM_LLA = UJoiningGroup.MALAYALAM_LLA;
pub const U_JG_MALAYALAM_LLLA = UJoiningGroup.MALAYALAM_LLLA;
pub const U_JG_MALAYALAM_NGA = UJoiningGroup.MALAYALAM_NGA;
pub const U_JG_MALAYALAM_NNA = UJoiningGroup.MALAYALAM_NNA;
pub const U_JG_MALAYALAM_NNNA = UJoiningGroup.MALAYALAM_NNNA;
pub const U_JG_MALAYALAM_NYA = UJoiningGroup.MALAYALAM_NYA;
pub const U_JG_MALAYALAM_RA = UJoiningGroup.MALAYALAM_RA;
pub const U_JG_MALAYALAM_SSA = UJoiningGroup.MALAYALAM_SSA;
pub const U_JG_MALAYALAM_TTA = UJoiningGroup.MALAYALAM_TTA;
pub const U_JG_HANIFI_ROHINGYA_KINNA_YA = UJoiningGroup.HANIFI_ROHINGYA_KINNA_YA;
pub const U_JG_HANIFI_ROHINGYA_PA = UJoiningGroup.HANIFI_ROHINGYA_PA;

pub const UGraphemeClusterBreak = enum(i32) {
    OTHER = 0,
    CONTROL = 1,
    CR = 2,
    EXTEND = 3,
    L = 4,
    LF = 5,
    LV = 6,
    LVT = 7,
    T = 8,
    V = 9,
    SPACING_MARK = 10,
    PREPEND = 11,
    REGIONAL_INDICATOR = 12,
    E_BASE = 13,
    E_BASE_GAZ = 14,
    E_MODIFIER = 15,
    GLUE_AFTER_ZWJ = 16,
    ZWJ = 17,
};
pub const U_GCB_OTHER = UGraphemeClusterBreak.OTHER;
pub const U_GCB_CONTROL = UGraphemeClusterBreak.CONTROL;
pub const U_GCB_CR = UGraphemeClusterBreak.CR;
pub const U_GCB_EXTEND = UGraphemeClusterBreak.EXTEND;
pub const U_GCB_L = UGraphemeClusterBreak.L;
pub const U_GCB_LF = UGraphemeClusterBreak.LF;
pub const U_GCB_LV = UGraphemeClusterBreak.LV;
pub const U_GCB_LVT = UGraphemeClusterBreak.LVT;
pub const U_GCB_T = UGraphemeClusterBreak.T;
pub const U_GCB_V = UGraphemeClusterBreak.V;
pub const U_GCB_SPACING_MARK = UGraphemeClusterBreak.SPACING_MARK;
pub const U_GCB_PREPEND = UGraphemeClusterBreak.PREPEND;
pub const U_GCB_REGIONAL_INDICATOR = UGraphemeClusterBreak.REGIONAL_INDICATOR;
pub const U_GCB_E_BASE = UGraphemeClusterBreak.E_BASE;
pub const U_GCB_E_BASE_GAZ = UGraphemeClusterBreak.E_BASE_GAZ;
pub const U_GCB_E_MODIFIER = UGraphemeClusterBreak.E_MODIFIER;
pub const U_GCB_GLUE_AFTER_ZWJ = UGraphemeClusterBreak.GLUE_AFTER_ZWJ;
pub const U_GCB_ZWJ = UGraphemeClusterBreak.ZWJ;

pub const UWordBreakValues = enum(i32) {
    OTHER = 0,
    ALETTER = 1,
    FORMAT = 2,
    KATAKANA = 3,
    MIDLETTER = 4,
    MIDNUM = 5,
    NUMERIC = 6,
    EXTENDNUMLET = 7,
    CR = 8,
    EXTEND = 9,
    LF = 10,
    MIDNUMLET = 11,
    NEWLINE = 12,
    REGIONAL_INDICATOR = 13,
    HEBREW_LETTER = 14,
    SINGLE_QUOTE = 15,
    DOUBLE_QUOTE = 16,
    E_BASE = 17,
    E_BASE_GAZ = 18,
    E_MODIFIER = 19,
    GLUE_AFTER_ZWJ = 20,
    ZWJ = 21,
    WSEGSPACE = 22,
};
pub const U_WB_OTHER = UWordBreakValues.OTHER;
pub const U_WB_ALETTER = UWordBreakValues.ALETTER;
pub const U_WB_FORMAT = UWordBreakValues.FORMAT;
pub const U_WB_KATAKANA = UWordBreakValues.KATAKANA;
pub const U_WB_MIDLETTER = UWordBreakValues.MIDLETTER;
pub const U_WB_MIDNUM = UWordBreakValues.MIDNUM;
pub const U_WB_NUMERIC = UWordBreakValues.NUMERIC;
pub const U_WB_EXTENDNUMLET = UWordBreakValues.EXTENDNUMLET;
pub const U_WB_CR = UWordBreakValues.CR;
pub const U_WB_EXTEND = UWordBreakValues.EXTEND;
pub const U_WB_LF = UWordBreakValues.LF;
pub const U_WB_MIDNUMLET = UWordBreakValues.MIDNUMLET;
pub const U_WB_NEWLINE = UWordBreakValues.NEWLINE;
pub const U_WB_REGIONAL_INDICATOR = UWordBreakValues.REGIONAL_INDICATOR;
pub const U_WB_HEBREW_LETTER = UWordBreakValues.HEBREW_LETTER;
pub const U_WB_SINGLE_QUOTE = UWordBreakValues.SINGLE_QUOTE;
pub const U_WB_DOUBLE_QUOTE = UWordBreakValues.DOUBLE_QUOTE;
pub const U_WB_E_BASE = UWordBreakValues.E_BASE;
pub const U_WB_E_BASE_GAZ = UWordBreakValues.E_BASE_GAZ;
pub const U_WB_E_MODIFIER = UWordBreakValues.E_MODIFIER;
pub const U_WB_GLUE_AFTER_ZWJ = UWordBreakValues.GLUE_AFTER_ZWJ;
pub const U_WB_ZWJ = UWordBreakValues.ZWJ;
pub const U_WB_WSEGSPACE = UWordBreakValues.WSEGSPACE;

pub const USentenceBreak = enum(i32) {
    OTHER = 0,
    ATERM = 1,
    CLOSE = 2,
    FORMAT = 3,
    LOWER = 4,
    NUMERIC = 5,
    OLETTER = 6,
    SEP = 7,
    SP = 8,
    STERM = 9,
    UPPER = 10,
    CR = 11,
    EXTEND = 12,
    LF = 13,
    SCONTINUE = 14,
};
pub const U_SB_OTHER = USentenceBreak.OTHER;
pub const U_SB_ATERM = USentenceBreak.ATERM;
pub const U_SB_CLOSE = USentenceBreak.CLOSE;
pub const U_SB_FORMAT = USentenceBreak.FORMAT;
pub const U_SB_LOWER = USentenceBreak.LOWER;
pub const U_SB_NUMERIC = USentenceBreak.NUMERIC;
pub const U_SB_OLETTER = USentenceBreak.OLETTER;
pub const U_SB_SEP = USentenceBreak.SEP;
pub const U_SB_SP = USentenceBreak.SP;
pub const U_SB_STERM = USentenceBreak.STERM;
pub const U_SB_UPPER = USentenceBreak.UPPER;
pub const U_SB_CR = USentenceBreak.CR;
pub const U_SB_EXTEND = USentenceBreak.EXTEND;
pub const U_SB_LF = USentenceBreak.LF;
pub const U_SB_SCONTINUE = USentenceBreak.SCONTINUE;

pub const ULineBreak = enum(i32) {
    UNKNOWN = 0,
    AMBIGUOUS = 1,
    ALPHABETIC = 2,
    BREAK_BOTH = 3,
    BREAK_AFTER = 4,
    BREAK_BEFORE = 5,
    MANDATORY_BREAK = 6,
    CONTINGENT_BREAK = 7,
    CLOSE_PUNCTUATION = 8,
    COMBINING_MARK = 9,
    CARRIAGE_RETURN = 10,
    EXCLAMATION = 11,
    GLUE = 12,
    HYPHEN = 13,
    IDEOGRAPHIC = 14,
    INSEPARABLE = 15,
    // INSEPERABLE = 15, this enum value conflicts with INSEPARABLE
    INFIX_NUMERIC = 16,
    LINE_FEED = 17,
    NONSTARTER = 18,
    NUMERIC = 19,
    OPEN_PUNCTUATION = 20,
    POSTFIX_NUMERIC = 21,
    PREFIX_NUMERIC = 22,
    QUOTATION = 23,
    COMPLEX_CONTEXT = 24,
    SURROGATE = 25,
    SPACE = 26,
    BREAK_SYMBOLS = 27,
    ZWSPACE = 28,
    NEXT_LINE = 29,
    WORD_JOINER = 30,
    H2 = 31,
    H3 = 32,
    JL = 33,
    JT = 34,
    JV = 35,
    CLOSE_PARENTHESIS = 36,
    CONDITIONAL_JAPANESE_STARTER = 37,
    HEBREW_LETTER = 38,
    REGIONAL_INDICATOR = 39,
    E_BASE = 40,
    E_MODIFIER = 41,
    ZWJ = 42,
};
pub const U_LB_UNKNOWN = ULineBreak.UNKNOWN;
pub const U_LB_AMBIGUOUS = ULineBreak.AMBIGUOUS;
pub const U_LB_ALPHABETIC = ULineBreak.ALPHABETIC;
pub const U_LB_BREAK_BOTH = ULineBreak.BREAK_BOTH;
pub const U_LB_BREAK_AFTER = ULineBreak.BREAK_AFTER;
pub const U_LB_BREAK_BEFORE = ULineBreak.BREAK_BEFORE;
pub const U_LB_MANDATORY_BREAK = ULineBreak.MANDATORY_BREAK;
pub const U_LB_CONTINGENT_BREAK = ULineBreak.CONTINGENT_BREAK;
pub const U_LB_CLOSE_PUNCTUATION = ULineBreak.CLOSE_PUNCTUATION;
pub const U_LB_COMBINING_MARK = ULineBreak.COMBINING_MARK;
pub const U_LB_CARRIAGE_RETURN = ULineBreak.CARRIAGE_RETURN;
pub const U_LB_EXCLAMATION = ULineBreak.EXCLAMATION;
pub const U_LB_GLUE = ULineBreak.GLUE;
pub const U_LB_HYPHEN = ULineBreak.HYPHEN;
pub const U_LB_IDEOGRAPHIC = ULineBreak.IDEOGRAPHIC;
pub const U_LB_INSEPARABLE = ULineBreak.INSEPARABLE;
pub const U_LB_INSEPERABLE = ULineBreak.INSEPARABLE;
pub const U_LB_INFIX_NUMERIC = ULineBreak.INFIX_NUMERIC;
pub const U_LB_LINE_FEED = ULineBreak.LINE_FEED;
pub const U_LB_NONSTARTER = ULineBreak.NONSTARTER;
pub const U_LB_NUMERIC = ULineBreak.NUMERIC;
pub const U_LB_OPEN_PUNCTUATION = ULineBreak.OPEN_PUNCTUATION;
pub const U_LB_POSTFIX_NUMERIC = ULineBreak.POSTFIX_NUMERIC;
pub const U_LB_PREFIX_NUMERIC = ULineBreak.PREFIX_NUMERIC;
pub const U_LB_QUOTATION = ULineBreak.QUOTATION;
pub const U_LB_COMPLEX_CONTEXT = ULineBreak.COMPLEX_CONTEXT;
pub const U_LB_SURROGATE = ULineBreak.SURROGATE;
pub const U_LB_SPACE = ULineBreak.SPACE;
pub const U_LB_BREAK_SYMBOLS = ULineBreak.BREAK_SYMBOLS;
pub const U_LB_ZWSPACE = ULineBreak.ZWSPACE;
pub const U_LB_NEXT_LINE = ULineBreak.NEXT_LINE;
pub const U_LB_WORD_JOINER = ULineBreak.WORD_JOINER;
pub const U_LB_H2 = ULineBreak.H2;
pub const U_LB_H3 = ULineBreak.H3;
pub const U_LB_JL = ULineBreak.JL;
pub const U_LB_JT = ULineBreak.JT;
pub const U_LB_JV = ULineBreak.JV;
pub const U_LB_CLOSE_PARENTHESIS = ULineBreak.CLOSE_PARENTHESIS;
pub const U_LB_CONDITIONAL_JAPANESE_STARTER = ULineBreak.CONDITIONAL_JAPANESE_STARTER;
pub const U_LB_HEBREW_LETTER = ULineBreak.HEBREW_LETTER;
pub const U_LB_REGIONAL_INDICATOR = ULineBreak.REGIONAL_INDICATOR;
pub const U_LB_E_BASE = ULineBreak.E_BASE;
pub const U_LB_E_MODIFIER = ULineBreak.E_MODIFIER;
pub const U_LB_ZWJ = ULineBreak.ZWJ;

pub const UNumericType = enum(i32) {
    NONE = 0,
    DECIMAL = 1,
    DIGIT = 2,
    NUMERIC = 3,
};
pub const U_NT_NONE = UNumericType.NONE;
pub const U_NT_DECIMAL = UNumericType.DECIMAL;
pub const U_NT_DIGIT = UNumericType.DIGIT;
pub const U_NT_NUMERIC = UNumericType.NUMERIC;

pub const UHangulSyllableType = enum(i32) {
    NOT_APPLICABLE = 0,
    LEADING_JAMO = 1,
    VOWEL_JAMO = 2,
    TRAILING_JAMO = 3,
    LV_SYLLABLE = 4,
    LVT_SYLLABLE = 5,
};
pub const U_HST_NOT_APPLICABLE = UHangulSyllableType.NOT_APPLICABLE;
pub const U_HST_LEADING_JAMO = UHangulSyllableType.LEADING_JAMO;
pub const U_HST_VOWEL_JAMO = UHangulSyllableType.VOWEL_JAMO;
pub const U_HST_TRAILING_JAMO = UHangulSyllableType.TRAILING_JAMO;
pub const U_HST_LV_SYLLABLE = UHangulSyllableType.LV_SYLLABLE;
pub const U_HST_LVT_SYLLABLE = UHangulSyllableType.LVT_SYLLABLE;

pub const UIndicPositionalCategory = enum(i32) {
    NA = 0,
    BOTTOM = 1,
    BOTTOM_AND_LEFT = 2,
    BOTTOM_AND_RIGHT = 3,
    LEFT = 4,
    LEFT_AND_RIGHT = 5,
    OVERSTRUCK = 6,
    RIGHT = 7,
    TOP = 8,
    TOP_AND_BOTTOM = 9,
    TOP_AND_BOTTOM_AND_RIGHT = 10,
    TOP_AND_LEFT = 11,
    TOP_AND_LEFT_AND_RIGHT = 12,
    TOP_AND_RIGHT = 13,
    VISUAL_ORDER_LEFT = 14,
};
pub const U_INPC_NA = UIndicPositionalCategory.NA;
pub const U_INPC_BOTTOM = UIndicPositionalCategory.BOTTOM;
pub const U_INPC_BOTTOM_AND_LEFT = UIndicPositionalCategory.BOTTOM_AND_LEFT;
pub const U_INPC_BOTTOM_AND_RIGHT = UIndicPositionalCategory.BOTTOM_AND_RIGHT;
pub const U_INPC_LEFT = UIndicPositionalCategory.LEFT;
pub const U_INPC_LEFT_AND_RIGHT = UIndicPositionalCategory.LEFT_AND_RIGHT;
pub const U_INPC_OVERSTRUCK = UIndicPositionalCategory.OVERSTRUCK;
pub const U_INPC_RIGHT = UIndicPositionalCategory.RIGHT;
pub const U_INPC_TOP = UIndicPositionalCategory.TOP;
pub const U_INPC_TOP_AND_BOTTOM = UIndicPositionalCategory.TOP_AND_BOTTOM;
pub const U_INPC_TOP_AND_BOTTOM_AND_RIGHT = UIndicPositionalCategory.TOP_AND_BOTTOM_AND_RIGHT;
pub const U_INPC_TOP_AND_LEFT = UIndicPositionalCategory.TOP_AND_LEFT;
pub const U_INPC_TOP_AND_LEFT_AND_RIGHT = UIndicPositionalCategory.TOP_AND_LEFT_AND_RIGHT;
pub const U_INPC_TOP_AND_RIGHT = UIndicPositionalCategory.TOP_AND_RIGHT;
pub const U_INPC_VISUAL_ORDER_LEFT = UIndicPositionalCategory.VISUAL_ORDER_LEFT;

pub const UIndicSyllabicCategory = enum(i32) {
    OTHER = 0,
    AVAGRAHA = 1,
    BINDU = 2,
    BRAHMI_JOINING_NUMBER = 3,
    CANTILLATION_MARK = 4,
    CONSONANT = 5,
    CONSONANT_DEAD = 6,
    CONSONANT_FINAL = 7,
    CONSONANT_HEAD_LETTER = 8,
    CONSONANT_INITIAL_POSTFIXED = 9,
    CONSONANT_KILLER = 10,
    CONSONANT_MEDIAL = 11,
    CONSONANT_PLACEHOLDER = 12,
    CONSONANT_PRECEDING_REPHA = 13,
    CONSONANT_PREFIXED = 14,
    CONSONANT_SUBJOINED = 15,
    CONSONANT_SUCCEEDING_REPHA = 16,
    CONSONANT_WITH_STACKER = 17,
    GEMINATION_MARK = 18,
    INVISIBLE_STACKER = 19,
    JOINER = 20,
    MODIFYING_LETTER = 21,
    NON_JOINER = 22,
    NUKTA = 23,
    NUMBER = 24,
    NUMBER_JOINER = 25,
    PURE_KILLER = 26,
    REGISTER_SHIFTER = 27,
    SYLLABLE_MODIFIER = 28,
    TONE_LETTER = 29,
    TONE_MARK = 30,
    VIRAMA = 31,
    VISARGA = 32,
    VOWEL = 33,
    VOWEL_DEPENDENT = 34,
    VOWEL_INDEPENDENT = 35,
};
pub const U_INSC_OTHER = UIndicSyllabicCategory.OTHER;
pub const U_INSC_AVAGRAHA = UIndicSyllabicCategory.AVAGRAHA;
pub const U_INSC_BINDU = UIndicSyllabicCategory.BINDU;
pub const U_INSC_BRAHMI_JOINING_NUMBER = UIndicSyllabicCategory.BRAHMI_JOINING_NUMBER;
pub const U_INSC_CANTILLATION_MARK = UIndicSyllabicCategory.CANTILLATION_MARK;
pub const U_INSC_CONSONANT = UIndicSyllabicCategory.CONSONANT;
pub const U_INSC_CONSONANT_DEAD = UIndicSyllabicCategory.CONSONANT_DEAD;
pub const U_INSC_CONSONANT_FINAL = UIndicSyllabicCategory.CONSONANT_FINAL;
pub const U_INSC_CONSONANT_HEAD_LETTER = UIndicSyllabicCategory.CONSONANT_HEAD_LETTER;
pub const U_INSC_CONSONANT_INITIAL_POSTFIXED = UIndicSyllabicCategory.CONSONANT_INITIAL_POSTFIXED;
pub const U_INSC_CONSONANT_KILLER = UIndicSyllabicCategory.CONSONANT_KILLER;
pub const U_INSC_CONSONANT_MEDIAL = UIndicSyllabicCategory.CONSONANT_MEDIAL;
pub const U_INSC_CONSONANT_PLACEHOLDER = UIndicSyllabicCategory.CONSONANT_PLACEHOLDER;
pub const U_INSC_CONSONANT_PRECEDING_REPHA = UIndicSyllabicCategory.CONSONANT_PRECEDING_REPHA;
pub const U_INSC_CONSONANT_PREFIXED = UIndicSyllabicCategory.CONSONANT_PREFIXED;
pub const U_INSC_CONSONANT_SUBJOINED = UIndicSyllabicCategory.CONSONANT_SUBJOINED;
pub const U_INSC_CONSONANT_SUCCEEDING_REPHA = UIndicSyllabicCategory.CONSONANT_SUCCEEDING_REPHA;
pub const U_INSC_CONSONANT_WITH_STACKER = UIndicSyllabicCategory.CONSONANT_WITH_STACKER;
pub const U_INSC_GEMINATION_MARK = UIndicSyllabicCategory.GEMINATION_MARK;
pub const U_INSC_INVISIBLE_STACKER = UIndicSyllabicCategory.INVISIBLE_STACKER;
pub const U_INSC_JOINER = UIndicSyllabicCategory.JOINER;
pub const U_INSC_MODIFYING_LETTER = UIndicSyllabicCategory.MODIFYING_LETTER;
pub const U_INSC_NON_JOINER = UIndicSyllabicCategory.NON_JOINER;
pub const U_INSC_NUKTA = UIndicSyllabicCategory.NUKTA;
pub const U_INSC_NUMBER = UIndicSyllabicCategory.NUMBER;
pub const U_INSC_NUMBER_JOINER = UIndicSyllabicCategory.NUMBER_JOINER;
pub const U_INSC_PURE_KILLER = UIndicSyllabicCategory.PURE_KILLER;
pub const U_INSC_REGISTER_SHIFTER = UIndicSyllabicCategory.REGISTER_SHIFTER;
pub const U_INSC_SYLLABLE_MODIFIER = UIndicSyllabicCategory.SYLLABLE_MODIFIER;
pub const U_INSC_TONE_LETTER = UIndicSyllabicCategory.TONE_LETTER;
pub const U_INSC_TONE_MARK = UIndicSyllabicCategory.TONE_MARK;
pub const U_INSC_VIRAMA = UIndicSyllabicCategory.VIRAMA;
pub const U_INSC_VISARGA = UIndicSyllabicCategory.VISARGA;
pub const U_INSC_VOWEL = UIndicSyllabicCategory.VOWEL;
pub const U_INSC_VOWEL_DEPENDENT = UIndicSyllabicCategory.VOWEL_DEPENDENT;
pub const U_INSC_VOWEL_INDEPENDENT = UIndicSyllabicCategory.VOWEL_INDEPENDENT;

pub const UVerticalOrientation = enum(i32) {
    ROTATED = 0,
    TRANSFORMED_ROTATED = 1,
    TRANSFORMED_UPRIGHT = 2,
    UPRIGHT = 3,
};
pub const U_VO_ROTATED = UVerticalOrientation.ROTATED;
pub const U_VO_TRANSFORMED_ROTATED = UVerticalOrientation.TRANSFORMED_ROTATED;
pub const U_VO_TRANSFORMED_UPRIGHT = UVerticalOrientation.TRANSFORMED_UPRIGHT;
pub const U_VO_UPRIGHT = UVerticalOrientation.UPRIGHT;

pub const UCharEnumTypeRange = fn(
    context: ?*const c_void,
    start: i32,
    limit: i32,
    type: UCharCategory,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UEnumCharNamesFn = fn(
    context: ?*c_void,
    code: i32,
    nameChoice: UCharNameChoice,
    name: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UBiDiDirection = enum(i32) {
    LTR = 0,
    RTL = 1,
    MIXED = 2,
    NEUTRAL = 3,
};
pub const UBIDI_LTR = UBiDiDirection.LTR;
pub const UBIDI_RTL = UBiDiDirection.RTL;
pub const UBIDI_MIXED = UBiDiDirection.MIXED;
pub const UBIDI_NEUTRAL = UBiDiDirection.NEUTRAL;

pub const UBiDiReorderingMode = enum(i32) {
    DEFAULT = 0,
    NUMBERS_SPECIAL = 1,
    GROUP_NUMBERS_WITH_R = 2,
    RUNS_ONLY = 3,
    INVERSE_NUMBERS_AS_L = 4,
    INVERSE_LIKE_DIRECT = 5,
    INVERSE_FOR_NUMBERS_SPECIAL = 6,
};
pub const UBIDI_REORDER_DEFAULT = UBiDiReorderingMode.DEFAULT;
pub const UBIDI_REORDER_NUMBERS_SPECIAL = UBiDiReorderingMode.NUMBERS_SPECIAL;
pub const UBIDI_REORDER_GROUP_NUMBERS_WITH_R = UBiDiReorderingMode.GROUP_NUMBERS_WITH_R;
pub const UBIDI_REORDER_RUNS_ONLY = UBiDiReorderingMode.RUNS_ONLY;
pub const UBIDI_REORDER_INVERSE_NUMBERS_AS_L = UBiDiReorderingMode.INVERSE_NUMBERS_AS_L;
pub const UBIDI_REORDER_INVERSE_LIKE_DIRECT = UBiDiReorderingMode.INVERSE_LIKE_DIRECT;
pub const UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL = UBiDiReorderingMode.INVERSE_FOR_NUMBERS_SPECIAL;

pub const UBiDiReorderingOption = enum(i32) {
    DEFAULT = 0,
    INSERT_MARKS = 1,
    REMOVE_CONTROLS = 2,
    STREAMING = 4,
};
pub const UBIDI_OPTION_DEFAULT = UBiDiReorderingOption.DEFAULT;
pub const UBIDI_OPTION_INSERT_MARKS = UBiDiReorderingOption.INSERT_MARKS;
pub const UBIDI_OPTION_REMOVE_CONTROLS = UBiDiReorderingOption.REMOVE_CONTROLS;
pub const UBIDI_OPTION_STREAMING = UBiDiReorderingOption.STREAMING;

pub const UBiDiClassCallback = fn(
    context: ?*const c_void,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub const UBiDiOrder = enum(i32) {
    LOGICAL = 0,
    VISUAL = 1,
};
pub const UBIDI_LOGICAL = UBiDiOrder.LOGICAL;
pub const UBIDI_VISUAL = UBiDiOrder.VISUAL;

pub const UBiDiMirroring = enum(i32) {
    FF = 0,
    N = 1,
};
pub const UBIDI_MIRRORING_OFF = UBiDiMirroring.FF;
pub const UBIDI_MIRRORING_ON = UBiDiMirroring.N;

pub const UTextClone = fn(
    dest: ?*UText,
    src: ?*const UText,
    deep: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub const UTextNativeLength = fn(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub const UTextAccess = fn(
    ut: ?*UText,
    nativeIndex: i64,
    forward: i8,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UTextExtract = fn(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UTextReplace = fn(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    replacementText: ?*const u16,
    replacmentLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UTextCopy = fn(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    nativeDest: i64,
    move: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTextMapOffsetToNative = fn(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub const UTextMapNativeIndexToUTF16 = fn(
    ut: ?*const UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UTextClose = fn(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTextFuncs = extern struct {
    tableSize: i32,
    reserved1: i32,
    reserved2: i32,
    reserved3: i32,
    clone: ?UTextClone,
    nativeLength: ?UTextNativeLength,
    access: ?UTextAccess,
    extract: ?UTextExtract,
    replace: ?UTextReplace,
    copy: ?UTextCopy,
    mapOffsetToNative: ?UTextMapOffsetToNative,
    mapNativeIndexToUTF16: ?UTextMapNativeIndexToUTF16,
    close: ?UTextClose,
    spare1: ?UTextClose,
    spare2: ?UTextClose,
    spare3: ?UTextClose,
};

pub const UText = extern struct {
    magic: u32,
    flags: i32,
    providerProperties: i32,
    sizeOfStruct: i32,
    chunkNativeLimit: i64,
    extraSize: i32,
    nativeIndexingLimit: i32,
    chunkNativeStart: i64,
    chunkOffset: i32,
    chunkLength: i32,
    chunkContents: ?*const u16,
    pFuncs: ?*const UTextFuncs,
    pExtra: ?*c_void,
    context: ?*const c_void,
    p: ?*const c_void,
    q: ?*const c_void,
    r: ?*const c_void,
    privP: ?*c_void,
    a: i64,
    b: i32,
    c: i32,
    privA: i64,
    privB: i32,
    privC: i32,
};

pub const USetSpanCondition = enum(i32) {
    NOT_CONTAINED = 0,
    CONTAINED = 1,
    SIMPLE = 2,
};
pub const USET_SPAN_NOT_CONTAINED = USetSpanCondition.NOT_CONTAINED;
pub const USET_SPAN_CONTAINED = USetSpanCondition.CONTAINED;
pub const USET_SPAN_SIMPLE = USetSpanCondition.SIMPLE;

pub const USerializedSet = extern struct {
    array: ?*const u16,
    bmpLength: i32,
    length: i32,
    staticArray: [8]u16,
};

pub const UNormalization2Mode = enum(i32) {
    COMPOSE = 0,
    DECOMPOSE = 1,
    FCD = 2,
    COMPOSE_CONTIGUOUS = 3,
};
pub const UNORM2_COMPOSE = UNormalization2Mode.COMPOSE;
pub const UNORM2_DECOMPOSE = UNormalization2Mode.DECOMPOSE;
pub const UNORM2_FCD = UNormalization2Mode.FCD;
pub const UNORM2_COMPOSE_CONTIGUOUS = UNormalization2Mode.COMPOSE_CONTIGUOUS;

pub const UNormalizationCheckResult = enum(i32) {
    NO = 0,
    YES = 1,
    MAYBE = 2,
};
pub const UNORM_NO = UNormalizationCheckResult.NO;
pub const UNORM_YES = UNormalizationCheckResult.YES;
pub const UNORM_MAYBE = UNormalizationCheckResult.MAYBE;

pub const UNormalizationMode = enum(i32) {
    NONE = 1,
    NFD = 2,
    NFKD = 3,
    NFC = 4,
    // DEFAULT = 4, this enum value conflicts with NFC
    NFKC = 5,
    FCD = 6,
    MODE_COUNT = 7,
};
pub const UNORM_NONE = UNormalizationMode.NONE;
pub const UNORM_NFD = UNormalizationMode.NFD;
pub const UNORM_NFKD = UNormalizationMode.NFKD;
pub const UNORM_NFC = UNormalizationMode.NFC;
pub const UNORM_DEFAULT = UNormalizationMode.NFC;
pub const UNORM_NFKC = UNormalizationMode.NFKC;
pub const UNORM_FCD = UNormalizationMode.FCD;
pub const UNORM_MODE_COUNT = UNormalizationMode.MODE_COUNT;

pub const UNESCAPE_CHAR_AT = fn(
    offset: i32,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u16;

pub const UParseError = extern struct {
    line: i32,
    offset: i32,
    preContext: [16]u16,
    postContext: [16]u16,
};

pub const UStringPrepProfileType = enum(i32) {
    @"3491_NAMEPREP" = 0,
    @"3530_NFS4_CS_PREP" = 1,
    @"3530_NFS4_CS_PREP_CI" = 2,
    @"3530_NFS4_CIS_PREP" = 3,
    @"3530_NFS4_MIXED_PREP_PREFIX" = 4,
    @"3530_NFS4_MIXED_PREP_SUFFIX" = 5,
    @"3722_ISCSI" = 6,
    @"3920_NODEPREP" = 7,
    @"3920_RESOURCEPREP" = 8,
    @"4011_MIB" = 9,
    @"4013_SASLPREP" = 10,
    @"4505_TRACE" = 11,
    @"4518_LDAP" = 12,
    @"4518_LDAP_CI" = 13,
};
pub const USPREP_RFC3491_NAMEPREP = UStringPrepProfileType.@"3491_NAMEPREP";
pub const USPREP_RFC3530_NFS4_CS_PREP = UStringPrepProfileType.@"3530_NFS4_CS_PREP";
pub const USPREP_RFC3530_NFS4_CS_PREP_CI = UStringPrepProfileType.@"3530_NFS4_CS_PREP_CI";
pub const USPREP_RFC3530_NFS4_CIS_PREP = UStringPrepProfileType.@"3530_NFS4_CIS_PREP";
pub const USPREP_RFC3530_NFS4_MIXED_PREP_PREFIX = UStringPrepProfileType.@"3530_NFS4_MIXED_PREP_PREFIX";
pub const USPREP_RFC3530_NFS4_MIXED_PREP_SUFFIX = UStringPrepProfileType.@"3530_NFS4_MIXED_PREP_SUFFIX";
pub const USPREP_RFC3722_ISCSI = UStringPrepProfileType.@"3722_ISCSI";
pub const USPREP_RFC3920_NODEPREP = UStringPrepProfileType.@"3920_NODEPREP";
pub const USPREP_RFC3920_RESOURCEPREP = UStringPrepProfileType.@"3920_RESOURCEPREP";
pub const USPREP_RFC4011_MIB = UStringPrepProfileType.@"4011_MIB";
pub const USPREP_RFC4013_SASLPREP = UStringPrepProfileType.@"4013_SASLPREP";
pub const USPREP_RFC4505_TRACE = UStringPrepProfileType.@"4505_TRACE";
pub const USPREP_RFC4518_LDAP = UStringPrepProfileType.@"4518_LDAP";
pub const USPREP_RFC4518_LDAP_CI = UStringPrepProfileType.@"4518_LDAP_CI";

pub const UIDNAInfo = extern struct {
    size: i16,
    isTransitionalDifferent: i8,
    reservedB3: i8,
    errors: u32,
    reservedI2: i32,
    reservedI3: i32,
};

pub const UBreakIteratorType = enum(i32) {
    CHARACTER = 0,
    WORD = 1,
    LINE = 2,
    SENTENCE = 3,
};
pub const UBRK_CHARACTER = UBreakIteratorType.CHARACTER;
pub const UBRK_WORD = UBreakIteratorType.WORD;
pub const UBRK_LINE = UBreakIteratorType.LINE;
pub const UBRK_SENTENCE = UBreakIteratorType.SENTENCE;

pub const UWordBreak = enum(i32) {
    NONE = 0,
    NONE_LIMIT = 100,
    // NUMBER = 100, this enum value conflicts with NONE_LIMIT
    NUMBER_LIMIT = 200,
    // LETTER = 200, this enum value conflicts with NUMBER_LIMIT
    LETTER_LIMIT = 300,
    // KANA = 300, this enum value conflicts with LETTER_LIMIT
    KANA_LIMIT = 400,
    // IDEO = 400, this enum value conflicts with KANA_LIMIT
    IDEO_LIMIT = 500,
};
pub const UBRK_WORD_NONE = UWordBreak.NONE;
pub const UBRK_WORD_NONE_LIMIT = UWordBreak.NONE_LIMIT;
pub const UBRK_WORD_NUMBER = UWordBreak.NONE_LIMIT;
pub const UBRK_WORD_NUMBER_LIMIT = UWordBreak.NUMBER_LIMIT;
pub const UBRK_WORD_LETTER = UWordBreak.NUMBER_LIMIT;
pub const UBRK_WORD_LETTER_LIMIT = UWordBreak.LETTER_LIMIT;
pub const UBRK_WORD_KANA = UWordBreak.LETTER_LIMIT;
pub const UBRK_WORD_KANA_LIMIT = UWordBreak.KANA_LIMIT;
pub const UBRK_WORD_IDEO = UWordBreak.KANA_LIMIT;
pub const UBRK_WORD_IDEO_LIMIT = UWordBreak.IDEO_LIMIT;

pub const ULineBreakTag = enum(i32) {
    SOFT = 0,
    SOFT_LIMIT = 100,
    // HARD = 100, this enum value conflicts with SOFT_LIMIT
    HARD_LIMIT = 200,
};
pub const UBRK_LINE_SOFT = ULineBreakTag.SOFT;
pub const UBRK_LINE_SOFT_LIMIT = ULineBreakTag.SOFT_LIMIT;
pub const UBRK_LINE_HARD = ULineBreakTag.SOFT_LIMIT;
pub const UBRK_LINE_HARD_LIMIT = ULineBreakTag.HARD_LIMIT;

pub const USentenceBreakTag = enum(i32) {
    TERM = 0,
    TERM_LIMIT = 100,
    // SEP = 100, this enum value conflicts with TERM_LIMIT
    SEP_LIMIT = 200,
};
pub const UBRK_SENTENCE_TERM = USentenceBreakTag.TERM;
pub const UBRK_SENTENCE_TERM_LIMIT = USentenceBreakTag.TERM_LIMIT;
pub const UBRK_SENTENCE_SEP = USentenceBreakTag.TERM_LIMIT;
pub const UBRK_SENTENCE_SEP_LIMIT = USentenceBreakTag.SEP_LIMIT;

pub const UCalendarType = enum(i32) {
    TRADITIONAL = 0,
    // DEFAULT = 0, this enum value conflicts with TRADITIONAL
    GREGORIAN = 1,
};
pub const UCAL_TRADITIONAL = UCalendarType.TRADITIONAL;
pub const UCAL_DEFAULT = UCalendarType.TRADITIONAL;
pub const UCAL_GREGORIAN = UCalendarType.GREGORIAN;

pub const UCalendarDateFields = enum(i32) {
    ERA = 0,
    YEAR = 1,
    MONTH = 2,
    WEEK_OF_YEAR = 3,
    WEEK_OF_MONTH = 4,
    DATE = 5,
    DAY_OF_YEAR = 6,
    DAY_OF_WEEK = 7,
    DAY_OF_WEEK_IN_MONTH = 8,
    AM_PM = 9,
    HOUR = 10,
    HOUR_OF_DAY = 11,
    MINUTE = 12,
    SECOND = 13,
    MILLISECOND = 14,
    ZONE_OFFSET = 15,
    DST_OFFSET = 16,
    YEAR_WOY = 17,
    DOW_LOCAL = 18,
    EXTENDED_YEAR = 19,
    JULIAN_DAY = 20,
    MILLISECONDS_IN_DAY = 21,
    IS_LEAP_MONTH = 22,
    FIELD_COUNT = 23,
    // DAY_OF_MONTH = 5, this enum value conflicts with DATE
};
pub const UCAL_ERA = UCalendarDateFields.ERA;
pub const UCAL_YEAR = UCalendarDateFields.YEAR;
pub const UCAL_MONTH = UCalendarDateFields.MONTH;
pub const UCAL_WEEK_OF_YEAR = UCalendarDateFields.WEEK_OF_YEAR;
pub const UCAL_WEEK_OF_MONTH = UCalendarDateFields.WEEK_OF_MONTH;
pub const UCAL_DATE = UCalendarDateFields.DATE;
pub const UCAL_DAY_OF_YEAR = UCalendarDateFields.DAY_OF_YEAR;
pub const UCAL_DAY_OF_WEEK = UCalendarDateFields.DAY_OF_WEEK;
pub const UCAL_DAY_OF_WEEK_IN_MONTH = UCalendarDateFields.DAY_OF_WEEK_IN_MONTH;
pub const UCAL_AM_PM = UCalendarDateFields.AM_PM;
pub const UCAL_HOUR = UCalendarDateFields.HOUR;
pub const UCAL_HOUR_OF_DAY = UCalendarDateFields.HOUR_OF_DAY;
pub const UCAL_MINUTE = UCalendarDateFields.MINUTE;
pub const UCAL_SECOND = UCalendarDateFields.SECOND;
pub const UCAL_MILLISECOND = UCalendarDateFields.MILLISECOND;
pub const UCAL_ZONE_OFFSET = UCalendarDateFields.ZONE_OFFSET;
pub const UCAL_DST_OFFSET = UCalendarDateFields.DST_OFFSET;
pub const UCAL_YEAR_WOY = UCalendarDateFields.YEAR_WOY;
pub const UCAL_DOW_LOCAL = UCalendarDateFields.DOW_LOCAL;
pub const UCAL_EXTENDED_YEAR = UCalendarDateFields.EXTENDED_YEAR;
pub const UCAL_JULIAN_DAY = UCalendarDateFields.JULIAN_DAY;
pub const UCAL_MILLISECONDS_IN_DAY = UCalendarDateFields.MILLISECONDS_IN_DAY;
pub const UCAL_IS_LEAP_MONTH = UCalendarDateFields.IS_LEAP_MONTH;
pub const UCAL_FIELD_COUNT = UCalendarDateFields.FIELD_COUNT;
pub const UCAL_DAY_OF_MONTH = UCalendarDateFields.DATE;

pub const UCalendarDaysOfWeek = enum(i32) {
    SUNDAY = 1,
    MONDAY = 2,
    TUESDAY = 3,
    WEDNESDAY = 4,
    THURSDAY = 5,
    FRIDAY = 6,
    SATURDAY = 7,
};
pub const UCAL_SUNDAY = UCalendarDaysOfWeek.SUNDAY;
pub const UCAL_MONDAY = UCalendarDaysOfWeek.MONDAY;
pub const UCAL_TUESDAY = UCalendarDaysOfWeek.TUESDAY;
pub const UCAL_WEDNESDAY = UCalendarDaysOfWeek.WEDNESDAY;
pub const UCAL_THURSDAY = UCalendarDaysOfWeek.THURSDAY;
pub const UCAL_FRIDAY = UCalendarDaysOfWeek.FRIDAY;
pub const UCAL_SATURDAY = UCalendarDaysOfWeek.SATURDAY;

pub const UCalendarMonths = enum(i32) {
    JANUARY = 0,
    FEBRUARY = 1,
    MARCH = 2,
    APRIL = 3,
    MAY = 4,
    JUNE = 5,
    JULY = 6,
    AUGUST = 7,
    SEPTEMBER = 8,
    OCTOBER = 9,
    NOVEMBER = 10,
    DECEMBER = 11,
    UNDECIMBER = 12,
};
pub const UCAL_JANUARY = UCalendarMonths.JANUARY;
pub const UCAL_FEBRUARY = UCalendarMonths.FEBRUARY;
pub const UCAL_MARCH = UCalendarMonths.MARCH;
pub const UCAL_APRIL = UCalendarMonths.APRIL;
pub const UCAL_MAY = UCalendarMonths.MAY;
pub const UCAL_JUNE = UCalendarMonths.JUNE;
pub const UCAL_JULY = UCalendarMonths.JULY;
pub const UCAL_AUGUST = UCalendarMonths.AUGUST;
pub const UCAL_SEPTEMBER = UCalendarMonths.SEPTEMBER;
pub const UCAL_OCTOBER = UCalendarMonths.OCTOBER;
pub const UCAL_NOVEMBER = UCalendarMonths.NOVEMBER;
pub const UCAL_DECEMBER = UCalendarMonths.DECEMBER;
pub const UCAL_UNDECIMBER = UCalendarMonths.UNDECIMBER;

pub const UCalendarAMPMs = enum(i32) {
    AM = 0,
    PM = 1,
};
pub const UCAL_AM = UCalendarAMPMs.AM;
pub const UCAL_PM = UCalendarAMPMs.PM;

pub const USystemTimeZoneType = enum(i32) {
    ANY = 0,
    CANONICAL = 1,
    CANONICAL_LOCATION = 2,
};
pub const UCAL_ZONE_TYPE_ANY = USystemTimeZoneType.ANY;
pub const UCAL_ZONE_TYPE_CANONICAL = USystemTimeZoneType.CANONICAL;
pub const UCAL_ZONE_TYPE_CANONICAL_LOCATION = USystemTimeZoneType.CANONICAL_LOCATION;

pub const UCalendarDisplayNameType = enum(i32) {
    STANDARD = 0,
    SHORT_STANDARD = 1,
    DST = 2,
    SHORT_DST = 3,
};
pub const UCAL_STANDARD = UCalendarDisplayNameType.STANDARD;
pub const UCAL_SHORT_STANDARD = UCalendarDisplayNameType.SHORT_STANDARD;
pub const UCAL_DST = UCalendarDisplayNameType.DST;
pub const UCAL_SHORT_DST = UCalendarDisplayNameType.SHORT_DST;

pub const UCalendarAttribute = enum(i32) {
    LENIENT = 0,
    FIRST_DAY_OF_WEEK = 1,
    MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    REPEATED_WALL_TIME = 3,
    SKIPPED_WALL_TIME = 4,
};
pub const UCAL_LENIENT = UCalendarAttribute.LENIENT;
pub const UCAL_FIRST_DAY_OF_WEEK = UCalendarAttribute.FIRST_DAY_OF_WEEK;
pub const UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = UCalendarAttribute.MINIMAL_DAYS_IN_FIRST_WEEK;
pub const UCAL_REPEATED_WALL_TIME = UCalendarAttribute.REPEATED_WALL_TIME;
pub const UCAL_SKIPPED_WALL_TIME = UCalendarAttribute.SKIPPED_WALL_TIME;

pub const UCalendarWallTimeOption = enum(i32) {
    LAST = 0,
    FIRST = 1,
    NEXT_VALID = 2,
};
pub const UCAL_WALLTIME_LAST = UCalendarWallTimeOption.LAST;
pub const UCAL_WALLTIME_FIRST = UCalendarWallTimeOption.FIRST;
pub const UCAL_WALLTIME_NEXT_VALID = UCalendarWallTimeOption.NEXT_VALID;

pub const UCalendarLimitType = enum(i32) {
    MINIMUM = 0,
    MAXIMUM = 1,
    GREATEST_MINIMUM = 2,
    LEAST_MAXIMUM = 3,
    ACTUAL_MINIMUM = 4,
    ACTUAL_MAXIMUM = 5,
};
pub const UCAL_MINIMUM = UCalendarLimitType.MINIMUM;
pub const UCAL_MAXIMUM = UCalendarLimitType.MAXIMUM;
pub const UCAL_GREATEST_MINIMUM = UCalendarLimitType.GREATEST_MINIMUM;
pub const UCAL_LEAST_MAXIMUM = UCalendarLimitType.LEAST_MAXIMUM;
pub const UCAL_ACTUAL_MINIMUM = UCalendarLimitType.ACTUAL_MINIMUM;
pub const UCAL_ACTUAL_MAXIMUM = UCalendarLimitType.ACTUAL_MAXIMUM;

pub const UCalendarWeekdayType = enum(i32) {
    DAY = 0,
    END = 1,
    END_ONSET = 2,
    END_CEASE = 3,
};
pub const UCAL_WEEKDAY = UCalendarWeekdayType.DAY;
pub const UCAL_WEEKEND = UCalendarWeekdayType.END;
pub const UCAL_WEEKEND_ONSET = UCalendarWeekdayType.END_ONSET;
pub const UCAL_WEEKEND_CEASE = UCalendarWeekdayType.END_CEASE;

pub const UTimeZoneTransitionType = enum(i32) {
    NEXT = 0,
    NEXT_INCLUSIVE = 1,
    PREVIOUS = 2,
    PREVIOUS_INCLUSIVE = 3,
};
pub const UCAL_TZ_TRANSITION_NEXT = UTimeZoneTransitionType.NEXT;
pub const UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = UTimeZoneTransitionType.NEXT_INCLUSIVE;
pub const UCAL_TZ_TRANSITION_PREVIOUS = UTimeZoneTransitionType.PREVIOUS;
pub const UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = UTimeZoneTransitionType.PREVIOUS_INCLUSIVE;

pub const UCollationResult = enum(i32) {
    EQUAL = 0,
    GREATER = 1,
    LESS = -1,
};
pub const UCOL_EQUAL = UCollationResult.EQUAL;
pub const UCOL_GREATER = UCollationResult.GREATER;
pub const UCOL_LESS = UCollationResult.LESS;

pub const UColAttributeValue = enum(i32) {
    DEFAULT = -1,
    PRIMARY = 0,
    SECONDARY = 1,
    TERTIARY = 2,
    // DEFAULT_STRENGTH = 2, this enum value conflicts with TERTIARY
    CE_STRENGTH_LIMIT = 3,
    // QUATERNARY = 3, this enum value conflicts with CE_STRENGTH_LIMIT
    IDENTICAL = 15,
    STRENGTH_LIMIT = 16,
    // OFF = 16, this enum value conflicts with STRENGTH_LIMIT
    ON = 17,
    SHIFTED = 20,
    NON_IGNORABLE = 21,
    LOWER_FIRST = 24,
    UPPER_FIRST = 25,
};
pub const UCOL_DEFAULT = UColAttributeValue.DEFAULT;
pub const UCOL_PRIMARY = UColAttributeValue.PRIMARY;
pub const UCOL_SECONDARY = UColAttributeValue.SECONDARY;
pub const UCOL_TERTIARY = UColAttributeValue.TERTIARY;
pub const UCOL_DEFAULT_STRENGTH = UColAttributeValue.TERTIARY;
pub const UCOL_CE_STRENGTH_LIMIT = UColAttributeValue.CE_STRENGTH_LIMIT;
pub const UCOL_QUATERNARY = UColAttributeValue.CE_STRENGTH_LIMIT;
pub const UCOL_IDENTICAL = UColAttributeValue.IDENTICAL;
pub const UCOL_STRENGTH_LIMIT = UColAttributeValue.STRENGTH_LIMIT;
pub const UCOL_OFF = UColAttributeValue.STRENGTH_LIMIT;
pub const UCOL_ON = UColAttributeValue.ON;
pub const UCOL_SHIFTED = UColAttributeValue.SHIFTED;
pub const UCOL_NON_IGNORABLE = UColAttributeValue.NON_IGNORABLE;
pub const UCOL_LOWER_FIRST = UColAttributeValue.LOWER_FIRST;
pub const UCOL_UPPER_FIRST = UColAttributeValue.UPPER_FIRST;

pub const UColReorderCode = enum(i32) {
    DEFAULT = -1,
    NONE = 103,
    // OTHERS = 103, this enum value conflicts with NONE
    SPACE = 4096,
    // FIRST = 4096, this enum value conflicts with SPACE
    PUNCTUATION = 4097,
    SYMBOL = 4098,
    CURRENCY = 4099,
    DIGIT = 4100,
};
pub const UCOL_REORDER_CODE_DEFAULT = UColReorderCode.DEFAULT;
pub const UCOL_REORDER_CODE_NONE = UColReorderCode.NONE;
pub const UCOL_REORDER_CODE_OTHERS = UColReorderCode.NONE;
pub const UCOL_REORDER_CODE_SPACE = UColReorderCode.SPACE;
pub const UCOL_REORDER_CODE_FIRST = UColReorderCode.SPACE;
pub const UCOL_REORDER_CODE_PUNCTUATION = UColReorderCode.PUNCTUATION;
pub const UCOL_REORDER_CODE_SYMBOL = UColReorderCode.SYMBOL;
pub const UCOL_REORDER_CODE_CURRENCY = UColReorderCode.CURRENCY;
pub const UCOL_REORDER_CODE_DIGIT = UColReorderCode.DIGIT;

pub const UColAttribute = enum(i32) {
    FRENCH_COLLATION = 0,
    ALTERNATE_HANDLING = 1,
    CASE_FIRST = 2,
    CASE_LEVEL = 3,
    NORMALIZATION_MODE = 4,
    // DECOMPOSITION_MODE = 4, this enum value conflicts with NORMALIZATION_MODE
    STRENGTH = 5,
    NUMERIC_COLLATION = 7,
    ATTRIBUTE_COUNT = 8,
};
pub const UCOL_FRENCH_COLLATION = UColAttribute.FRENCH_COLLATION;
pub const UCOL_ALTERNATE_HANDLING = UColAttribute.ALTERNATE_HANDLING;
pub const UCOL_CASE_FIRST = UColAttribute.CASE_FIRST;
pub const UCOL_CASE_LEVEL = UColAttribute.CASE_LEVEL;
pub const UCOL_NORMALIZATION_MODE = UColAttribute.NORMALIZATION_MODE;
pub const UCOL_DECOMPOSITION_MODE = UColAttribute.NORMALIZATION_MODE;
pub const UCOL_STRENGTH = UColAttribute.STRENGTH;
pub const UCOL_NUMERIC_COLLATION = UColAttribute.NUMERIC_COLLATION;
pub const UCOL_ATTRIBUTE_COUNT = UColAttribute.ATTRIBUTE_COUNT;

pub const UColRuleOption = enum(i32) {
    TAILORING_ONLY = 0,
    FULL_RULES = 1,
};
pub const UCOL_TAILORING_ONLY = UColRuleOption.TAILORING_ONLY;
pub const UCOL_FULL_RULES = UColRuleOption.FULL_RULES;

pub const UColBoundMode = enum(i32) {
    LOWER = 0,
    UPPER = 1,
    UPPER_LONG = 2,
};
pub const UCOL_BOUND_LOWER = UColBoundMode.LOWER;
pub const UCOL_BOUND_UPPER = UColBoundMode.UPPER;
pub const UCOL_BOUND_UPPER_LONG = UColBoundMode.UPPER_LONG;

pub const UDateTimePatternField = enum(i32) {
    ERA_FIELD = 0,
    YEAR_FIELD = 1,
    QUARTER_FIELD = 2,
    MONTH_FIELD = 3,
    WEEK_OF_YEAR_FIELD = 4,
    WEEK_OF_MONTH_FIELD = 5,
    WEEKDAY_FIELD = 6,
    DAY_OF_YEAR_FIELD = 7,
    DAY_OF_WEEK_IN_MONTH_FIELD = 8,
    DAY_FIELD = 9,
    DAYPERIOD_FIELD = 10,
    HOUR_FIELD = 11,
    MINUTE_FIELD = 12,
    SECOND_FIELD = 13,
    FRACTIONAL_SECOND_FIELD = 14,
    ZONE_FIELD = 15,
    FIELD_COUNT = 16,
};
pub const UDATPG_ERA_FIELD = UDateTimePatternField.ERA_FIELD;
pub const UDATPG_YEAR_FIELD = UDateTimePatternField.YEAR_FIELD;
pub const UDATPG_QUARTER_FIELD = UDateTimePatternField.QUARTER_FIELD;
pub const UDATPG_MONTH_FIELD = UDateTimePatternField.MONTH_FIELD;
pub const UDATPG_WEEK_OF_YEAR_FIELD = UDateTimePatternField.WEEK_OF_YEAR_FIELD;
pub const UDATPG_WEEK_OF_MONTH_FIELD = UDateTimePatternField.WEEK_OF_MONTH_FIELD;
pub const UDATPG_WEEKDAY_FIELD = UDateTimePatternField.WEEKDAY_FIELD;
pub const UDATPG_DAY_OF_YEAR_FIELD = UDateTimePatternField.DAY_OF_YEAR_FIELD;
pub const UDATPG_DAY_OF_WEEK_IN_MONTH_FIELD = UDateTimePatternField.DAY_OF_WEEK_IN_MONTH_FIELD;
pub const UDATPG_DAY_FIELD = UDateTimePatternField.DAY_FIELD;
pub const UDATPG_DAYPERIOD_FIELD = UDateTimePatternField.DAYPERIOD_FIELD;
pub const UDATPG_HOUR_FIELD = UDateTimePatternField.HOUR_FIELD;
pub const UDATPG_MINUTE_FIELD = UDateTimePatternField.MINUTE_FIELD;
pub const UDATPG_SECOND_FIELD = UDateTimePatternField.SECOND_FIELD;
pub const UDATPG_FRACTIONAL_SECOND_FIELD = UDateTimePatternField.FRACTIONAL_SECOND_FIELD;
pub const UDATPG_ZONE_FIELD = UDateTimePatternField.ZONE_FIELD;
pub const UDATPG_FIELD_COUNT = UDateTimePatternField.FIELD_COUNT;

pub const UDateTimePGDisplayWidth = enum(i32) {
    WIDE = 0,
    ABBREVIATED = 1,
    NARROW = 2,
};
pub const UDATPG_WIDE = UDateTimePGDisplayWidth.WIDE;
pub const UDATPG_ABBREVIATED = UDateTimePGDisplayWidth.ABBREVIATED;
pub const UDATPG_NARROW = UDateTimePGDisplayWidth.NARROW;

pub const UDateTimePatternMatchOptions = enum(i32) {
    NO_OPTIONS = 0,
    HOUR_FIELD_LENGTH = 2048,
    ALL_FIELDS_LENGTH = 65535,
};
pub const UDATPG_MATCH_NO_OPTIONS = UDateTimePatternMatchOptions.NO_OPTIONS;
pub const UDATPG_MATCH_HOUR_FIELD_LENGTH = UDateTimePatternMatchOptions.HOUR_FIELD_LENGTH;
pub const UDATPG_MATCH_ALL_FIELDS_LENGTH = UDateTimePatternMatchOptions.ALL_FIELDS_LENGTH;

pub const UDateTimePatternConflict = enum(i32) {
    NO_CONFLICT = 0,
    BASE_CONFLICT = 1,
    CONFLICT = 2,
};
pub const UDATPG_NO_CONFLICT = UDateTimePatternConflict.NO_CONFLICT;
pub const UDATPG_BASE_CONFLICT = UDateTimePatternConflict.BASE_CONFLICT;
pub const UDATPG_CONFLICT = UDateTimePatternConflict.CONFLICT;

pub const UFormattableType = enum(i32) {
    DATE = 0,
    DOUBLE = 1,
    LONG = 2,
    STRING = 3,
    ARRAY = 4,
    INT64 = 5,
    OBJECT = 6,
};
pub const UFMT_DATE = UFormattableType.DATE;
pub const UFMT_DOUBLE = UFormattableType.DOUBLE;
pub const UFMT_LONG = UFormattableType.LONG;
pub const UFMT_STRING = UFormattableType.STRING;
pub const UFMT_ARRAY = UFormattableType.ARRAY;
pub const UFMT_INT64 = UFormattableType.INT64;
pub const UFMT_OBJECT = UFormattableType.OBJECT;

pub const UGender = enum(i32) {
    MALE = 0,
    FEMALE = 1,
    OTHER = 2,
};
pub const UGENDER_MALE = UGender.MALE;
pub const UGENDER_FEMALE = UGender.FEMALE;
pub const UGENDER_OTHER = UGender.OTHER;

pub const ULocaleDataExemplarSetType = enum(i32) {
    STANDARD = 0,
    AUXILIARY = 1,
    INDEX = 2,
    PUNCTUATION = 3,
};
pub const ULOCDATA_ES_STANDARD = ULocaleDataExemplarSetType.STANDARD;
pub const ULOCDATA_ES_AUXILIARY = ULocaleDataExemplarSetType.AUXILIARY;
pub const ULOCDATA_ES_INDEX = ULocaleDataExemplarSetType.INDEX;
pub const ULOCDATA_ES_PUNCTUATION = ULocaleDataExemplarSetType.PUNCTUATION;

pub const ULocaleDataDelimiterType = enum(i32) {
    QUOTATION_START = 0,
    QUOTATION_END = 1,
    ALT_QUOTATION_START = 2,
    ALT_QUOTATION_END = 3,
};
pub const ULOCDATA_QUOTATION_START = ULocaleDataDelimiterType.QUOTATION_START;
pub const ULOCDATA_QUOTATION_END = ULocaleDataDelimiterType.QUOTATION_END;
pub const ULOCDATA_ALT_QUOTATION_START = ULocaleDataDelimiterType.ALT_QUOTATION_START;
pub const ULOCDATA_ALT_QUOTATION_END = ULocaleDataDelimiterType.ALT_QUOTATION_END;

pub const UMeasurementSystem = enum(i32) {
    SI = 0,
    US = 1,
    UK = 2,
};
pub const UMS_SI = UMeasurementSystem.SI;
pub const UMS_US = UMeasurementSystem.US;
pub const UMS_UK = UMeasurementSystem.UK;

pub const UNumberFormatStyle = enum(i32) {
    PATTERN_DECIMAL = 0,
    DECIMAL = 1,
    CURRENCY = 2,
    PERCENT = 3,
    SCIENTIFIC = 4,
    SPELLOUT = 5,
    ORDINAL = 6,
    DURATION = 7,
    NUMBERING_SYSTEM = 8,
    PATTERN_RULEBASED = 9,
    CURRENCY_ISO = 10,
    CURRENCY_PLURAL = 11,
    CURRENCY_ACCOUNTING = 12,
    CASH_CURRENCY = 13,
    DECIMAL_COMPACT_SHORT = 14,
    DECIMAL_COMPACT_LONG = 15,
    CURRENCY_STANDARD = 16,
    // DEFAULT = 1, this enum value conflicts with DECIMAL
    // IGNORE = 0, this enum value conflicts with PATTERN_DECIMAL
};
pub const UNUM_PATTERN_DECIMAL = UNumberFormatStyle.PATTERN_DECIMAL;
pub const UNUM_DECIMAL = UNumberFormatStyle.DECIMAL;
pub const UNUM_CURRENCY = UNumberFormatStyle.CURRENCY;
pub const UNUM_PERCENT = UNumberFormatStyle.PERCENT;
pub const UNUM_SCIENTIFIC = UNumberFormatStyle.SCIENTIFIC;
pub const UNUM_SPELLOUT = UNumberFormatStyle.SPELLOUT;
pub const UNUM_ORDINAL = UNumberFormatStyle.ORDINAL;
pub const UNUM_DURATION = UNumberFormatStyle.DURATION;
pub const UNUM_NUMBERING_SYSTEM = UNumberFormatStyle.NUMBERING_SYSTEM;
pub const UNUM_PATTERN_RULEBASED = UNumberFormatStyle.PATTERN_RULEBASED;
pub const UNUM_CURRENCY_ISO = UNumberFormatStyle.CURRENCY_ISO;
pub const UNUM_CURRENCY_PLURAL = UNumberFormatStyle.CURRENCY_PLURAL;
pub const UNUM_CURRENCY_ACCOUNTING = UNumberFormatStyle.CURRENCY_ACCOUNTING;
pub const UNUM_CASH_CURRENCY = UNumberFormatStyle.CASH_CURRENCY;
pub const UNUM_DECIMAL_COMPACT_SHORT = UNumberFormatStyle.DECIMAL_COMPACT_SHORT;
pub const UNUM_DECIMAL_COMPACT_LONG = UNumberFormatStyle.DECIMAL_COMPACT_LONG;
pub const UNUM_CURRENCY_STANDARD = UNumberFormatStyle.CURRENCY_STANDARD;
pub const UNUM_DEFAULT = UNumberFormatStyle.DECIMAL;
pub const UNUM_IGNORE = UNumberFormatStyle.PATTERN_DECIMAL;

pub const UNumberFormatRoundingMode = enum(i32) {
    CEILING = 0,
    FLOOR = 1,
    DOWN = 2,
    UP = 3,
    HALFEVEN = 4,
    HALFDOWN = 5,
    HALFUP = 6,
    UNNECESSARY = 7,
};
pub const UNUM_ROUND_CEILING = UNumberFormatRoundingMode.CEILING;
pub const UNUM_ROUND_FLOOR = UNumberFormatRoundingMode.FLOOR;
pub const UNUM_ROUND_DOWN = UNumberFormatRoundingMode.DOWN;
pub const UNUM_ROUND_UP = UNumberFormatRoundingMode.UP;
pub const UNUM_ROUND_HALFEVEN = UNumberFormatRoundingMode.HALFEVEN;
pub const UNUM_ROUND_HALFDOWN = UNumberFormatRoundingMode.HALFDOWN;
pub const UNUM_ROUND_HALFUP = UNumberFormatRoundingMode.HALFUP;
pub const UNUM_ROUND_UNNECESSARY = UNumberFormatRoundingMode.UNNECESSARY;

pub const UNumberFormatPadPosition = enum(i32) {
    BEFORE_PREFIX = 0,
    AFTER_PREFIX = 1,
    BEFORE_SUFFIX = 2,
    AFTER_SUFFIX = 3,
};
pub const UNUM_PAD_BEFORE_PREFIX = UNumberFormatPadPosition.BEFORE_PREFIX;
pub const UNUM_PAD_AFTER_PREFIX = UNumberFormatPadPosition.AFTER_PREFIX;
pub const UNUM_PAD_BEFORE_SUFFIX = UNumberFormatPadPosition.BEFORE_SUFFIX;
pub const UNUM_PAD_AFTER_SUFFIX = UNumberFormatPadPosition.AFTER_SUFFIX;

pub const UNumberCompactStyle = enum(i32) {
    SHORT = 0,
    LONG = 1,
};
pub const UNUM_SHORT = UNumberCompactStyle.SHORT;
pub const UNUM_LONG = UNumberCompactStyle.LONG;

pub const UCurrencySpacing = enum(i32) {
    MATCH = 0,
    SURROUNDING_MATCH = 1,
    INSERT = 2,
    SPACING_COUNT = 3,
};
pub const UNUM_CURRENCY_MATCH = UCurrencySpacing.MATCH;
pub const UNUM_CURRENCY_SURROUNDING_MATCH = UCurrencySpacing.SURROUNDING_MATCH;
pub const UNUM_CURRENCY_INSERT = UCurrencySpacing.INSERT;
pub const UNUM_CURRENCY_SPACING_COUNT = UCurrencySpacing.SPACING_COUNT;

pub const UNumberFormatFields = enum(i32) {
    INTEGER_FIELD = 0,
    FRACTION_FIELD = 1,
    DECIMAL_SEPARATOR_FIELD = 2,
    EXPONENT_SYMBOL_FIELD = 3,
    EXPONENT_SIGN_FIELD = 4,
    EXPONENT_FIELD = 5,
    GROUPING_SEPARATOR_FIELD = 6,
    CURRENCY_FIELD = 7,
    PERCENT_FIELD = 8,
    PERMILL_FIELD = 9,
    SIGN_FIELD = 10,
};
pub const UNUM_INTEGER_FIELD = UNumberFormatFields.INTEGER_FIELD;
pub const UNUM_FRACTION_FIELD = UNumberFormatFields.FRACTION_FIELD;
pub const UNUM_DECIMAL_SEPARATOR_FIELD = UNumberFormatFields.DECIMAL_SEPARATOR_FIELD;
pub const UNUM_EXPONENT_SYMBOL_FIELD = UNumberFormatFields.EXPONENT_SYMBOL_FIELD;
pub const UNUM_EXPONENT_SIGN_FIELD = UNumberFormatFields.EXPONENT_SIGN_FIELD;
pub const UNUM_EXPONENT_FIELD = UNumberFormatFields.EXPONENT_FIELD;
pub const UNUM_GROUPING_SEPARATOR_FIELD = UNumberFormatFields.GROUPING_SEPARATOR_FIELD;
pub const UNUM_CURRENCY_FIELD = UNumberFormatFields.CURRENCY_FIELD;
pub const UNUM_PERCENT_FIELD = UNumberFormatFields.PERCENT_FIELD;
pub const UNUM_PERMILL_FIELD = UNumberFormatFields.PERMILL_FIELD;
pub const UNUM_SIGN_FIELD = UNumberFormatFields.SIGN_FIELD;

pub const UNumberFormatAttributeValue = enum(i32) {
    N = 0,
};
pub const UNUM_FORMAT_ATTRIBUTE_VALUE_HIDDEN = UNumberFormatAttributeValue.N;

pub const UNumberFormatAttribute = enum(i32) {
    PARSE_INT_ONLY = 0,
    GROUPING_USED = 1,
    DECIMAL_ALWAYS_SHOWN = 2,
    MAX_INTEGER_DIGITS = 3,
    MIN_INTEGER_DIGITS = 4,
    INTEGER_DIGITS = 5,
    MAX_FRACTION_DIGITS = 6,
    MIN_FRACTION_DIGITS = 7,
    FRACTION_DIGITS = 8,
    MULTIPLIER = 9,
    GROUPING_SIZE = 10,
    ROUNDING_MODE = 11,
    ROUNDING_INCREMENT = 12,
    FORMAT_WIDTH = 13,
    PADDING_POSITION = 14,
    SECONDARY_GROUPING_SIZE = 15,
    SIGNIFICANT_DIGITS_USED = 16,
    MIN_SIGNIFICANT_DIGITS = 17,
    MAX_SIGNIFICANT_DIGITS = 18,
    LENIENT_PARSE = 19,
    PARSE_ALL_INPUT = 20,
    SCALE = 21,
    CURRENCY_USAGE = 23,
    FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = 4096,
    PARSE_NO_EXPONENT = 4097,
    PARSE_DECIMAL_MARK_REQUIRED = 4098,
};
pub const UNUM_PARSE_INT_ONLY = UNumberFormatAttribute.PARSE_INT_ONLY;
pub const UNUM_GROUPING_USED = UNumberFormatAttribute.GROUPING_USED;
pub const UNUM_DECIMAL_ALWAYS_SHOWN = UNumberFormatAttribute.DECIMAL_ALWAYS_SHOWN;
pub const UNUM_MAX_INTEGER_DIGITS = UNumberFormatAttribute.MAX_INTEGER_DIGITS;
pub const UNUM_MIN_INTEGER_DIGITS = UNumberFormatAttribute.MIN_INTEGER_DIGITS;
pub const UNUM_INTEGER_DIGITS = UNumberFormatAttribute.INTEGER_DIGITS;
pub const UNUM_MAX_FRACTION_DIGITS = UNumberFormatAttribute.MAX_FRACTION_DIGITS;
pub const UNUM_MIN_FRACTION_DIGITS = UNumberFormatAttribute.MIN_FRACTION_DIGITS;
pub const UNUM_FRACTION_DIGITS = UNumberFormatAttribute.FRACTION_DIGITS;
pub const UNUM_MULTIPLIER = UNumberFormatAttribute.MULTIPLIER;
pub const UNUM_GROUPING_SIZE = UNumberFormatAttribute.GROUPING_SIZE;
pub const UNUM_ROUNDING_MODE = UNumberFormatAttribute.ROUNDING_MODE;
pub const UNUM_ROUNDING_INCREMENT = UNumberFormatAttribute.ROUNDING_INCREMENT;
pub const UNUM_FORMAT_WIDTH = UNumberFormatAttribute.FORMAT_WIDTH;
pub const UNUM_PADDING_POSITION = UNumberFormatAttribute.PADDING_POSITION;
pub const UNUM_SECONDARY_GROUPING_SIZE = UNumberFormatAttribute.SECONDARY_GROUPING_SIZE;
pub const UNUM_SIGNIFICANT_DIGITS_USED = UNumberFormatAttribute.SIGNIFICANT_DIGITS_USED;
pub const UNUM_MIN_SIGNIFICANT_DIGITS = UNumberFormatAttribute.MIN_SIGNIFICANT_DIGITS;
pub const UNUM_MAX_SIGNIFICANT_DIGITS = UNumberFormatAttribute.MAX_SIGNIFICANT_DIGITS;
pub const UNUM_LENIENT_PARSE = UNumberFormatAttribute.LENIENT_PARSE;
pub const UNUM_PARSE_ALL_INPUT = UNumberFormatAttribute.PARSE_ALL_INPUT;
pub const UNUM_SCALE = UNumberFormatAttribute.SCALE;
pub const UNUM_CURRENCY_USAGE = UNumberFormatAttribute.CURRENCY_USAGE;
pub const UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = UNumberFormatAttribute.FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS;
pub const UNUM_PARSE_NO_EXPONENT = UNumberFormatAttribute.PARSE_NO_EXPONENT;
pub const UNUM_PARSE_DECIMAL_MARK_REQUIRED = UNumberFormatAttribute.PARSE_DECIMAL_MARK_REQUIRED;

pub const UNumberFormatTextAttribute = enum(i32) {
    POSITIVE_PREFIX = 0,
    POSITIVE_SUFFIX = 1,
    NEGATIVE_PREFIX = 2,
    NEGATIVE_SUFFIX = 3,
    PADDING_CHARACTER = 4,
    CURRENCY_CODE = 5,
    DEFAULT_RULESET = 6,
    PUBLIC_RULESETS = 7,
};
pub const UNUM_POSITIVE_PREFIX = UNumberFormatTextAttribute.POSITIVE_PREFIX;
pub const UNUM_POSITIVE_SUFFIX = UNumberFormatTextAttribute.POSITIVE_SUFFIX;
pub const UNUM_NEGATIVE_PREFIX = UNumberFormatTextAttribute.NEGATIVE_PREFIX;
pub const UNUM_NEGATIVE_SUFFIX = UNumberFormatTextAttribute.NEGATIVE_SUFFIX;
pub const UNUM_PADDING_CHARACTER = UNumberFormatTextAttribute.PADDING_CHARACTER;
pub const UNUM_CURRENCY_CODE = UNumberFormatTextAttribute.CURRENCY_CODE;
pub const UNUM_DEFAULT_RULESET = UNumberFormatTextAttribute.DEFAULT_RULESET;
pub const UNUM_PUBLIC_RULESETS = UNumberFormatTextAttribute.PUBLIC_RULESETS;

pub const UNumberFormatSymbol = enum(i32) {
    DECIMAL_SEPARATOR_SYMBOL = 0,
    GROUPING_SEPARATOR_SYMBOL = 1,
    PATTERN_SEPARATOR_SYMBOL = 2,
    PERCENT_SYMBOL = 3,
    ZERO_DIGIT_SYMBOL = 4,
    DIGIT_SYMBOL = 5,
    MINUS_SIGN_SYMBOL = 6,
    PLUS_SIGN_SYMBOL = 7,
    CURRENCY_SYMBOL = 8,
    INTL_CURRENCY_SYMBOL = 9,
    MONETARY_SEPARATOR_SYMBOL = 10,
    EXPONENTIAL_SYMBOL = 11,
    PERMILL_SYMBOL = 12,
    PAD_ESCAPE_SYMBOL = 13,
    INFINITY_SYMBOL = 14,
    NAN_SYMBOL = 15,
    SIGNIFICANT_DIGIT_SYMBOL = 16,
    MONETARY_GROUPING_SEPARATOR_SYMBOL = 17,
    ONE_DIGIT_SYMBOL = 18,
    TWO_DIGIT_SYMBOL = 19,
    THREE_DIGIT_SYMBOL = 20,
    FOUR_DIGIT_SYMBOL = 21,
    FIVE_DIGIT_SYMBOL = 22,
    SIX_DIGIT_SYMBOL = 23,
    SEVEN_DIGIT_SYMBOL = 24,
    EIGHT_DIGIT_SYMBOL = 25,
    NINE_DIGIT_SYMBOL = 26,
    EXPONENT_MULTIPLICATION_SYMBOL = 27,
};
pub const UNUM_DECIMAL_SEPARATOR_SYMBOL = UNumberFormatSymbol.DECIMAL_SEPARATOR_SYMBOL;
pub const UNUM_GROUPING_SEPARATOR_SYMBOL = UNumberFormatSymbol.GROUPING_SEPARATOR_SYMBOL;
pub const UNUM_PATTERN_SEPARATOR_SYMBOL = UNumberFormatSymbol.PATTERN_SEPARATOR_SYMBOL;
pub const UNUM_PERCENT_SYMBOL = UNumberFormatSymbol.PERCENT_SYMBOL;
pub const UNUM_ZERO_DIGIT_SYMBOL = UNumberFormatSymbol.ZERO_DIGIT_SYMBOL;
pub const UNUM_DIGIT_SYMBOL = UNumberFormatSymbol.DIGIT_SYMBOL;
pub const UNUM_MINUS_SIGN_SYMBOL = UNumberFormatSymbol.MINUS_SIGN_SYMBOL;
pub const UNUM_PLUS_SIGN_SYMBOL = UNumberFormatSymbol.PLUS_SIGN_SYMBOL;
pub const UNUM_CURRENCY_SYMBOL = UNumberFormatSymbol.CURRENCY_SYMBOL;
pub const UNUM_INTL_CURRENCY_SYMBOL = UNumberFormatSymbol.INTL_CURRENCY_SYMBOL;
pub const UNUM_MONETARY_SEPARATOR_SYMBOL = UNumberFormatSymbol.MONETARY_SEPARATOR_SYMBOL;
pub const UNUM_EXPONENTIAL_SYMBOL = UNumberFormatSymbol.EXPONENTIAL_SYMBOL;
pub const UNUM_PERMILL_SYMBOL = UNumberFormatSymbol.PERMILL_SYMBOL;
pub const UNUM_PAD_ESCAPE_SYMBOL = UNumberFormatSymbol.PAD_ESCAPE_SYMBOL;
pub const UNUM_INFINITY_SYMBOL = UNumberFormatSymbol.INFINITY_SYMBOL;
pub const UNUM_NAN_SYMBOL = UNumberFormatSymbol.NAN_SYMBOL;
pub const UNUM_SIGNIFICANT_DIGIT_SYMBOL = UNumberFormatSymbol.SIGNIFICANT_DIGIT_SYMBOL;
pub const UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL = UNumberFormatSymbol.MONETARY_GROUPING_SEPARATOR_SYMBOL;
pub const UNUM_ONE_DIGIT_SYMBOL = UNumberFormatSymbol.ONE_DIGIT_SYMBOL;
pub const UNUM_TWO_DIGIT_SYMBOL = UNumberFormatSymbol.TWO_DIGIT_SYMBOL;
pub const UNUM_THREE_DIGIT_SYMBOL = UNumberFormatSymbol.THREE_DIGIT_SYMBOL;
pub const UNUM_FOUR_DIGIT_SYMBOL = UNumberFormatSymbol.FOUR_DIGIT_SYMBOL;
pub const UNUM_FIVE_DIGIT_SYMBOL = UNumberFormatSymbol.FIVE_DIGIT_SYMBOL;
pub const UNUM_SIX_DIGIT_SYMBOL = UNumberFormatSymbol.SIX_DIGIT_SYMBOL;
pub const UNUM_SEVEN_DIGIT_SYMBOL = UNumberFormatSymbol.SEVEN_DIGIT_SYMBOL;
pub const UNUM_EIGHT_DIGIT_SYMBOL = UNumberFormatSymbol.EIGHT_DIGIT_SYMBOL;
pub const UNUM_NINE_DIGIT_SYMBOL = UNumberFormatSymbol.NINE_DIGIT_SYMBOL;
pub const UNUM_EXPONENT_MULTIPLICATION_SYMBOL = UNumberFormatSymbol.EXPONENT_MULTIPLICATION_SYMBOL;

pub const UDateFormatStyle = enum(i32) {
    FULL = 0,
    LONG = 1,
    MEDIUM = 2,
    SHORT = 3,
    // DEFAULT = 2, this enum value conflicts with MEDIUM
    RELATIVE = 128,
    // FULL_RELATIVE = 128, this enum value conflicts with RELATIVE
    LONG_RELATIVE = 129,
    MEDIUM_RELATIVE = 130,
    SHORT_RELATIVE = 131,
    NONE = -1,
    PATTERN = -2,
};
pub const UDAT_FULL = UDateFormatStyle.FULL;
pub const UDAT_LONG = UDateFormatStyle.LONG;
pub const UDAT_MEDIUM = UDateFormatStyle.MEDIUM;
pub const UDAT_SHORT = UDateFormatStyle.SHORT;
pub const UDAT_DEFAULT = UDateFormatStyle.MEDIUM;
pub const UDAT_RELATIVE = UDateFormatStyle.RELATIVE;
pub const UDAT_FULL_RELATIVE = UDateFormatStyle.RELATIVE;
pub const UDAT_LONG_RELATIVE = UDateFormatStyle.LONG_RELATIVE;
pub const UDAT_MEDIUM_RELATIVE = UDateFormatStyle.MEDIUM_RELATIVE;
pub const UDAT_SHORT_RELATIVE = UDateFormatStyle.SHORT_RELATIVE;
pub const UDAT_NONE = UDateFormatStyle.NONE;
pub const UDAT_PATTERN = UDateFormatStyle.PATTERN;

pub const UDateFormatField = enum(i32) {
    ERA_FIELD = 0,
    YEAR_FIELD = 1,
    MONTH_FIELD = 2,
    DATE_FIELD = 3,
    HOUR_OF_DAY1_FIELD = 4,
    HOUR_OF_DAY0_FIELD = 5,
    MINUTE_FIELD = 6,
    SECOND_FIELD = 7,
    FRACTIONAL_SECOND_FIELD = 8,
    DAY_OF_WEEK_FIELD = 9,
    DAY_OF_YEAR_FIELD = 10,
    DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    WEEK_OF_YEAR_FIELD = 12,
    WEEK_OF_MONTH_FIELD = 13,
    AM_PM_FIELD = 14,
    HOUR1_FIELD = 15,
    HOUR0_FIELD = 16,
    TIMEZONE_FIELD = 17,
    YEAR_WOY_FIELD = 18,
    DOW_LOCAL_FIELD = 19,
    EXTENDED_YEAR_FIELD = 20,
    JULIAN_DAY_FIELD = 21,
    MILLISECONDS_IN_DAY_FIELD = 22,
    TIMEZONE_RFC_FIELD = 23,
    TIMEZONE_GENERIC_FIELD = 24,
    STANDALONE_DAY_FIELD = 25,
    STANDALONE_MONTH_FIELD = 26,
    QUARTER_FIELD = 27,
    STANDALONE_QUARTER_FIELD = 28,
    TIMEZONE_SPECIAL_FIELD = 29,
    YEAR_NAME_FIELD = 30,
    TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    TIMEZONE_ISO_FIELD = 32,
    TIMEZONE_ISO_LOCAL_FIELD = 33,
    AM_PM_MIDNIGHT_NOON_FIELD = 35,
    FLEXIBLE_DAY_PERIOD_FIELD = 36,
};
pub const UDAT_ERA_FIELD = UDateFormatField.ERA_FIELD;
pub const UDAT_YEAR_FIELD = UDateFormatField.YEAR_FIELD;
pub const UDAT_MONTH_FIELD = UDateFormatField.MONTH_FIELD;
pub const UDAT_DATE_FIELD = UDateFormatField.DATE_FIELD;
pub const UDAT_HOUR_OF_DAY1_FIELD = UDateFormatField.HOUR_OF_DAY1_FIELD;
pub const UDAT_HOUR_OF_DAY0_FIELD = UDateFormatField.HOUR_OF_DAY0_FIELD;
pub const UDAT_MINUTE_FIELD = UDateFormatField.MINUTE_FIELD;
pub const UDAT_SECOND_FIELD = UDateFormatField.SECOND_FIELD;
pub const UDAT_FRACTIONAL_SECOND_FIELD = UDateFormatField.FRACTIONAL_SECOND_FIELD;
pub const UDAT_DAY_OF_WEEK_FIELD = UDateFormatField.DAY_OF_WEEK_FIELD;
pub const UDAT_DAY_OF_YEAR_FIELD = UDateFormatField.DAY_OF_YEAR_FIELD;
pub const UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = UDateFormatField.DAY_OF_WEEK_IN_MONTH_FIELD;
pub const UDAT_WEEK_OF_YEAR_FIELD = UDateFormatField.WEEK_OF_YEAR_FIELD;
pub const UDAT_WEEK_OF_MONTH_FIELD = UDateFormatField.WEEK_OF_MONTH_FIELD;
pub const UDAT_AM_PM_FIELD = UDateFormatField.AM_PM_FIELD;
pub const UDAT_HOUR1_FIELD = UDateFormatField.HOUR1_FIELD;
pub const UDAT_HOUR0_FIELD = UDateFormatField.HOUR0_FIELD;
pub const UDAT_TIMEZONE_FIELD = UDateFormatField.TIMEZONE_FIELD;
pub const UDAT_YEAR_WOY_FIELD = UDateFormatField.YEAR_WOY_FIELD;
pub const UDAT_DOW_LOCAL_FIELD = UDateFormatField.DOW_LOCAL_FIELD;
pub const UDAT_EXTENDED_YEAR_FIELD = UDateFormatField.EXTENDED_YEAR_FIELD;
pub const UDAT_JULIAN_DAY_FIELD = UDateFormatField.JULIAN_DAY_FIELD;
pub const UDAT_MILLISECONDS_IN_DAY_FIELD = UDateFormatField.MILLISECONDS_IN_DAY_FIELD;
pub const UDAT_TIMEZONE_RFC_FIELD = UDateFormatField.TIMEZONE_RFC_FIELD;
pub const UDAT_TIMEZONE_GENERIC_FIELD = UDateFormatField.TIMEZONE_GENERIC_FIELD;
pub const UDAT_STANDALONE_DAY_FIELD = UDateFormatField.STANDALONE_DAY_FIELD;
pub const UDAT_STANDALONE_MONTH_FIELD = UDateFormatField.STANDALONE_MONTH_FIELD;
pub const UDAT_QUARTER_FIELD = UDateFormatField.QUARTER_FIELD;
pub const UDAT_STANDALONE_QUARTER_FIELD = UDateFormatField.STANDALONE_QUARTER_FIELD;
pub const UDAT_TIMEZONE_SPECIAL_FIELD = UDateFormatField.TIMEZONE_SPECIAL_FIELD;
pub const UDAT_YEAR_NAME_FIELD = UDateFormatField.YEAR_NAME_FIELD;
pub const UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = UDateFormatField.TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD;
pub const UDAT_TIMEZONE_ISO_FIELD = UDateFormatField.TIMEZONE_ISO_FIELD;
pub const UDAT_TIMEZONE_ISO_LOCAL_FIELD = UDateFormatField.TIMEZONE_ISO_LOCAL_FIELD;
pub const UDAT_AM_PM_MIDNIGHT_NOON_FIELD = UDateFormatField.AM_PM_MIDNIGHT_NOON_FIELD;
pub const UDAT_FLEXIBLE_DAY_PERIOD_FIELD = UDateFormatField.FLEXIBLE_DAY_PERIOD_FIELD;

pub const UDateFormatBooleanAttribute = enum(i32) {
    PARSE_ALLOW_WHITESPACE = 0,
    PARSE_ALLOW_NUMERIC = 1,
    PARSE_PARTIAL_LITERAL_MATCH = 2,
    PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    BOOLEAN_ATTRIBUTE_COUNT = 4,
};
pub const UDAT_PARSE_ALLOW_WHITESPACE = UDateFormatBooleanAttribute.PARSE_ALLOW_WHITESPACE;
pub const UDAT_PARSE_ALLOW_NUMERIC = UDateFormatBooleanAttribute.PARSE_ALLOW_NUMERIC;
pub const UDAT_PARSE_PARTIAL_LITERAL_MATCH = UDateFormatBooleanAttribute.PARSE_PARTIAL_LITERAL_MATCH;
pub const UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = UDateFormatBooleanAttribute.PARSE_MULTIPLE_PATTERNS_FOR_MATCH;
pub const UDAT_BOOLEAN_ATTRIBUTE_COUNT = UDateFormatBooleanAttribute.BOOLEAN_ATTRIBUTE_COUNT;

pub const UDateFormatSymbolType = enum(i32) {
    ERAS = 0,
    MONTHS = 1,
    SHORT_MONTHS = 2,
    WEEKDAYS = 3,
    SHORT_WEEKDAYS = 4,
    AM_PMS = 5,
    LOCALIZED_CHARS = 6,
    ERA_NAMES = 7,
    NARROW_MONTHS = 8,
    NARROW_WEEKDAYS = 9,
    STANDALONE_MONTHS = 10,
    STANDALONE_SHORT_MONTHS = 11,
    STANDALONE_NARROW_MONTHS = 12,
    STANDALONE_WEEKDAYS = 13,
    STANDALONE_SHORT_WEEKDAYS = 14,
    STANDALONE_NARROW_WEEKDAYS = 15,
    QUARTERS = 16,
    SHORT_QUARTERS = 17,
    STANDALONE_QUARTERS = 18,
    STANDALONE_SHORT_QUARTERS = 19,
    SHORTER_WEEKDAYS = 20,
    STANDALONE_SHORTER_WEEKDAYS = 21,
    CYCLIC_YEARS_WIDE = 22,
    CYCLIC_YEARS_ABBREVIATED = 23,
    CYCLIC_YEARS_NARROW = 24,
    ZODIAC_NAMES_WIDE = 25,
    ZODIAC_NAMES_ABBREVIATED = 26,
    ZODIAC_NAMES_NARROW = 27,
};
pub const UDAT_ERAS = UDateFormatSymbolType.ERAS;
pub const UDAT_MONTHS = UDateFormatSymbolType.MONTHS;
pub const UDAT_SHORT_MONTHS = UDateFormatSymbolType.SHORT_MONTHS;
pub const UDAT_WEEKDAYS = UDateFormatSymbolType.WEEKDAYS;
pub const UDAT_SHORT_WEEKDAYS = UDateFormatSymbolType.SHORT_WEEKDAYS;
pub const UDAT_AM_PMS = UDateFormatSymbolType.AM_PMS;
pub const UDAT_LOCALIZED_CHARS = UDateFormatSymbolType.LOCALIZED_CHARS;
pub const UDAT_ERA_NAMES = UDateFormatSymbolType.ERA_NAMES;
pub const UDAT_NARROW_MONTHS = UDateFormatSymbolType.NARROW_MONTHS;
pub const UDAT_NARROW_WEEKDAYS = UDateFormatSymbolType.NARROW_WEEKDAYS;
pub const UDAT_STANDALONE_MONTHS = UDateFormatSymbolType.STANDALONE_MONTHS;
pub const UDAT_STANDALONE_SHORT_MONTHS = UDateFormatSymbolType.STANDALONE_SHORT_MONTHS;
pub const UDAT_STANDALONE_NARROW_MONTHS = UDateFormatSymbolType.STANDALONE_NARROW_MONTHS;
pub const UDAT_STANDALONE_WEEKDAYS = UDateFormatSymbolType.STANDALONE_WEEKDAYS;
pub const UDAT_STANDALONE_SHORT_WEEKDAYS = UDateFormatSymbolType.STANDALONE_SHORT_WEEKDAYS;
pub const UDAT_STANDALONE_NARROW_WEEKDAYS = UDateFormatSymbolType.STANDALONE_NARROW_WEEKDAYS;
pub const UDAT_QUARTERS = UDateFormatSymbolType.QUARTERS;
pub const UDAT_SHORT_QUARTERS = UDateFormatSymbolType.SHORT_QUARTERS;
pub const UDAT_STANDALONE_QUARTERS = UDateFormatSymbolType.STANDALONE_QUARTERS;
pub const UDAT_STANDALONE_SHORT_QUARTERS = UDateFormatSymbolType.STANDALONE_SHORT_QUARTERS;
pub const UDAT_SHORTER_WEEKDAYS = UDateFormatSymbolType.SHORTER_WEEKDAYS;
pub const UDAT_STANDALONE_SHORTER_WEEKDAYS = UDateFormatSymbolType.STANDALONE_SHORTER_WEEKDAYS;
pub const UDAT_CYCLIC_YEARS_WIDE = UDateFormatSymbolType.CYCLIC_YEARS_WIDE;
pub const UDAT_CYCLIC_YEARS_ABBREVIATED = UDateFormatSymbolType.CYCLIC_YEARS_ABBREVIATED;
pub const UDAT_CYCLIC_YEARS_NARROW = UDateFormatSymbolType.CYCLIC_YEARS_NARROW;
pub const UDAT_ZODIAC_NAMES_WIDE = UDateFormatSymbolType.ZODIAC_NAMES_WIDE;
pub const UDAT_ZODIAC_NAMES_ABBREVIATED = UDateFormatSymbolType.ZODIAC_NAMES_ABBREVIATED;
pub const UDAT_ZODIAC_NAMES_NARROW = UDateFormatSymbolType.ZODIAC_NAMES_NARROW;

pub const UPluralType = enum(i32) {
    CARDINAL = 0,
    ORDINAL = 1,
};
pub const UPLURAL_TYPE_CARDINAL = UPluralType.CARDINAL;
pub const UPLURAL_TYPE_ORDINAL = UPluralType.ORDINAL;

pub const URegexpFlag = enum(i32) {
    CASE_INSENSITIVE = 2,
    COMMENTS = 4,
    DOTALL = 32,
    LITERAL = 16,
    MULTILINE = 8,
    UNIX_LINES = 1,
    UWORD = 256,
    ERROR_ON_UNKNOWN_ESCAPES = 512,
};
pub const UREGEX_CASE_INSENSITIVE = URegexpFlag.CASE_INSENSITIVE;
pub const UREGEX_COMMENTS = URegexpFlag.COMMENTS;
pub const UREGEX_DOTALL = URegexpFlag.DOTALL;
pub const UREGEX_LITERAL = URegexpFlag.LITERAL;
pub const UREGEX_MULTILINE = URegexpFlag.MULTILINE;
pub const UREGEX_UNIX_LINES = URegexpFlag.UNIX_LINES;
pub const UREGEX_UWORD = URegexpFlag.UWORD;
pub const UREGEX_ERROR_ON_UNKNOWN_ESCAPES = URegexpFlag.ERROR_ON_UNKNOWN_ESCAPES;

pub const URegexMatchCallback = fn(
    context: ?*const c_void,
    steps: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const URegexFindProgressCallback = fn(
    context: ?*const c_void,
    matchIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const URegionType = enum(i32) {
    UNKNOWN = 0,
    TERRITORY = 1,
    WORLD = 2,
    CONTINENT = 3,
    SUBCONTINENT = 4,
    GROUPING = 5,
    DEPRECATED = 6,
};
pub const URGN_UNKNOWN = URegionType.UNKNOWN;
pub const URGN_TERRITORY = URegionType.TERRITORY;
pub const URGN_WORLD = URegionType.WORLD;
pub const URGN_CONTINENT = URegionType.CONTINENT;
pub const URGN_SUBCONTINENT = URegionType.SUBCONTINENT;
pub const URGN_GROUPING = URegionType.GROUPING;
pub const URGN_DEPRECATED = URegionType.DEPRECATED;

pub const UDateRelativeDateTimeFormatterStyle = enum(i32) {
    LONG = 0,
    SHORT = 1,
    NARROW = 2,
};
pub const UDAT_STYLE_LONG = UDateRelativeDateTimeFormatterStyle.LONG;
pub const UDAT_STYLE_SHORT = UDateRelativeDateTimeFormatterStyle.SHORT;
pub const UDAT_STYLE_NARROW = UDateRelativeDateTimeFormatterStyle.NARROW;

pub const URelativeDateTimeUnit = enum(i32) {
    YEAR = 0,
    QUARTER = 1,
    MONTH = 2,
    WEEK = 3,
    DAY = 4,
    HOUR = 5,
    MINUTE = 6,
    SECOND = 7,
    SUNDAY = 8,
    MONDAY = 9,
    TUESDAY = 10,
    WEDNESDAY = 11,
    THURSDAY = 12,
    FRIDAY = 13,
    SATURDAY = 14,
};
pub const UDAT_REL_UNIT_YEAR = URelativeDateTimeUnit.YEAR;
pub const UDAT_REL_UNIT_QUARTER = URelativeDateTimeUnit.QUARTER;
pub const UDAT_REL_UNIT_MONTH = URelativeDateTimeUnit.MONTH;
pub const UDAT_REL_UNIT_WEEK = URelativeDateTimeUnit.WEEK;
pub const UDAT_REL_UNIT_DAY = URelativeDateTimeUnit.DAY;
pub const UDAT_REL_UNIT_HOUR = URelativeDateTimeUnit.HOUR;
pub const UDAT_REL_UNIT_MINUTE = URelativeDateTimeUnit.MINUTE;
pub const UDAT_REL_UNIT_SECOND = URelativeDateTimeUnit.SECOND;
pub const UDAT_REL_UNIT_SUNDAY = URelativeDateTimeUnit.SUNDAY;
pub const UDAT_REL_UNIT_MONDAY = URelativeDateTimeUnit.MONDAY;
pub const UDAT_REL_UNIT_TUESDAY = URelativeDateTimeUnit.TUESDAY;
pub const UDAT_REL_UNIT_WEDNESDAY = URelativeDateTimeUnit.WEDNESDAY;
pub const UDAT_REL_UNIT_THURSDAY = URelativeDateTimeUnit.THURSDAY;
pub const UDAT_REL_UNIT_FRIDAY = URelativeDateTimeUnit.FRIDAY;
pub const UDAT_REL_UNIT_SATURDAY = URelativeDateTimeUnit.SATURDAY;

pub const USearchAttribute = enum(i32) {
    OVERLAP = 0,
    ELEMENT_COMPARISON = 2,
};
pub const USEARCH_OVERLAP = USearchAttribute.OVERLAP;
pub const USEARCH_ELEMENT_COMPARISON = USearchAttribute.ELEMENT_COMPARISON;

pub const USearchAttributeValue = enum(i32) {
    DEFAULT = -1,
    OFF = 0,
    ON = 1,
    STANDARD_ELEMENT_COMPARISON = 2,
    PATTERN_BASE_WEIGHT_IS_WILDCARD = 3,
    ANY_BASE_WEIGHT_IS_WILDCARD = 4,
};
pub const USEARCH_DEFAULT = USearchAttributeValue.DEFAULT;
pub const USEARCH_OFF = USearchAttributeValue.OFF;
pub const USEARCH_ON = USearchAttributeValue.ON;
pub const USEARCH_STANDARD_ELEMENT_COMPARISON = USearchAttributeValue.STANDARD_ELEMENT_COMPARISON;
pub const USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD = USearchAttributeValue.PATTERN_BASE_WEIGHT_IS_WILDCARD;
pub const USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD = USearchAttributeValue.ANY_BASE_WEIGHT_IS_WILDCARD;

pub const USpoofChecks = enum(i32) {
    SINGLE_SCRIPT_CONFUSABLE = 1,
    MIXED_SCRIPT_CONFUSABLE = 2,
    WHOLE_SCRIPT_CONFUSABLE = 4,
    CONFUSABLE = 7,
    RESTRICTION_LEVEL = 16,
    INVISIBLE = 32,
    CHAR_LIMIT = 64,
    MIXED_NUMBERS = 128,
    ALL_CHECKS = 65535,
    AUX_INFO = 1073741824,
};
pub const USPOOF_SINGLE_SCRIPT_CONFUSABLE = USpoofChecks.SINGLE_SCRIPT_CONFUSABLE;
pub const USPOOF_MIXED_SCRIPT_CONFUSABLE = USpoofChecks.MIXED_SCRIPT_CONFUSABLE;
pub const USPOOF_WHOLE_SCRIPT_CONFUSABLE = USpoofChecks.WHOLE_SCRIPT_CONFUSABLE;
pub const USPOOF_CONFUSABLE = USpoofChecks.CONFUSABLE;
pub const USPOOF_RESTRICTION_LEVEL = USpoofChecks.RESTRICTION_LEVEL;
pub const USPOOF_INVISIBLE = USpoofChecks.INVISIBLE;
pub const USPOOF_CHAR_LIMIT = USpoofChecks.CHAR_LIMIT;
pub const USPOOF_MIXED_NUMBERS = USpoofChecks.MIXED_NUMBERS;
pub const USPOOF_ALL_CHECKS = USpoofChecks.ALL_CHECKS;
pub const USPOOF_AUX_INFO = USpoofChecks.AUX_INFO;

pub const URestrictionLevel = enum(i32) {
    ASCII = 268435456,
    SINGLE_SCRIPT_RESTRICTIVE = 536870912,
    HIGHLY_RESTRICTIVE = 805306368,
    MODERATELY_RESTRICTIVE = 1073741824,
    MINIMALLY_RESTRICTIVE = 1342177280,
    UNRESTRICTIVE = 1610612736,
    RESTRICTION_LEVEL_MASK = 2130706432,
};
pub const USPOOF_ASCII = URestrictionLevel.ASCII;
pub const USPOOF_SINGLE_SCRIPT_RESTRICTIVE = URestrictionLevel.SINGLE_SCRIPT_RESTRICTIVE;
pub const USPOOF_HIGHLY_RESTRICTIVE = URestrictionLevel.HIGHLY_RESTRICTIVE;
pub const USPOOF_MODERATELY_RESTRICTIVE = URestrictionLevel.MODERATELY_RESTRICTIVE;
pub const USPOOF_MINIMALLY_RESTRICTIVE = URestrictionLevel.MINIMALLY_RESTRICTIVE;
pub const USPOOF_UNRESTRICTIVE = URestrictionLevel.UNRESTRICTIVE;
pub const USPOOF_RESTRICTION_LEVEL_MASK = URestrictionLevel.RESTRICTION_LEVEL_MASK;

pub const UDateTimeScale = enum(i32) {
    JAVA_TIME = 0,
    UNIX_TIME = 1,
    ICU4C_TIME = 2,
    WINDOWS_FILE_TIME = 3,
    DOTNET_DATE_TIME = 4,
    MAC_OLD_TIME = 5,
    MAC_TIME = 6,
    EXCEL_TIME = 7,
    DB2_TIME = 8,
    UNIX_MICROSECONDS_TIME = 9,
};
pub const UDTS_JAVA_TIME = UDateTimeScale.JAVA_TIME;
pub const UDTS_UNIX_TIME = UDateTimeScale.UNIX_TIME;
pub const UDTS_ICU4C_TIME = UDateTimeScale.ICU4C_TIME;
pub const UDTS_WINDOWS_FILE_TIME = UDateTimeScale.WINDOWS_FILE_TIME;
pub const UDTS_DOTNET_DATE_TIME = UDateTimeScale.DOTNET_DATE_TIME;
pub const UDTS_MAC_OLD_TIME = UDateTimeScale.MAC_OLD_TIME;
pub const UDTS_MAC_TIME = UDateTimeScale.MAC_TIME;
pub const UDTS_EXCEL_TIME = UDateTimeScale.EXCEL_TIME;
pub const UDTS_DB2_TIME = UDateTimeScale.DB2_TIME;
pub const UDTS_UNIX_MICROSECONDS_TIME = UDateTimeScale.UNIX_MICROSECONDS_TIME;

pub const UTimeScaleValue = enum(i32) {
    UNITS_VALUE = 0,
    EPOCH_OFFSET_VALUE = 1,
    FROM_MIN_VALUE = 2,
    FROM_MAX_VALUE = 3,
    TO_MIN_VALUE = 4,
    TO_MAX_VALUE = 5,
};
pub const UTSV_UNITS_VALUE = UTimeScaleValue.UNITS_VALUE;
pub const UTSV_EPOCH_OFFSET_VALUE = UTimeScaleValue.EPOCH_OFFSET_VALUE;
pub const UTSV_FROM_MIN_VALUE = UTimeScaleValue.FROM_MIN_VALUE;
pub const UTSV_FROM_MAX_VALUE = UTimeScaleValue.FROM_MAX_VALUE;
pub const UTSV_TO_MIN_VALUE = UTimeScaleValue.TO_MIN_VALUE;
pub const UTSV_TO_MAX_VALUE = UTimeScaleValue.TO_MAX_VALUE;

pub const UTransDirection = enum(i32) {
    FORWARD = 0,
    REVERSE = 1,
};
pub const UTRANS_FORWARD = UTransDirection.FORWARD;
pub const UTRANS_REVERSE = UTransDirection.REVERSE;

pub const UTransPosition = extern struct {
    contextStart: i32,
    contextLimit: i32,
    start: i32,
    limit: i32,
};

const CLSID_CActiveIMM_Value = @import("zig.zig").Guid.initString("4955dd33-b159-11d0-8fcf-00aa006bcc59");
pub const CLSID_CActiveIMM = &CLSID_CActiveIMM_Value;

const IID_IEnumRegisterWordA_Value = @import("zig.zig").Guid.initString("08c03412-f96b-11d0-a475-00aa006bcc59");
pub const IID_IEnumRegisterWordA = &IID_IEnumRegisterWordA_Value;
pub const IEnumRegisterWordA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumRegisterWordA,
            ppEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumRegisterWordA,
            ulCount: u32,
            rgRegisterWord: ?*REGISTERWORDA,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRegisterWordA,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Clone(@ptrCast(*const IEnumRegisterWordA, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDA, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Next(@ptrCast(*const IEnumRegisterWordA, self), ulCount, rgRegisterWord, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Reset(@ptrCast(*const IEnumRegisterWordA, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Skip(@ptrCast(*const IEnumRegisterWordA, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRegisterWordW_Value = @import("zig.zig").Guid.initString("4955dd31-b159-11d0-8fcf-00aa006bcc59");
pub const IID_IEnumRegisterWordW = &IID_IEnumRegisterWordW_Value;
pub const IEnumRegisterWordW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumRegisterWordW,
            ppEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumRegisterWordW,
            ulCount: u32,
            rgRegisterWord: ?*REGISTERWORDW,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRegisterWordW,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Clone(@ptrCast(*const IEnumRegisterWordW, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDW, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Next(@ptrCast(*const IEnumRegisterWordW, self), ulCount, rgRegisterWord, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Reset(@ptrCast(*const IEnumRegisterWordW, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Skip(@ptrCast(*const IEnumRegisterWordW, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumInputContext_Value = @import("zig.zig").Guid.initString("09b5eab0-f997-11d1-93d4-0060b067b86e");
pub const IID_IEnumInputContext = &IID_IEnumInputContext_Value;
pub const IEnumInputContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumInputContext,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumInputContext,
            ulCount: u32,
            rgInputContext: ?*?HIMC,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumInputContext,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Clone(self: *const T, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Clone(@ptrCast(*const IEnumInputContext, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Next(self: *const T, ulCount: u32, rgInputContext: ?*?HIMC, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Next(@ptrCast(*const IEnumInputContext, self), ulCount, rgInputContext, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Reset(@ptrCast(*const IEnumInputContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Skip(@ptrCast(*const IEnumInputContext, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMRegistrar_Value = @import("zig.zig").Guid.initString("b3458082-bd00-11d1-939b-0060b067b86e");
pub const IID_IActiveIMMRegistrar = &IID_IActiveIMMRegistrar_Value;
pub const IActiveIMMRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterIME: fn(
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
            lgid: u16,
            pszIconFile: ?[*:0]const u16,
            pszDesc: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterIME: fn(
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMRegistrar_RegisterIME(self: *const T, rclsid: ?*const Guid, lgid: u16, pszIconFile: ?[*:0]const u16, pszDesc: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMRegistrar.VTable, self.vtable).RegisterIME(@ptrCast(*const IActiveIMMRegistrar, self), rclsid, lgid, pszIconFile, pszDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMRegistrar_UnregisterIME(self: *const T, rclsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMRegistrar.VTable, self.vtable).UnregisterIME(@ptrCast(*const IActiveIMMRegistrar, self), rclsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMMessagePumpOwner_Value = @import("zig.zig").Guid.initString("b5cf2cfa-8aeb-11d1-9364-0060b067b86e");
pub const IID_IActiveIMMMessagePumpOwner = &IID_IActiveIMMMessagePumpOwner_Value;
pub const IActiveIMMMessagePumpOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTranslateMessage: fn(
            self: *const IActiveIMMMessagePumpOwner,
            pMsg: ?*const MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IActiveIMMMessagePumpOwner,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IActiveIMMMessagePumpOwner,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Start(@ptrCast(*const IActiveIMMMessagePumpOwner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).End(@ptrCast(*const IActiveIMMMessagePumpOwner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_OnTranslateMessage(self: *const T, pMsg: ?*const MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).OnTranslateMessage(@ptrCast(*const IActiveIMMMessagePumpOwner, self), pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Pause(self: *const T, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Pause(@ptrCast(*const IActiveIMMMessagePumpOwner, self), pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Resume(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Resume(@ptrCast(*const IActiveIMMMessagePumpOwner, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMApp_Value = @import("zig.zig").Guid.initString("08c0e040-62d1-11d1-9326-0060b067b86e");
pub const IID_IActiveIMMApp = &IID_IActiveIMMApp_Value;
pub const IActiveIMMApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIME: ?HIMC,
            phPrev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: fn(
            self: *const IActiveIMMApp,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: fn(
            self: *const IActiveIMMApp,
            hIME: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
            pData: ?*c_void,
            pEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*c_void,
            pEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*c_void,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*c_void,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PWSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pfdwConversion: ?*u32,
            pfdwSentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            phDefWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PWSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            fdwIndex: u32,
            pdwProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFA,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            puVirtualKey: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: fn(
            self: *const IActiveIMMApp,
            szIMEFileName: ?PSTR,
            szLayoutText: ?PSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: fn(
            self: *const IActiveIMMApp,
            szIMEFileName: ?PWSTR,
            szLayoutText: ?PWSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: fn(
            self: *const IActiveIMMApp,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: fn(
            self: *const IActiveIMMApp,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*c_void,
            dwCompLen: u32,
            pRead: ?*c_void,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*c_void,
            dwCompLen: u32,
            pRead: ?*c_void,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            fdwConversion: u32,
            fdwSentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            fOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            dwHotKeyID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szUnregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szUnregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const IActiveIMMApp,
            fRestoreLayout: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const IActiveIMMApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefWindowProc: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            Msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FilterClientWindows: fn(
            self: *const IActiveIMMApp,
            aaClassList: ?*u16,
            uSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIMC: ?HIMC,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: fn(
            self: *const IActiveIMMApp,
            idThread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOA,
            pImeMenu: ?*IMEMENUITEMINFOA,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOW,
            pImeMenu: ?*IMEMENUITEMINFOW,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: fn(
            self: *const IActiveIMMApp,
            idThread: u32,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).AssociateContext(@ptrCast(*const IActiveIMMApp, self), hWnd, hIME, phPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ConfigureIMEA(@ptrCast(*const IActiveIMMApp, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ConfigureIMEW(@ptrCast(*const IActiveIMMApp, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_CreateContext(self: *const T, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).CreateContext(@ptrCast(*const IActiveIMMApp, self), phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_DestroyContext(self: *const T, hIME: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).DestroyContext(@ptrCast(*const IActiveIMMApp, self), hIME);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*c_void, pEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumRegisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*c_void, pEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumRegisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*c_void, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EscapeA(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*c_void, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EscapeW(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListCountA(@ptrCast(*const IActiveIMMApp, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListCountW(@ptrCast(*const IActiveIMMApp, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionFontA(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionFontW(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionStringA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionStringW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetContext(@ptrCast(*const IActiveIMMApp, self), hWnd, phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionListA(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionListW(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, pfdwConversion, pfdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDefaultIMEWnd(@ptrCast(*const IActiveIMMApp, self), hWnd, phDefWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDescriptionA(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDescriptionW(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetGuideLineA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetGuideLineW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetIMEFileNameA(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetIMEFileNameW(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetOpenStatus(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetOpenStatus(@ptrCast(*const IActiveIMMApp, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveIMMApp, self), hKL, fdwIndex, pdwProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetRegisterWordStyleA(@ptrCast(*const IActiveIMMApp, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetRegisterWordStyleW(@ptrCast(*const IActiveIMMApp, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetStatusWindowPos(@ptrCast(*const IActiveIMMApp, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetVirtualKey(@ptrCast(*const IActiveIMMApp, self), hWnd, puVirtualKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).InstallIMEA(@ptrCast(*const IActiveIMMApp, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).InstallIMEW(@ptrCast(*const IActiveIMMApp, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsIME(self: *const T, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsIME(@ptrCast(*const IActiveIMMApp, self), hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsUIMessageA(@ptrCast(*const IActiveIMMApp, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsUIMessageW(@ptrCast(*const IActiveIMMApp, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).NotifyIME(@ptrCast(*const IActiveIMMApp, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).RegisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).RegisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ReleaseContext(@ptrCast(*const IActiveIMMApp, self), hWnd, hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCandidateWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionFontA(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionFontW(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*c_void, dwCompLen: u32, pRead: ?*c_void, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionStringA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*c_void, dwCompLen: u32, pRead: ?*c_void, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionStringW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetConversionStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, fdwConversion, fdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetOpenStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, fOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetStatusWindowPos(@ptrCast(*const IActiveIMMApp, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SimulateHotKey(@ptrCast(*const IActiveIMMApp, self), hWnd, dwHotKeyID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).UnregisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).UnregisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_Activate(self: *const T, fRestoreLayout: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).Activate(@ptrCast(*const IActiveIMMApp, self), fRestoreLayout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).Deactivate(@ptrCast(*const IActiveIMMApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_OnDefWindowProc(self: *const T, hWnd: ?HWND, Msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).OnDefWindowProc(@ptrCast(*const IActiveIMMApp, self), hWnd, Msg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_FilterClientWindows(self: *const T, aaClassList: ?*u16, uSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).FilterClientWindows(@ptrCast(*const IActiveIMMApp, self), aaClassList, uSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIMMApp, self), hKL, uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIMMApp, self), hKL, plid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).AssociateContextEx(@ptrCast(*const IActiveIMMApp, self), hWnd, hIMC, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_DisableIME(self: *const T, idThread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).DisableIME(@ptrCast(*const IActiveIMMApp, self), idThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetImeMenuItemsA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetImeMenuItemsW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumInputContext(@ptrCast(*const IActiveIMMApp, self), idThread, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMIME_Value = @import("zig.zig").Guid.initString("08c03411-f96b-11d0-a475-00aa006bcc59");
pub const IID_IActiveIMMIME = &IID_IActiveIMMIME_Value;
pub const IActiveIMMIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIME: ?HIMC,
            phPrev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: fn(
            self: *const IActiveIMMIME,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: fn(
            self: *const IActiveIMMIME,
            hIME: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
            pData: ?*c_void,
            pEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*c_void,
            pEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*c_void,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*c_void,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PWSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pfdwConversion: ?*u32,
            pfdwSentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            phDefWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PWSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            fdwIndex: u32,
            pdwProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFA,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            puVirtualKey: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: fn(
            self: *const IActiveIMMIME,
            szIMEFileName: ?PSTR,
            szLayoutText: ?PSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: fn(
            self: *const IActiveIMMIME,
            szIMEFileName: ?PWSTR,
            szLayoutText: ?PWSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: fn(
            self: *const IActiveIMMIME,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: fn(
            self: *const IActiveIMMIME,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*c_void,
            dwCompLen: u32,
            pRead: ?*c_void,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*c_void,
            dwCompLen: u32,
            pRead: ?*c_void,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            fdwConversion: u32,
            fdwSentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            fOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            dwHotKeyID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szUnregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szUnregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateMessage: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMC: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            ppIMC: ?*?*INPUTCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMC: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCLockCount: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwLockCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIMCC: fn(
            self: *const IActiveIMMIME,
            dwSize: u32,
            phIMCC: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReSizeIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            dwSize: u32,
            phIMCC: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCSize: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            pdwSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCLockCount: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            pdwLockCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHotKey: fn(
            self: *const IActiveIMMIME,
            dwHotKeyID: u32,
            puModifiers: ?*u32,
            puVKey: ?*u32,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotKey: fn(
            self: *const IActiveIMMIME,
            dwHotKeyID: u32,
            uModifiers: u32,
            uVKey: u32,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSoftKeyboard: fn(
            self: *const IActiveIMMIME,
            uType: u32,
            hOwner: ?HWND,
            x: i32,
            y: i32,
            phSoftKbdWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroySoftKeyboard: fn(
            self: *const IActiveIMMIME,
            hSoftKbdWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSoftKeyboard: fn(
            self: *const IActiveIMMIME,
            hSoftKbdWnd: ?HWND,
            nCmdShow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeybdEvent: fn(
            self: *const IActiveIMMIME,
            lgidIME: u16,
            bVk: u8,
            bScan: u8,
            dwFlags: u32,
            dwExtraInfo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockModal: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockModal: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIMC: ?HIMC,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: fn(
            self: *const IActiveIMMIME,
            idThread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOA,
            pImeMenu: ?*IMEMENUITEMINFOA,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOW,
            pImeMenu: ?*IMEMENUITEMINFOW,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: fn(
            self: *const IActiveIMMIME,
            idThread: u32,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCA: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCW: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSleeping: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).AssociateContext(@ptrCast(*const IActiveIMMIME, self), hWnd, hIME, phPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ConfigureIMEA(@ptrCast(*const IActiveIMMIME, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ConfigureIMEW(@ptrCast(*const IActiveIMMIME, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateContext(self: *const T, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateContext(@ptrCast(*const IActiveIMMIME, self), phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroyContext(self: *const T, hIME: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroyContext(@ptrCast(*const IActiveIMMIME, self), hIME);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*c_void, pEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumRegisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*c_void, pEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumRegisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*c_void, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EscapeA(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*c_void, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EscapeW(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListCountA(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListCountW(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionFontA(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionFontW(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionStringA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionStringW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetContext(@ptrCast(*const IActiveIMMIME, self), hWnd, phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionListA(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionListW(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, pfdwConversion, pfdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDefaultIMEWnd(@ptrCast(*const IActiveIMMIME, self), hWnd, phDefWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDescriptionA(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDescriptionW(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetGuideLineA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetGuideLineW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMEFileNameA(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMEFileNameW(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetOpenStatus(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetOpenStatus(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveIMMIME, self), hKL, fdwIndex, pdwProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetRegisterWordStyleA(@ptrCast(*const IActiveIMMIME, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetRegisterWordStyleW(@ptrCast(*const IActiveIMMIME, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetStatusWindowPos(@ptrCast(*const IActiveIMMIME, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetVirtualKey(@ptrCast(*const IActiveIMMIME, self), hWnd, puVirtualKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).InstallIMEA(@ptrCast(*const IActiveIMMIME, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).InstallIMEW(@ptrCast(*const IActiveIMMIME, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsIME(self: *const T, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsIME(@ptrCast(*const IActiveIMMIME, self), hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsUIMessageA(@ptrCast(*const IActiveIMMIME, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsUIMessageW(@ptrCast(*const IActiveIMMIME, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).NotifyIME(@ptrCast(*const IActiveIMMIME, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RegisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RegisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ReleaseContext(@ptrCast(*const IActiveIMMIME, self), hWnd, hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCandidateWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionFontA(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionFontW(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*c_void, dwCompLen: u32, pRead: ?*c_void, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionStringA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*c_void, dwCompLen: u32, pRead: ?*c_void, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionStringW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetConversionStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, fdwConversion, fdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetOpenStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, fOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetStatusWindowPos(@ptrCast(*const IActiveIMMIME, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SimulateHotKey(@ptrCast(*const IActiveIMMIME, self), hWnd, dwHotKeyID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnregisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnregisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GenerateMessage(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GenerateMessage(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockIMC(self: *const T, hIMC: ?HIMC, ppIMC: ?*?*INPUTCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockIMC(@ptrCast(*const IActiveIMMIME, self), hIMC, ppIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockIMC(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockIMC(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCLockCount(self: *const T, hIMC: ?HIMC, pdwLockCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCLockCount(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwLockCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateIMCC(self: *const T, dwSize: u32, phIMCC: ?*?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateIMCC(@ptrCast(*const IActiveIMMIME, self), dwSize, phIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroyIMCC(self: *const T, hIMCC: ?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroyIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockIMCC(self: *const T, hIMCC: ?HIMCC, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockIMCC(self: *const T, hIMCC: ?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ReSizeIMCC(self: *const T, hIMCC: ?HIMCC, dwSize: u32, phIMCC: ?*?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ReSizeIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC, dwSize, phIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCCSize(self: *const T, hIMCC: ?HIMCC, pdwSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCCSize(@ptrCast(*const IActiveIMMIME, self), hIMCC, pdwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCCLockCount(self: *const T, hIMCC: ?HIMCC, pdwLockCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCCLockCount(@ptrCast(*const IActiveIMMIME, self), hIMCC, pdwLockCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetHotKey(self: *const T, dwHotKeyID: u32, puModifiers: ?*u32, puVKey: ?*u32, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetHotKey(@ptrCast(*const IActiveIMMIME, self), dwHotKeyID, puModifiers, puVKey, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetHotKey(self: *const T, dwHotKeyID: u32, uModifiers: u32, uVKey: u32, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetHotKey(@ptrCast(*const IActiveIMMIME, self), dwHotKeyID, uModifiers, uVKey, hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateSoftKeyboard(self: *const T, uType: u32, hOwner: ?HWND, x: i32, y: i32, phSoftKbdWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateSoftKeyboard(@ptrCast(*const IActiveIMMIME, self), uType, hOwner, x, y, phSoftKbdWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroySoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroySoftKeyboard(@ptrCast(*const IActiveIMMIME, self), hSoftKbdWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ShowSoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND, nCmdShow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ShowSoftKeyboard(@ptrCast(*const IActiveIMMIME, self), hSoftKbdWnd, nCmdShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIMMIME, self), hKL, uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIMMIME, self), hKL, plid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_KeybdEvent(self: *const T, lgidIME: u16, bVk: u8, bScan: u8, dwFlags: u32, dwExtraInfo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).KeybdEvent(@ptrCast(*const IActiveIMMIME, self), lgidIME, bVk, bScan, dwFlags, dwExtraInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockModal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockModal(@ptrCast(*const IActiveIMMIME, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockModal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockModal(@ptrCast(*const IActiveIMMIME, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).AssociateContextEx(@ptrCast(*const IActiveIMMIME, self), hWnd, hIMC, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DisableIME(self: *const T, idThread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DisableIME(@ptrCast(*const IActiveIMMIME, self), idThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetImeMenuItemsA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetImeMenuItemsW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumInputContext(@ptrCast(*const IActiveIMMIME, self), idThread, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RequestMessageA(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RequestMessageA(@ptrCast(*const IActiveIMMIME, self), hIMC, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RequestMessageW(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RequestMessageW(@ptrCast(*const IActiveIMMIME, self), hIMC, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SendIMCA(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SendIMCA(@ptrCast(*const IActiveIMMIME, self), hWnd, uMsg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SendIMCW(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SendIMCW(@ptrCast(*const IActiveIMMIME, self), hWnd, uMsg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsSleeping(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsSleeping(@ptrCast(*const IActiveIMMIME, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME_Value = @import("zig.zig").Guid.initString("6fe20962-d077-11d0-8fe7-00aa006bcc59");
pub const IID_IActiveIME = &IID_IActiveIME_Value;
pub const IActiveIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Inquire: fn(
            self: *const IActiveIME,
            dwSystemInfoFlags: u32,
            pIMEInfo: ?*IMEINFO,
            szWndClass: ?PWSTR,
            pdwPrivate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConversionList: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            szSource: ?PWSTR,
            uFlag: u32,
            uBufLen: u32,
            pDest: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: fn(
            self: *const IActiveIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pRegisterWord: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: fn(
            self: *const IActiveIME,
            uReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Escape: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*c_void,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveContext: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            fFlag: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessKey: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            uVirKey: u32,
            lParam: u32,
            pbKeyState: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            fSelect: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionString: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*c_void,
            dwCompLen: u32,
            pRead: ?*c_void,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ToAsciiEx: fn(
            self: *const IActiveIME,
            uVirKey: u32,
            uScanCode: u32,
            pbKeyState: ?*u8,
            fuState: u32,
            hIMC: ?HIMC,
            pdwTransBuf: ?*u32,
            puSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyle: fn(
            self: *const IActiveIME,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puBufSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*c_void,
            ppEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIME,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIME,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Inquire(self: *const T, dwSystemInfoFlags: u32, pIMEInfo: ?*IMEINFO, szWndClass: ?PWSTR, pdwPrivate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Inquire(@ptrCast(*const IActiveIME, self), dwSystemInfoFlags, pIMEInfo, szWndClass, pdwPrivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ConversionList(self: *const T, hIMC: ?HIMC, szSource: ?PWSTR, uFlag: u32, uBufLen: u32, pDest: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ConversionList(@ptrCast(*const IActiveIME, self), hIMC, szSource, uFlag, uBufLen, pDest, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Configure(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pRegisterWord: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Configure(@ptrCast(*const IActiveIME, self), hKL, hWnd, dwMode, pRegisterWord);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Destroy(self: *const T, uReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Destroy(@ptrCast(*const IActiveIME, self), uReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Escape(self: *const T, hIMC: ?HIMC, uEscape: u32, pData: ?*c_void, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Escape(@ptrCast(*const IActiveIME, self), hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_SetActiveContext(self: *const T, hIMC: ?HIMC, fFlag: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).SetActiveContext(@ptrCast(*const IActiveIME, self), hIMC, fFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ProcessKey(self: *const T, hIMC: ?HIMC, uVirKey: u32, lParam: u32, pbKeyState: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ProcessKey(@ptrCast(*const IActiveIME, self), hIMC, uVirKey, lParam, pbKeyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Notify(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Notify(@ptrCast(*const IActiveIME, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Select(self: *const T, hIMC: ?HIMC, fSelect: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Select(@ptrCast(*const IActiveIME, self), hIMC, fSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_SetCompositionString(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*c_void, dwCompLen: u32, pRead: ?*c_void, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).SetCompositionString(@ptrCast(*const IActiveIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ToAsciiEx(self: *const T, uVirKey: u32, uScanCode: u32, pbKeyState: ?*u8, fuState: u32, hIMC: ?HIMC, pdwTransBuf: ?*u32, puSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ToAsciiEx(@ptrCast(*const IActiveIME, self), uVirKey, uScanCode, pbKeyState, fuState, hIMC, pdwTransBuf, puSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_RegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).RegisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_UnregisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).UnregisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetRegisterWordStyle(self: *const T, nItem: u32, pStyleBuf: ?*STYLEBUFW, puBufSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetRegisterWordStyle(@ptrCast(*const IActiveIME, self), nItem, pStyleBuf, puBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_EnumRegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*c_void, ppEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).EnumRegisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szRegister, pData, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetCodePageA(self: *const T, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIME, self), uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetLangId(self: *const T, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIME, self), plid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME2_Value = @import("zig.zig").Guid.initString("e1c4bf0e-2d53-11d2-93e1-0060b067b86e");
pub const IID_IActiveIME2 = &IID_IActiveIME2_Value;
pub const IActiveIME2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveIME.VTable,
        Sleep: fn(
            self: *const IActiveIME2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unsleep: fn(
            self: *const IActiveIME2,
            fDead: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveIME.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME2_Sleep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME2.VTable, self.vtable).Sleep(@ptrCast(*const IActiveIME2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME2_Unsleep(self: *const T, fDead: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME2.VTable, self.vtable).Unsleep(@ptrCast(*const IActiveIME2, self), fDead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (1237)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "GDI32" fn GetTextCharset(
    hdc: ?HDC,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "GDI32" fn GetTextCharsetInfo(
    hdc: ?HDC,
    lpSig: ?*FONTSIGNATURE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "GDI32" fn TranslateCharsetInfo(
    lpSrc: ?*u32,
    lpCs: ?*CHARSETINFO,
    dwFlags: TRANSLATE_CHARSET_INFO_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetDateFormatA(
    Locale: u32,
    dwFlags: u32,
    lpDate: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u8,
    lpDateStr: ?[*:0]u8,
    cchDate: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetDateFormatW(
    Locale: u32,
    dwFlags: u32,
    lpDate: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u16,
    lpDateStr: ?[*:0]u16,
    cchDate: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetTimeFormatA(
    Locale: u32,
    dwFlags: u32,
    lpTime: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u8,
    lpTimeStr: ?[*:0]u8,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetTimeFormatW(
    Locale: u32,
    dwFlags: u32,
    lpTime: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u16,
    lpTimeStr: ?[*:0]u16,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetTimeFormatEx(
    lpLocaleName: ?[*:0]const u16,
    dwFlags: TIME_FORMAT_FLAGS,
    lpTime: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u16,
    lpTimeStr: ?[*:0]u16,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDateFormatEx(
    lpLocaleName: ?[*:0]const u16,
    dwFlags: ENUM_DATE_FORMATS_FLAGS,
    lpDate: ?*const SYSTEMTIME,
    lpFormat: ?[*:0]const u16,
    lpDateStr: ?[*:0]u16,
    cchDate: i32,
    lpCalendar: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDurationFormatEx(
    lpLocaleName: ?[*:0]const u16,
    dwFlags: u32,
    lpDuration: ?*const SYSTEMTIME,
    ullDuration: u64,
    lpFormat: ?[*:0]const u16,
    lpDurationStr: ?[*:0]u16,
    cchDuration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CompareStringEx(
    lpLocaleName: ?[*:0]const u16,
    dwCmpFlags: COMPARE_STRING_FLAGS,
    lpString1: [*:0]const u16,
    cchCount1: i32,
    lpString2: [*:0]const u16,
    cchCount2: i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CompareStringOrdinal(
    lpString1: [*:0]const u16,
    cchCount1: i32,
    lpString2: [*:0]const u16,
    cchCount2: i32,
    bIgnoreCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CompareStringW(
    Locale: u32,
    dwCmpFlags: u32,
    lpString1: [*:0]const u16,
    cchCount1: i32,
    lpString2: [*:0]const u16,
    cchCount2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn FoldStringW(
    dwMapFlags: FOLD_STRING_MAP_FLAGS,
    lpSrcStr: [*:0]const u16,
    cchSrc: i32,
    lpDestStr: ?[*:0]u16,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetStringTypeExW(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: [*:0]const u16,
    cchSrc: i32,
    lpCharType: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetStringTypeW(
    dwInfoType: u32,
    lpSrcStr: [*:0]const u16,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn MultiByteToWideChar(
    CodePage: u32,
    dwFlags: MULTI_BYTE_TO_WIDE_CHAR_FLAGS,
    lpMultiByteStr: [*]const u8,
    cbMultiByte: i32,
    lpWideCharStr: ?[*:0]u16,
    cchWideChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WideCharToMultiByte(
    CodePage: u32,
    dwFlags: u32,
    lpWideCharStr: [*:0]const u16,
    cchWideChar: i32,
    // TODO: what to do with BytesParamIndex 5?
    lpMultiByteStr: ?PSTR,
    cbMultiByte: i32,
    lpDefaultChar: ?[*]const u8,
    lpUsedDefaultChar: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsValidCodePage(
    CodePage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetACP(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetOEMCP(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCPInfo(
    CodePage: u32,
    lpCPInfo: ?*CPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCPInfoExA(
    CodePage: u32,
    dwFlags: u32,
    lpCPInfoEx: ?*CPINFOEXA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCPInfoExW(
    CodePage: u32,
    dwFlags: u32,
    lpCPInfoEx: ?*CPINFOEXW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CompareStringA(
    Locale: u32,
    dwCmpFlags: u32,
    lpString1: [*]i8,
    cchCount1: i32,
    lpString2: [*]i8,
    cchCount2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindNLSString(
    Locale: u32,
    dwFindNLSStringFlags: u32,
    lpStringSource: [*:0]const u16,
    cchSource: i32,
    lpStringValue: [*:0]const u16,
    cchValue: i32,
    pcchFound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn LCMapStringW(
    Locale: u32,
    dwMapFlags: u32,
    lpSrcStr: [*:0]const u16,
    cchSrc: i32,
    lpDestStr: ?PWSTR,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn LCMapStringA(
    Locale: u32,
    dwMapFlags: u32,
    lpSrcStr: [*:0]const u8,
    cchSrc: i32,
    lpDestStr: ?PSTR,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetLocaleInfoW(
    Locale: u32,
    LCType: u32,
    lpLCData: ?[*:0]u16,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetLocaleInfoA(
    Locale: u32,
    LCType: u32,
    lpLCData: ?[*:0]u8,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetLocaleInfoA(
    Locale: u32,
    LCType: u32,
    lpLCData: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetLocaleInfoW(
    Locale: u32,
    LCType: u32,
    lpLCData: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCalendarInfoA(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?[*:0]u8,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCalendarInfoW(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?[*:0]u16,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetCalendarInfoA(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetCalendarInfoW(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsDBCSLeadByte(
    TestChar: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsDBCSLeadByteEx(
    CodePage: u32,
    TestChar: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn LocaleNameToLCID(
    lpName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn LCIDToLocaleName(
    Locale: u32,
    lpName: ?[*:0]u16,
    cchName: i32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDurationFormat(
    Locale: u32,
    dwFlags: u32,
    lpDuration: ?*const SYSTEMTIME,
    ullDuration: u64,
    lpFormat: ?[*:0]const u16,
    lpDurationStr: ?[*:0]u16,
    cchDuration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetNumberFormatA(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?[*:0]const u8,
    lpFormat: ?*const NUMBERFMTA,
    lpNumberStr: ?[*:0]u8,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetNumberFormatW(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?[*:0]const u16,
    lpFormat: ?*const NUMBERFMTW,
    lpNumberStr: ?[*:0]u16,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCurrencyFormatA(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?[*:0]const u8,
    lpFormat: ?*const CURRENCYFMTA,
    lpCurrencyStr: ?[*:0]u8,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCurrencyFormatW(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?[*:0]const u16,
    lpFormat: ?*const CURRENCYFMTW,
    lpCurrencyStr: ?[*:0]u16,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumCalendarInfoA(
    lpCalInfoEnumProc: ?CALINFO_ENUMPROCA,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumCalendarInfoW(
    lpCalInfoEnumProc: ?CALINFO_ENUMPROCW,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumCalendarInfoExA(
    lpCalInfoEnumProcEx: ?CALINFO_ENUMPROCEXA,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumCalendarInfoExW(
    lpCalInfoEnumProcEx: ?CALINFO_ENUMPROCEXW,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumTimeFormatsA(
    lpTimeFmtEnumProc: ?TIMEFMT_ENUMPROCA,
    Locale: u32,
    dwFlags: TIME_FORMAT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumTimeFormatsW(
    lpTimeFmtEnumProc: ?TIMEFMT_ENUMPROCW,
    Locale: u32,
    dwFlags: TIME_FORMAT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumDateFormatsA(
    lpDateFmtEnumProc: ?DATEFMT_ENUMPROCA,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumDateFormatsW(
    lpDateFmtEnumProc: ?DATEFMT_ENUMPROCW,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumDateFormatsExA(
    lpDateFmtEnumProcEx: ?DATEFMT_ENUMPROCEXA,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumDateFormatsExW(
    lpDateFmtEnumProcEx: ?DATEFMT_ENUMPROCEXW,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsValidLanguageGroup(
    LanguageGroup: u32,
    dwFlags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNLSVersion(
    Function: u32,
    Locale: u32,
    lpVersionInformation: ?*NLSVERSIONINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsValidLocale(
    Locale: u32,
    dwFlags: IS_VALID_LOCALE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetGeoInfoA(
    Location: i32,
    GeoType: u32,
    lpGeoData: ?[*:0]u8,
    cchData: i32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetGeoInfoW(
    Location: i32,
    GeoType: u32,
    lpGeoData: ?[*:0]u16,
    cchData: i32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn GetGeoInfoEx(
    location: ?PWSTR,
    geoType: u32,
    geoData: ?[*:0]u16,
    geoDataCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn EnumSystemGeoID(
    GeoClass: u32,
    ParentGeoId: i32,
    lpGeoEnumProc: ?GEO_ENUMPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn EnumSystemGeoNames(
    geoClass: u32,
    geoEnumProc: ?GEO_ENUMNAMEPROC,
    data: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetUserGeoID(
    GeoClass: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn GetUserDefaultGeoName(
    geoName: [*:0]u16,
    geoNameCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetUserGeoID(
    GeoId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn SetUserGeoName(
    geoName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn ConvertDefaultLocale(
    Locale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemDefaultUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetThreadLocale(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetThreadLocale(
    Locale: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetUserDefaultUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetUserDefaultLangID(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemDefaultLangID(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemDefaultLCID(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetUserDefaultLCID(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadUILanguage(
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetThreadUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetProcessPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?[*]u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetProcessPreferredUILanguages(
    dwFlags: u32,
    pwszLanguagesBuffer: ?[*]const u16,
    pulNumLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetUserPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?[*]u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?[*]u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetThreadPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?[*]u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadPreferredUILanguages(
    dwFlags: u32,
    pwszLanguagesBuffer: ?[*]const u16,
    pulNumLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileMUIInfo(
    dwFlags: u32,
    pcwszFilePath: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pFileMUIInfo: ?*FILEMUIINFO,
    pcbFileMUIInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileMUIPath(
    dwFlags: u32,
    pcwszFilePath: ?[*:0]const u16,
    pwszLanguage: ?[*:0]u16,
    pcchLanguage: ?*u32,
    pwszFileMUIPath: ?[*:0]u16,
    pcchFileMUIPath: ?*u32,
    pululEnumerator: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetUILanguageInfo(
    dwFlags: u32,
    pwmszLanguage: ?[*]const u16,
    pwszFallbackLanguages: ?[*]u16,
    pcchFallbackLanguages: ?*u32,
    pAttributes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadPreferredUILanguages2(
    flags: u32,
    languages: ?[*]const u16,
    numLanguagesSet: ?*u32,
    snapshot: ?*?HSAVEDUILANGUAGES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RestoreThreadPreferredUILanguages(
    snapshot: ?HSAVEDUILANGUAGES,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn NotifyUILanguageChange(
    dwFlags: u32,
    pcwstrNewLanguage: ?[*:0]const u16,
    pcwstrPreviousLanguage: ?[*:0]const u16,
    dwReserved: u32,
    pdwStatusRtrn: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetStringTypeExA(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: [*:0]const u8,
    cchSrc: i32,
    lpCharType: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetStringTypeA(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: [*:0]const u8,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn FoldStringA(
    dwMapFlags: FOLD_STRING_MAP_FLAGS,
    lpSrcStr: [*:0]const u8,
    cchSrc: i32,
    lpDestStr: ?[*:0]u8,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemLocalesA(
    lpLocaleEnumProc: ?LOCALE_ENUMPROCA,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemLocalesW(
    lpLocaleEnumProc: ?LOCALE_ENUMPROCW,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemLanguageGroupsA(
    lpLanguageGroupEnumProc: ?LANGUAGEGROUP_ENUMPROCA,
    dwFlags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemLanguageGroupsW(
    lpLanguageGroupEnumProc: ?LANGUAGEGROUP_ENUMPROCW,
    dwFlags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumLanguageGroupLocalesA(
    lpLangGroupLocaleEnumProc: ?LANGGROUPLOCALE_ENUMPROCA,
    LanguageGroup: u32,
    dwFlags: u32,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumLanguageGroupLocalesW(
    lpLangGroupLocaleEnumProc: ?LANGGROUPLOCALE_ENUMPROCW,
    LanguageGroup: u32,
    dwFlags: u32,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumUILanguagesA(
    lpUILanguageEnumProc: ?UILANGUAGE_ENUMPROCA,
    dwFlags: u32,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumUILanguagesW(
    lpUILanguageEnumProc: ?UILANGUAGE_ENUMPROCW,
    dwFlags: u32,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemCodePagesA(
    lpCodePageEnumProc: ?CODEPAGE_ENUMPROCA,
    dwFlags: ENUM_SYSTEM_CODE_PAGES_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn EnumSystemCodePagesW(
    lpCodePageEnumProc: ?CODEPAGE_ENUMPROCW,
    dwFlags: ENUM_SYSTEM_CODE_PAGES_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "NORMALIZ" fn IdnToAscii(
    dwFlags: u32,
    lpUnicodeCharStr: [*:0]const u16,
    cchUnicodeChar: i32,
    lpASCIICharStr: ?[*:0]u16,
    cchASCIIChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "NORMALIZ" fn IdnToUnicode(
    dwFlags: u32,
    lpASCIICharStr: [*:0]const u16,
    cchASCIIChar: i32,
    lpUnicodeCharStr: ?[*:0]u16,
    cchUnicodeChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IdnToNameprepUnicode(
    dwFlags: u32,
    lpUnicodeCharStr: [*:0]const u16,
    cchUnicodeChar: i32,
    lpNameprepCharStr: ?[*:0]u16,
    cchNameprepChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn NormalizeString(
    NormForm: NORM_FORM,
    lpSrcString: [*:0]const u16,
    cwSrcLength: i32,
    lpDstString: ?[*:0]u16,
    cwDstLength: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsNormalizedString(
    NormForm: NORM_FORM,
    lpString: [*:0]const u16,
    cwLength: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn VerifyScripts(
    dwFlags: u32,
    lpLocaleScripts: ?[*:0]const u16,
    cchLocaleScripts: i32,
    lpTestScripts: ?[*:0]const u16,
    cchTestScripts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetStringScripts(
    dwFlags: u32,
    lpString: ?[*:0]const u16,
    cchString: i32,
    lpScripts: ?[*:0]u16,
    cchScripts: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLocaleInfoEx(
    lpLocaleName: ?[*:0]const u16,
    LCType: u32,
    lpLCData: ?[*:0]u16,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetCalendarInfoEx(
    lpLocaleName: ?[*:0]const u16,
    Calendar: u32,
    lpReserved: ?[*:0]const u16,
    CalType: u32,
    lpCalData: ?[*:0]u16,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumberFormatEx(
    lpLocaleName: ?[*:0]const u16,
    dwFlags: u32,
    lpValue: ?[*:0]const u16,
    lpFormat: ?*const NUMBERFMTW,
    lpNumberStr: ?[*:0]u16,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetCurrencyFormatEx(
    lpLocaleName: ?[*:0]const u16,
    dwFlags: u32,
    lpValue: ?[*:0]const u16,
    lpFormat: ?*const CURRENCYFMTW,
    lpCurrencyStr: ?[*:0]u16,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetUserDefaultLocaleName(
    lpLocaleName: [*:0]u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemDefaultLocaleName(
    lpLocaleName: [*:0]u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsNLSDefinedString(
    Function: u32,
    dwFlags: u32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpString: [*:0]const u16,
    cchStr: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNLSVersionEx(
    function: u32,
    lpLocaleName: ?[*:0]const u16,
    lpVersionInformation: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn IsValidNLSVersion(
    function: u32,
    lpLocaleName: ?[*:0]const u16,
    lpVersionInformation: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindNLSStringEx(
    lpLocaleName: ?[*:0]const u16,
    dwFindNLSStringFlags: u32,
    lpStringSource: [*:0]const u16,
    cchSource: i32,
    lpStringValue: [*:0]const u16,
    cchValue: i32,
    pcchFound: ?*i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*c_void,
    sortHandle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn LCMapStringEx(
    lpLocaleName: ?[*:0]const u16,
    dwMapFlags: u32,
    lpSrcStr: [*:0]const u16,
    cchSrc: i32,
    lpDestStr: ?[*:0]u16,
    cchDest: i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*c_void,
    sortHandle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsValidLocaleName(
    lpLocaleName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn EnumCalendarInfoExEx(
    pCalInfoEnumProcExEx: ?CALINFO_ENUMPROCEXEX,
    lpLocaleName: ?[*:0]const u16,
    Calendar: u32,
    lpReserved: ?[*:0]const u16,
    CalType: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn EnumDateFormatsExEx(
    lpDateFmtEnumProcExEx: ?DATEFMT_ENUMPROCEXEX,
    lpLocaleName: ?[*:0]const u16,
    dwFlags: ENUM_DATE_FORMATS_FLAGS,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn EnumTimeFormatsEx(
    lpTimeFmtEnumProcEx: ?TIMEFMT_ENUMPROCEX,
    lpLocaleName: ?[*:0]const u16,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn EnumSystemLocalesEx(
    lpLocaleEnumProcEx: ?LOCALE_ENUMPROCEX,
    dwFlags: u32,
    lParam: LPARAM,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn ResolveLocaleName(
    lpNameToResolve: ?[*:0]const u16,
    lpLocaleName: ?[*:0]u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmInstallIMEA(
    lpszIMEFileName: ?[*:0]const u8,
    lpszLayoutText: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmInstallIMEW(
    lpszIMEFileName: ?[*:0]const u16,
    lpszLayoutText: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDefaultIMEWnd(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDescriptionA(
    param0: ?HKL,
    lpszDescription: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDescriptionW(
    param0: ?HKL,
    lpszDescription: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetIMEFileNameA(
    param0: ?HKL,
    lpszFileName: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetIMEFileNameW(
    param0: ?HKL,
    lpszFileName: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetProperty(
    param0: ?HKL,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsIME(
    param0: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSimulateHotKey(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmCreateContext(
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDestroyContext(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetContext(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmReleaseContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmAssociateContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmAssociateContextEx(
    param0: ?HWND,
    param1: ?HIMC,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionStringA(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*c_void,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionStringW(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*c_void,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionStringA(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*c_void,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*c_void,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionStringW(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*c_void,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*c_void,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListCountA(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListCountW(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListA(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListW(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetGuideLineA(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetGuideLineW(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PWSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionStatus(
    param0: ?HIMC,
    lpfdwConversion: ?*u32,
    lpfdwSentence: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetConversionStatus(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetOpenStatus(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetOpenStatus(
    param0: ?HIMC,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmConfigureIMEA(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmConfigureIMEW(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEscapeA(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEscapeW(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionListA(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionListW(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmNotifyIME(
    param0: ?HIMC,
    dwAction: NOTIFY_IME_ACTION,
    dwIndex: NOTIFY_IME_INDEX,
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateWindow(
    param0: ?HIMC,
    param1: u32,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCandidateWindow(
    param0: ?HIMC,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsUIMessageA(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsUIMessageW(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetVirtualKey(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRegisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszRegister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRegisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszRegister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmUnregisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszUnregister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmUnregisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszUnregister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetRegisterWordStyleA(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetRegisterWordStyleW(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumRegisterWordA(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCA,
    lpszReading: ?[*:0]const u8,
    param3: u32,
    lpszRegister: ?[*:0]const u8,
    param5: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumRegisterWordW(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCW,
    lpszReading: ?[*:0]const u16,
    param3: u32,
    lpszRegister: ?[*:0]const u16,
    param5: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDisableIME(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumInputContext(
    idThread: u32,
    lpfn: ?IMCENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetImeMenuItemsA(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOA,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOA,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetImeMenuItemsW(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOW,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOW,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDisableTextFrameService(
    idThread: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "IMM32" fn ImmDisableLegacyIME(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingGetServices(
    pOptions: ?*MAPPING_ENUM_OPTIONS,
    prgServices: ?*?*MAPPING_SERVICE_INFO,
    pdwServicesCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingFreeServices(
    pServiceInfo: ?*MAPPING_SERVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingRecognizeText(
    pServiceInfo: ?*MAPPING_SERVICE_INFO,
    pszText: [*:0]const u16,
    dwLength: u32,
    dwIndex: u32,
    pOptions: ?*MAPPING_OPTIONS,
    pbag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingDoAction(
    pBag: ?*MAPPING_PROPERTY_BAG,
    dwRangeIndex: u32,
    pszActionId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingFreePropertyBag(
    pBag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "IMM32" fn ImmGetHotKey(
    param0: u32,
    lpuModifiers: ?*u32,
    lpuVKey: ?*u32,
    phKL: ?*isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmSetHotKey(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGenerateMessage(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRequestMessageA(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRequestMessageW(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "IMM32" fn ImmCreateSoftKeyboard(
    param0: u32,
    param1: ?HWND,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

pub extern "IMM32" fn ImmDestroySoftKeyboard(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmShowSoftKeyboard(
    param0: ?HWND,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmLockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?*INPUTCONTEXT;

pub extern "IMM32" fn ImmUnlockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGetIMCLockCount(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IMM32" fn ImmCreateIMCC(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmDestroyIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmLockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "IMM32" fn ImmUnlockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGetIMCCLockCount(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IMM32" fn ImmReSizeIMCC(
    param0: ?HIMCC,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmGetIMCCSize(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptFreeCache(
    psc: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptItemize(
    pwcInChars: [*:0]const u16,
    cInChars: i32,
    cMaxItems: i32,
    psControl: ?*const SCRIPT_CONTROL,
    psState: ?*const SCRIPT_STATE,
    pItems: [*]SCRIPT_ITEM,
    pcItems: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptLayout(
    cRuns: i32,
    pbLevel: [*:0]const u8,
    piVisualToLogical: ?*i32,
    piLogicalToVisual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptShape(
    hdc: ?HDC,
    psc: ?*?*c_void,
    pwcChars: [*:0]const u16,
    cChars: i32,
    cMaxGlyphs: i32,
    psa: ?*SCRIPT_ANALYSIS,
    pwOutGlyphs: [*:0]u16,
    pwLogClust: ?*u16,
    psva: [*]SCRIPT_VISATTR,
    pcGlyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptPlace(
    hdc: ?HDC,
    psc: ?*?*c_void,
    pwGlyphs: [*:0]const u16,
    cGlyphs: i32,
    psva: [*]const SCRIPT_VISATTR,
    psa: ?*SCRIPT_ANALYSIS,
    piAdvance: ?*i32,
    pGoffset: ?*GOFFSET,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptTextOut(
    hdc: ?HDC,
    psc: ?*?*c_void,
    x: i32,
    y: i32,
    fuOptions: u32,
    lprc: ?*const RECT,
    psa: ?*const SCRIPT_ANALYSIS,
    pwcReserved: ?[*:0]const u16,
    iReserved: i32,
    pwGlyphs: [*:0]const u16,
    cGlyphs: i32,
    piAdvance: [*]const i32,
    piJustify: ?[*]const i32,
    pGoffset: [*]const GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptJustify(
    psva: [*]const SCRIPT_VISATTR,
    piAdvance: [*]const i32,
    cGlyphs: i32,
    iDx: i32,
    iMinKashida: i32,
    piJustify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptBreak(
    pwcChars: [*:0]const u16,
    cChars: i32,
    psa: ?*const SCRIPT_ANALYSIS,
    psla: ?*SCRIPT_LOGATTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptCPtoX(
    iCP: i32,
    fTrailing: BOOL,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    piAdvance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    piX: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptXtoCP(
    iX: i32,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    piAdvance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    piCP: ?*i32,
    piTrailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptGetLogicalWidths(
    psa: ?*const SCRIPT_ANALYSIS,
    cChars: i32,
    cGlyphs: i32,
    piGlyphWidth: [*]const i32,
    pwLogClust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    piDx: [*]i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptApplyLogicalWidth(
    piDx: [*]const i32,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    piAdvance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    pABC: ?*ABC,
    piJustify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptGetCMap(
    hdc: ?HDC,
    psc: ?*?*c_void,
    pwcInChars: [*:0]const u16,
    cChars: i32,
    dwFlags: u32,
    pwOutGlyphs: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptGetGlyphABCWidth(
    hdc: ?HDC,
    psc: ?*?*c_void,
    wGlyph: u16,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptGetProperties(
    ppSp: ?*const ?*?*SCRIPT_PROPERTIES,
    piNumScripts: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptGetFontProperties(
    hdc: ?HDC,
    psc: ?*?*c_void,
    sfp: ?*SCRIPT_FONTPROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptCacheGetHeight(
    hdc: ?HDC,
    psc: ?*?*c_void,
    tmHeight: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringAnalyse(
    hdc: ?HDC,
    pString: ?*const c_void,
    cString: i32,
    cGlyphs: i32,
    iCharset: i32,
    dwFlags: u32,
    iReqWidth: i32,
    psControl: ?*SCRIPT_CONTROL,
    psState: ?*SCRIPT_STATE,
    piDx: ?[*]const i32,
    pTabdef: ?*SCRIPT_TABDEF,
    pbInClass: ?*const u8,
    pssa: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringFree(
    pssa: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptString_pSize(
    ssa: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*SIZE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptString_pcOutChars(
    ssa: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptString_pLogAttr(
    ssa: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*SCRIPT_LOGATTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringGetOrder(
    ssa: ?*c_void,
    puOrder: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringCPtoX(
    ssa: ?*c_void,
    icp: i32,
    fTrailing: BOOL,
    pX: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringXtoCP(
    ssa: ?*c_void,
    iX: i32,
    piCh: ?*i32,
    piTrailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringGetLogicalWidths(
    ssa: ?*c_void,
    piDx: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringValidate(
    ssa: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptStringOut(
    ssa: ?*c_void,
    iX: i32,
    iY: i32,
    uOptions: ETO_OPTIONS,
    prc: ?*const RECT,
    iMinSel: i32,
    iMaxSel: i32,
    fDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptIsComplex(
    pwcInChars: [*:0]const u16,
    cInChars: i32,
    dwFlags: SCRIPT_IS_COMPLEX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptRecordDigitSubstitution(
    Locale: u32,
    psds: ?*SCRIPT_DIGITSUBSTITUTE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USP10" fn ScriptApplyDigitSubstitution(
    psds: ?*const SCRIPT_DIGITSUBSTITUTE,
    psc: ?*SCRIPT_CONTROL,
    pss: ?*SCRIPT_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptShapeOpenType(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    rcRangeChars: ?[*]i32,
    rpRangeProperties: ?[*]?*textrange_properties,
    cRanges: i32,
    pwcChars: [*:0]const u16,
    cChars: i32,
    cMaxGlyphs: i32,
    pwLogClust: ?*u16,
    pCharProps: ?*script_charprop,
    pwOutGlyphs: [*:0]u16,
    pOutGlyphProps: [*]script_glyphprop,
    pcGlyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptPlaceOpenType(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    rcRangeChars: ?[*]i32,
    rpRangeProperties: ?[*]?*textrange_properties,
    cRanges: i32,
    pwcChars: [*:0]const u16,
    pwLogClust: [*:0]u16,
    pCharProps: [*]script_charprop,
    cChars: i32,
    pwGlyphs: [*:0]const u16,
    pGlyphProps: [*]const script_glyphprop,
    cGlyphs: i32,
    piAdvance: ?*i32,
    pGoffset: ?*GOFFSET,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptItemizeOpenType(
    pwcInChars: [*:0]const u16,
    cInChars: i32,
    cMaxItems: i32,
    psControl: ?*const SCRIPT_CONTROL,
    psState: ?*const SCRIPT_STATE,
    pItems: [*]SCRIPT_ITEM,
    pScriptTags: [*]u32,
    pcItems: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptGetFontScriptTags(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    cMaxTags: i32,
    pScriptTags: [*]u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptGetFontLanguageTags(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    cMaxTags: i32,
    pLangsysTags: [*]u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptGetFontFeatureTags(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    cMaxTags: i32,
    pFeatureTags: [*]u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptGetFontAlternateGlyphs(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    wGlyphId: u16,
    cMaxAlternates: i32,
    pAlternateGlyphs: [*:0]u16,
    pcAlternates: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptSubstituteSingleGlyph(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    lParameter: i32,
    wGlyphId: u16,
    pwOutGlyphId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USP10" fn ScriptPositionSingleGlyph(
    hdc: ?HDC,
    psc: ?*?*c_void,
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    lParameter: i32,
    wGlyphId: u16,
    iAdvance: i32,
    GOffset: GOFFSET,
    piOutAdvance: ?*i32,
    pOutGoffset: ?*GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "icu" fn utf8_nextCharSafeBody(
    s: ?*const u8,
    pi: ?*i32,
    length: i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_appendCharSafeBody(
    s: ?*u8,
    i: i32,
    length: i32,
    c: i32,
    pIsError: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_prevCharSafeBody(
    s: ?*const u8,
    start: i32,
    pi: ?*i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_back1SafeBody(
    s: ?*const u8,
    start: i32,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_versionFromString(
    versionArray: ?*u8,
    versionString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_versionFromUString(
    versionArray: ?*u8,
    versionString: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_versionToString(
    versionArray: ?*const u8,
    versionString: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getVersion(
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_errorName(
    code: UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn utrace_setLevel(
    traceLevel: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_getLevel(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_setFunctions(
    context: ?*const c_void,
    e: ?UTraceEntry,
    x: ?UTraceExit,
    d: ?UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_getFunctions(
    context: ?*const ?*c_void,
    e: ?*?UTraceEntry,
    x: ?*?UTraceExit,
    d: ?*?UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_vformat(
    outBuf: ?PSTR,
    capacity: i32,
    indent: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_format(
    outBuf: ?PSTR,
    capacity: i32,
    indent: i32,
    fmt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_functionName(
    fnNumber: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_shapeArabic(
    source: ?*const u16,
    sourceLength: i32,
    dest: ?*u16,
    destSize: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getCode(
    nameOrAbbrOrLocale: ?[*:0]const u8,
    fillIn: ?*UScriptCode,
    capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getName(
    scriptCode: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uscript_getShortName(
    scriptCode: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uscript_getScript(
    codepoint: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UScriptCode;

pub extern "icu" fn uscript_hasScript(
    c: i32,
    sc: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_getScriptExtensions(
    c: i32,
    scripts: ?*UScriptCode,
    capacity: i32,
    errorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getSampleString(
    script: UScriptCode,
    dest: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getUsage(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) UScriptUsage;

pub extern "icu" fn uscript_isRightToLeft(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_breaksBetweenLetters(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_isCased(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uiter_current32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_next32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_previous32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_getState(
    iter: ?*const UCharIterator,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn uiter_setState(
    iter: ?*UCharIterator,
    state: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setString(
    iter: ?*UCharIterator,
    s: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setUTF16BE(
    iter: ?*UCharIterator,
    s: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setUTF8(
    iter: ?*UCharIterator,
    s: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_close(
    en: ?*UEnumeration,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_count(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uenum_unext(
    en: ?*UEnumeration,
    resultLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uenum_next(
    en: ?*UEnumeration,
    resultLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uenum_reset(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_openUCharStringsEnumeration(
    strings: ?*const ?*u16,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uenum_openCharStringsEnumeration(
    strings: ?*const ?*i8,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uloc_getDefault(
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_setDefault(
    localeID: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uloc_getLanguage(
    localeID: ?[*:0]const u8,
    language: ?PSTR,
    languageCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getScript(
    localeID: ?[*:0]const u8,
    script: ?PSTR,
    scriptCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getCountry(
    localeID: ?[*:0]const u8,
    country: ?PSTR,
    countryCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getVariant(
    localeID: ?[*:0]const u8,
    variant: ?PSTR,
    variantCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getName(
    localeID: ?[*:0]const u8,
    name: ?PSTR,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_canonicalize(
    localeID: ?[*:0]const u8,
    name: ?PSTR,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getISO3Language(
    localeID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_getISO3Country(
    localeID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_getLCID(
    localeID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn uloc_getDisplayLanguage(
    locale: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    language: ?*u16,
    languageCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayScript(
    locale: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    script: ?*u16,
    scriptCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayCountry(
    locale: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    country: ?*u16,
    countryCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayVariant(
    locale: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    variant: ?*u16,
    variantCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayKeyword(
    keyword: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayKeywordValue(
    locale: ?[*:0]const u8,
    keyword: ?[*:0]const u8,
    displayLocale: ?[*:0]const u8,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayName(
    localeID: ?[*:0]const u8,
    inLocaleID: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getAvailable(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getISOLanguages(
) callconv(@import("std").os.windows.WINAPI) ?*?*i8;

pub extern "icu" fn uloc_getISOCountries(
) callconv(@import("std").os.windows.WINAPI) ?*?*i8;

pub extern "icu" fn uloc_getParent(
    localeID: ?[*:0]const u8,
    parent: ?PSTR,
    parentCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getBaseName(
    localeID: ?[*:0]const u8,
    name: ?PSTR,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_openKeywords(
    localeID: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uloc_getKeywordValue(
    localeID: ?[*:0]const u8,
    keywordName: ?[*:0]const u8,
    buffer: ?PSTR,
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_setKeywordValue(
    keywordName: ?[*:0]const u8,
    keywordValue: ?[*:0]const u8,
    buffer: ?PSTR,
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_isRightToLeft(
    locale: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uloc_getCharacterOrientation(
    localeId: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

pub extern "icu" fn uloc_getLineOrientation(
    localeId: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

pub extern "icu" fn uloc_acceptLanguageFromHTTP(
    result: ?PSTR,
    resultAvailable: i32,
    outResult: ?*UAcceptResult,
    httpAcceptLanguage: ?[*:0]const u8,
    availableLocales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_acceptLanguage(
    result: ?PSTR,
    resultAvailable: i32,
    outResult: ?*UAcceptResult,
    acceptList: ?*const ?*i8,
    acceptListCount: i32,
    availableLocales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getLocaleForLCID(
    hostID: u32,
    locale: ?PSTR,
    localeCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_addLikelySubtags(
    localeID: ?[*:0]const u8,
    maximizedLocaleID: ?PSTR,
    maximizedLocaleIDCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_minimizeSubtags(
    localeID: ?[*:0]const u8,
    minimizedLocaleID: ?PSTR,
    minimizedLocaleIDCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_forLanguageTag(
    langtag: ?[*:0]const u8,
    localeID: ?PSTR,
    localeIDCapacity: i32,
    parsedLength: ?*i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_toLanguageTag(
    localeID: ?[*:0]const u8,
    langtag: ?PSTR,
    langtagCapacity: i32,
    strict: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_toUnicodeLocaleKey(
    keyword: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toUnicodeLocaleType(
    keyword: ?[*:0]const u8,
    value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toLegacyKey(
    keyword: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toLegacyType(
    keyword: ?[*:0]const u8,
    value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_open(
    packageName: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_openDirect(
    packageName: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_openU(
    packageName: ?*const u16,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_close(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_getVersion(
    resB: ?*const UResourceBundle,
    versionInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_getLocaleByType(
    resourceBundle: ?*const UResourceBundle,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getString(
    resourceBundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8String(
    resB: ?*const UResourceBundle,
    dest: ?PSTR,
    length: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getBinary(
    resourceBundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "icu" fn ures_getIntVector(
    resourceBundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn ures_getUInt(
    resourceBundle: ?*const UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ures_getInt(
    resourceBundle: ?*const UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ures_getSize(
    resourceBundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ures_getType(
    resourceBundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) UResType;

pub extern "icu" fn ures_getKey(
    resourceBundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_resetIterator(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_hasNext(
    resourceBundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ures_getNextResource(
    resourceBundle: ?*UResourceBundle,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getNextString(
    resourceBundle: ?*UResourceBundle,
    len: ?*i32,
    key: ?*const ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getByIndex(
    resourceBundle: ?*const UResourceBundle,
    indexR: i32,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getStringByIndex(
    resourceBundle: ?*const UResourceBundle,
    indexS: i32,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8StringByIndex(
    resB: ?*const UResourceBundle,
    stringIndex: i32,
    dest: ?PSTR,
    pLength: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getByKey(
    resourceBundle: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getStringByKey(
    resB: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8StringByKey(
    resB: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    dest: ?PSTR,
    pLength: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_openAvailableLocales(
    packageName: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uldn_open(
    locale: ?[*:0]const u8,
    dialectHandling: UDialectHandling,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

pub extern "icu" fn uldn_close(
    ldn: ?*ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uldn_getLocale(
    ldn: ?*const ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uldn_getDialectHandling(
    ldn: ?*const ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) UDialectHandling;

pub extern "icu" fn uldn_localeDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    locale: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_languageDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    lang: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_scriptDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    script: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_scriptCodeDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    scriptCode: UScriptCode,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_regionDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    region: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_variantDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    variant: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_keyDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    key: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_keyValueDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    key: ?[*:0]const u8,
    value: ?[*:0]const u8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_openForContext(
    locale: ?[*:0]const u8,
    contexts: ?*UDisplayContext,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

pub extern "icu" fn uldn_getContext(
    ldn: ?*const ULocaleDisplayNames,
    type: UDisplayContextType,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn ucurr_forLocale(
    locale: ?[*:0]const u8,
    buff: ?*u16,
    buffCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_register(
    isoCode: ?*const u16,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "icu" fn ucurr_unregister(
    key: ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucurr_getName(
    currency: ?*const u16,
    locale: ?[*:0]const u8,
    nameStyle: UCurrNameStyle,
    isChoiceFormat: ?*i8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucurr_getPluralName(
    currency: ?*const u16,
    locale: ?[*:0]const u8,
    isChoiceFormat: ?*i8,
    pluralCount: ?[*:0]const u8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucurr_getDefaultFractionDigits(
    currency: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getDefaultFractionDigitsForUsage(
    currency: ?*const u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getRoundingIncrement(
    currency: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucurr_getRoundingIncrementForUsage(
    currency: ?*const u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucurr_openISOCurrencies(
    currType: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucurr_isAvailable(
    isoCode: ?*const u16,
    from: f64,
    to: f64,
    errorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucurr_countCurrencies(
    locale: ?[*:0]const u8,
    date: f64,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_forLocaleAndDate(
    locale: ?[*:0]const u8,
    date: f64,
    index: i32,
    buff: ?*u16,
    buffCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucurr_getNumericCode(
    currency: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_STOP(
    context: ?*const c_void,
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*const u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_STOP(
    context: ?*const c_void,
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_SKIP(
    context: ?*const c_void,
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*const u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_SUBSTITUTE(
    context: ?*const c_void,
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*const u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_ESCAPE(
    context: ?*const c_void,
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*const u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_SKIP(
    context: ?*const c_void,
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_SUBSTITUTE(
    context: ?*const c_void,
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_ESCAPE(
    context: ?*const c_void,
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_compareNames(
    name1: ?[*:0]const u8,
    name2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_open(
    converterName: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openU(
    name: ?*const u16,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openCCSID(
    codepage: i32,
    platform: UConverterPlatform,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openPackage(
    packageName: ?[*:0]const u8,
    converterName: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_safeClone(
    cnv: ?*const UConverter,
    stackBuffer: ?*c_void,
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_close(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getSubstChars(
    converter: ?*const UConverter,
    subChars: ?PSTR,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setSubstChars(
    converter: ?*UConverter,
    subChars: ?[*:0]const u8,
    len: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setSubstString(
    cnv: ?*UConverter,
    s: ?*const u16,
    length: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getInvalidChars(
    converter: ?*const UConverter,
    errBytes: ?PSTR,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getInvalidUChars(
    converter: ?*const UConverter,
    errUChars: ?*u16,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_reset(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_resetToUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_resetFromUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getMaxCharSize(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_getMinCharSize(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_getDisplayName(
    converter: ?*const UConverter,
    displayLocale: ?[*:0]const u8,
    displayName: ?*u16,
    displayNameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getName(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getCCSID(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getPlatform(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UConverterPlatform;

pub extern "icu" fn ucnv_getType(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) UConverterType;

pub extern "icu" fn ucnv_getStarters(
    converter: ?*const UConverter,
    starters: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getUnicodeSet(
    cnv: ?*const UConverter,
    setFillIn: ?*USet,
    whichSet: UConverterUnicodeSet,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getToUCallBack(
    converter: ?*const UConverter,
    action: ?*?UConverterToUCallback,
    context: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getFromUCallBack(
    converter: ?*const UConverter,
    action: ?*?UConverterFromUCallback,
    context: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setToUCallBack(
    converter: ?*UConverter,
    newAction: ?UConverterToUCallback,
    newContext: ?*const c_void,
    oldAction: ?*?UConverterToUCallback,
    oldContext: ?*const ?*c_void,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setFromUCallBack(
    converter: ?*UConverter,
    newAction: ?UConverterFromUCallback,
    newContext: ?*const c_void,
    oldAction: ?*?UConverterFromUCallback,
    oldContext: ?*const ?*c_void,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fromUnicode(
    converter: ?*UConverter,
    target: ?*?*i8,
    targetLimit: ?[*:0]const u8,
    source: ?*const ?*u16,
    sourceLimit: ?*const u16,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_toUnicode(
    converter: ?*UConverter,
    target: ?*?*u16,
    targetLimit: ?*const u16,
    source: ?*const ?*i8,
    sourceLimit: ?[*:0]const u8,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fromUChars(
    cnv: ?*UConverter,
    dest: ?PSTR,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toUChars(
    cnv: ?*UConverter,
    dest: ?*u16,
    destCapacity: i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getNextUChar(
    converter: ?*UConverter,
    source: ?*const ?*i8,
    sourceLimit: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_convertEx(
    targetCnv: ?*UConverter,
    sourceCnv: ?*UConverter,
    target: ?*?*i8,
    targetLimit: ?[*:0]const u8,
    source: ?*const ?*i8,
    sourceLimit: ?[*:0]const u8,
    pivotStart: ?*u16,
    pivotSource: ?*?*u16,
    pivotTarget: ?*?*u16,
    pivotLimit: ?*const u16,
    reset: i8,
    flush: i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_convert(
    toConverterName: ?[*:0]const u8,
    fromConverterName: ?[*:0]const u8,
    target: ?PSTR,
    targetCapacity: i32,
    source: ?[*:0]const u8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toAlgorithmic(
    algorithmicType: UConverterType,
    cnv: ?*UConverter,
    target: ?PSTR,
    targetCapacity: i32,
    source: ?[*:0]const u8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_fromAlgorithmic(
    cnv: ?*UConverter,
    algorithmicType: UConverterType,
    target: ?PSTR,
    targetCapacity: i32,
    source: ?[*:0]const u8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_flushCache(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getAvailableName(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_openAllNames(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnv_countAliases(
    alias: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "icu" fn ucnv_getAlias(
    alias: ?[*:0]const u8,
    n: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getAliases(
    alias: ?[*:0]const u8,
    aliases: ?*const ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_openStandardNames(
    convName: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnv_countStandards(
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "icu" fn ucnv_getStandard(
    n: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getStandardName(
    name: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getCanonicalName(
    alias: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getDefaultName(
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_setDefaultName(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fixFileSeparator(
    cnv: ?*const UConverter,
    source: ?*u16,
    sourceLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_isAmbiguous(
    cnv: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_setFallback(
    cnv: ?*UConverter,
    usesFallback: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_usesFallback(
    cnv: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_detectUnicodeSignature(
    source: ?[*:0]const u8,
    sourceLength: i32,
    signatureLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_fromUCountPending(
    cnv: ?*const UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toUCountPending(
    cnv: ?*const UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_isFixedWidth(
    cnv: ?*UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_cbFromUWriteBytes(
    args: ?*UConverterFromUnicodeArgs,
    source: ?[*:0]const u8,
    length: i32,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbFromUWriteSub(
    args: ?*UConverterFromUnicodeArgs,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbFromUWriteUChars(
    args: ?*UConverterFromUnicodeArgs,
    source: ?*const ?*u16,
    sourceLimit: ?*const u16,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbToUWriteUChars(
    args: ?*UConverterToUnicodeArgs,
    source: ?*const u16,
    length: i32,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbToUWriteSub(
    args: ?*UConverterToUnicodeArgs,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_init(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_cleanup(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_setMemoryFunctions(
    context: ?*const c_void,
    a: ?*?UMemAllocFn,
    r: ?*?UMemReallocFn,
    f: ?*?UMemFreeFn,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_catopen(
    name: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn u_catclose(
    catd: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_catgets(
    catd: ?*UResourceBundle,
    set_num: i32,
    msg_num: i32,
    s: ?*const u16,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_hasBinaryProperty(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isUAlphabetic(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isULowercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isUUppercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isUWhiteSpace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_getIntPropertyValue(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getIntPropertyMinValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getIntPropertyMaxValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getNumericValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn u_islower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_istitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isalpha(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isalnum(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isxdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_ispunct(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isgraph(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isblank(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isdefined(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isspace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaSpaceChar(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isWhitespace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_iscntrl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isISOControl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isprint(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isbase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_charDirection(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub extern "icu" fn u_isMirrored(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_charMirror(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getBidiPairedBracket(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charType(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_enumCharTypes(
    enumRange: ?*?UCharEnumTypeRange,
    context: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getCombiningClass(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn u_charDigitValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ublock_getCode(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UBlockCode;

pub extern "icu" fn u_charName(
    code: i32,
    nameChoice: UCharNameChoice,
    buffer: ?PSTR,
    bufferLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charFromName(
    nameChoice: UCharNameChoice,
    name: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_enumCharNames(
    start: i32,
    limit: i32,
    @"fn": ?*?UEnumCharNamesFn,
    context: ?*c_void,
    nameChoice: UCharNameChoice,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getPropertyName(
    property: UProperty,
    nameChoice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_getPropertyEnum(
    alias: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) UProperty;

pub extern "icu" fn u_getPropertyValueName(
    property: UProperty,
    value: i32,
    nameChoice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_getPropertyValueEnum(
    property: UProperty,
    alias: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_isIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isIDIgnorable(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_tolower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_toupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_totitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_foldCase(
    c: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_digit(
    ch: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_forDigit(
    digit: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charAge(
    c: i32,
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getUnicodeVersion(
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getFC_NFKC_Closure(
    c: i32,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_open(
) callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

pub extern "icu" fn ubidi_openSized(
    maxLength: i32,
    maxRunCount: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

pub extern "icu" fn ubidi_close(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setInverse(
    pBiDi: ?*UBiDi,
    isInverse: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_isInverse(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubidi_orderParagraphsLTR(
    pBiDi: ?*UBiDi,
    orderParagraphsLTR: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_isOrderParagraphsLTR(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubidi_setReorderingMode(
    pBiDi: ?*UBiDi,
    reorderingMode: UBiDiReorderingMode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getReorderingMode(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiReorderingMode;

pub extern "icu" fn ubidi_setReorderingOptions(
    pBiDi: ?*UBiDi,
    reorderingOptions: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getReorderingOptions(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ubidi_setContext(
    pBiDi: ?*UBiDi,
    prologue: ?*const u16,
    proLength: i32,
    epilogue: ?*const u16,
    epiLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setPara(
    pBiDi: ?*UBiDi,
    text: ?*const u16,
    length: i32,
    paraLevel: u8,
    embeddingLevels: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setLine(
    pParaBiDi: ?*const UBiDi,
    start: i32,
    limit: i32,
    pLineBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getDirection(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getBaseDirection(
    text: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getText(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ubidi_getLength(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParaLevel(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn ubidi_countParagraphs(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParagraph(
    pBiDi: ?*const UBiDi,
    charIndex: i32,
    pParaStart: ?*i32,
    pParaLimit: ?*i32,
    pParaLevel: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParagraphByIndex(
    pBiDi: ?*const UBiDi,
    paraIndex: i32,
    pParaStart: ?*i32,
    pParaLimit: ?*i32,
    pParaLevel: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getLevelAt(
    pBiDi: ?*const UBiDi,
    charIndex: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn ubidi_getLevels(
    pBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "icu" fn ubidi_getLogicalRun(
    pBiDi: ?*const UBiDi,
    logicalPosition: i32,
    pLogicalLimit: ?*i32,
    pLevel: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_countRuns(
    pBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getVisualRun(
    pBiDi: ?*UBiDi,
    runIndex: i32,
    pLogicalStart: ?*i32,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getVisualIndex(
    pBiDi: ?*UBiDi,
    logicalIndex: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getLogicalIndex(
    pBiDi: ?*UBiDi,
    visualIndex: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getLogicalMap(
    pBiDi: ?*UBiDi,
    indexMap: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getVisualMap(
    pBiDi: ?*UBiDi,
    indexMap: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_reorderLogical(
    levels: ?*const u8,
    length: i32,
    indexMap: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_reorderVisual(
    levels: ?*const u8,
    length: i32,
    indexMap: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_invertMap(
    srcMap: ?*const i32,
    destMap: ?*i32,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getProcessedLength(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getResultLength(
    pBiDi: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getCustomizedClass(
    pBiDi: ?*UBiDi,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub extern "icu" fn ubidi_setClassCallback(
    pBiDi: ?*UBiDi,
    newFn: ?UBiDiClassCallback,
    newContext: ?*const c_void,
    oldFn: ?*?UBiDiClassCallback,
    oldContext: ?*const ?*c_void,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getClassCallback(
    pBiDi: ?*UBiDi,
    @"fn": ?*?UBiDiClassCallback,
    context: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_writeReordered(
    pBiDi: ?*UBiDi,
    dest: ?*u16,
    destSize: i32,
    options: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_writeReverse(
    src: ?*const u16,
    srcLength: i32,
    dest: ?*u16,
    destSize: i32,
    options: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubiditransform_transform(
    pBiDiTransform: ?*UBiDiTransform,
    src: ?*const u16,
    srcLength: i32,
    dest: ?*u16,
    destSize: i32,
    inParaLevel: u8,
    inOrder: UBiDiOrder,
    outParaLevel: u8,
    outOrder: UBiDiOrder,
    doMirroring: UBiDiMirroring,
    shapingOptions: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ubiditransform_open(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDiTransform;

pub extern "icu" fn ubiditransform_close(
    pBidiTransform: ?*UBiDiTransform,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_close(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_openUTF8(
    ut: ?*UText,
    s: ?[*:0]const u8,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_openUChars(
    ut: ?*UText,
    s: ?*const u16,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_clone(
    dest: ?*UText,
    src: ?*const UText,
    deep: i8,
    readOnly: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_equals(
    a: ?*const UText,
    b: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_nativeLength(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_isLengthExpensive(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_char32At(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_current32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_next32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_previous32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_next32From(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_previous32From(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_getNativeIndex(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_setNativeIndex(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_moveIndex32(
    ut: ?*UText,
    delta: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_getPreviousNativeIndex(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_extract(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_isWritable(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_hasMetaData(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_replace(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    replacementText: ?*const u16,
    replacementLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_copy(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    destIndex: i64,
    move: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_freeze(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_setup(
    ut: ?*UText,
    extraSpace: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uset_openEmpty(
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_open(
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_openPattern(
    pattern: ?*const u16,
    patternLength: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_openPatternOptions(
    pattern: ?*const u16,
    patternLength: i32,
    options: u32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_close(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_clone(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_isFrozen(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_freeze(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_cloneAsThawed(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_set(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_applyPattern(
    set: ?*USet,
    pattern: ?*const u16,
    patternLength: i32,
    options: u32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_applyIntPropertyValue(
    set: ?*USet,
    prop: UProperty,
    value: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_applyPropertyAlias(
    set: ?*USet,
    prop: ?*const u16,
    propLength: i32,
    value: ?*const u16,
    valueLength: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_resemblesPattern(
    pattern: ?*const u16,
    patternLength: i32,
    pos: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_toPattern(
    set: ?*const USet,
    result: ?*u16,
    resultCapacity: i32,
    escapeUnprintable: i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_add(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addAll(
    set: ?*USet,
    additionalSet: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addString(
    set: ?*USet,
    str: ?*const u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addAllCodePoints(
    set: ?*USet,
    str: ?*const u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_remove(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeString(
    set: ?*USet,
    str: ?*const u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeAll(
    set: ?*USet,
    removeSet: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_retain(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_retainAll(
    set: ?*USet,
    retain: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_compact(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_complement(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_complementAll(
    set: ?*USet,
    complement: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_clear(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_closeOver(
    set: ?*USet,
    attributes: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeAllStrings(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_isEmpty(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_contains(
    set: ?*const USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsRange(
    set: ?*const USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsString(
    set: ?*const USet,
    str: ?*const u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_indexOf(
    set: ?*const USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_charAt(
    set: ?*const USet,
    charIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_size(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getItemCount(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getItem(
    set: ?*const USet,
    itemIndex: i32,
    start: ?*i32,
    end: ?*i32,
    str: ?*u16,
    strCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_containsAll(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsAllCodePoints(
    set: ?*const USet,
    str: ?*const u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsNone(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsSome(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_span(
    set: ?*const USet,
    s: ?*const u16,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanBack(
    set: ?*const USet,
    s: ?*const u16,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanUTF8(
    set: ?*const USet,
    s: ?[*:0]const u8,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanBackUTF8(
    set: ?*const USet,
    s: ?[*:0]const u8,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_equals(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_serialize(
    set: ?*const USet,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getSerializedSet(
    fillSet: ?*USerializedSet,
    src: ?*const u16,
    srcLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_setSerializedToOne(
    fillSet: ?*USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_serializedContains(
    set: ?*const USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_getSerializedRangeCount(
    set: ?*const USerializedSet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getSerializedRange(
    set: ?*const USerializedSet,
    rangeIndex: i32,
    pStart: ?*i32,
    pEnd: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_getNFCInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFDInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKCInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKDInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKCCasefoldInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getInstance(
    packageName: ?[*:0]const u8,
    name: ?[*:0]const u8,
    mode: UNormalization2Mode,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_openFiltered(
    norm2: ?*const UNormalizer2,
    filterSet: ?*const USet,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_close(
    norm2: ?*UNormalizer2,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unorm2_normalize(
    norm2: ?*const UNormalizer2,
    src: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_normalizeSecondAndAppend(
    norm2: ?*const UNormalizer2,
    first: ?*u16,
    firstLength: i32,
    firstCapacity: i32,
    second: ?*const u16,
    secondLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_append(
    norm2: ?*const UNormalizer2,
    first: ?*u16,
    firstLength: i32,
    firstCapacity: i32,
    second: ?*const u16,
    secondLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getDecomposition(
    norm2: ?*const UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getRawDecomposition(
    norm2: ?*const UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_composePair(
    norm2: ?*const UNormalizer2,
    a: i32,
    b: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getCombiningClass(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn unorm2_isNormalized(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_quickCheck(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UNormalizationCheckResult;

pub extern "icu" fn unorm2_spanQuickCheckYes(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_hasBoundaryBefore(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_hasBoundaryAfter(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_isInert(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm_compare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnvsel_open(
    converterList: ?*const ?*i8,
    converterListSize: i32,
    excludedCodePoints: ?*const USet,
    whichSet: UConverterUnicodeSet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

pub extern "icu" fn ucnvsel_close(
    sel: ?*UConverterSelector,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnvsel_openFromSerialized(
    buffer: ?*const c_void,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

pub extern "icu" fn ucnvsel_serialize(
    sel: ?*const UConverterSelector,
    buffer: ?*c_void,
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnvsel_selectForString(
    sel: ?*const UConverterSelector,
    s: ?*const u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnvsel_selectForUTF8(
    sel: ?*const UConverterSelector,
    s: ?[*:0]const u8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn u_charsToUChars(
    cs: ?[*:0]const u8,
    us: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_UCharsToChars(
    us: ?*const u16,
    cs: ?PSTR,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_strlen(
    s: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_countChar32(
    s: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strHasMoreChar32Than(
    s: ?*const u16,
    length: i32,
    number: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_strcat(
    dst: ?*u16,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strncat(
    dst: ?*u16,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strstr(
    s: ?*const u16,
    substring: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFindFirst(
    s: ?*const u16,
    length: i32,
    substring: ?*const u16,
    subLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strchr(
    s: ?*const u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strchr32(
    s: ?*const u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrstr(
    s: ?*const u16,
    substring: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFindLast(
    s: ?*const u16,
    length: i32,
    substring: ?*const u16,
    subLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrchr(
    s: ?*const u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrchr32(
    s: ?*const u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strpbrk(
    string: ?*const u16,
    matchSet: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strcspn(
    string: ?*const u16,
    matchSet: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strspn(
    string: ?*const u16,
    matchSet: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strtok_r(
    src: ?*u16,
    delim: ?*const u16,
    saveState: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strcmp(
    s1: ?*const u16,
    s2: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCompare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    codePointOrder: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCompareIter(
    iter1: ?*UCharIterator,
    iter2: ?*UCharIterator,
    codePointOrder: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCaseCompare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncmp(
    ucs1: ?*const u16,
    ucs2: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    n: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memcasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    length: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcpy(
    dst: ?*u16,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strncpy(
    dst: ?*u16,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_uastrcpy(
    dst: ?*u16,
    src: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_uastrncpy(
    dst: ?*u16,
    src: ?[*:0]const u8,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_austrcpy(
    dst: ?PSTR,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_austrncpy(
    dst: ?PSTR,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_memcpy(
    dest: ?*u16,
    src: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memmove(
    dest: ?*u16,
    src: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memset(
    dest: ?*u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memcmp(
    buf1: ?*const u16,
    buf2: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memcmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memchr(
    s: ?*const u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memchr32(
    s: ?*const u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memrchr(
    s: ?*const u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memrchr32(
    s: ?*const u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_unescape(
    src: ?[*:0]const u8,
    dest: ?*u16,
    destCapacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_unescapeAt(
    charAt: ?UNESCAPE_CHAR_AT,
    offset: ?*i32,
    length: i32,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToUpper(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    locale: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToLower(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    locale: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToTitle(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    titleIter: ?*UBreakIterator,
    locale: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strFoldCase(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToWCS(
    dest: ?PWSTR,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "icu" fn u_strFromWCS(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?[*:0]const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF8(
    dest: ?PSTR,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromUTF8(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF8WithSub(
    dest: ?PSTR,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromUTF8WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFromUTF8Lenient(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF32(
    dest: ?*i32,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn u_strFromUTF32(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const i32,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF32WithSub(
    dest: ?*i32,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn u_strFromUTF32WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const i32,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToJavaModifiedUTF8(
    dest: ?PSTR,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromJavaModifiedUTF8WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucasemap_open(
    locale: ?[*:0]const u8,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCaseMap;

pub extern "icu" fn ucasemap_close(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_getLocale(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucasemap_getOptions(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucasemap_setLocale(
    csm: ?*UCaseMap,
    locale: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_setOptions(
    csm: ?*UCaseMap,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_getBreakIterator(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ucasemap_setBreakIterator(
    csm: ?*UCaseMap,
    iterToAdopt: ?*UBreakIterator,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_toTitle(
    csm: ?*UCaseMap,
    dest: ?*u16,
    destCapacity: i32,
    src: ?*const u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToLower(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    destCapacity: i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToUpper(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    destCapacity: i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToTitle(
    csm: ?*UCaseMap,
    dest: ?PSTR,
    destCapacity: i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8FoldCase(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    destCapacity: i32,
    src: ?[*:0]const u8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usprep_open(
    path: ?[*:0]const u8,
    fileName: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

pub extern "icu" fn usprep_openByType(
    type: UStringPrepProfileType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

pub extern "icu" fn usprep_close(
    profile: ?*UStringPrepProfile,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usprep_prepare(
    prep: ?*const UStringPrepProfile,
    src: ?*const u16,
    srcLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    options: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_openUTS46(
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UIDNA;

pub extern "icu" fn uidna_close(
    idna: ?*UIDNA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uidna_labelToASCII(
    idna: ?*const UIDNA,
    label: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToUnicode(
    idna: ?*const UIDNA,
    label: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToASCII(
    idna: ?*const UIDNA,
    name: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToUnicode(
    idna: ?*const UIDNA,
    name: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToASCII_UTF8(
    idna: ?*const UIDNA,
    label: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToUnicodeUTF8(
    idna: ?*const UIDNA,
    label: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToASCII_UTF8(
    idna: ?*const UIDNA,
    name: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToUnicodeUTF8(
    idna: ?*const UIDNA,
    name: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_open(
    type: UBreakIteratorType,
    locale: ?[*:0]const u8,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_openRules(
    rules: ?*const u16,
    rulesLength: i32,
    text: ?*const u16,
    textLength: i32,
    parseErr: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_openBinaryRules(
    binaryRules: ?*const u8,
    rulesLength: i32,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_safeClone(
    bi: ?*const UBreakIterator,
    stackBuffer: ?*c_void,
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_close(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_setText(
    bi: ?*UBreakIterator,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_setUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_current(
    bi: ?*const UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_next(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_previous(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_first(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_last(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_preceding(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_following(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getAvailable(
    index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ubrk_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_isBoundary(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubrk_getRuleStatus(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getRuleStatusVec(
    bi: ?*UBreakIterator,
    fillInVec: ?*i32,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getLocaleByType(
    bi: ?*const UBreakIterator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ubrk_refreshUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_getBinaryRules(
    bi: ?*UBreakIterator,
    binaryRules: ?*u8,
    rulesCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getDataVersion(
    dataVersionFillin: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_openTimeZoneIDEnumeration(
    zoneType: USystemTimeZoneType,
    region: ?[*:0]const u8,
    rawOffset: ?*const i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_openTimeZones(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_openCountryTimeZones(
    country: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_getDefaultTimeZone(
    result: ?*u16,
    resultCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_setDefaultTimeZone(
    zoneID: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getDSTSavings(
    zoneID: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getNow(
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_open(
    zoneID: ?*const u16,
    len: i32,
    locale: ?[*:0]const u8,
    type: UCalendarType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn ucal_close(
    cal: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_clone(
    cal: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn ucal_setTimeZone(
    cal: ?*?*c_void,
    zoneID: ?*const u16,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getTimeZoneID(
    cal: ?*const ?*c_void,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneDisplayName(
    cal: ?*const ?*c_void,
    type: UCalendarDisplayNameType,
    locale: ?[*:0]const u8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_inDaylightTime(
    cal: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_setGregorianChange(
    cal: ?*?*c_void,
    date: f64,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getGregorianChange(
    cal: ?*const ?*c_void,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_getAttribute(
    cal: ?*const ?*c_void,
    attr: UCalendarAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_setAttribute(
    cal: ?*?*c_void,
    attr: UCalendarAttribute,
    newValue: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getMillis(
    cal: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_setMillis(
    cal: ?*?*c_void,
    dateTime: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_setDate(
    cal: ?*?*c_void,
    year: i32,
    month: i32,
    date: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_setDateTime(
    cal: ?*?*c_void,
    year: i32,
    month: i32,
    date: i32,
    hour: i32,
    minute: i32,
    second: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_equivalentTo(
    cal1: ?*const ?*c_void,
    cal2: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_add(
    cal: ?*?*c_void,
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_roll(
    cal: ?*?*c_void,
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_get(
    cal: ?*const ?*c_void,
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_set(
    cal: ?*?*c_void,
    field: UCalendarDateFields,
    value: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_isSet(
    cal: ?*const ?*c_void,
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_clearField(
    cal: ?*?*c_void,
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_clear(
    calendar: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getLimit(
    cal: ?*const ?*c_void,
    field: UCalendarDateFields,
    type: UCalendarLimitType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getLocaleByType(
    cal: ?*const ?*c_void,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getTZDataVersion(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getCanonicalTimeZoneID(
    id: ?*const u16,
    len: i32,
    result: ?*u16,
    resultCapacity: i32,
    isSystemID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getType(
    cal: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_getDayOfWeekType(
    cal: ?*const ?*c_void,
    dayOfWeek: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCalendarWeekdayType;

pub extern "icu" fn ucal_getWeekendTransition(
    cal: ?*const ?*c_void,
    dayOfWeek: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_isWeekend(
    cal: ?*const ?*c_void,
    date: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_getFieldDifference(
    cal: ?*?*c_void,
    target: f64,
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneTransitionDate(
    cal: ?*const ?*c_void,
    type: UTimeZoneTransitionType,
    transition: ?*f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_getWindowsTimeZoneID(
    id: ?*const u16,
    len: i32,
    winid: ?*u16,
    winidCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneIDForWindowsID(
    winid: ?*const u16,
    len: i32,
    region: ?[*:0]const u8,
    id: ?*u16,
    idCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_open(
    loc: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_openRules(
    rules: ?*const u16,
    rulesLength: i32,
    normalizationMode: UColAttributeValue,
    strength: UColAttributeValue,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_getContractionsAndExpansions(
    coll: ?*const UCollator,
    contractions: ?*USet,
    expansions: ?*USet,
    addPrefixes: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_close(
    coll: ?*UCollator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_strcoll(
    coll: ?*const UCollator,
    source: ?*const u16,
    sourceLength: i32,
    target: ?*const u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_strcollUTF8(
    coll: ?*const UCollator,
    source: ?[*:0]const u8,
    sourceLength: i32,
    target: ?[*:0]const u8,
    targetLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_greater(
    coll: ?*const UCollator,
    source: ?*const u16,
    sourceLength: i32,
    target: ?*const u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_greaterOrEqual(
    coll: ?*const UCollator,
    source: ?*const u16,
    sourceLength: i32,
    target: ?*const u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_equal(
    coll: ?*const UCollator,
    source: ?*const u16,
    sourceLength: i32,
    target: ?*const u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_strcollIter(
    coll: ?*const UCollator,
    sIter: ?*UCharIterator,
    tIter: ?*UCharIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_getStrength(
    coll: ?*const UCollator,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

pub extern "icu" fn ucol_setStrength(
    coll: ?*UCollator,
    strength: UColAttributeValue,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getReorderCodes(
    coll: ?*const UCollator,
    dest: ?*i32,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setReorderCodes(
    coll: ?*UCollator,
    reorderCodes: ?*const i32,
    reorderCodesLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getEquivalentReorderCodes(
    reorderCode: i32,
    dest: ?*i32,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getDisplayName(
    objLoc: ?[*:0]const u8,
    dispLoc: ?[*:0]const u8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucol_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_openAvailableLocales(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywords(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywordValues(
    keyword: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getFunctionalEquivalent(
    result: ?PSTR,
    resultCapacity: i32,
    keyword: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    isAvailable: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getRules(
    coll: ?*const UCollator,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucol_getSortKey(
    coll: ?*const UCollator,
    source: ?*const u16,
    sourceLength: i32,
    result: ?*u8,
    resultLength: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_nextSortKeyPart(
    coll: ?*const UCollator,
    iter: ?*UCharIterator,
    state: ?*u32,
    dest: ?*u8,
    count: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getBound(
    source: ?*const u8,
    sourceLength: i32,
    boundType: UColBoundMode,
    noOfLevels: u32,
    result: ?*u8,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getVersion(
    coll: ?*const UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getUCAVersion(
    coll: ?*const UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_mergeSortkeys(
    src1: ?*const u8,
    src1Length: i32,
    src2: ?*const u8,
    src2Length: i32,
    dest: ?*u8,
    destCapacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setAttribute(
    coll: ?*UCollator,
    attr: UColAttribute,
    value: UColAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getAttribute(
    coll: ?*const UCollator,
    attr: UColAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

pub extern "icu" fn ucol_setMaxVariable(
    coll: ?*UCollator,
    group: UColReorderCode,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getMaxVariable(
    coll: ?*const UCollator,
) callconv(@import("std").os.windows.WINAPI) UColReorderCode;

pub extern "icu" fn ucol_getVariableTop(
    coll: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucol_safeClone(
    coll: ?*const UCollator,
    stackBuffer: ?*c_void,
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_getRulesEx(
    coll: ?*const UCollator,
    delta: UColRuleOption,
    buffer: ?*u16,
    bufferLen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getLocaleByType(
    coll: ?*const UCollator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucol_getTailoredSet(
    coll: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn ucol_cloneBinary(
    coll: ?*const UCollator,
    buffer: ?*u8,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_openBinary(
    bin: ?*const u8,
    length: i32,
    base: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_openElements(
    coll: ?*const UCollator,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollationElements;

pub extern "icu" fn ucol_keyHashCode(
    key: ?*const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_closeElements(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_reset(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_next(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_previous(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getMaxExpansion(
    elems: ?*const UCollationElements,
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setText(
    elems: ?*UCollationElements,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getOffset(
    elems: ?*const UCollationElements,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setOffset(
    elems: ?*UCollationElements,
    offset: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_primaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_secondaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_tertiaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetDetector;

pub extern "icu" fn ucsdet_close(
    ucsd: ?*UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_setText(
    ucsd: ?*UCharsetDetector,
    textIn: ?[*:0]const u8,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_setDeclaredEncoding(
    ucsd: ?*UCharsetDetector,
    encoding: ?[*:0]const u8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_detect(
    ucsd: ?*UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetMatch;

pub extern "icu" fn ucsdet_detectAll(
    ucsd: ?*UCharsetDetector,
    matchesFound: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*UCharsetMatch;

pub extern "icu" fn ucsdet_getName(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucsdet_getConfidence(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_getLanguage(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucsdet_getUChars(
    ucsm: ?*const UCharsetMatch,
    buf: ?*u16,
    cap: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_getAllDetectableCharsets(
    ucsd: ?*const UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucsdet_isInputFilterEnabled(
    ucsd: ?*const UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucsdet_enableInputFilter(
    ucsd: ?*UCharsetDetector,
    filter: i8,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udatpg_open(
    locale: ?[*:0]const u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udatpg_openEmpty(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udatpg_close(
    dtpg: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_clone(
    dtpg: ?*const ?*c_void,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udatpg_getBestPattern(
    dtpg: ?*?*c_void,
    skeleton: ?*const u16,
    length: i32,
    bestPattern: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getBestPatternWithOptions(
    dtpg: ?*?*c_void,
    skeleton: ?*const u16,
    length: i32,
    options: UDateTimePatternMatchOptions,
    bestPattern: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getSkeleton(
    unusedDtpg: ?*?*c_void,
    pattern: ?*const u16,
    length: i32,
    skeleton: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getBaseSkeleton(
    unusedDtpg: ?*?*c_void,
    pattern: ?*const u16,
    length: i32,
    baseSkeleton: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_addPattern(
    dtpg: ?*?*c_void,
    pattern: ?*const u16,
    patternLength: i32,
    override: i8,
    conflictingPattern: ?*u16,
    capacity: i32,
    pLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDateTimePatternConflict;

pub extern "icu" fn udatpg_setAppendItemFormat(
    dtpg: ?*?*c_void,
    field: UDateTimePatternField,
    value: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getAppendItemFormat(
    dtpg: ?*const ?*c_void,
    field: UDateTimePatternField,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_setAppendItemName(
    dtpg: ?*?*c_void,
    field: UDateTimePatternField,
    value: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getAppendItemName(
    dtpg: ?*const ?*c_void,
    field: UDateTimePatternField,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_getFieldDisplayName(
    dtpg: ?*const ?*c_void,
    field: UDateTimePatternField,
    width: UDateTimePGDisplayWidth,
    fieldName: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_setDateTimeFormat(
    dtpg: ?*const ?*c_void,
    dtFormat: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getDateTimeFormat(
    dtpg: ?*const ?*c_void,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_setDecimal(
    dtpg: ?*?*c_void,
    decimal: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getDecimal(
    dtpg: ?*const ?*c_void,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_replaceFieldTypes(
    dtpg: ?*?*c_void,
    pattern: ?*const u16,
    patternLength: i32,
    skeleton: ?*const u16,
    skeletonLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_replaceFieldTypesWithOptions(
    dtpg: ?*?*c_void,
    pattern: ?*const u16,
    patternLength: i32,
    skeleton: ?*const u16,
    skeletonLength: i32,
    options: UDateTimePatternMatchOptions,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_openSkeletons(
    dtpg: ?*const ?*c_void,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn udatpg_openBaseSkeletons(
    dtpg: ?*const ?*c_void,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn udatpg_getPatternForSkeleton(
    dtpg: ?*const ?*c_void,
    skeleton: ?*const u16,
    skeletonLength: i32,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ufieldpositer_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFieldPositionIterator;

pub extern "icu" fn ufieldpositer_close(
    fpositer: ?*UFieldPositionIterator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ufieldpositer_next(
    fpositer: ?*UFieldPositionIterator,
    beginIndex: ?*i32,
    endIndex: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn ufmt_close(
    fmt: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ufmt_getType(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UFormattableType;

pub extern "icu" fn ufmt_isNumeric(
    fmt: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ufmt_getDate(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ufmt_getDouble(
    fmt: ?*?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ufmt_getLong(
    fmt: ?*?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_getInt64(
    fmt: ?*?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn ufmt_getObject(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "icu" fn ufmt_getUChars(
    fmt: ?*?*c_void,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ufmt_getArrayLength(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_getArrayItemByIndex(
    fmt: ?*?*c_void,
    n: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn ufmt_getDecNumChars(
    fmt: ?*?*c_void,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn udtitvfmt_open(
    locale: ?[*:0]const u8,
    skeleton: ?*const u16,
    skeletonLength: i32,
    tzID: ?*const u16,
    tzIDLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UDateIntervalFormat;

pub extern "icu" fn udtitvfmt_close(
    formatter: ?*UDateIntervalFormat,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udtitvfmt_format(
    formatter: ?*const UDateIntervalFormat,
    fromDate: f64,
    toDate: f64,
    result: ?*u16,
    resultCapacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ugender_getInstance(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UGenderInfo;

pub extern "icu" fn ugender_getListGender(
    genderInfo: ?*const UGenderInfo,
    genders: ?*const UGender,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UGender;

pub extern "icu" fn ulistfmt_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UListFormatter;

pub extern "icu" fn ulistfmt_close(
    listfmt: ?*UListFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulistfmt_format(
    listfmt: ?*const UListFormatter,
    strings: ?*const ?*u16,
    stringLengths: ?*const i32,
    stringCount: i32,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulocdata_open(
    localeID: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleData;

pub extern "icu" fn ulocdata_close(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_setNoSubstitute(
    uld: ?*ULocaleData,
    setting: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getNoSubstitute(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ulocdata_getExemplarSet(
    uld: ?*ULocaleData,
    fillIn: ?*USet,
    options: u32,
    extype: ULocaleDataExemplarSetType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn ulocdata_getDelimiter(
    uld: ?*ULocaleData,
    type: ULocaleDataDelimiterType,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulocdata_getMeasurementSystem(
    localeID: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UMeasurementSystem;

pub extern "icu" fn ulocdata_getPaperSize(
    localeID: ?[*:0]const u8,
    height: ?*i32,
    width: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getCLDRVersion(
    versionArray: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getLocaleDisplayPattern(
    uld: ?*ULocaleData,
    pattern: ?*u16,
    patternCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulocdata_getLocaleSeparator(
    uld: ?*ULocaleData,
    separator: ?*u16,
    separatorCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_formatMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_vformatMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_parseMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    source: ?*const u16,
    sourceLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_vparseMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    source: ?*const u16,
    sourceLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_formatMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_vformatMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    parseError: ?*UParseError,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_parseMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    source: ?*const u16,
    sourceLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_vparseMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    patternLength: i32,
    source: ?*const u16,
    sourceLength: i32,
    ap: ?*i8,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_open(
    pattern: ?*const u16,
    patternLength: i32,
    locale: ?[*:0]const u8,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn umsg_close(
    format: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_clone(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "icu" fn umsg_setLocale(
    fmt: ?*?*c_void,
    locale: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_getLocale(
    fmt: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn umsg_applyPattern(
    fmt: ?*?*c_void,
    pattern: ?*const u16,
    patternLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_toPattern(
    fmt: ?*const ?*c_void,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_format(
    fmt: ?*const ?*c_void,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_vformat(
    fmt: ?*const ?*c_void,
    result: ?*u16,
    resultLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_parse(
    fmt: ?*const ?*c_void,
    source: ?*const u16,
    sourceLength: i32,
    count: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_vparse(
    fmt: ?*const ?*c_void,
    source: ?*const u16,
    sourceLength: i32,
    count: ?*i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_autoQuoteApostrophe(
    pattern: ?*const u16,
    patternLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_open(
    style: UNumberFormatStyle,
    pattern: ?*const u16,
    patternLength: i32,
    locale: ?[*:0]const u8,
    parseErr: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn unum_close(
    fmt: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_clone(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn unum_format(
    fmt: ?*const ?*c_void,
    number: i32,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatInt64(
    fmt: ?*const ?*c_void,
    number: i64,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDouble(
    fmt: ?*const ?*c_void,
    number: f64,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDoubleForFields(
    format: ?*const ?*c_void,
    number: f64,
    result: ?*u16,
    resultLength: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDecimal(
    fmt: ?*const ?*c_void,
    number: ?[*:0]const u8,
    length: i32,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDoubleCurrency(
    fmt: ?*const ?*c_void,
    number: f64,
    currency: ?*u16,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatUFormattable(
    fmt: ?*const ?*c_void,
    number: ?*const ?*c_void,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parse(
    fmt: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parseInt64(
    fmt: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn unum_parseDouble(
    fmt: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_parseDecimal(
    fmt: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    outBuf: ?PSTR,
    outBufLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parseDoubleCurrency(
    fmt: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    currency: ?*u16,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_parseToUFormattable(
    fmt: ?*const ?*c_void,
    result: ?*?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn unum_applyPattern(
    format: ?*?*c_void,
    localized: i8,
    pattern: ?*const u16,
    patternLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unum_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_getAttribute(
    fmt: ?*const ?*c_void,
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setAttribute(
    fmt: ?*?*c_void,
    attr: UNumberFormatAttribute,
    newValue: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getDoubleAttribute(
    fmt: ?*const ?*c_void,
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_setDoubleAttribute(
    fmt: ?*?*c_void,
    attr: UNumberFormatAttribute,
    newValue: f64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getTextAttribute(
    fmt: ?*const ?*c_void,
    tag: UNumberFormatTextAttribute,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setTextAttribute(
    fmt: ?*?*c_void,
    tag: UNumberFormatTextAttribute,
    newValue: ?*const u16,
    newValueLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_toPattern(
    fmt: ?*const ?*c_void,
    isPatternLocalized: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_getSymbol(
    fmt: ?*const ?*c_void,
    symbol: UNumberFormatSymbol,
    buffer: ?*u16,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setSymbol(
    fmt: ?*?*c_void,
    symbol: UNumberFormatSymbol,
    value: ?*const u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getLocaleByType(
    fmt: ?*const ?*c_void,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unum_setContext(
    fmt: ?*?*c_void,
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getContext(
    fmt: ?*const ?*c_void,
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn udat_toCalendarDateField(
    field: UDateFormatField,
) callconv(@import("std").os.windows.WINAPI) UCalendarDateFields;

pub extern "icu" fn udat_open(
    timeStyle: UDateFormatStyle,
    dateStyle: UDateFormatStyle,
    locale: ?[*:0]const u8,
    tzID: ?*const u16,
    tzIDLength: i32,
    pattern: ?*const u16,
    patternLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udat_close(
    format: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getBooleanAttribute(
    fmt: ?*const ?*c_void,
    attr: UDateFormatBooleanAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udat_setBooleanAttribute(
    fmt: ?*?*c_void,
    attr: UDateFormatBooleanAttribute,
    newValue: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_clone(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udat_format(
    format: ?*const ?*c_void,
    dateToFormat: f64,
    result: ?*u16,
    resultLength: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatCalendar(
    format: ?*const ?*c_void,
    calendar: ?*?*c_void,
    result: ?*u16,
    capacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatForFields(
    format: ?*const ?*c_void,
    dateToFormat: f64,
    result: ?*u16,
    resultLength: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatCalendarForFields(
    format: ?*const ?*c_void,
    calendar: ?*?*c_void,
    result: ?*u16,
    capacity: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_parse(
    format: ?*const ?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn udat_parseCalendar(
    format: ?*const ?*c_void,
    calendar: ?*?*c_void,
    text: ?*const u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_isLenient(
    fmt: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udat_setLenient(
    fmt: ?*?*c_void,
    isLenient: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getCalendar(
    fmt: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udat_setCalendar(
    fmt: ?*?*c_void,
    calendarToSet: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getNumberFormat(
    fmt: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udat_getNumberFormatForField(
    fmt: ?*const ?*c_void,
    field: u16,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn udat_adoptNumberFormatForFields(
    fmt: ?*?*c_void,
    fields: ?*const u16,
    numberFormatToSet: ?*?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_setNumberFormat(
    fmt: ?*?*c_void,
    numberFormatToSet: ?*const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_adoptNumberFormat(
    fmt: ?*?*c_void,
    numberFormatToAdopt: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn udat_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_get2DigitYearStart(
    fmt: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn udat_set2DigitYearStart(
    fmt: ?*?*c_void,
    d: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_toPattern(
    fmt: ?*const ?*c_void,
    localized: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_applyPattern(
    format: ?*?*c_void,
    localized: i8,
    pattern: ?*const u16,
    patternLength: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getSymbols(
    fmt: ?*const ?*c_void,
    type: UDateFormatSymbolType,
    symbolIndex: i32,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_countSymbols(
    fmt: ?*const ?*c_void,
    type: UDateFormatSymbolType,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_setSymbols(
    format: ?*?*c_void,
    type: UDateFormatSymbolType,
    symbolIndex: i32,
    value: ?*u16,
    valueLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getLocaleByType(
    fmt: ?*const ?*c_void,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn udat_setContext(
    fmt: ?*?*c_void,
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getContext(
    fmt: ?*const ?*c_void,
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn unumf_openForSkeletonAndLocale(
    skeleton: ?*const u16,
    skeletonLen: i32,
    locale: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberFormatter;

pub extern "icu" fn unumf_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedNumber;

pub extern "icu" fn unumf_formatInt(
    uformatter: ?*const UNumberFormatter,
    value: i64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_formatDouble(
    uformatter: ?*const UNumberFormatter,
    value: f64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_formatDecimal(
    uformatter: ?*const UNumberFormatter,
    value: ?[*:0]const u8,
    valueLen: i32,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_resultToString(
    uresult: ?*const UFormattedNumber,
    buffer: ?*u16,
    bufferCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unumf_resultNextFieldPosition(
    uresult: ?*const UFormattedNumber,
    ufpos: ?*UFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unumf_resultGetAllFieldPositions(
    uresult: ?*const UFormattedNumber,
    ufpositer: ?*UFieldPositionIterator,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_close(
    uformatter: ?*UNumberFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_closeResult(
    uresult: ?*UFormattedNumber,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumsys_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

pub extern "icu" fn unumsys_openByName(
    name: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

pub extern "icu" fn unumsys_close(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumsys_openAvailableNames(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn unumsys_getName(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unumsys_isAlgorithmic(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unumsys_getRadix(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unumsys_getDescription(
    unumsys: ?*const UNumberingSystem,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uplrules_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

pub extern "icu" fn uplrules_openForType(
    locale: ?[*:0]const u8,
    type: UPluralType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

pub extern "icu" fn uplrules_close(
    uplrules: ?*UPluralRules,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uplrules_select(
    uplrules: ?*const UPluralRules,
    number: f64,
    keyword: ?*u16,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uplrules_getKeywords(
    uplrules: ?*const UPluralRules,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregex_open(
    pattern: ?*const u16,
    patternLength: i32,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_openUText(
    pattern: ?*UText,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_openC(
    pattern: ?[*:0]const u8,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_close(
    regexp: ?*URegularExpression,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_clone(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_pattern(
    regexp: ?*const URegularExpression,
    patLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uregex_patternUText(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_flags(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setText(
    regexp: ?*URegularExpression,
    text: ?*const u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getText(
    regexp: ?*URegularExpression,
    textLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uregex_getUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_refreshUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_matches(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_matches64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_lookingAt(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_lookingAt64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_find(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_find64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_findNext(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_groupCount(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupNumberFromName(
    regexp: ?*URegularExpression,
    groupName: ?*const u16,
    nameLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupNumberFromCName(
    regexp: ?*URegularExpression,
    groupName: ?[*:0]const u8,
    nameLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_group(
    regexp: ?*URegularExpression,
    groupNum: i32,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupUText(
    regexp: ?*URegularExpression,
    groupNum: i32,
    dest: ?*UText,
    groupLength: ?*i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_start(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_start64(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_end(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_end64(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_reset(
    regexp: ?*URegularExpression,
    index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_reset64(
    regexp: ?*URegularExpression,
    index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegion(
    regexp: ?*URegularExpression,
    regionStart: i32,
    regionLimit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegion64(
    regexp: ?*URegularExpression,
    regionStart: i64,
    regionLimit: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegionAndStart(
    regexp: ?*URegularExpression,
    regionStart: i64,
    regionLimit: i64,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_regionStart(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_regionStart64(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_regionEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_regionEnd64(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_hasTransparentBounds(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_useTransparentBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_hasAnchoringBounds(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_useAnchoringBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_hitEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_requireEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_replaceAll(
    regexp: ?*URegularExpression,
    replacementText: ?*const u16,
    replacementLength: i32,
    destBuf: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_replaceAllUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_replaceFirst(
    regexp: ?*URegularExpression,
    replacementText: ?*const u16,
    replacementLength: i32,
    destBuf: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_replaceFirstUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_appendReplacement(
    regexp: ?*URegularExpression,
    replacementText: ?*const u16,
    replacementLength: i32,
    destBuf: ?*?*u16,
    destCapacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_appendReplacementUText(
    regexp: ?*URegularExpression,
    replacementText: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_appendTail(
    regexp: ?*URegularExpression,
    destBuf: ?*?*u16,
    destCapacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_appendTailUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_split(
    regexp: ?*URegularExpression,
    destBuf: ?*u16,
    destCapacity: i32,
    requiredCapacity: ?*i32,
    destFields: ?*?*u16,
    destFieldsCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_splitUText(
    regexp: ?*URegularExpression,
    destFields: ?*?*UText,
    destFieldsCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setTimeLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getTimeLimit(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setStackLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getStackLimit(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setMatchCallback(
    regexp: ?*URegularExpression,
    callback: ?URegexMatchCallback,
    context: ?*const c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getMatchCallback(
    regexp: ?*const URegularExpression,
    callback: ?*?URegexMatchCallback,
    context: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setFindProgressCallback(
    regexp: ?*URegularExpression,
    callback: ?URegexFindProgressCallback,
    context: ?*const c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getFindProgressCallback(
    regexp: ?*const URegularExpression,
    callback: ?*?URegexFindProgressCallback,
    context: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregion_getRegionFromCode(
    regionCode: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getRegionFromNumericCode(
    code: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getAvailable(
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_areEqual(
    uregion: ?*const URegion,
    otherRegion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregion_getContainingRegion(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getContainingRegionOfType(
    uregion: ?*const URegion,
    type: URegionType,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getContainedRegions(
    uregion: ?*const URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_getContainedRegionsOfType(
    uregion: ?*const URegion,
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_contains(
    uregion: ?*const URegion,
    otherRegion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregion_getPreferredValues(
    uregion: ?*const URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_getRegionCode(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uregion_getNumericCode(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregion_getType(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) URegionType;

pub extern "icu" fn ureldatefmt_open(
    locale: ?[*:0]const u8,
    nfToAdopt: ?*?*c_void,
    width: UDateRelativeDateTimeFormatterStyle,
    capitalizationContext: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URelativeDateTimeFormatter;

pub extern "icu" fn ureldatefmt_close(
    reldatefmt: ?*URelativeDateTimeFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ureldatefmt_formatNumeric(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ureldatefmt_format(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ureldatefmt_combineDateAndTime(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    relativeDateString: ?*const u16,
    relativeDateStringLen: i32,
    timeString: ?*const u16,
    timeStringLen: i32,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_open(
    pattern: ?*const u16,
    patternlength: i32,
    text: ?*const u16,
    textlength: i32,
    locale: ?[*:0]const u8,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

pub extern "icu" fn usearch_openFromCollator(
    pattern: ?*const u16,
    patternlength: i32,
    text: ?*const u16,
    textlength: i32,
    collator: ?*const UCollator,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

pub extern "icu" fn usearch_close(
    searchiter: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_setOffset(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getOffset(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_setAttribute(
    strsrch: ?*UStringSearch,
    attribute: USearchAttribute,
    value: USearchAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getAttribute(
    strsrch: ?*const UStringSearch,
    attribute: USearchAttribute,
) callconv(@import("std").os.windows.WINAPI) USearchAttributeValue;

pub extern "icu" fn usearch_getMatchedStart(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_getMatchedLength(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_getMatchedText(
    strsrch: ?*const UStringSearch,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_setBreakIterator(
    strsrch: ?*UStringSearch,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getBreakIterator(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn usearch_setText(
    strsrch: ?*UStringSearch,
    text: ?*const u16,
    textlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getText(
    strsrch: ?*const UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn usearch_getCollator(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn usearch_setCollator(
    strsrch: ?*UStringSearch,
    collator: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_setPattern(
    strsrch: ?*UStringSearch,
    pattern: ?*const u16,
    patternlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getPattern(
    strsrch: ?*const UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn usearch_first(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_following(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_last(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_preceding(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_next(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_previous(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_reset(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_openFromSerialized(
    data: ?*const c_void,
    length: i32,
    pActualLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_openFromSource(
    confusables: ?[*:0]const u8,
    confusablesLen: i32,
    confusablesWholeScript: ?[*:0]const u8,
    confusablesWholeScriptLen: i32,
    errType: ?*i32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_close(
    sc: ?*USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_clone(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_setChecks(
    sc: ?*USpoofChecker,
    checks: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getChecks(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_setRestrictionLevel(
    sc: ?*USpoofChecker,
    restrictionLevel: URestrictionLevel,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getRestrictionLevel(
    sc: ?*const USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

pub extern "icu" fn uspoof_setAllowedLocales(
    sc: ?*USpoofChecker,
    localesList: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getAllowedLocales(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uspoof_setAllowedChars(
    sc: ?*USpoofChecker,
    chars: ?*const USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getAllowedChars(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_check(
    sc: ?*const USpoofChecker,
    id: ?*const u16,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_checkUTF8(
    sc: ?*const USpoofChecker,
    id: ?[*:0]const u8,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_check2(
    sc: ?*const USpoofChecker,
    id: ?*const u16,
    length: i32,
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_check2UTF8(
    sc: ?*const USpoofChecker,
    id: ?[*:0]const u8,
    length: i32,
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_openCheckResult(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofCheckResult;

pub extern "icu" fn uspoof_closeCheckResult(
    checkResult: ?*USpoofCheckResult,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getCheckResultChecks(
    checkResult: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getCheckResultRestrictionLevel(
    checkResult: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

pub extern "icu" fn uspoof_getCheckResultNumerics(
    checkResult: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_areConfusable(
    sc: ?*const USpoofChecker,
    id1: ?*const u16,
    length1: i32,
    id2: ?*const u16,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_areConfusableUTF8(
    sc: ?*const USpoofChecker,
    id1: ?[*:0]const u8,
    length1: i32,
    id2: ?[*:0]const u8,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getSkeleton(
    sc: ?*const USpoofChecker,
    type: u32,
    id: ?*const u16,
    length: i32,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getSkeletonUTF8(
    sc: ?*const USpoofChecker,
    type: u32,
    id: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getInclusionSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_getRecommendedSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_serialize(
    sc: ?*USpoofChecker,
    data: ?*c_void,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utmscale_getTimeScaleValue(
    timeScale: UDateTimeScale,
    value: UTimeScaleValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utmscale_fromInt64(
    otherTime: i64,
    timeScale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utmscale_toInt64(
    universalTime: i64,
    timeScale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utrans_openU(
    id: ?*const u16,
    idLength: i32,
    dir: UTransDirection,
    rules: ?*const u16,
    rulesLength: i32,
    parseError: ?*UParseError,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn utrans_openInverse(
    trans: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn utrans_clone(
    trans: ?*const ?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*c_void;

pub extern "icu" fn utrans_close(
    trans: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_getUnicodeID(
    trans: ?*const ?*c_void,
    resultLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn utrans_register(
    adoptedTrans: ?*?*c_void,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_unregisterID(
    id: ?*const u16,
    idLength: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_setFilter(
    trans: ?*?*c_void,
    filterPattern: ?*const u16,
    filterPatternLen: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_countAvailableIDs(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrans_openIDs(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn utrans_trans(
    trans: ?*const ?*c_void,
    rep: ?*?*c_void,
    repFunc: ?*const UReplaceableCallbacks,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transIncremental(
    trans: ?*const ?*c_void,
    rep: ?*?*c_void,
    repFunc: ?*const UReplaceableCallbacks,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transUChars(
    trans: ?*const ?*c_void,
    text: ?*u16,
    textLength: ?*i32,
    textCapacity: i32,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transIncrementalUChars(
    trans: ?*const ?*c_void,
    text: ?*u16,
    textLength: ?*i32,
    textCapacity: i32,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_toRules(
    trans: ?*const ?*c_void,
    escapeUnprintable: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrans_getSourceSet(
    trans: ?*const ?*c_void,
    ignoreFilter: i8,
    fillIn: ?*USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn FindStringOrdinal(
    dwFindStringOrdinalFlags: u32,
    lpStringSource: [*:0]const u16,
    cchSource: i32,
    lpStringValue: [*:0]const u16,
    cchValue: i32,
    bIgnoreCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcmpA(
    lpString1: ?[*:0]const u8,
    lpString2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcmpW(
    lpString1: ?[*:0]const u16,
    lpString2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcmpiA(
    lpString1: ?[*:0]const u8,
    lpString2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcmpiW(
    lpString1: ?[*:0]const u16,
    lpString2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcpynA(
    lpString1: [*:0]u8,
    lpString2: ?[*:0]const u8,
    iMaxLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcpynW(
    lpString1: [*:0]u16,
    lpString2: ?[*:0]const u16,
    iMaxLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcpyA(
    lpString1: ?PSTR,
    lpString2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcpyW(
    lpString1: ?PWSTR,
    lpString2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcatA(
    lpString1: ?PSTR,
    lpString2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrcatW(
    lpString1: ?PWSTR,
    lpString2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrlenA(
    lpString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn lstrlenW(
    lpString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn IsTextUnicode(
    // TODO: what to do with BytesParamIndex 1?
    lpv: ?*const c_void,
    iSize: i32,
    lpiResult: ?*IS_TEXT_UNICODE_RESULT,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (69)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CPINFOEX = thismodule.CPINFOEXA;
        pub const NUMBERFMT = thismodule.NUMBERFMTA;
        pub const CURRENCYFMT = thismodule.CURRENCYFMTA;
        pub const LOCALE_ENUMPROC = thismodule.LOCALE_ENUMPROCA;
        pub const LANGUAGEGROUP_ENUMPROC = thismodule.LANGUAGEGROUP_ENUMPROCA;
        pub const LANGGROUPLOCALE_ENUMPROC = thismodule.LANGGROUPLOCALE_ENUMPROCA;
        pub const UILANGUAGE_ENUMPROC = thismodule.UILANGUAGE_ENUMPROCA;
        pub const CODEPAGE_ENUMPROC = thismodule.CODEPAGE_ENUMPROCA;
        pub const DATEFMT_ENUMPROC = thismodule.DATEFMT_ENUMPROCA;
        pub const DATEFMT_ENUMPROCEX = thismodule.DATEFMT_ENUMPROCEXA;
        pub const TIMEFMT_ENUMPROC = thismodule.TIMEFMT_ENUMPROCA;
        pub const CALINFO_ENUMPROC = thismodule.CALINFO_ENUMPROCA;
        pub const CALINFO_ENUMPROCEX = thismodule.CALINFO_ENUMPROCEXA;
        pub const REGISTERWORD = thismodule.REGISTERWORDA;
        pub const STYLEBUF = thismodule.STYLEBUFA;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOA;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCA;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordA;
        pub const GetDateFormat = thismodule.GetDateFormatA;
        pub const GetTimeFormat = thismodule.GetTimeFormatA;
        pub const CompareString = thismodule.CompareStringA;
        pub const FoldString = thismodule.FoldStringA;
        pub const GetStringTypeEx = thismodule.GetStringTypeExA;
        pub const GetStringType = thismodule.GetStringTypeA;
        pub const GetCPInfoEx = thismodule.GetCPInfoExA;
        pub const LCMapString = thismodule.LCMapStringA;
        pub const GetLocaleInfo = thismodule.GetLocaleInfoA;
        pub const SetLocaleInfo = thismodule.SetLocaleInfoA;
        pub const GetCalendarInfo = thismodule.GetCalendarInfoA;
        pub const SetCalendarInfo = thismodule.SetCalendarInfoA;
        pub const GetNumberFormat = thismodule.GetNumberFormatA;
        pub const GetCurrencyFormat = thismodule.GetCurrencyFormatA;
        pub const EnumCalendarInfo = thismodule.EnumCalendarInfoA;
        pub const EnumCalendarInfoEx = thismodule.EnumCalendarInfoExA;
        pub const EnumTimeFormats = thismodule.EnumTimeFormatsA;
        pub const EnumDateFormats = thismodule.EnumDateFormatsA;
        pub const EnumDateFormatsEx = thismodule.EnumDateFormatsExA;
        pub const GetGeoInfo = thismodule.GetGeoInfoA;
        pub const EnumSystemLocales = thismodule.EnumSystemLocalesA;
        pub const EnumSystemLanguageGroups = thismodule.EnumSystemLanguageGroupsA;
        pub const EnumLanguageGroupLocales = thismodule.EnumLanguageGroupLocalesA;
        pub const EnumUILanguages = thismodule.EnumUILanguagesA;
        pub const EnumSystemCodePages = thismodule.EnumSystemCodePagesA;
        pub const ImmInstallIME = thismodule.ImmInstallIMEA;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionA;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameA;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringA;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringA;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountA;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListA;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineA;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontA;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontA;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEA;
        pub const ImmEscape = thismodule.ImmEscapeA;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListA;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageA;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordA;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordA;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleA;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordA;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsA;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageA;
        pub const lstrcmp = thismodule.lstrcmpA;
        pub const lstrcmpi = thismodule.lstrcmpiA;
        pub const lstrcpyn = thismodule.lstrcpynA;
        pub const lstrcpy = thismodule.lstrcpyA;
        pub const lstrcat = thismodule.lstrcatA;
        pub const lstrlen = thismodule.lstrlenA;
    },
    .wide => struct {
        pub const CPINFOEX = thismodule.CPINFOEXW;
        pub const NUMBERFMT = thismodule.NUMBERFMTW;
        pub const CURRENCYFMT = thismodule.CURRENCYFMTW;
        pub const LOCALE_ENUMPROC = thismodule.LOCALE_ENUMPROCW;
        pub const LANGUAGEGROUP_ENUMPROC = thismodule.LANGUAGEGROUP_ENUMPROCW;
        pub const LANGGROUPLOCALE_ENUMPROC = thismodule.LANGGROUPLOCALE_ENUMPROCW;
        pub const UILANGUAGE_ENUMPROC = thismodule.UILANGUAGE_ENUMPROCW;
        pub const CODEPAGE_ENUMPROC = thismodule.CODEPAGE_ENUMPROCW;
        pub const DATEFMT_ENUMPROC = thismodule.DATEFMT_ENUMPROCW;
        pub const DATEFMT_ENUMPROCEX = thismodule.DATEFMT_ENUMPROCEXW;
        pub const TIMEFMT_ENUMPROC = thismodule.TIMEFMT_ENUMPROCW;
        pub const CALINFO_ENUMPROC = thismodule.CALINFO_ENUMPROCW;
        pub const CALINFO_ENUMPROCEX = thismodule.CALINFO_ENUMPROCEXW;
        pub const REGISTERWORD = thismodule.REGISTERWORDW;
        pub const STYLEBUF = thismodule.STYLEBUFW;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOW;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCW;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordW;
        pub const GetDateFormat = thismodule.GetDateFormatW;
        pub const GetTimeFormat = thismodule.GetTimeFormatW;
        pub const CompareString = thismodule.CompareStringW;
        pub const FoldString = thismodule.FoldStringW;
        pub const GetStringTypeEx = thismodule.GetStringTypeExW;
        pub const GetStringType = thismodule.GetStringTypeW;
        pub const GetCPInfoEx = thismodule.GetCPInfoExW;
        pub const LCMapString = thismodule.LCMapStringW;
        pub const GetLocaleInfo = thismodule.GetLocaleInfoW;
        pub const SetLocaleInfo = thismodule.SetLocaleInfoW;
        pub const GetCalendarInfo = thismodule.GetCalendarInfoW;
        pub const SetCalendarInfo = thismodule.SetCalendarInfoW;
        pub const GetNumberFormat = thismodule.GetNumberFormatW;
        pub const GetCurrencyFormat = thismodule.GetCurrencyFormatW;
        pub const EnumCalendarInfo = thismodule.EnumCalendarInfoW;
        pub const EnumCalendarInfoEx = thismodule.EnumCalendarInfoExW;
        pub const EnumTimeFormats = thismodule.EnumTimeFormatsW;
        pub const EnumDateFormats = thismodule.EnumDateFormatsW;
        pub const EnumDateFormatsEx = thismodule.EnumDateFormatsExW;
        pub const GetGeoInfo = thismodule.GetGeoInfoW;
        pub const EnumSystemLocales = thismodule.EnumSystemLocalesW;
        pub const EnumSystemLanguageGroups = thismodule.EnumSystemLanguageGroupsW;
        pub const EnumLanguageGroupLocales = thismodule.EnumLanguageGroupLocalesW;
        pub const EnumUILanguages = thismodule.EnumUILanguagesW;
        pub const EnumSystemCodePages = thismodule.EnumSystemCodePagesW;
        pub const ImmInstallIME = thismodule.ImmInstallIMEW;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionW;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameW;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringW;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringW;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountW;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListW;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineW;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontW;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontW;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEW;
        pub const ImmEscape = thismodule.ImmEscapeW;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListW;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageW;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordW;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordW;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleW;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordW;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsW;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageW;
        pub const lstrcmp = thismodule.lstrcmpW;
        pub const lstrcmpi = thismodule.lstrcmpiW;
        pub const lstrcpyn = thismodule.lstrcpynW;
        pub const lstrcpy = thismodule.lstrcpyW;
        pub const lstrcat = thismodule.lstrcatW;
        pub const lstrlen = thismodule.lstrlenW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CPINFOEX = *opaque{};
        pub const NUMBERFMT = *opaque{};
        pub const CURRENCYFMT = *opaque{};
        pub const LOCALE_ENUMPROC = *opaque{};
        pub const LANGUAGEGROUP_ENUMPROC = *opaque{};
        pub const LANGGROUPLOCALE_ENUMPROC = *opaque{};
        pub const UILANGUAGE_ENUMPROC = *opaque{};
        pub const CODEPAGE_ENUMPROC = *opaque{};
        pub const DATEFMT_ENUMPROC = *opaque{};
        pub const DATEFMT_ENUMPROCEX = *opaque{};
        pub const TIMEFMT_ENUMPROC = *opaque{};
        pub const CALINFO_ENUMPROC = *opaque{};
        pub const CALINFO_ENUMPROCEX = *opaque{};
        pub const REGISTERWORD = *opaque{};
        pub const STYLEBUF = *opaque{};
        pub const IMEMENUITEMINFO = *opaque{};
        pub const REGISTERWORDENUMPROC = *opaque{};
        pub const IEnumRegisterWord = *opaque{};
        pub const GetDateFormat = *opaque{};
        pub const GetTimeFormat = *opaque{};
        pub const CompareString = *opaque{};
        pub const FoldString = *opaque{};
        pub const GetStringTypeEx = *opaque{};
        pub const GetStringType = *opaque{};
        pub const GetCPInfoEx = *opaque{};
        pub const LCMapString = *opaque{};
        pub const GetLocaleInfo = *opaque{};
        pub const SetLocaleInfo = *opaque{};
        pub const GetCalendarInfo = *opaque{};
        pub const SetCalendarInfo = *opaque{};
        pub const GetNumberFormat = *opaque{};
        pub const GetCurrencyFormat = *opaque{};
        pub const EnumCalendarInfo = *opaque{};
        pub const EnumCalendarInfoEx = *opaque{};
        pub const EnumTimeFormats = *opaque{};
        pub const EnumDateFormats = *opaque{};
        pub const EnumDateFormatsEx = *opaque{};
        pub const GetGeoInfo = *opaque{};
        pub const EnumSystemLocales = *opaque{};
        pub const EnumSystemLanguageGroups = *opaque{};
        pub const EnumLanguageGroupLocales = *opaque{};
        pub const EnumUILanguages = *opaque{};
        pub const EnumSystemCodePages = *opaque{};
        pub const ImmInstallIME = *opaque{};
        pub const ImmGetDescription = *opaque{};
        pub const ImmGetIMEFileName = *opaque{};
        pub const ImmGetCompositionString = *opaque{};
        pub const ImmSetCompositionString = *opaque{};
        pub const ImmGetCandidateListCount = *opaque{};
        pub const ImmGetCandidateList = *opaque{};
        pub const ImmGetGuideLine = *opaque{};
        pub const ImmGetCompositionFont = *opaque{};
        pub const ImmSetCompositionFont = *opaque{};
        pub const ImmConfigureIME = *opaque{};
        pub const ImmEscape = *opaque{};
        pub const ImmGetConversionList = *opaque{};
        pub const ImmIsUIMessage = *opaque{};
        pub const ImmRegisterWord = *opaque{};
        pub const ImmUnregisterWord = *opaque{};
        pub const ImmGetRegisterWordStyle = *opaque{};
        pub const ImmEnumRegisterWord = *opaque{};
        pub const ImmGetImeMenuItems = *opaque{};
        pub const ImmRequestMessage = *opaque{};
        pub const lstrcmp = *opaque{};
        pub const lstrcmpi = *opaque{};
        pub const lstrcpyn = *opaque{};
        pub const lstrcpy = *opaque{};
        pub const lstrcat = *opaque{};
        pub const lstrlen = *opaque{};
    } else struct {
        pub const CPINFOEX = @compileError("'CPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NUMBERFMT = @compileError("'NUMBERFMT' requires that UNICODE be set to true or false in the root module");
        pub const CURRENCYFMT = @compileError("'CURRENCYFMT' requires that UNICODE be set to true or false in the root module");
        pub const LOCALE_ENUMPROC = @compileError("'LOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGUAGEGROUP_ENUMPROC = @compileError("'LANGUAGEGROUP_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGGROUPLOCALE_ENUMPROC = @compileError("'LANGGROUPLOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const UILANGUAGE_ENUMPROC = @compileError("'UILANGUAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CODEPAGE_ENUMPROC = @compileError("'CODEPAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROC = @compileError("'DATEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROCEX = @compileError("'DATEFMT_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const TIMEFMT_ENUMPROC = @compileError("'TIMEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROC = @compileError("'CALINFO_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROCEX = @compileError("'CALINFO_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORD = @compileError("'REGISTERWORD' requires that UNICODE be set to true or false in the root module");
        pub const STYLEBUF = @compileError("'STYLEBUF' requires that UNICODE be set to true or false in the root module");
        pub const IMEMENUITEMINFO = @compileError("'IMEMENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORDENUMPROC = @compileError("'REGISTERWORDENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const IEnumRegisterWord = @compileError("'IEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const GetDateFormat = @compileError("'GetDateFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetTimeFormat = @compileError("'GetTimeFormat' requires that UNICODE be set to true or false in the root module");
        pub const CompareString = @compileError("'CompareString' requires that UNICODE be set to true or false in the root module");
        pub const FoldString = @compileError("'FoldString' requires that UNICODE be set to true or false in the root module");
        pub const GetStringTypeEx = @compileError("'GetStringTypeEx' requires that UNICODE be set to true or false in the root module");
        pub const GetStringType = @compileError("'GetStringType' requires that UNICODE be set to true or false in the root module");
        pub const GetCPInfoEx = @compileError("'GetCPInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const LCMapString = @compileError("'LCMapString' requires that UNICODE be set to true or false in the root module");
        pub const GetLocaleInfo = @compileError("'GetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetLocaleInfo = @compileError("'SetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetCalendarInfo = @compileError("'GetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetCalendarInfo = @compileError("'SetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetNumberFormat = @compileError("'GetNumberFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrencyFormat = @compileError("'GetCurrencyFormat' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfo = @compileError("'EnumCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfoEx = @compileError("'EnumCalendarInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumTimeFormats = @compileError("'EnumTimeFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormats = @compileError("'EnumDateFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormatsEx = @compileError("'EnumDateFormatsEx' requires that UNICODE be set to true or false in the root module");
        pub const GetGeoInfo = @compileError("'GetGeoInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLocales = @compileError("'EnumSystemLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLanguageGroups = @compileError("'EnumSystemLanguageGroups' requires that UNICODE be set to true or false in the root module");
        pub const EnumLanguageGroupLocales = @compileError("'EnumLanguageGroupLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumUILanguages = @compileError("'EnumUILanguages' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemCodePages = @compileError("'EnumSystemCodePages' requires that UNICODE be set to true or false in the root module");
        pub const ImmInstallIME = @compileError("'ImmInstallIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetDescription = @compileError("'ImmGetDescription' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetIMEFileName = @compileError("'ImmGetIMEFileName' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionString = @compileError("'ImmGetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionString = @compileError("'ImmSetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateListCount = @compileError("'ImmGetCandidateListCount' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateList = @compileError("'ImmGetCandidateList' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetGuideLine = @compileError("'ImmGetGuideLine' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionFont = @compileError("'ImmGetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionFont = @compileError("'ImmSetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmConfigureIME = @compileError("'ImmConfigureIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmEscape = @compileError("'ImmEscape' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetConversionList = @compileError("'ImmGetConversionList' requires that UNICODE be set to true or false in the root module");
        pub const ImmIsUIMessage = @compileError("'ImmIsUIMessage' requires that UNICODE be set to true or false in the root module");
        pub const ImmRegisterWord = @compileError("'ImmRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmUnregisterWord = @compileError("'ImmUnregisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetRegisterWordStyle = @compileError("'ImmGetRegisterWordStyle' requires that UNICODE be set to true or false in the root module");
        pub const ImmEnumRegisterWord = @compileError("'ImmEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetImeMenuItems = @compileError("'ImmGetImeMenuItems' requires that UNICODE be set to true or false in the root module");
        pub const ImmRequestMessage = @compileError("'ImmRequestMessage' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmp = @compileError("'lstrcmp' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmpi = @compileError("'lstrcmpi' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpyn = @compileError("'lstrcpyn' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpy = @compileError("'lstrcpy' requires that UNICODE be set to true or false in the root module");
        pub const lstrcat = @compileError("'lstrcat' requires that UNICODE be set to true or false in the root module");
        pub const lstrlen = @compileError("'lstrlen' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (28)
//--------------------------------------------------------------------------------
const Guid = @import("zig.zig").Guid;
const ABC = @import("graphics/gdi.zig").ABC;
const BOOL = @import("foundation.zig").BOOL;
const BSTR = @import("foundation.zig").BSTR;
const CHAR = @import("system/system_services.zig").CHAR;
const ETO_OPTIONS = @import("graphics/gdi.zig").ETO_OPTIONS;
const HBITMAP = @import("graphics/gdi.zig").HBITMAP;
const HDC = @import("graphics/gdi.zig").HDC;
const HICON = @import("ui/windows_and_messaging.zig").HICON;
const HKL = @import("ui/text_services.zig").HKL;
const HRESULT = @import("foundation.zig").HRESULT;
const HWND = @import("foundation.zig").HWND;
const IClassFactory = @import("system/com.zig").IClassFactory;
const IEnumString = @import("system/com.zig").IEnumString;
const IUnknown = @import("system/com.zig").IUnknown;
const LOGFONTA = @import("graphics/gdi.zig").LOGFONTA;
const LOGFONTW = @import("graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("foundation.zig").LPARAM;
const LRESULT = @import("foundation.zig").LRESULT;
const MSG = @import("ui/windows_and_messaging.zig").MSG;
const POINT = @import("foundation.zig").POINT;
const PSTR = @import("foundation.zig").PSTR;
const PWSTR = @import("foundation.zig").PWSTR;
const RECT = @import("foundation.zig").RECT;
const SAFEARRAY = @import("system/ole_automation.zig").SAFEARRAY;
const SIZE = @import("foundation.zig").SIZE;
const SYSTEMTIME = @import("foundation.zig").SYSTEMTIME;
const WPARAM = @import("foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LOCALE_ENUMPROCA")) { _ = LOCALE_ENUMPROCA; }
    if (@hasDecl(@This(), "LOCALE_ENUMPROCW")) { _ = LOCALE_ENUMPROCW; }
    if (@hasDecl(@This(), "LANGUAGEGROUP_ENUMPROCA")) { _ = LANGUAGEGROUP_ENUMPROCA; }
    if (@hasDecl(@This(), "LANGGROUPLOCALE_ENUMPROCA")) { _ = LANGGROUPLOCALE_ENUMPROCA; }
    if (@hasDecl(@This(), "UILANGUAGE_ENUMPROCA")) { _ = UILANGUAGE_ENUMPROCA; }
    if (@hasDecl(@This(), "CODEPAGE_ENUMPROCA")) { _ = CODEPAGE_ENUMPROCA; }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCA")) { _ = DATEFMT_ENUMPROCA; }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXA")) { _ = DATEFMT_ENUMPROCEXA; }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCA")) { _ = TIMEFMT_ENUMPROCA; }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCA")) { _ = CALINFO_ENUMPROCA; }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXA")) { _ = CALINFO_ENUMPROCEXA; }
    if (@hasDecl(@This(), "LANGUAGEGROUP_ENUMPROCW")) { _ = LANGUAGEGROUP_ENUMPROCW; }
    if (@hasDecl(@This(), "LANGGROUPLOCALE_ENUMPROCW")) { _ = LANGGROUPLOCALE_ENUMPROCW; }
    if (@hasDecl(@This(), "UILANGUAGE_ENUMPROCW")) { _ = UILANGUAGE_ENUMPROCW; }
    if (@hasDecl(@This(), "CODEPAGE_ENUMPROCW")) { _ = CODEPAGE_ENUMPROCW; }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCW")) { _ = DATEFMT_ENUMPROCW; }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXW")) { _ = DATEFMT_ENUMPROCEXW; }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCW")) { _ = TIMEFMT_ENUMPROCW; }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCW")) { _ = CALINFO_ENUMPROCW; }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXW")) { _ = CALINFO_ENUMPROCEXW; }
    if (@hasDecl(@This(), "GEO_ENUMPROC")) { _ = GEO_ENUMPROC; }
    if (@hasDecl(@This(), "GEO_ENUMNAMEPROC")) { _ = GEO_ENUMNAMEPROC; }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXEX")) { _ = CALINFO_ENUMPROCEXEX; }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXEX")) { _ = DATEFMT_ENUMPROCEXEX; }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCEX")) { _ = TIMEFMT_ENUMPROCEX; }
    if (@hasDecl(@This(), "LOCALE_ENUMPROCEX")) { _ = LOCALE_ENUMPROCEX; }
    if (@hasDecl(@This(), "IMCENUMPROC")) { _ = IMCENUMPROC; }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCA")) { _ = REGISTERWORDENUMPROCA; }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCW")) { _ = REGISTERWORDENUMPROCW; }
    if (@hasDecl(@This(), "PFN_MAPPINGCALLBACKPROC")) { _ = PFN_MAPPINGCALLBACKPROC; }
    if (@hasDecl(@This(), "PFNLOG")) { _ = PFNLOG; }
    if (@hasDecl(@This(), "fpCreateIFECommonInstanceType")) { _ = fpCreateIFECommonInstanceType; }
    if (@hasDecl(@This(), "fpCreateIFELanguageInstanceType")) { _ = fpCreateIFELanguageInstanceType; }
    if (@hasDecl(@This(), "fpCreateIFEDictionaryInstanceType")) { _ = fpCreateIFEDictionaryInstanceType; }
    if (@hasDecl(@This(), "UTraceEntry")) { _ = UTraceEntry; }
    if (@hasDecl(@This(), "UTraceExit")) { _ = UTraceExit; }
    if (@hasDecl(@This(), "UTraceData")) { _ = UTraceData; }
    if (@hasDecl(@This(), "UCharIteratorGetIndex")) { _ = UCharIteratorGetIndex; }
    if (@hasDecl(@This(), "UCharIteratorMove")) { _ = UCharIteratorMove; }
    if (@hasDecl(@This(), "UCharIteratorHasNext")) { _ = UCharIteratorHasNext; }
    if (@hasDecl(@This(), "UCharIteratorHasPrevious")) { _ = UCharIteratorHasPrevious; }
    if (@hasDecl(@This(), "UCharIteratorCurrent")) { _ = UCharIteratorCurrent; }
    if (@hasDecl(@This(), "UCharIteratorNext")) { _ = UCharIteratorNext; }
    if (@hasDecl(@This(), "UCharIteratorPrevious")) { _ = UCharIteratorPrevious; }
    if (@hasDecl(@This(), "UCharIteratorReserved")) { _ = UCharIteratorReserved; }
    if (@hasDecl(@This(), "UCharIteratorGetState")) { _ = UCharIteratorGetState; }
    if (@hasDecl(@This(), "UCharIteratorSetState")) { _ = UCharIteratorSetState; }
    if (@hasDecl(@This(), "UConverterToUCallback")) { _ = UConverterToUCallback; }
    if (@hasDecl(@This(), "UConverterFromUCallback")) { _ = UConverterFromUCallback; }
    if (@hasDecl(@This(), "UMemAllocFn")) { _ = UMemAllocFn; }
    if (@hasDecl(@This(), "UMemReallocFn")) { _ = UMemReallocFn; }
    if (@hasDecl(@This(), "UMemFreeFn")) { _ = UMemFreeFn; }
    if (@hasDecl(@This(), "UCharEnumTypeRange")) { _ = UCharEnumTypeRange; }
    if (@hasDecl(@This(), "UEnumCharNamesFn")) { _ = UEnumCharNamesFn; }
    if (@hasDecl(@This(), "UBiDiClassCallback")) { _ = UBiDiClassCallback; }
    if (@hasDecl(@This(), "UTextClone")) { _ = UTextClone; }
    if (@hasDecl(@This(), "UTextNativeLength")) { _ = UTextNativeLength; }
    if (@hasDecl(@This(), "UTextAccess")) { _ = UTextAccess; }
    if (@hasDecl(@This(), "UTextExtract")) { _ = UTextExtract; }
    if (@hasDecl(@This(), "UTextReplace")) { _ = UTextReplace; }
    if (@hasDecl(@This(), "UTextCopy")) { _ = UTextCopy; }
    if (@hasDecl(@This(), "UTextMapOffsetToNative")) { _ = UTextMapOffsetToNative; }
    if (@hasDecl(@This(), "UTextMapNativeIndexToUTF16")) { _ = UTextMapNativeIndexToUTF16; }
    if (@hasDecl(@This(), "UTextClose")) { _ = UTextClose; }
    if (@hasDecl(@This(), "UNESCAPE_CHAR_AT")) { _ = UNESCAPE_CHAR_AT; }
    if (@hasDecl(@This(), "URegexMatchCallback")) { _ = URegexMatchCallback; }
    if (@hasDecl(@This(), "URegexFindProgressCallback")) { _ = URegexFindProgressCallback; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

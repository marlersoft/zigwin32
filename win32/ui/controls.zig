//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (2064)
//--------------------------------------------------------------------------------
pub const TVI_ROOT = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65536));
pub const TVI_FIRST = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65535));
pub const TVI_LAST = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65534));
pub const TVI_SORT = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65533));
pub const BCN_FIRST = @as(u32, 4294966046);
pub const EM_SCROLLCARET = @as(u32, 183);
pub const EM_SETLIMITTEXT = @as(u32, 197);
pub const EM_GETLIMITTEXT = @as(u32, 213);
pub const EM_POSFROMCHAR = @as(u32, 214);
pub const EM_CHARFROMPOS = @as(u32, 215);
pub const FILEOPENORD = @as(u32, 1536);
pub const MULTIFILEOPENORD = @as(u32, 1537);
pub const PRINTDLGORD = @as(u32, 1538);
pub const PRNSETUPDLGORD = @as(u32, 1539);
pub const FINDDLGORD = @as(u32, 1540);
pub const REPLACEDLGORD = @as(u32, 1541);
pub const FONTDLGORD = @as(u32, 1542);
pub const FORMATDLGORD31 = @as(u32, 1543);
pub const FORMATDLGORD30 = @as(u32, 1544);
pub const RUNDLGORD = @as(u32, 1545);
pub const PAGESETUPDLGORD = @as(u32, 1546);
pub const NEWFILEOPENORD = @as(u32, 1547);
pub const PRINTDLGEXORD = @as(u32, 1549);
pub const PAGESETUPDLGORDMOTIF = @as(u32, 1550);
pub const COLORMGMTDLGORD = @as(u32, 1551);
pub const NEWFILEOPENV2ORD = @as(u32, 1552);
pub const NEWFILEOPENV3ORD = @as(u32, 1553);
pub const NEWFORMATDLGWITHLINK = @as(u32, 1591);
pub const IDC_MANAGE_LINK = @as(u32, 1592);
pub const WM_CTLCOLOR = @as(u32, 25);
pub const ILDRF_IMAGELOWQUALITY = @as(u32, 1);
pub const ILDRF_OVERLAYLOWQUALITY = @as(u32, 16);
pub const ILR_DEFAULT = @as(u32, 0);
pub const ILR_HORIZONTAL_LEFT = @as(u32, 0);
pub const ILR_HORIZONTAL_CENTER = @as(u32, 1);
pub const ILR_HORIZONTAL_RIGHT = @as(u32, 2);
pub const ILR_VERTICAL_TOP = @as(u32, 0);
pub const ILR_VERTICAL_CENTER = @as(u32, 16);
pub const ILR_VERTICAL_BOTTOM = @as(u32, 32);
pub const ILR_SCALE_CLIP = @as(u32, 0);
pub const ILR_SCALE_ASPECTRATIO = @as(u32, 256);
pub const ILGOS_ALWAYS = @as(u32, 0);
pub const ILGOS_FROMSTANDBY = @as(u32, 1);
pub const ILFIP_ALWAYS = @as(u32, 0);
pub const ILFIP_FROMSTANDBY = @as(u32, 1);
pub const ILDI_PURGE = @as(u32, 1);
pub const ILDI_STANDBY = @as(u32, 2);
pub const ILDI_RESETACCESS = @as(u32, 4);
pub const ILDI_QUERYACCESS = @as(u32, 8);
pub const MAXPROPPAGES = @as(u32, 100);
pub const PSP_DEFAULT = @as(u32, 0);
pub const PSP_DLGINDIRECT = @as(u32, 1);
pub const PSP_USEHICON = @as(u32, 2);
pub const PSP_USEICONID = @as(u32, 4);
pub const PSP_USETITLE = @as(u32, 8);
pub const PSP_RTLREADING = @as(u32, 16);
pub const PSP_HASHELP = @as(u32, 32);
pub const PSP_USEREFPARENT = @as(u32, 64);
pub const PSP_USECALLBACK = @as(u32, 128);
pub const PSP_PREMATURE = @as(u32, 1024);
pub const PSP_HIDEHEADER = @as(u32, 2048);
pub const PSP_USEHEADERTITLE = @as(u32, 4096);
pub const PSP_USEHEADERSUBTITLE = @as(u32, 8192);
pub const PSP_USEFUSIONCONTEXT = @as(u32, 16384);
pub const PSH_DEFAULT = @as(u32, 0);
pub const PSH_PROPTITLE = @as(u32, 1);
pub const PSH_USEHICON = @as(u32, 2);
pub const PSH_USEICONID = @as(u32, 4);
pub const PSH_PROPSHEETPAGE = @as(u32, 8);
pub const PSH_WIZARDHASFINISH = @as(u32, 16);
pub const PSH_WIZARD = @as(u32, 32);
pub const PSH_USEPSTARTPAGE = @as(u32, 64);
pub const PSH_NOAPPLYNOW = @as(u32, 128);
pub const PSH_USECALLBACK = @as(u32, 256);
pub const PSH_HASHELP = @as(u32, 512);
pub const PSH_MODELESS = @as(u32, 1024);
pub const PSH_RTLREADING = @as(u32, 2048);
pub const PSH_WIZARDCONTEXTHELP = @as(u32, 4096);
pub const PSH_WIZARD97 = @as(u32, 8192);
pub const PSH_WATERMARK = @as(u32, 32768);
pub const PSH_USEHBMWATERMARK = @as(u32, 65536);
pub const PSH_USEHPLWATERMARK = @as(u32, 131072);
pub const PSH_STRETCHWATERMARK = @as(u32, 262144);
pub const PSH_HEADER = @as(u32, 524288);
pub const PSH_USEHBMHEADER = @as(u32, 1048576);
pub const PSH_USEPAGELANG = @as(u32, 2097152);
pub const PSH_WIZARD_LITE = @as(u32, 4194304);
pub const PSH_NOCONTEXTHELP = @as(u32, 33554432);
pub const PSH_AEROWIZARD = @as(u32, 16384);
pub const PSH_RESIZABLE = @as(u32, 67108864);
pub const PSH_HEADERBITMAP = @as(u32, 134217728);
pub const PSH_NOMARGIN = @as(u32, 268435456);
pub const PSCB_INITIALIZED = @as(u32, 1);
pub const PSCB_PRECREATE = @as(u32, 2);
pub const PSCB_BUTTONPRESSED = @as(u32, 3);
pub const PSNRET_NOERROR = @as(u32, 0);
pub const PSNRET_INVALID = @as(u32, 1);
pub const PSNRET_INVALID_NOCHANGEPAGE = @as(u32, 2);
pub const PSNRET_MESSAGEHANDLED = @as(u32, 3);
pub const PSM_SETCURSEL = @as(u32, 1125);
pub const PSM_REMOVEPAGE = @as(u32, 1126);
pub const PSM_ADDPAGE = @as(u32, 1127);
pub const PSM_CHANGED = @as(u32, 1128);
pub const PSM_RESTARTWINDOWS = @as(u32, 1129);
pub const PSM_REBOOTSYSTEM = @as(u32, 1130);
pub const PSM_CANCELTOCLOSE = @as(u32, 1131);
pub const PSM_QUERYSIBLINGS = @as(u32, 1132);
pub const PSM_UNCHANGED = @as(u32, 1133);
pub const PSM_APPLY = @as(u32, 1134);
pub const PSM_SETTITLEA = @as(u32, 1135);
pub const PSM_SETTITLEW = @as(u32, 1144);
pub const PSM_SETWIZBUTTONS = @as(u32, 1136);
pub const PSWIZB_BACK = @as(u32, 1);
pub const PSWIZB_NEXT = @as(u32, 2);
pub const PSWIZB_FINISH = @as(u32, 4);
pub const PSWIZB_DISABLEDFINISH = @as(u32, 8);
pub const PSWIZBF_ELEVATIONREQUIRED = @as(u32, 1);
pub const PSWIZB_CANCEL = @as(u32, 16);
pub const PSM_PRESSBUTTON = @as(u32, 1137);
pub const PSBTN_BACK = @as(u32, 0);
pub const PSBTN_NEXT = @as(u32, 1);
pub const PSBTN_FINISH = @as(u32, 2);
pub const PSBTN_OK = @as(u32, 3);
pub const PSBTN_APPLYNOW = @as(u32, 4);
pub const PSBTN_CANCEL = @as(u32, 5);
pub const PSBTN_HELP = @as(u32, 6);
pub const PSBTN_MAX = @as(u32, 6);
pub const PSM_SETCURSELID = @as(u32, 1138);
pub const PSM_SETFINISHTEXTA = @as(u32, 1139);
pub const PSM_SETFINISHTEXTW = @as(u32, 1145);
pub const PSM_GETTABCONTROL = @as(u32, 1140);
pub const PSM_ISDIALOGMESSAGE = @as(u32, 1141);
pub const PSM_GETCURRENTPAGEHWND = @as(u32, 1142);
pub const PSM_INSERTPAGE = @as(u32, 1143);
pub const PSM_SETHEADERTITLEA = @as(u32, 1149);
pub const PSM_SETHEADERTITLEW = @as(u32, 1150);
pub const PSM_SETHEADERSUBTITLEA = @as(u32, 1151);
pub const PSM_SETHEADERSUBTITLEW = @as(u32, 1152);
pub const PSM_HWNDTOINDEX = @as(u32, 1153);
pub const PSM_INDEXTOHWND = @as(u32, 1154);
pub const PSM_PAGETOINDEX = @as(u32, 1155);
pub const PSM_INDEXTOPAGE = @as(u32, 1156);
pub const PSM_IDTOINDEX = @as(u32, 1157);
pub const PSM_INDEXTOID = @as(u32, 1158);
pub const PSM_GETRESULT = @as(u32, 1159);
pub const PSM_RECALCPAGESIZES = @as(u32, 1160);
pub const PSM_SETNEXTTEXTW = @as(u32, 1161);
pub const PSWIZB_SHOW = @as(u32, 0);
pub const PSWIZB_RESTORE = @as(u32, 1);
pub const PSM_SHOWWIZBUTTONS = @as(u32, 1162);
pub const PSM_ENABLEWIZBUTTONS = @as(u32, 1163);
pub const PSM_SETBUTTONTEXTW = @as(u32, 1164);
pub const ID_PSRESTARTWINDOWS = @as(u32, 2);
pub const WIZ_CXDLG = @as(u32, 276);
pub const WIZ_CYDLG = @as(u32, 140);
pub const WIZ_CXBMP = @as(u32, 80);
pub const WIZ_BODYX = @as(u32, 92);
pub const WIZ_BODYCX = @as(u32, 184);
pub const PROP_SM_CXDLG = @as(u32, 212);
pub const PROP_SM_CYDLG = @as(u32, 188);
pub const PROP_MED_CXDLG = @as(u32, 227);
pub const PROP_MED_CYDLG = @as(u32, 215);
pub const PROP_LG_CXDLG = @as(u32, 252);
pub const PROP_LG_CYDLG = @as(u32, 218);
pub const WM_CONTEXTMENU = @as(u32, 123);
pub const WM_UNICHAR = @as(u32, 265);
pub const WM_PRINTCLIENT = @as(u32, 792);
pub const EM_CANPASTE = @as(u32, 1074);
pub const EM_DISPLAYBAND = @as(u32, 1075);
pub const EM_EXGETSEL = @as(u32, 1076);
pub const EM_EXLIMITTEXT = @as(u32, 1077);
pub const EM_EXLINEFROMCHAR = @as(u32, 1078);
pub const EM_EXSETSEL = @as(u32, 1079);
pub const EM_FINDTEXT = @as(u32, 1080);
pub const EM_FORMATRANGE = @as(u32, 1081);
pub const EM_GETCHARFORMAT = @as(u32, 1082);
pub const EM_GETEVENTMASK = @as(u32, 1083);
pub const EM_GETOLEINTERFACE = @as(u32, 1084);
pub const EM_GETPARAFORMAT = @as(u32, 1085);
pub const EM_GETSELTEXT = @as(u32, 1086);
pub const EM_HIDESELECTION = @as(u32, 1087);
pub const EM_PASTESPECIAL = @as(u32, 1088);
pub const EM_REQUESTRESIZE = @as(u32, 1089);
pub const EM_SELECTIONTYPE = @as(u32, 1090);
pub const EM_SETBKGNDCOLOR = @as(u32, 1091);
pub const EM_SETCHARFORMAT = @as(u32, 1092);
pub const EM_SETEVENTMASK = @as(u32, 1093);
pub const EM_SETOLECALLBACK = @as(u32, 1094);
pub const EM_SETPARAFORMAT = @as(u32, 1095);
pub const EM_SETTARGETDEVICE = @as(u32, 1096);
pub const EM_STREAMIN = @as(u32, 1097);
pub const EM_STREAMOUT = @as(u32, 1098);
pub const EM_GETTEXTRANGE = @as(u32, 1099);
pub const EM_FINDWORDBREAK = @as(u32, 1100);
pub const EM_SETOPTIONS = @as(u32, 1101);
pub const EM_GETOPTIONS = @as(u32, 1102);
pub const EM_FINDTEXTEX = @as(u32, 1103);
pub const EM_GETWORDBREAKPROCEX = @as(u32, 1104);
pub const EM_SETWORDBREAKPROCEX = @as(u32, 1105);
pub const EM_SETUNDOLIMIT = @as(u32, 1106);
pub const EM_REDO = @as(u32, 1108);
pub const EM_CANREDO = @as(u32, 1109);
pub const EM_GETUNDONAME = @as(u32, 1110);
pub const EM_GETREDONAME = @as(u32, 1111);
pub const EM_STOPGROUPTYPING = @as(u32, 1112);
pub const EM_SETTEXTMODE = @as(u32, 1113);
pub const EM_GETTEXTMODE = @as(u32, 1114);
pub const EM_AUTOURLDETECT = @as(u32, 1115);
pub const AURL_ENABLEURL = @as(u32, 1);
pub const AURL_ENABLEEMAILADDR = @as(u32, 2);
pub const AURL_ENABLETELNO = @as(u32, 4);
pub const AURL_ENABLEEAURLS = @as(u32, 8);
pub const AURL_ENABLEDRIVELETTERS = @as(u32, 16);
pub const AURL_DISABLEMIXEDLGC = @as(u32, 32);
pub const EM_GETAUTOURLDETECT = @as(u32, 1116);
pub const EM_SETPALETTE = @as(u32, 1117);
pub const EM_GETTEXTEX = @as(u32, 1118);
pub const EM_GETTEXTLENGTHEX = @as(u32, 1119);
pub const EM_SHOWSCROLLBAR = @as(u32, 1120);
pub const EM_SETTEXTEX = @as(u32, 1121);
pub const EM_SETPUNCTUATION = @as(u32, 1124);
pub const EM_GETPUNCTUATION = @as(u32, 1125);
pub const EM_SETWORDWRAPMODE = @as(u32, 1126);
pub const EM_GETWORDWRAPMODE = @as(u32, 1127);
pub const EM_SETIMECOLOR = @as(u32, 1128);
pub const EM_GETIMECOLOR = @as(u32, 1129);
pub const EM_SETIMEOPTIONS = @as(u32, 1130);
pub const EM_GETIMEOPTIONS = @as(u32, 1131);
pub const EM_CONVPOSITION = @as(u32, 1132);
pub const EM_SETLANGOPTIONS = @as(u32, 1144);
pub const EM_GETLANGOPTIONS = @as(u32, 1145);
pub const EM_GETIMECOMPMODE = @as(u32, 1146);
pub const EM_FINDTEXTW = @as(u32, 1147);
pub const EM_FINDTEXTEXW = @as(u32, 1148);
pub const EM_RECONVERSION = @as(u32, 1149);
pub const EM_SETIMEMODEBIAS = @as(u32, 1150);
pub const EM_GETIMEMODEBIAS = @as(u32, 1151);
pub const EM_SETBIDIOPTIONS = @as(u32, 1224);
pub const EM_GETBIDIOPTIONS = @as(u32, 1225);
pub const EM_SETTYPOGRAPHYOPTIONS = @as(u32, 1226);
pub const EM_GETTYPOGRAPHYOPTIONS = @as(u32, 1227);
pub const EM_SETEDITSTYLE = @as(u32, 1228);
pub const EM_GETEDITSTYLE = @as(u32, 1229);
pub const SES_EMULATESYSEDIT = @as(u32, 1);
pub const SES_BEEPONMAXTEXT = @as(u32, 2);
pub const SES_EXTENDBACKCOLOR = @as(u32, 4);
pub const SES_MAPCPS = @as(u32, 8);
pub const SES_HYPERLINKTOOLTIPS = @as(u32, 8);
pub const SES_EMULATE10 = @as(u32, 16);
pub const SES_DEFAULTLATINLIGA = @as(u32, 16);
pub const SES_USECRLF = @as(u32, 32);
pub const SES_NOFOCUSLINKNOTIFY = @as(u32, 32);
pub const SES_USEAIMM = @as(u32, 64);
pub const SES_NOIME = @as(u32, 128);
pub const SES_ALLOWBEEPS = @as(u32, 256);
pub const SES_UPPERCASE = @as(u32, 512);
pub const SES_LOWERCASE = @as(u32, 1024);
pub const SES_NOINPUTSEQUENCECHK = @as(u32, 2048);
pub const SES_BIDI = @as(u32, 4096);
pub const SES_SCROLLONKILLFOCUS = @as(u32, 8192);
pub const SES_XLTCRCRLFTOCR = @as(u32, 16384);
pub const SES_DRAFTMODE = @as(u32, 32768);
pub const SES_USECTF = @as(u32, 65536);
pub const SES_HIDEGRIDLINES = @as(u32, 131072);
pub const SES_USEATFONT = @as(u32, 262144);
pub const SES_CUSTOMLOOK = @as(u32, 524288);
pub const SES_LBSCROLLNOTIFY = @as(u32, 1048576);
pub const SES_CTFALLOWEMBED = @as(u32, 2097152);
pub const SES_CTFALLOWSMARTTAG = @as(u32, 4194304);
pub const SES_CTFALLOWPROOFING = @as(u32, 8388608);
pub const SES_LOGICALCARET = @as(u32, 16777216);
pub const SES_WORDDRAGDROP = @as(u32, 33554432);
pub const SES_SMARTDRAGDROP = @as(u32, 67108864);
pub const SES_MULTISELECT = @as(u32, 134217728);
pub const SES_CTFNOLOCK = @as(u32, 268435456);
pub const SES_NOEALINEHEIGHTADJUST = @as(u32, 536870912);
pub const SES_MAX = @as(u32, 536870912);
pub const IMF_AUTOKEYBOARD = @as(u32, 1);
pub const IMF_AUTOFONT = @as(u32, 2);
pub const IMF_IMECANCELCOMPLETE = @as(u32, 4);
pub const IMF_IMEALWAYSSENDNOTIFY = @as(u32, 8);
pub const IMF_AUTOFONTSIZEADJUST = @as(u32, 16);
pub const IMF_UIFONTS = @as(u32, 32);
pub const IMF_NOIMPLICITLANG = @as(u32, 64);
pub const IMF_DUALFONT = @as(u32, 128);
pub const IMF_NOKBDLIDFIXUP = @as(u32, 512);
pub const IMF_NORTFFONTSUBSTITUTE = @as(u32, 1024);
pub const IMF_SPELLCHECKING = @as(u32, 2048);
pub const IMF_TKBPREDICTION = @as(u32, 4096);
pub const IMF_IMEUIINTEGRATION = @as(u32, 8192);
pub const ICM_NOTOPEN = @as(u32, 0);
pub const ICM_LEVEL3 = @as(u32, 1);
pub const ICM_LEVEL2 = @as(u32, 2);
pub const ICM_LEVEL2_5 = @as(u32, 3);
pub const ICM_LEVEL2_SUI = @as(u32, 4);
pub const ICM_CTF = @as(u32, 5);
pub const TO_ADVANCEDTYPOGRAPHY = @as(u32, 1);
pub const TO_SIMPLELINEBREAK = @as(u32, 2);
pub const TO_DISABLECUSTOMTEXTOUT = @as(u32, 4);
pub const TO_ADVANCEDLAYOUT = @as(u32, 8);
pub const EM_OUTLINE = @as(u32, 1244);
pub const EM_GETSCROLLPOS = @as(u32, 1245);
pub const EM_SETSCROLLPOS = @as(u32, 1246);
pub const EM_SETFONTSIZE = @as(u32, 1247);
pub const EM_GETZOOM = @as(u32, 1248);
pub const EM_SETZOOM = @as(u32, 1249);
pub const EM_GETVIEWKIND = @as(u32, 1250);
pub const EM_SETVIEWKIND = @as(u32, 1251);
pub const EM_GETPAGE = @as(u32, 1252);
pub const EM_SETPAGE = @as(u32, 1253);
pub const EM_GETHYPHENATEINFO = @as(u32, 1254);
pub const EM_SETHYPHENATEINFO = @as(u32, 1255);
pub const EM_GETPAGEROTATE = @as(u32, 1259);
pub const EM_SETPAGEROTATE = @as(u32, 1260);
pub const EM_GETCTFMODEBIAS = @as(u32, 1261);
pub const EM_SETCTFMODEBIAS = @as(u32, 1262);
pub const EM_GETCTFOPENSTATUS = @as(u32, 1264);
pub const EM_SETCTFOPENSTATUS = @as(u32, 1265);
pub const EM_GETIMECOMPTEXT = @as(u32, 1266);
pub const EM_ISIME = @as(u32, 1267);
pub const EM_GETIMEPROPERTY = @as(u32, 1268);
pub const EM_GETQUERYRTFOBJ = @as(u32, 1293);
pub const EM_SETQUERYRTFOBJ = @as(u32, 1294);
pub const EPR_0 = @as(u32, 0);
pub const EPR_270 = @as(u32, 1);
pub const EPR_180 = @as(u32, 2);
pub const EPR_90 = @as(u32, 3);
pub const EPR_SE = @as(u32, 5);
pub const CTFMODEBIAS_DEFAULT = @as(u32, 0);
pub const CTFMODEBIAS_FILENAME = @as(u32, 1);
pub const CTFMODEBIAS_NAME = @as(u32, 2);
pub const CTFMODEBIAS_READING = @as(u32, 3);
pub const CTFMODEBIAS_DATETIME = @as(u32, 4);
pub const CTFMODEBIAS_CONVERSATION = @as(u32, 5);
pub const CTFMODEBIAS_NUMERIC = @as(u32, 6);
pub const CTFMODEBIAS_HIRAGANA = @as(u32, 7);
pub const CTFMODEBIAS_KATAKANA = @as(u32, 8);
pub const CTFMODEBIAS_HANGUL = @as(u32, 9);
pub const CTFMODEBIAS_HALFWIDTHKATAKANA = @as(u32, 10);
pub const CTFMODEBIAS_FULLWIDTHALPHANUMERIC = @as(u32, 11);
pub const CTFMODEBIAS_HALFWIDTHALPHANUMERIC = @as(u32, 12);
pub const IMF_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IMF_SMODE_NONE = @as(u32, 2);
pub const EMO_EXIT = @as(u32, 0);
pub const EMO_ENTER = @as(u32, 1);
pub const EMO_PROMOTE = @as(u32, 2);
pub const EMO_EXPAND = @as(u32, 3);
pub const EMO_MOVESELECTION = @as(u32, 4);
pub const EMO_GETVIEWMODE = @as(u32, 5);
pub const EMO_EXPANDSELECTION = @as(u32, 0);
pub const EMO_EXPANDDOCUMENT = @as(u32, 1);
pub const VM_NORMAL = @as(u32, 4);
pub const VM_OUTLINE = @as(u32, 2);
pub const VM_PAGE = @as(u32, 9);
pub const EM_INSERTTABLE = @as(u32, 1256);
pub const EM_GETAUTOCORRECTPROC = @as(u32, 1257);
pub const EM_SETAUTOCORRECTPROC = @as(u32, 1258);
pub const EM_CALLAUTOCORRECTPROC = @as(u32, 1279);
pub const ATP_NOCHANGE = @as(u32, 0);
pub const ATP_CHANGE = @as(u32, 1);
pub const ATP_NODELIMITER = @as(u32, 2);
pub const ATP_REPLACEALLTEXT = @as(u32, 4);
pub const EM_GETTABLEPARMS = @as(u32, 1289);
pub const EM_SETEDITSTYLEEX = @as(u32, 1299);
pub const EM_GETEDITSTYLEEX = @as(u32, 1300);
pub const SES_EX_NOTABLE = @as(u32, 4);
pub const SES_EX_NOMATH = @as(u32, 64);
pub const SES_EX_HANDLEFRIENDLYURL = @as(u32, 256);
pub const SES_EX_NOTHEMING = @as(u32, 524288);
pub const SES_EX_NOACETATESELECTION = @as(u32, 1048576);
pub const SES_EX_USESINGLELINE = @as(u32, 2097152);
pub const SES_EX_MULTITOUCH = @as(u32, 134217728);
pub const SES_EX_HIDETEMPFORMAT = @as(u32, 268435456);
pub const SES_EX_USEMOUSEWPARAM = @as(u32, 536870912);
pub const EM_GETSTORYTYPE = @as(u32, 1314);
pub const EM_SETSTORYTYPE = @as(u32, 1315);
pub const EM_GETELLIPSISMODE = @as(u32, 1329);
pub const EM_SETELLIPSISMODE = @as(u32, 1330);
pub const ELLIPSIS_MASK = @as(u32, 3);
pub const ELLIPSIS_NONE = @as(u32, 0);
pub const ELLIPSIS_END = @as(u32, 1);
pub const ELLIPSIS_WORD = @as(u32, 3);
pub const EM_SETTABLEPARMS = @as(u32, 1331);
pub const EM_GETTOUCHOPTIONS = @as(u32, 1334);
pub const EM_SETTOUCHOPTIONS = @as(u32, 1335);
pub const EM_INSERTIMAGE = @as(u32, 1338);
pub const EM_SETUIANAME = @as(u32, 1344);
pub const EM_GETELLIPSISSTATE = @as(u32, 1346);
pub const RTO_SHOWHANDLES = @as(u32, 1);
pub const RTO_DISABLEHANDLES = @as(u32, 2);
pub const RTO_READINGMODE = @as(u32, 3);
pub const EN_MSGFILTER = @as(u32, 1792);
pub const EN_REQUESTRESIZE = @as(u32, 1793);
pub const EN_SELCHANGE = @as(u32, 1794);
pub const EN_DROPFILES = @as(u32, 1795);
pub const EN_PROTECTED = @as(u32, 1796);
pub const EN_CORRECTTEXT = @as(u32, 1797);
pub const EN_STOPNOUNDO = @as(u32, 1798);
pub const EN_IMECHANGE = @as(u32, 1799);
pub const EN_SAVECLIPBOARD = @as(u32, 1800);
pub const EN_OLEOPFAILED = @as(u32, 1801);
pub const EN_OBJECTPOSITIONS = @as(u32, 1802);
pub const EN_LINK = @as(u32, 1803);
pub const EN_DRAGDROPDONE = @as(u32, 1804);
pub const EN_PARAGRAPHEXPANDED = @as(u32, 1805);
pub const EN_PAGECHANGE = @as(u32, 1806);
pub const EN_LOWFIRTF = @as(u32, 1807);
pub const EN_ALIGNLTR = @as(u32, 1808);
pub const EN_ALIGNRTL = @as(u32, 1809);
pub const EN_CLIPFORMAT = @as(u32, 1810);
pub const EN_STARTCOMPOSITION = @as(u32, 1811);
pub const EN_ENDCOMPOSITION = @as(u32, 1812);
pub const ENM_NONE = @as(u32, 0);
pub const ENM_CHANGE = @as(u32, 1);
pub const ENM_UPDATE = @as(u32, 2);
pub const ENM_SCROLL = @as(u32, 4);
pub const ENM_SCROLLEVENTS = @as(u32, 8);
pub const ENM_DRAGDROPDONE = @as(u32, 16);
pub const ENM_PARAGRAPHEXPANDED = @as(u32, 32);
pub const ENM_PAGECHANGE = @as(u32, 64);
pub const ENM_CLIPFORMAT = @as(u32, 128);
pub const ENM_KEYEVENTS = @as(u32, 65536);
pub const ENM_MOUSEEVENTS = @as(u32, 131072);
pub const ENM_REQUESTRESIZE = @as(u32, 262144);
pub const ENM_SELCHANGE = @as(u32, 524288);
pub const ENM_DROPFILES = @as(u32, 1048576);
pub const ENM_PROTECTED = @as(u32, 2097152);
pub const ENM_CORRECTTEXT = @as(u32, 4194304);
pub const ENM_IMECHANGE = @as(u32, 8388608);
pub const ENM_LANGCHANGE = @as(u32, 16777216);
pub const ENM_OBJECTPOSITIONS = @as(u32, 33554432);
pub const ENM_LINK = @as(u32, 67108864);
pub const ENM_LOWFIRTF = @as(u32, 134217728);
pub const ENM_STARTCOMPOSITION = @as(u32, 268435456);
pub const ENM_ENDCOMPOSITION = @as(u32, 536870912);
pub const ENM_GROUPTYPINGCHANGE = @as(u32, 1073741824);
pub const ENM_HIDELINKTOOLTIP = @as(u32, 2147483648);
pub const ES_SAVESEL = @as(u32, 32768);
pub const ES_SUNKEN = @as(u32, 16384);
pub const ES_DISABLENOSCROLL = @as(u32, 8192);
pub const ES_SELECTIONBAR = @as(u32, 16777216);
pub const ES_NOOLEDRAGDROP = @as(u32, 8);
pub const ES_EX_NOCALLOLEINIT = @as(u32, 0);
pub const ES_VERTICAL = @as(u32, 4194304);
pub const ES_NOIME = @as(u32, 524288);
pub const ES_SELFIME = @as(u32, 262144);
pub const ECO_AUTOWORDSELECTION = @as(u32, 1);
pub const ECO_AUTOVSCROLL = @as(u32, 64);
pub const ECO_AUTOHSCROLL = @as(u32, 128);
pub const ECO_NOHIDESEL = @as(u32, 256);
pub const ECO_READONLY = @as(u32, 2048);
pub const ECO_WANTRETURN = @as(u32, 4096);
pub const ECO_SAVESEL = @as(u32, 32768);
pub const ECO_SELECTIONBAR = @as(u32, 16777216);
pub const ECO_VERTICAL = @as(u32, 4194304);
pub const ECOOP_SET = @as(u32, 1);
pub const ECOOP_OR = @as(u32, 2);
pub const ECOOP_AND = @as(u32, 3);
pub const ECOOP_XOR = @as(u32, 4);
pub const WB_MOVEWORDPREV = @as(u32, 4);
pub const WB_MOVEWORDNEXT = @as(u32, 5);
pub const WB_PREVBREAK = @as(u32, 6);
pub const WB_NEXTBREAK = @as(u32, 7);
pub const PC_FOLLOWING = @as(u32, 1);
pub const PC_LEADING = @as(u32, 2);
pub const PC_OVERFLOW = @as(u32, 3);
pub const PC_DELIMITER = @as(u32, 4);
pub const WBF_WORDWRAP = @as(u32, 16);
pub const WBF_WORDBREAK = @as(u32, 32);
pub const WBF_OVERFLOW = @as(u32, 64);
pub const WBF_LEVEL1 = @as(u32, 128);
pub const WBF_LEVEL2 = @as(u32, 256);
pub const WBF_CUSTOM = @as(u32, 512);
pub const IMF_FORCENONE = @as(u32, 1);
pub const IMF_FORCEENABLE = @as(u32, 2);
pub const IMF_FORCEDISABLE = @as(u32, 4);
pub const IMF_CLOSESTATUSWINDOW = @as(u32, 8);
pub const IMF_VERTICAL = @as(u32, 32);
pub const IMF_FORCEACTIVE = @as(u32, 64);
pub const IMF_FORCEINACTIVE = @as(u32, 128);
pub const IMF_FORCEREMEMBER = @as(u32, 256);
pub const IMF_MULTIPLEEDIT = @as(u32, 1024);
pub const SCF_SELECTION = @as(u32, 1);
pub const SCF_WORD = @as(u32, 2);
pub const SCF_DEFAULT = @as(u32, 0);
pub const SCF_ALL = @as(u32, 4);
pub const SCF_USEUIRULES = @as(u32, 8);
pub const SCF_ASSOCIATEFONT = @as(u32, 16);
pub const SCF_NOKBUPDATE = @as(u32, 32);
pub const SCF_ASSOCIATEFONT2 = @as(u32, 64);
pub const SCF_SMARTFONT = @as(u32, 128);
pub const SCF_CHARREPFROMLCID = @as(u32, 256);
pub const SPF_DONTSETDEFAULT = @as(u32, 2);
pub const SPF_SETDEFAULT = @as(u32, 4);
pub const SF_TEXT = @as(u32, 1);
pub const SF_RTF = @as(u32, 2);
pub const SF_RTFNOOBJS = @as(u32, 3);
pub const SF_TEXTIZED = @as(u32, 4);
pub const SF_UNICODE = @as(u32, 16);
pub const SF_USECODEPAGE = @as(u32, 32);
pub const SF_NCRFORNONASCII = @as(u32, 64);
pub const SFF_WRITEXTRAPAR = @as(u32, 128);
pub const SFF_SELECTION = @as(u32, 32768);
pub const SFF_PLAINRTF = @as(u32, 16384);
pub const SFF_PERSISTVIEWSCALE = @as(u32, 8192);
pub const SFF_KEEPDOCINFO = @as(u32, 4096);
pub const SFF_PWD = @as(u32, 2048);
pub const SF_RTFVAL = @as(u32, 1792);
pub const MAX_TAB_STOPS = @as(u32, 32);
pub const MAX_TABLE_CELLS = @as(u32, 63);
pub const PFM_SPACEBEFORE = @as(u32, 64);
pub const PFM_SPACEAFTER = @as(u32, 128);
pub const PFM_LINESPACING = @as(u32, 256);
pub const PFM_STYLE = @as(u32, 1024);
pub const PFM_BORDER = @as(u32, 2048);
pub const PFM_SHADING = @as(u32, 4096);
pub const PFM_NUMBERINGSTYLE = @as(u32, 8192);
pub const PFM_NUMBERINGTAB = @as(u32, 16384);
pub const PFM_NUMBERINGSTART = @as(u32, 32768);
pub const PFM_KEEP = @as(u32, 131072);
pub const PFM_KEEPNEXT = @as(u32, 262144);
pub const PFM_PAGEBREAKBEFORE = @as(u32, 524288);
pub const PFM_NOLINENUMBER = @as(u32, 1048576);
pub const PFM_NOWIDOWCONTROL = @as(u32, 2097152);
pub const PFM_DONOTHYPHEN = @as(u32, 4194304);
pub const PFM_SIDEBYSIDE = @as(u32, 8388608);
pub const PFM_COLLAPSED = @as(u32, 16777216);
pub const PFM_OUTLINELEVEL = @as(u32, 33554432);
pub const PFM_BOX = @as(u32, 67108864);
pub const PFM_RESERVED2 = @as(u32, 134217728);
pub const PFM_TABLEROWDELIMITER = @as(u32, 268435456);
pub const PFM_TEXTWRAPPINGBREAK = @as(u32, 536870912);
pub const PFM_TABLE = @as(u32, 1073741824);
pub const PFN_BULLET = @as(u32, 1);
pub const PFN_ARABIC = @as(u32, 2);
pub const PFN_LCLETTER = @as(u32, 3);
pub const PFN_UCLETTER = @as(u32, 4);
pub const PFN_LCROMAN = @as(u32, 5);
pub const PFN_UCROMAN = @as(u32, 6);
pub const PFA_JUSTIFY = @as(u32, 4);
pub const PFA_FULL_INTERWORD = @as(u32, 4);
pub const WM_NOTIFY = @as(u32, 78);
pub const GCMF_GRIPPER = @as(u32, 1);
pub const GCMF_SPELLING = @as(u32, 2);
pub const GCMF_TOUCHMENU = @as(u32, 16384);
pub const GCMF_MOUSEMENU = @as(u32, 8192);
pub const OLEOP_DOVERB = @as(u32, 1);
pub const ST_DEFAULT = @as(u32, 0);
pub const ST_KEEPUNDO = @as(u32, 1);
pub const ST_SELECTION = @as(u32, 2);
pub const ST_NEWCHARS = @as(u32, 4);
pub const ST_UNICODE = @as(u32, 8);
pub const BOM_DEFPARADIR = @as(u32, 1);
pub const BOM_PLAINTEXT = @as(u32, 2);
pub const BOM_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOM_CONTEXTREADING = @as(u32, 8);
pub const BOM_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOM_LEGACYBIDICLASS = @as(u32, 64);
pub const BOM_UNICODEBIDI = @as(u32, 128);
pub const BOE_RTLDIR = @as(u32, 1);
pub const BOE_PLAINTEXT = @as(u32, 2);
pub const BOE_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOE_CONTEXTREADING = @as(u32, 8);
pub const BOE_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOE_FORCERECALC = @as(u32, 32);
pub const BOE_LEGACYBIDICLASS = @as(u32, 64);
pub const BOE_UNICODEBIDI = @as(u32, 128);
pub const FR_MATCHDIAC = @as(u32, 536870912);
pub const FR_MATCHKASHIDA = @as(u32, 1073741824);
pub const FR_MATCHALEFHAMZA = @as(u32, 2147483648);
pub const PFA_FULL_NEWSPAPER = @as(u32, 5);
pub const PFA_FULL_INTERLETTER = @as(u32, 6);
pub const PFA_FULL_SCALED = @as(u32, 7);
pub const PFA_FULL_GLYPHS = @as(u32, 8);
pub const AURL_ENABLEEA = @as(u32, 1);
pub const GCM_TOUCHMENU = @as(u32, 16384);
pub const GCM_MOUSEMENU = @as(u32, 8192);
pub const REO_NULL = @as(i32, 0);
pub const REO_READWRITEMASK = @as(i32, 2047);
pub const RECO_PASTE = @as(i32, 0);
pub const RECO_DROP = @as(i32, 1);
pub const RECO_COPY = @as(i32, 2);
pub const RECO_CUT = @as(i32, 3);
pub const RECO_DRAG = @as(i32, 4);
pub const S_MSG_KEY_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const TXTBIT_RICHTEXT = @as(u32, 1);
pub const TXTBIT_MULTILINE = @as(u32, 2);
pub const TXTBIT_READONLY = @as(u32, 4);
pub const TXTBIT_SHOWACCELERATOR = @as(u32, 8);
pub const TXTBIT_USEPASSWORD = @as(u32, 16);
pub const TXTBIT_HIDESELECTION = @as(u32, 32);
pub const TXTBIT_SAVESELECTION = @as(u32, 64);
pub const TXTBIT_AUTOWORDSEL = @as(u32, 128);
pub const TXTBIT_VERTICAL = @as(u32, 256);
pub const TXTBIT_SELBARCHANGE = @as(u32, 512);
pub const TXTBIT_WORDWRAP = @as(u32, 1024);
pub const TXTBIT_ALLOWBEEP = @as(u32, 2048);
pub const TXTBIT_DISABLEDRAG = @as(u32, 4096);
pub const TXTBIT_VIEWINSETCHANGE = @as(u32, 8192);
pub const TXTBIT_BACKSTYLECHANGE = @as(u32, 16384);
pub const TXTBIT_MAXLENGTHCHANGE = @as(u32, 32768);
pub const TXTBIT_SCROLLBARCHANGE = @as(u32, 65536);
pub const TXTBIT_CHARFORMATCHANGE = @as(u32, 131072);
pub const TXTBIT_PARAFORMATCHANGE = @as(u32, 262144);
pub const TXTBIT_EXTENTCHANGE = @as(u32, 524288);
pub const TXTBIT_CLIENTRECTCHANGE = @as(u32, 1048576);
pub const TXTBIT_USECURRENTBKG = @as(u32, 2097152);
pub const TXTBIT_NOTHREADREFCOUNT = @as(u32, 4194304);
pub const TXTBIT_SHOWPASSWORD = @as(u32, 8388608);
pub const TXTBIT_D2DDWRITE = @as(u32, 16777216);
pub const TXTBIT_D2DSIMPLETYPOGRAPHY = @as(u32, 33554432);
pub const TXTBIT_D2DPIXELSNAPPED = @as(u32, 67108864);
pub const TXTBIT_D2DSUBPIXELLINES = @as(u32, 134217728);
pub const TXTBIT_FLASHLASTPASSWORDCHAR = @as(u32, 268435456);
pub const TXTBIT_ADVANCEDINPUT = @as(u32, 536870912);
pub const TXES_ISDIALOG = @as(u32, 1);
pub const DA_LAST = @as(u32, 2147483647);
pub const DA_ERR = @as(i32, -1);
pub const DPAM_SORTED = @as(u32, 1);
pub const DPAM_NORMAL = @as(u32, 2);
pub const DPAM_UNION = @as(u32, 4);
pub const DPAM_INTERSECT = @as(u32, 8);
pub const DPAS_SORTED = @as(u32, 1);
pub const DPAS_INSERTBEFORE = @as(u32, 2);
pub const DPAS_INSERTAFTER = @as(u32, 4);
pub const MAX_THEMECOLOR = @as(u32, 64);
pub const MAX_THEMESIZE = @as(u32, 64);
pub const DTBG_CLIPRECT = @as(u32, 1);
pub const DTBG_DRAWSOLID = @as(u32, 2);
pub const DTBG_OMITBORDER = @as(u32, 4);
pub const DTBG_OMITCONTENT = @as(u32, 8);
pub const DTBG_COMPUTINGREGION = @as(u32, 16);
pub const DTBG_MIRRORDC = @as(u32, 32);
pub const DTBG_NOMIRROR = @as(u32, 64);
pub const DTT_GRAYED = @as(u32, 1);
pub const HTTB_BACKGROUNDSEG = @as(u32, 0);
pub const HTTB_FIXEDBORDER = @as(u32, 2);
pub const HTTB_CAPTION = @as(u32, 4);
pub const HTTB_RESIZINGBORDER_LEFT = @as(u32, 16);
pub const HTTB_RESIZINGBORDER_TOP = @as(u32, 32);
pub const HTTB_RESIZINGBORDER_RIGHT = @as(u32, 64);
pub const HTTB_RESIZINGBORDER_BOTTOM = @as(u32, 128);
pub const HTTB_SIZINGTEMPLATE = @as(u32, 256);
pub const HTTB_SYSTEMSIZINGMARGINS = @as(u32, 512);
pub const MAX_INTLIST_COUNT = @as(u32, 402);
pub const ETDT_DISABLE = @as(u32, 1);
pub const ETDT_ENABLE = @as(u32, 2);
pub const ETDT_USETABTEXTURE = @as(u32, 4);
pub const ETDT_USEAEROWIZARDTABTEXTURE = @as(u32, 8);
pub const WTNCA_NODRAWCAPTION = @as(u32, 1);
pub const WTNCA_NODRAWICON = @as(u32, 2);
pub const WTNCA_NOSYSMENU = @as(u32, 4);
pub const WTNCA_NOMIRRORHELP = @as(u32, 8);
pub const ODT_HEADER = @as(u32, 100);
pub const LVM_FIRST = @as(u32, 4096);
pub const TV_FIRST = @as(u32, 4352);
pub const HDM_FIRST = @as(u32, 4608);
pub const TCM_FIRST = @as(u32, 4864);
pub const PGM_FIRST = @as(u32, 5120);
pub const ECM_FIRST = @as(u32, 5376);
pub const BCM_FIRST = @as(u32, 5632);
pub const CBM_FIRST = @as(u32, 5888);
pub const CCM_FIRST = @as(u32, 8192);
pub const CCM_LAST = @as(u32, 8704);
pub const CCM_SETBKCOLOR = @as(u32, 8193);
pub const CCM_SETCOLORSCHEME = @as(u32, 8194);
pub const CCM_GETCOLORSCHEME = @as(u32, 8195);
pub const CCM_GETDROPTARGET = @as(u32, 8196);
pub const CCM_SETUNICODEFORMAT = @as(u32, 8197);
pub const CCM_GETUNICODEFORMAT = @as(u32, 8198);
pub const COMCTL32_VERSION = @as(u32, 6);
pub const CCM_SETVERSION = @as(u32, 8199);
pub const CCM_GETVERSION = @as(u32, 8200);
pub const CCM_SETNOTIFYWINDOW = @as(u32, 8201);
pub const CCM_SETWINDOWTHEME = @as(u32, 8203);
pub const CCM_DPISCALE = @as(u32, 8204);
pub const INFOTIPSIZE = @as(u32, 1024);
pub const MSGF_COMMCTRL_BEGINDRAG = @as(u32, 16896);
pub const MSGF_COMMCTRL_SIZEHEADER = @as(u32, 16897);
pub const MSGF_COMMCTRL_DRAGSELECT = @as(u32, 16898);
pub const MSGF_COMMCTRL_TOOLBARCUST = @as(u32, 16899);
pub const CDRF_DODEFAULT = @as(u32, 0);
pub const CDRF_NEWFONT = @as(u32, 2);
pub const CDRF_SKIPDEFAULT = @as(u32, 4);
pub const CDRF_DOERASE = @as(u32, 8);
pub const CDRF_SKIPPOSTPAINT = @as(u32, 256);
pub const CDRF_NOTIFYPOSTPAINT = @as(u32, 16);
pub const CDRF_NOTIFYITEMDRAW = @as(u32, 32);
pub const CDRF_NOTIFYSUBITEMDRAW = @as(u32, 32);
pub const CDRF_NOTIFYPOSTERASE = @as(u32, 64);
pub const CDDS_POSTERASE = @as(u32, 4);
pub const CDDS_ITEM = @as(u32, 65536);
pub const CDIS_SELECTED = @as(u32, 1);
pub const CDIS_GRAYED = @as(u32, 2);
pub const CDIS_DISABLED = @as(u32, 4);
pub const CDIS_CHECKED = @as(u32, 8);
pub const CDIS_FOCUS = @as(u32, 16);
pub const CDIS_DEFAULT = @as(u32, 32);
pub const CDIS_HOT = @as(u32, 64);
pub const CDIS_MARKED = @as(u32, 128);
pub const CDIS_INDETERMINATE = @as(u32, 256);
pub const CDIS_SHOWKEYBOARDCUES = @as(u32, 512);
pub const CDIS_NEARHOT = @as(u32, 1024);
pub const CDIS_OTHERSIDEHOT = @as(u32, 2048);
pub const CDIS_DROPHILITED = @as(u32, 4096);
pub const NM_GETCUSTOMSPLITRECT = @as(u32, 4294966049);
pub const CLR_NONE = @as(i32, -1);
pub const CLR_DEFAULT = @as(i32, -16777216);
pub const ILD_TRANSPARENT = @as(u32, 1);
pub const ILD_IMAGE = @as(u32, 32);
pub const ILD_ROP = @as(u32, 64);
pub const ILD_BLEND25 = @as(u32, 2);
pub const ILD_OVERLAYMASK = @as(u32, 3840);
pub const ILD_PRESERVEALPHA = @as(u32, 4096);
pub const ILD_SCALE = @as(u32, 8192);
pub const ILD_DPISCALE = @as(u32, 16384);
pub const ILD_ASYNC = @as(u32, 32768);
pub const ILS_NORMAL = @as(u32, 0);
pub const ILS_GLOW = @as(u32, 1);
pub const ILS_SHADOW = @as(u32, 2);
pub const ILS_SATURATE = @as(u32, 4);
pub const ILS_ALPHA = @as(u32, 8);
pub const ILGT_NORMAL = @as(u32, 0);
pub const ILGT_ASYNC = @as(u32, 1);
pub const ILP_NORMAL = @as(u32, 0);
pub const ILP_DOWNLEVEL = @as(u32, 1);
pub const HDS_HORZ = @as(u32, 0);
pub const HDS_BUTTONS = @as(u32, 2);
pub const HDS_HOTTRACK = @as(u32, 4);
pub const HDS_HIDDEN = @as(u32, 8);
pub const HDS_DRAGDROP = @as(u32, 64);
pub const HDS_FULLDRAG = @as(u32, 128);
pub const HDS_FILTERBAR = @as(u32, 256);
pub const HDS_FLAT = @as(u32, 512);
pub const HDS_CHECKBOXES = @as(u32, 1024);
pub const HDS_NOSIZING = @as(u32, 2048);
pub const HDS_OVERFLOW = @as(u32, 4096);
pub const HDFT_ISSTRING = @as(u32, 0);
pub const HDFT_ISNUMBER = @as(u32, 1);
pub const HDFT_ISDATE = @as(u32, 2);
pub const HDFT_HASNOVALUE = @as(u32, 32768);
pub const HDF_LEFT = @as(u32, 0);
pub const HDF_RIGHT = @as(u32, 1);
pub const HDF_CENTER = @as(u32, 2);
pub const HDF_JUSTIFYMASK = @as(u32, 3);
pub const HDF_RTLREADING = @as(u32, 4);
pub const HDF_BITMAP = @as(u32, 8192);
pub const HDF_STRING = @as(u32, 16384);
pub const HDF_OWNERDRAW = @as(u32, 32768);
pub const HDF_IMAGE = @as(u32, 2048);
pub const HDF_BITMAP_ON_RIGHT = @as(u32, 4096);
pub const HDF_SORTUP = @as(u32, 1024);
pub const HDF_SORTDOWN = @as(u32, 512);
pub const HDF_CHECKBOX = @as(u32, 64);
pub const HDF_CHECKED = @as(u32, 128);
pub const HDF_FIXEDWIDTH = @as(u32, 256);
pub const HDF_SPLITBUTTON = @as(u32, 16777216);
pub const HDIS_FOCUSED = @as(u32, 1);
pub const HDM_GETITEMCOUNT = @as(u32, 4608);
pub const HDM_INSERTITEMA = @as(u32, 4609);
pub const HDM_INSERTITEMW = @as(u32, 4618);
pub const HDM_DELETEITEM = @as(u32, 4610);
pub const HDM_GETITEMA = @as(u32, 4611);
pub const HDM_GETITEMW = @as(u32, 4619);
pub const HDM_SETITEMA = @as(u32, 4612);
pub const HDM_SETITEMW = @as(u32, 4620);
pub const HDM_LAYOUT = @as(u32, 4613);
pub const HHT_NOWHERE = @as(u32, 1);
pub const HHT_ONHEADER = @as(u32, 2);
pub const HHT_ONDIVIDER = @as(u32, 4);
pub const HHT_ONDIVOPEN = @as(u32, 8);
pub const HHT_ONFILTER = @as(u32, 16);
pub const HHT_ONFILTERBUTTON = @as(u32, 32);
pub const HHT_ABOVE = @as(u32, 256);
pub const HHT_BELOW = @as(u32, 512);
pub const HHT_TORIGHT = @as(u32, 1024);
pub const HHT_TOLEFT = @as(u32, 2048);
pub const HHT_ONITEMSTATEICON = @as(u32, 4096);
pub const HHT_ONDROPDOWN = @as(u32, 8192);
pub const HHT_ONOVERFLOW = @as(u32, 16384);
pub const HDSIL_NORMAL = @as(u32, 0);
pub const HDSIL_STATE = @as(u32, 1);
pub const HDM_HITTEST = @as(u32, 4614);
pub const HDM_GETITEMRECT = @as(u32, 4615);
pub const HDM_SETIMAGELIST = @as(u32, 4616);
pub const HDM_GETIMAGELIST = @as(u32, 4617);
pub const HDM_ORDERTOINDEX = @as(u32, 4623);
pub const HDM_CREATEDRAGIMAGE = @as(u32, 4624);
pub const HDM_GETORDERARRAY = @as(u32, 4625);
pub const HDM_SETORDERARRAY = @as(u32, 4626);
pub const HDM_SETHOTDIVIDER = @as(u32, 4627);
pub const HDM_SETBITMAPMARGIN = @as(u32, 4628);
pub const HDM_GETBITMAPMARGIN = @as(u32, 4629);
pub const HDM_SETFILTERCHANGETIMEOUT = @as(u32, 4630);
pub const HDM_EDITFILTER = @as(u32, 4631);
pub const HDM_CLEARFILTER = @as(u32, 4632);
pub const HDM_GETITEMDROPDOWNRECT = @as(u32, 4633);
pub const HDM_GETOVERFLOWRECT = @as(u32, 4634);
pub const HDM_GETFOCUSEDITEM = @as(u32, 4635);
pub const HDM_SETFOCUSEDITEM = @as(u32, 4636);
pub const CMB_MASKED = @as(u32, 2);
pub const TBSTATE_CHECKED = @as(u32, 1);
pub const TBSTATE_PRESSED = @as(u32, 2);
pub const TBSTATE_ENABLED = @as(u32, 4);
pub const TBSTATE_HIDDEN = @as(u32, 8);
pub const TBSTATE_INDETERMINATE = @as(u32, 16);
pub const TBSTATE_WRAP = @as(u32, 32);
pub const TBSTATE_ELLIPSES = @as(u32, 64);
pub const TBSTATE_MARKED = @as(u32, 128);
pub const TBSTYLE_BUTTON = @as(u32, 0);
pub const TBSTYLE_SEP = @as(u32, 1);
pub const TBSTYLE_CHECK = @as(u32, 2);
pub const TBSTYLE_GROUP = @as(u32, 4);
pub const TBSTYLE_DROPDOWN = @as(u32, 8);
pub const TBSTYLE_AUTOSIZE = @as(u32, 16);
pub const TBSTYLE_NOPREFIX = @as(u32, 32);
pub const TBSTYLE_TOOLTIPS = @as(u32, 256);
pub const TBSTYLE_WRAPABLE = @as(u32, 512);
pub const TBSTYLE_ALTDRAG = @as(u32, 1024);
pub const TBSTYLE_FLAT = @as(u32, 2048);
pub const TBSTYLE_LIST = @as(u32, 4096);
pub const TBSTYLE_CUSTOMERASE = @as(u32, 8192);
pub const TBSTYLE_REGISTERDROP = @as(u32, 16384);
pub const TBSTYLE_TRANSPARENT = @as(u32, 32768);
pub const TBSTYLE_EX_DRAWDDARROWS = @as(u32, 1);
pub const BTNS_SHOWTEXT = @as(u32, 64);
pub const BTNS_WHOLEDROPDOWN = @as(u32, 128);
pub const TBSTYLE_EX_MIXEDBUTTONS = @as(u32, 8);
pub const TBSTYLE_EX_HIDECLIPPEDBUTTONS = @as(u32, 16);
pub const TBSTYLE_EX_MULTICOLUMN = @as(u32, 2);
pub const TBSTYLE_EX_VERTICAL = @as(u32, 4);
pub const TBSTYLE_EX_DOUBLEBUFFER = @as(u32, 128);
pub const TBCDRF_NOEDGES = @as(u32, 65536);
pub const TBCDRF_HILITEHOTTRACK = @as(u32, 131072);
pub const TBCDRF_NOOFFSET = @as(u32, 262144);
pub const TBCDRF_NOMARK = @as(u32, 524288);
pub const TBCDRF_NOETCHEDEFFECT = @as(u32, 1048576);
pub const TBCDRF_BLENDICON = @as(u32, 2097152);
pub const TBCDRF_NOBACKGROUND = @as(u32, 4194304);
pub const TBCDRF_USECDCOLORS = @as(u32, 8388608);
pub const TB_ENABLEBUTTON = @as(u32, 1025);
pub const TB_CHECKBUTTON = @as(u32, 1026);
pub const TB_PRESSBUTTON = @as(u32, 1027);
pub const TB_HIDEBUTTON = @as(u32, 1028);
pub const TB_INDETERMINATE = @as(u32, 1029);
pub const TB_MARKBUTTON = @as(u32, 1030);
pub const TB_ISBUTTONENABLED = @as(u32, 1033);
pub const TB_ISBUTTONCHECKED = @as(u32, 1034);
pub const TB_ISBUTTONPRESSED = @as(u32, 1035);
pub const TB_ISBUTTONHIDDEN = @as(u32, 1036);
pub const TB_ISBUTTONINDETERMINATE = @as(u32, 1037);
pub const TB_ISBUTTONHIGHLIGHTED = @as(u32, 1038);
pub const TB_SETSTATE = @as(u32, 1041);
pub const TB_GETSTATE = @as(u32, 1042);
pub const TB_ADDBITMAP = @as(u32, 1043);
pub const IDB_STD_SMALL_COLOR = @as(u32, 0);
pub const IDB_STD_LARGE_COLOR = @as(u32, 1);
pub const IDB_VIEW_SMALL_COLOR = @as(u32, 4);
pub const IDB_VIEW_LARGE_COLOR = @as(u32, 5);
pub const IDB_HIST_SMALL_COLOR = @as(u32, 8);
pub const IDB_HIST_LARGE_COLOR = @as(u32, 9);
pub const IDB_HIST_NORMAL = @as(u32, 12);
pub const IDB_HIST_HOT = @as(u32, 13);
pub const IDB_HIST_DISABLED = @as(u32, 14);
pub const IDB_HIST_PRESSED = @as(u32, 15);
pub const STD_CUT = @as(u32, 0);
pub const STD_COPY = @as(u32, 1);
pub const STD_PASTE = @as(u32, 2);
pub const STD_UNDO = @as(u32, 3);
pub const STD_REDOW = @as(u32, 4);
pub const STD_DELETE = @as(u32, 5);
pub const STD_FILENEW = @as(u32, 6);
pub const STD_FILEOPEN = @as(u32, 7);
pub const STD_FILESAVE = @as(u32, 8);
pub const STD_PRINTPRE = @as(u32, 9);
pub const STD_PROPERTIES = @as(u32, 10);
pub const STD_HELP = @as(u32, 11);
pub const STD_FIND = @as(u32, 12);
pub const STD_REPLACE = @as(u32, 13);
pub const STD_PRINT = @as(u32, 14);
pub const VIEW_LARGEICONS = @as(u32, 0);
pub const VIEW_SMALLICONS = @as(u32, 1);
pub const VIEW_LIST = @as(u32, 2);
pub const VIEW_DETAILS = @as(u32, 3);
pub const VIEW_SORTNAME = @as(u32, 4);
pub const VIEW_SORTSIZE = @as(u32, 5);
pub const VIEW_SORTDATE = @as(u32, 6);
pub const VIEW_SORTTYPE = @as(u32, 7);
pub const VIEW_PARENTFOLDER = @as(u32, 8);
pub const VIEW_NETCONNECT = @as(u32, 9);
pub const VIEW_NETDISCONNECT = @as(u32, 10);
pub const VIEW_NEWFOLDER = @as(u32, 11);
pub const VIEW_VIEWMENU = @as(u32, 12);
pub const HIST_BACK = @as(u32, 0);
pub const HIST_FORWARD = @as(u32, 1);
pub const HIST_FAVORITES = @as(u32, 2);
pub const HIST_ADDTOFAVORITES = @as(u32, 3);
pub const HIST_VIEWTREE = @as(u32, 4);
pub const TB_ADDBUTTONSA = @as(u32, 1044);
pub const TB_INSERTBUTTONA = @as(u32, 1045);
pub const TB_DELETEBUTTON = @as(u32, 1046);
pub const TB_GETBUTTON = @as(u32, 1047);
pub const TB_BUTTONCOUNT = @as(u32, 1048);
pub const TB_COMMANDTOINDEX = @as(u32, 1049);
pub const TB_SAVERESTOREA = @as(u32, 1050);
pub const TB_SAVERESTOREW = @as(u32, 1100);
pub const TB_CUSTOMIZE = @as(u32, 1051);
pub const TB_ADDSTRINGA = @as(u32, 1052);
pub const TB_ADDSTRINGW = @as(u32, 1101);
pub const TB_GETITEMRECT = @as(u32, 1053);
pub const TB_BUTTONSTRUCTSIZE = @as(u32, 1054);
pub const TB_SETBUTTONSIZE = @as(u32, 1055);
pub const TB_SETBITMAPSIZE = @as(u32, 1056);
pub const TB_AUTOSIZE = @as(u32, 1057);
pub const TB_GETTOOLTIPS = @as(u32, 1059);
pub const TB_SETTOOLTIPS = @as(u32, 1060);
pub const TB_SETPARENT = @as(u32, 1061);
pub const TB_SETROWS = @as(u32, 1063);
pub const TB_GETROWS = @as(u32, 1064);
pub const TB_SETCMDID = @as(u32, 1066);
pub const TB_CHANGEBITMAP = @as(u32, 1067);
pub const TB_GETBITMAP = @as(u32, 1068);
pub const TB_GETBUTTONTEXTA = @as(u32, 1069);
pub const TB_GETBUTTONTEXTW = @as(u32, 1099);
pub const TB_REPLACEBITMAP = @as(u32, 1070);
pub const TB_SETINDENT = @as(u32, 1071);
pub const TB_SETIMAGELIST = @as(u32, 1072);
pub const TB_GETIMAGELIST = @as(u32, 1073);
pub const TB_LOADIMAGES = @as(u32, 1074);
pub const TB_GETRECT = @as(u32, 1075);
pub const TB_SETHOTIMAGELIST = @as(u32, 1076);
pub const TB_GETHOTIMAGELIST = @as(u32, 1077);
pub const TB_SETDISABLEDIMAGELIST = @as(u32, 1078);
pub const TB_GETDISABLEDIMAGELIST = @as(u32, 1079);
pub const TB_SETSTYLE = @as(u32, 1080);
pub const TB_GETSTYLE = @as(u32, 1081);
pub const TB_GETBUTTONSIZE = @as(u32, 1082);
pub const TB_SETBUTTONWIDTH = @as(u32, 1083);
pub const TB_SETMAXTEXTROWS = @as(u32, 1084);
pub const TB_GETTEXTROWS = @as(u32, 1085);
pub const TB_GETOBJECT = @as(u32, 1086);
pub const TB_GETHOTITEM = @as(u32, 1095);
pub const TB_SETHOTITEM = @as(u32, 1096);
pub const TB_SETANCHORHIGHLIGHT = @as(u32, 1097);
pub const TB_GETANCHORHIGHLIGHT = @as(u32, 1098);
pub const TB_MAPACCELERATORA = @as(u32, 1102);
pub const TB_GETINSERTMARK = @as(u32, 1103);
pub const TB_SETINSERTMARK = @as(u32, 1104);
pub const TB_INSERTMARKHITTEST = @as(u32, 1105);
pub const TB_MOVEBUTTON = @as(u32, 1106);
pub const TB_GETMAXSIZE = @as(u32, 1107);
pub const TB_SETEXTENDEDSTYLE = @as(u32, 1108);
pub const TB_GETEXTENDEDSTYLE = @as(u32, 1109);
pub const TB_GETPADDING = @as(u32, 1110);
pub const TB_SETPADDING = @as(u32, 1111);
pub const TB_SETINSERTMARKCOLOR = @as(u32, 1112);
pub const TB_GETINSERTMARKCOLOR = @as(u32, 1113);
pub const TB_MAPACCELERATORW = @as(u32, 1114);
pub const TBBF_LARGE = @as(u32, 1);
pub const TB_GETBITMAPFLAGS = @as(u32, 1065);
pub const TB_GETBUTTONINFOW = @as(u32, 1087);
pub const TB_SETBUTTONINFOW = @as(u32, 1088);
pub const TB_GETBUTTONINFOA = @as(u32, 1089);
pub const TB_SETBUTTONINFOA = @as(u32, 1090);
pub const TB_INSERTBUTTONW = @as(u32, 1091);
pub const TB_ADDBUTTONSW = @as(u32, 1092);
pub const TB_HITTEST = @as(u32, 1093);
pub const TB_SETDRAWTEXTFLAGS = @as(u32, 1094);
pub const TB_GETSTRINGW = @as(u32, 1115);
pub const TB_GETSTRINGA = @as(u32, 1116);
pub const TB_SETBOUNDINGSIZE = @as(u32, 1117);
pub const TB_SETHOTITEM2 = @as(u32, 1118);
pub const TB_HASACCELERATOR = @as(u32, 1119);
pub const TB_SETLISTGAP = @as(u32, 1120);
pub const TB_GETIMAGELISTCOUNT = @as(u32, 1122);
pub const TB_GETIDEALSIZE = @as(u32, 1123);
pub const TBMF_PAD = @as(u32, 1);
pub const TBMF_BARPAD = @as(u32, 2);
pub const TBMF_BUTTONSPACING = @as(u32, 4);
pub const TB_GETMETRICS = @as(u32, 1125);
pub const TB_SETMETRICS = @as(u32, 1126);
pub const TB_GETITEMDROPDOWNRECT = @as(u32, 1127);
pub const TB_SETPRESSEDIMAGELIST = @as(u32, 1128);
pub const TB_GETPRESSEDIMAGELIST = @as(u32, 1129);
pub const TBNRF_HIDEHELP = @as(u32, 1);
pub const TBNRF_ENDCUSTOMIZE = @as(u32, 2);
pub const TBDDRET_DEFAULT = @as(u32, 0);
pub const TBDDRET_NODEFAULT = @as(u32, 1);
pub const TBDDRET_TREATPRESSED = @as(u32, 2);
pub const RBIM_IMAGELIST = @as(u32, 1);
pub const RBS_TOOLTIPS = @as(u32, 256);
pub const RBS_VARHEIGHT = @as(u32, 512);
pub const RBS_BANDBORDERS = @as(u32, 1024);
pub const RBS_FIXEDORDER = @as(u32, 2048);
pub const RBS_REGISTERDROP = @as(u32, 4096);
pub const RBS_AUTOSIZE = @as(u32, 8192);
pub const RBS_VERTICALGRIPPER = @as(u32, 16384);
pub const RBS_DBLCLKTOGGLE = @as(u32, 32768);
pub const RBBS_BREAK = @as(u32, 1);
pub const RBBS_FIXEDSIZE = @as(u32, 2);
pub const RBBS_CHILDEDGE = @as(u32, 4);
pub const RBBS_HIDDEN = @as(u32, 8);
pub const RBBS_NOVERT = @as(u32, 16);
pub const RBBS_FIXEDBMP = @as(u32, 32);
pub const RBBS_VARIABLEHEIGHT = @as(u32, 64);
pub const RBBS_GRIPPERALWAYS = @as(u32, 128);
pub const RBBS_NOGRIPPER = @as(u32, 256);
pub const RBBS_USECHEVRON = @as(u32, 512);
pub const RBBS_HIDETITLE = @as(u32, 1024);
pub const RBBS_TOPALIGN = @as(u32, 2048);
pub const RBBIM_STYLE = @as(u32, 1);
pub const RBBIM_COLORS = @as(u32, 2);
pub const RBBIM_TEXT = @as(u32, 4);
pub const RBBIM_IMAGE = @as(u32, 8);
pub const RBBIM_CHILD = @as(u32, 16);
pub const RBBIM_CHILDSIZE = @as(u32, 32);
pub const RBBIM_SIZE = @as(u32, 64);
pub const RBBIM_BACKGROUND = @as(u32, 128);
pub const RBBIM_ID = @as(u32, 256);
pub const RBBIM_IDEALSIZE = @as(u32, 512);
pub const RBBIM_LPARAM = @as(u32, 1024);
pub const RBBIM_HEADERSIZE = @as(u32, 2048);
pub const RBBIM_CHEVRONLOCATION = @as(u32, 4096);
pub const RBBIM_CHEVRONSTATE = @as(u32, 8192);
pub const RB_INSERTBANDA = @as(u32, 1025);
pub const RB_DELETEBAND = @as(u32, 1026);
pub const RB_GETBARINFO = @as(u32, 1027);
pub const RB_SETBARINFO = @as(u32, 1028);
pub const RB_SETBANDINFOA = @as(u32, 1030);
pub const RB_SETPARENT = @as(u32, 1031);
pub const RB_HITTEST = @as(u32, 1032);
pub const RB_GETRECT = @as(u32, 1033);
pub const RB_INSERTBANDW = @as(u32, 1034);
pub const RB_SETBANDINFOW = @as(u32, 1035);
pub const RB_GETBANDCOUNT = @as(u32, 1036);
pub const RB_GETROWCOUNT = @as(u32, 1037);
pub const RB_GETROWHEIGHT = @as(u32, 1038);
pub const RB_IDTOINDEX = @as(u32, 1040);
pub const RB_GETTOOLTIPS = @as(u32, 1041);
pub const RB_SETTOOLTIPS = @as(u32, 1042);
pub const RB_SETBKCOLOR = @as(u32, 1043);
pub const RB_GETBKCOLOR = @as(u32, 1044);
pub const RB_SETTEXTCOLOR = @as(u32, 1045);
pub const RB_GETTEXTCOLOR = @as(u32, 1046);
pub const RBSTR_CHANGERECT = @as(u32, 1);
pub const RB_SIZETORECT = @as(u32, 1047);
pub const RB_BEGINDRAG = @as(u32, 1048);
pub const RB_ENDDRAG = @as(u32, 1049);
pub const RB_DRAGMOVE = @as(u32, 1050);
pub const RB_GETBARHEIGHT = @as(u32, 1051);
pub const RB_GETBANDINFOW = @as(u32, 1052);
pub const RB_GETBANDINFOA = @as(u32, 1053);
pub const RB_MINIMIZEBAND = @as(u32, 1054);
pub const RB_MAXIMIZEBAND = @as(u32, 1055);
pub const RB_GETBANDBORDERS = @as(u32, 1058);
pub const RB_SHOWBAND = @as(u32, 1059);
pub const RB_SETPALETTE = @as(u32, 1061);
pub const RB_GETPALETTE = @as(u32, 1062);
pub const RB_MOVEBAND = @as(u32, 1063);
pub const RB_GETBANDMARGINS = @as(u32, 1064);
pub const RB_SETEXTENDEDSTYLE = @as(u32, 1065);
pub const RB_GETEXTENDEDSTYLE = @as(u32, 1066);
pub const RB_PUSHCHEVRON = @as(u32, 1067);
pub const RB_SETBANDWIDTH = @as(u32, 1068);
pub const RBAB_AUTOSIZE = @as(u32, 1);
pub const RBAB_ADDBAND = @as(u32, 2);
pub const RBHT_NOWHERE = @as(u32, 1);
pub const RBHT_CAPTION = @as(u32, 2);
pub const RBHT_CLIENT = @as(u32, 3);
pub const RBHT_GRABBER = @as(u32, 4);
pub const RBHT_CHEVRON = @as(u32, 8);
pub const RBHT_SPLITTER = @as(u32, 16);
pub const TTS_ALWAYSTIP = @as(u32, 1);
pub const TTS_NOPREFIX = @as(u32, 2);
pub const TTS_NOANIMATE = @as(u32, 16);
pub const TTS_NOFADE = @as(u32, 32);
pub const TTS_BALLOON = @as(u32, 64);
pub const TTS_CLOSE = @as(u32, 128);
pub const TTS_USEVISUALSTYLE = @as(u32, 256);
pub const TTF_DI_SETITEM = @as(u32, 32768);
pub const TTDT_AUTOMATIC = @as(u32, 0);
pub const TTDT_RESHOW = @as(u32, 1);
pub const TTDT_AUTOPOP = @as(u32, 2);
pub const TTDT_INITIAL = @as(u32, 3);
pub const TTM_ACTIVATE = @as(u32, 1025);
pub const TTM_SETDELAYTIME = @as(u32, 1027);
pub const TTM_ADDTOOLA = @as(u32, 1028);
pub const TTM_ADDTOOLW = @as(u32, 1074);
pub const TTM_DELTOOLA = @as(u32, 1029);
pub const TTM_DELTOOLW = @as(u32, 1075);
pub const TTM_NEWTOOLRECTA = @as(u32, 1030);
pub const TTM_NEWTOOLRECTW = @as(u32, 1076);
pub const TTM_RELAYEVENT = @as(u32, 1031);
pub const TTM_GETTOOLINFOA = @as(u32, 1032);
pub const TTM_GETTOOLINFOW = @as(u32, 1077);
pub const TTM_SETTOOLINFOA = @as(u32, 1033);
pub const TTM_SETTOOLINFOW = @as(u32, 1078);
pub const TTM_HITTESTA = @as(u32, 1034);
pub const TTM_HITTESTW = @as(u32, 1079);
pub const TTM_GETTEXTA = @as(u32, 1035);
pub const TTM_GETTEXTW = @as(u32, 1080);
pub const TTM_UPDATETIPTEXTA = @as(u32, 1036);
pub const TTM_UPDATETIPTEXTW = @as(u32, 1081);
pub const TTM_GETTOOLCOUNT = @as(u32, 1037);
pub const TTM_ENUMTOOLSA = @as(u32, 1038);
pub const TTM_ENUMTOOLSW = @as(u32, 1082);
pub const TTM_GETCURRENTTOOLA = @as(u32, 1039);
pub const TTM_GETCURRENTTOOLW = @as(u32, 1083);
pub const TTM_WINDOWFROMPOINT = @as(u32, 1040);
pub const TTM_TRACKACTIVATE = @as(u32, 1041);
pub const TTM_TRACKPOSITION = @as(u32, 1042);
pub const TTM_SETTIPBKCOLOR = @as(u32, 1043);
pub const TTM_SETTIPTEXTCOLOR = @as(u32, 1044);
pub const TTM_GETDELAYTIME = @as(u32, 1045);
pub const TTM_GETTIPBKCOLOR = @as(u32, 1046);
pub const TTM_GETTIPTEXTCOLOR = @as(u32, 1047);
pub const TTM_SETMAXTIPWIDTH = @as(u32, 1048);
pub const TTM_GETMAXTIPWIDTH = @as(u32, 1049);
pub const TTM_SETMARGIN = @as(u32, 1050);
pub const TTM_GETMARGIN = @as(u32, 1051);
pub const TTM_POP = @as(u32, 1052);
pub const TTM_UPDATE = @as(u32, 1053);
pub const TTM_GETBUBBLESIZE = @as(u32, 1054);
pub const TTM_ADJUSTRECT = @as(u32, 1055);
pub const TTM_SETTITLEA = @as(u32, 1056);
pub const TTM_SETTITLEW = @as(u32, 1057);
pub const TTM_POPUP = @as(u32, 1058);
pub const TTM_GETTITLE = @as(u32, 1059);
pub const SBARS_SIZEGRIP = @as(u32, 256);
pub const SBARS_TOOLTIPS = @as(u32, 2048);
pub const SBT_TOOLTIPS = @as(u32, 2048);
pub const SB_SETTEXTA = @as(u32, 1025);
pub const SB_SETTEXTW = @as(u32, 1035);
pub const SB_GETTEXTA = @as(u32, 1026);
pub const SB_GETTEXTW = @as(u32, 1037);
pub const SB_GETTEXTLENGTHA = @as(u32, 1027);
pub const SB_GETTEXTLENGTHW = @as(u32, 1036);
pub const SB_SETPARTS = @as(u32, 1028);
pub const SB_GETPARTS = @as(u32, 1030);
pub const SB_GETBORDERS = @as(u32, 1031);
pub const SB_SETMINHEIGHT = @as(u32, 1032);
pub const SB_SIMPLE = @as(u32, 1033);
pub const SB_GETRECT = @as(u32, 1034);
pub const SB_ISSIMPLE = @as(u32, 1038);
pub const SB_SETICON = @as(u32, 1039);
pub const SB_SETTIPTEXTA = @as(u32, 1040);
pub const SB_SETTIPTEXTW = @as(u32, 1041);
pub const SB_GETTIPTEXTA = @as(u32, 1042);
pub const SB_GETTIPTEXTW = @as(u32, 1043);
pub const SB_GETICON = @as(u32, 1044);
pub const SBT_OWNERDRAW = @as(u32, 4096);
pub const SBT_NOBORDERS = @as(u32, 256);
pub const SBT_POPOUT = @as(u32, 512);
pub const SBT_RTLREADING = @as(u32, 1024);
pub const SBT_NOTABPARSING = @as(u32, 2048);
pub const SB_SIMPLEID = @as(u32, 255);
pub const TBS_AUTOTICKS = @as(u32, 1);
pub const TBS_VERT = @as(u32, 2);
pub const TBS_HORZ = @as(u32, 0);
pub const TBS_TOP = @as(u32, 4);
pub const TBS_BOTTOM = @as(u32, 0);
pub const TBS_LEFT = @as(u32, 4);
pub const TBS_RIGHT = @as(u32, 0);
pub const TBS_BOTH = @as(u32, 8);
pub const TBS_NOTICKS = @as(u32, 16);
pub const TBS_ENABLESELRANGE = @as(u32, 32);
pub const TBS_FIXEDLENGTH = @as(u32, 64);
pub const TBS_NOTHUMB = @as(u32, 128);
pub const TBS_TOOLTIPS = @as(u32, 256);
pub const TBS_REVERSED = @as(u32, 512);
pub const TBS_DOWNISLEFT = @as(u32, 1024);
pub const TBS_NOTIFYBEFOREMOVE = @as(u32, 2048);
pub const TBS_TRANSPARENTBKGND = @as(u32, 4096);
pub const TBM_GETRANGEMIN = @as(u32, 1025);
pub const TBM_GETRANGEMAX = @as(u32, 1026);
pub const TBM_GETTIC = @as(u32, 1027);
pub const TBM_SETTIC = @as(u32, 1028);
pub const TBM_SETPOS = @as(u32, 1029);
pub const TBM_SETRANGE = @as(u32, 1030);
pub const TBM_SETRANGEMIN = @as(u32, 1031);
pub const TBM_SETRANGEMAX = @as(u32, 1032);
pub const TBM_CLEARTICS = @as(u32, 1033);
pub const TBM_SETSEL = @as(u32, 1034);
pub const TBM_SETSELSTART = @as(u32, 1035);
pub const TBM_SETSELEND = @as(u32, 1036);
pub const TBM_GETPTICS = @as(u32, 1038);
pub const TBM_GETTICPOS = @as(u32, 1039);
pub const TBM_GETNUMTICS = @as(u32, 1040);
pub const TBM_GETSELSTART = @as(u32, 1041);
pub const TBM_GETSELEND = @as(u32, 1042);
pub const TBM_CLEARSEL = @as(u32, 1043);
pub const TBM_SETTICFREQ = @as(u32, 1044);
pub const TBM_SETPAGESIZE = @as(u32, 1045);
pub const TBM_GETPAGESIZE = @as(u32, 1046);
pub const TBM_SETLINESIZE = @as(u32, 1047);
pub const TBM_GETLINESIZE = @as(u32, 1048);
pub const TBM_GETTHUMBRECT = @as(u32, 1049);
pub const TBM_GETCHANNELRECT = @as(u32, 1050);
pub const TBM_SETTHUMBLENGTH = @as(u32, 1051);
pub const TBM_GETTHUMBLENGTH = @as(u32, 1052);
pub const TBM_SETTOOLTIPS = @as(u32, 1053);
pub const TBM_GETTOOLTIPS = @as(u32, 1054);
pub const TBM_SETTIPSIDE = @as(u32, 1055);
pub const TBTS_TOP = @as(u32, 0);
pub const TBTS_LEFT = @as(u32, 1);
pub const TBTS_BOTTOM = @as(u32, 2);
pub const TBTS_RIGHT = @as(u32, 3);
pub const TBM_SETBUDDY = @as(u32, 1056);
pub const TBM_GETBUDDY = @as(u32, 1057);
pub const TBM_SETPOSNOTIFY = @as(u32, 1058);
pub const TB_LINEUP = @as(u32, 0);
pub const TB_LINEDOWN = @as(u32, 1);
pub const TB_PAGEUP = @as(u32, 2);
pub const TB_PAGEDOWN = @as(u32, 3);
pub const TB_THUMBPOSITION = @as(u32, 4);
pub const TB_THUMBTRACK = @as(u32, 5);
pub const TB_TOP = @as(u32, 6);
pub const TB_BOTTOM = @as(u32, 7);
pub const TB_ENDTRACK = @as(u32, 8);
pub const TBCD_TICS = @as(u32, 1);
pub const TBCD_THUMB = @as(u32, 2);
pub const TBCD_CHANNEL = @as(u32, 3);
pub const DL_CURSORSET = @as(u32, 0);
pub const DL_STOPCURSOR = @as(u32, 1);
pub const DL_COPYCURSOR = @as(u32, 2);
pub const DL_MOVECURSOR = @as(u32, 3);
pub const UD_MAXVAL = @as(u32, 32767);
pub const UDS_WRAP = @as(u32, 1);
pub const UDS_SETBUDDYINT = @as(u32, 2);
pub const UDS_ALIGNRIGHT = @as(u32, 4);
pub const UDS_ALIGNLEFT = @as(u32, 8);
pub const UDS_AUTOBUDDY = @as(u32, 16);
pub const UDS_ARROWKEYS = @as(u32, 32);
pub const UDS_HORZ = @as(u32, 64);
pub const UDS_NOTHOUSANDS = @as(u32, 128);
pub const UDS_HOTTRACK = @as(u32, 256);
pub const UDM_SETRANGE = @as(u32, 1125);
pub const UDM_GETRANGE = @as(u32, 1126);
pub const UDM_SETPOS = @as(u32, 1127);
pub const UDM_GETPOS = @as(u32, 1128);
pub const UDM_SETBUDDY = @as(u32, 1129);
pub const UDM_GETBUDDY = @as(u32, 1130);
pub const UDM_SETACCEL = @as(u32, 1131);
pub const UDM_GETACCEL = @as(u32, 1132);
pub const UDM_SETBASE = @as(u32, 1133);
pub const UDM_GETBASE = @as(u32, 1134);
pub const UDM_SETRANGE32 = @as(u32, 1135);
pub const UDM_GETRANGE32 = @as(u32, 1136);
pub const UDM_SETPOS32 = @as(u32, 1137);
pub const UDM_GETPOS32 = @as(u32, 1138);
pub const PBS_SMOOTH = @as(u32, 1);
pub const PBS_VERTICAL = @as(u32, 4);
pub const PBM_SETRANGE = @as(u32, 1025);
pub const PBM_SETPOS = @as(u32, 1026);
pub const PBM_DELTAPOS = @as(u32, 1027);
pub const PBM_SETSTEP = @as(u32, 1028);
pub const PBM_STEPIT = @as(u32, 1029);
pub const PBM_SETRANGE32 = @as(u32, 1030);
pub const PBM_GETRANGE = @as(u32, 1031);
pub const PBM_GETPOS = @as(u32, 1032);
pub const PBM_SETBARCOLOR = @as(u32, 1033);
pub const PBS_MARQUEE = @as(u32, 8);
pub const PBM_SETMARQUEE = @as(u32, 1034);
pub const PBS_SMOOTHREVERSE = @as(u32, 16);
pub const PBM_GETSTEP = @as(u32, 1037);
pub const PBM_GETBKCOLOR = @as(u32, 1038);
pub const PBM_GETBARCOLOR = @as(u32, 1039);
pub const PBM_SETSTATE = @as(u32, 1040);
pub const PBM_GETSTATE = @as(u32, 1041);
pub const PBST_NORMAL = @as(u32, 1);
pub const PBST_ERROR = @as(u32, 2);
pub const PBST_PAUSED = @as(u32, 3);
pub const HOTKEYF_SHIFT = @as(u32, 1);
pub const HOTKEYF_CONTROL = @as(u32, 2);
pub const HOTKEYF_ALT = @as(u32, 4);
pub const HOTKEYF_EXT = @as(u32, 128);
pub const HKCOMB_NONE = @as(u32, 1);
pub const HKCOMB_S = @as(u32, 2);
pub const HKCOMB_C = @as(u32, 4);
pub const HKCOMB_A = @as(u32, 8);
pub const HKCOMB_SC = @as(u32, 16);
pub const HKCOMB_SA = @as(u32, 32);
pub const HKCOMB_CA = @as(u32, 64);
pub const HKCOMB_SCA = @as(u32, 128);
pub const HKM_SETHOTKEY = @as(u32, 1025);
pub const HKM_GETHOTKEY = @as(u32, 1026);
pub const HKM_SETRULES = @as(u32, 1027);
pub const CCS_TOP = @as(i32, 1);
pub const CCS_NOMOVEY = @as(i32, 2);
pub const CCS_BOTTOM = @as(i32, 3);
pub const CCS_NORESIZE = @as(i32, 4);
pub const CCS_NOPARENTALIGN = @as(i32, 8);
pub const CCS_ADJUSTABLE = @as(i32, 32);
pub const CCS_NODIVIDER = @as(i32, 64);
pub const CCS_VERT = @as(i32, 128);
pub const INVALID_LINK_INDEX = @as(i32, -1);
pub const MAX_LINKID_TEXT = @as(u32, 48);
pub const LWS_TRANSPARENT = @as(u32, 1);
pub const LWS_IGNORERETURN = @as(u32, 2);
pub const LWS_NOPREFIX = @as(u32, 4);
pub const LWS_USEVISUALSTYLE = @as(u32, 8);
pub const LWS_USECUSTOMTEXT = @as(u32, 16);
pub const LWS_RIGHT = @as(u32, 32);
pub const LIF_ITEMINDEX = @as(u32, 1);
pub const LIF_STATE = @as(u32, 2);
pub const LIF_ITEMID = @as(u32, 4);
pub const LIF_URL = @as(u32, 8);
pub const LIS_FOCUSED = @as(u32, 1);
pub const LIS_ENABLED = @as(u32, 2);
pub const LIS_VISITED = @as(u32, 4);
pub const LIS_HOTTRACK = @as(u32, 8);
pub const LIS_DEFAULTCOLORS = @as(u32, 16);
pub const LM_HITTEST = @as(u32, 1792);
pub const LM_GETIDEALHEIGHT = @as(u32, 1793);
pub const LM_SETITEM = @as(u32, 1794);
pub const LM_GETITEM = @as(u32, 1795);
pub const LVS_ICON = @as(u32, 0);
pub const LVS_REPORT = @as(u32, 1);
pub const LVS_SMALLICON = @as(u32, 2);
pub const LVS_LIST = @as(u32, 3);
pub const LVS_TYPEMASK = @as(u32, 3);
pub const LVS_SINGLESEL = @as(u32, 4);
pub const LVS_SHOWSELALWAYS = @as(u32, 8);
pub const LVS_SORTASCENDING = @as(u32, 16);
pub const LVS_SORTDESCENDING = @as(u32, 32);
pub const LVS_SHAREIMAGELISTS = @as(u32, 64);
pub const LVS_NOLABELWRAP = @as(u32, 128);
pub const LVS_AUTOARRANGE = @as(u32, 256);
pub const LVS_EDITLABELS = @as(u32, 512);
pub const LVS_OWNERDATA = @as(u32, 4096);
pub const LVS_NOSCROLL = @as(u32, 8192);
pub const LVS_TYPESTYLEMASK = @as(u32, 64512);
pub const LVS_ALIGNTOP = @as(u32, 0);
pub const LVS_ALIGNLEFT = @as(u32, 2048);
pub const LVS_ALIGNMASK = @as(u32, 3072);
pub const LVS_OWNERDRAWFIXED = @as(u32, 1024);
pub const LVS_NOCOLUMNHEADER = @as(u32, 16384);
pub const LVS_NOSORTHEADER = @as(u32, 32768);
pub const LVM_GETBKCOLOR = @as(u32, 4096);
pub const LVM_SETBKCOLOR = @as(u32, 4097);
pub const LVM_GETIMAGELIST = @as(u32, 4098);
pub const LVSIL_NORMAL = @as(u32, 0);
pub const LVSIL_SMALL = @as(u32, 1);
pub const LVSIL_STATE = @as(u32, 2);
pub const LVSIL_GROUPHEADER = @as(u32, 3);
pub const LVM_SETIMAGELIST = @as(u32, 4099);
pub const LVM_GETITEMCOUNT = @as(u32, 4100);
pub const LVIF_TEXT = @as(u32, 1);
pub const LVIF_IMAGE = @as(u32, 2);
pub const LVIF_PARAM = @as(u32, 4);
pub const LVIF_STATE = @as(u32, 8);
pub const LVIF_INDENT = @as(u32, 16);
pub const LVIF_NORECOMPUTE = @as(u32, 2048);
pub const LVIF_GROUPID = @as(u32, 256);
pub const LVIF_COLUMNS = @as(u32, 512);
pub const LVIF_COLFMT = @as(u32, 65536);
pub const LVIS_FOCUSED = @as(u32, 1);
pub const LVIS_SELECTED = @as(u32, 2);
pub const LVIS_CUT = @as(u32, 4);
pub const LVIS_DROPHILITED = @as(u32, 8);
pub const LVIS_GLOW = @as(u32, 16);
pub const LVIS_ACTIVATING = @as(u32, 32);
pub const LVIS_OVERLAYMASK = @as(u32, 3840);
pub const LVIS_STATEIMAGEMASK = @as(u32, 61440);
pub const I_INDENTCALLBACK = @as(i32, -1);
pub const I_IMAGECALLBACK = @as(i32, -1);
pub const I_IMAGENONE = @as(i32, -2);
pub const LVM_GETITEMA = @as(u32, 4101);
pub const LVM_GETITEMW = @as(u32, 4171);
pub const LVM_SETITEMA = @as(u32, 4102);
pub const LVM_SETITEMW = @as(u32, 4172);
pub const LVM_INSERTITEMA = @as(u32, 4103);
pub const LVM_INSERTITEMW = @as(u32, 4173);
pub const LVM_DELETEITEM = @as(u32, 4104);
pub const LVM_DELETEALLITEMS = @as(u32, 4105);
pub const LVM_GETCALLBACKMASK = @as(u32, 4106);
pub const LVM_SETCALLBACKMASK = @as(u32, 4107);
pub const LVNI_ALL = @as(u32, 0);
pub const LVNI_FOCUSED = @as(u32, 1);
pub const LVNI_SELECTED = @as(u32, 2);
pub const LVNI_CUT = @as(u32, 4);
pub const LVNI_DROPHILITED = @as(u32, 8);
pub const LVNI_VISIBLEORDER = @as(u32, 16);
pub const LVNI_PREVIOUS = @as(u32, 32);
pub const LVNI_VISIBLEONLY = @as(u32, 64);
pub const LVNI_SAMEGROUPONLY = @as(u32, 128);
pub const LVNI_ABOVE = @as(u32, 256);
pub const LVNI_BELOW = @as(u32, 512);
pub const LVNI_TOLEFT = @as(u32, 1024);
pub const LVNI_TORIGHT = @as(u32, 2048);
pub const LVM_GETNEXTITEM = @as(u32, 4108);
pub const LVM_FINDITEMA = @as(u32, 4109);
pub const LVM_FINDITEMW = @as(u32, 4179);
pub const LVIR_BOUNDS = @as(u32, 0);
pub const LVIR_ICON = @as(u32, 1);
pub const LVIR_LABEL = @as(u32, 2);
pub const LVIR_SELECTBOUNDS = @as(u32, 3);
pub const LVM_GETITEMRECT = @as(u32, 4110);
pub const LVM_SETITEMPOSITION = @as(u32, 4111);
pub const LVM_GETITEMPOSITION = @as(u32, 4112);
pub const LVM_GETSTRINGWIDTHA = @as(u32, 4113);
pub const LVM_GETSTRINGWIDTHW = @as(u32, 4183);
pub const LVM_HITTEST = @as(u32, 4114);
pub const LVM_ENSUREVISIBLE = @as(u32, 4115);
pub const LVM_SCROLL = @as(u32, 4116);
pub const LVM_REDRAWITEMS = @as(u32, 4117);
pub const LVA_DEFAULT = @as(u32, 0);
pub const LVA_ALIGNLEFT = @as(u32, 1);
pub const LVA_ALIGNTOP = @as(u32, 2);
pub const LVA_SNAPTOGRID = @as(u32, 5);
pub const LVM_ARRANGE = @as(u32, 4118);
pub const LVM_EDITLABELA = @as(u32, 4119);
pub const LVM_EDITLABELW = @as(u32, 4214);
pub const LVM_GETEDITCONTROL = @as(u32, 4120);
pub const LVCFMT_LINE_BREAK = @as(u32, 1048576);
pub const LVCFMT_FILL = @as(u32, 2097152);
pub const LVCFMT_WRAP = @as(u32, 4194304);
pub const LVCFMT_NO_TITLE = @as(u32, 8388608);
pub const LVM_GETCOLUMNA = @as(u32, 4121);
pub const LVM_GETCOLUMNW = @as(u32, 4191);
pub const LVM_SETCOLUMNA = @as(u32, 4122);
pub const LVM_SETCOLUMNW = @as(u32, 4192);
pub const LVM_INSERTCOLUMNA = @as(u32, 4123);
pub const LVM_INSERTCOLUMNW = @as(u32, 4193);
pub const LVM_DELETECOLUMN = @as(u32, 4124);
pub const LVM_GETCOLUMNWIDTH = @as(u32, 4125);
pub const LVSCW_AUTOSIZE = @as(i32, -1);
pub const LVSCW_AUTOSIZE_USEHEADER = @as(i32, -2);
pub const LVM_SETCOLUMNWIDTH = @as(u32, 4126);
pub const LVM_GETHEADER = @as(u32, 4127);
pub const LVM_CREATEDRAGIMAGE = @as(u32, 4129);
pub const LVM_GETVIEWRECT = @as(u32, 4130);
pub const LVM_GETTEXTCOLOR = @as(u32, 4131);
pub const LVM_SETTEXTCOLOR = @as(u32, 4132);
pub const LVM_GETTEXTBKCOLOR = @as(u32, 4133);
pub const LVM_SETTEXTBKCOLOR = @as(u32, 4134);
pub const LVM_GETTOPINDEX = @as(u32, 4135);
pub const LVM_GETCOUNTPERPAGE = @as(u32, 4136);
pub const LVM_GETORIGIN = @as(u32, 4137);
pub const LVM_UPDATE = @as(u32, 4138);
pub const LVM_SETITEMSTATE = @as(u32, 4139);
pub const LVM_GETITEMSTATE = @as(u32, 4140);
pub const LVM_GETITEMTEXTA = @as(u32, 4141);
pub const LVM_GETITEMTEXTW = @as(u32, 4211);
pub const LVM_SETITEMTEXTA = @as(u32, 4142);
pub const LVM_SETITEMTEXTW = @as(u32, 4212);
pub const LVSICF_NOINVALIDATEALL = @as(u32, 1);
pub const LVSICF_NOSCROLL = @as(u32, 2);
pub const LVM_SETITEMCOUNT = @as(u32, 4143);
pub const LVM_SORTITEMS = @as(u32, 4144);
pub const LVM_SETITEMPOSITION32 = @as(u32, 4145);
pub const LVM_GETSELECTEDCOUNT = @as(u32, 4146);
pub const LVM_GETITEMSPACING = @as(u32, 4147);
pub const LVM_GETISEARCHSTRINGA = @as(u32, 4148);
pub const LVM_GETISEARCHSTRINGW = @as(u32, 4213);
pub const LVM_SETICONSPACING = @as(u32, 4149);
pub const LVM_SETEXTENDEDLISTVIEWSTYLE = @as(u32, 4150);
pub const LVM_GETEXTENDEDLISTVIEWSTYLE = @as(u32, 4151);
pub const LVS_EX_GRIDLINES = @as(u32, 1);
pub const LVS_EX_SUBITEMIMAGES = @as(u32, 2);
pub const LVS_EX_CHECKBOXES = @as(u32, 4);
pub const LVS_EX_TRACKSELECT = @as(u32, 8);
pub const LVS_EX_HEADERDRAGDROP = @as(u32, 16);
pub const LVS_EX_FULLROWSELECT = @as(u32, 32);
pub const LVS_EX_ONECLICKACTIVATE = @as(u32, 64);
pub const LVS_EX_TWOCLICKACTIVATE = @as(u32, 128);
pub const LVS_EX_FLATSB = @as(u32, 256);
pub const LVS_EX_REGIONAL = @as(u32, 512);
pub const LVS_EX_INFOTIP = @as(u32, 1024);
pub const LVS_EX_UNDERLINEHOT = @as(u32, 2048);
pub const LVS_EX_UNDERLINECOLD = @as(u32, 4096);
pub const LVS_EX_MULTIWORKAREAS = @as(u32, 8192);
pub const LVS_EX_LABELTIP = @as(u32, 16384);
pub const LVS_EX_BORDERSELECT = @as(u32, 32768);
pub const LVS_EX_DOUBLEBUFFER = @as(u32, 65536);
pub const LVS_EX_HIDELABELS = @as(u32, 131072);
pub const LVS_EX_SINGLEROW = @as(u32, 262144);
pub const LVS_EX_SNAPTOGRID = @as(u32, 524288);
pub const LVS_EX_SIMPLESELECT = @as(u32, 1048576);
pub const LVS_EX_JUSTIFYCOLUMNS = @as(u32, 2097152);
pub const LVS_EX_TRANSPARENTBKGND = @as(u32, 4194304);
pub const LVS_EX_TRANSPARENTSHADOWTEXT = @as(u32, 8388608);
pub const LVS_EX_AUTOAUTOARRANGE = @as(u32, 16777216);
pub const LVS_EX_HEADERINALLVIEWS = @as(u32, 33554432);
pub const LVS_EX_AUTOCHECKSELECT = @as(u32, 134217728);
pub const LVS_EX_AUTOSIZECOLUMNS = @as(u32, 268435456);
pub const LVS_EX_COLUMNSNAPPOINTS = @as(u32, 1073741824);
pub const LVS_EX_COLUMNOVERFLOW = @as(u32, 2147483648);
pub const LVM_GETSUBITEMRECT = @as(u32, 4152);
pub const LVM_SUBITEMHITTEST = @as(u32, 4153);
pub const LVM_SETCOLUMNORDERARRAY = @as(u32, 4154);
pub const LVM_GETCOLUMNORDERARRAY = @as(u32, 4155);
pub const LVM_SETHOTITEM = @as(u32, 4156);
pub const LVM_GETHOTITEM = @as(u32, 4157);
pub const LVM_SETHOTCURSOR = @as(u32, 4158);
pub const LVM_GETHOTCURSOR = @as(u32, 4159);
pub const LVM_APPROXIMATEVIEWRECT = @as(u32, 4160);
pub const LV_MAX_WORKAREAS = @as(u32, 16);
pub const LVM_SETWORKAREAS = @as(u32, 4161);
pub const LVM_GETWORKAREAS = @as(u32, 4166);
pub const LVM_GETNUMBEROFWORKAREAS = @as(u32, 4169);
pub const LVM_GETSELECTIONMARK = @as(u32, 4162);
pub const LVM_SETSELECTIONMARK = @as(u32, 4163);
pub const LVM_SETHOVERTIME = @as(u32, 4167);
pub const LVM_GETHOVERTIME = @as(u32, 4168);
pub const LVM_SETTOOLTIPS = @as(u32, 4170);
pub const LVM_GETTOOLTIPS = @as(u32, 4174);
pub const LVM_SORTITEMSEX = @as(u32, 4177);
pub const LVBKIF_SOURCE_NONE = @as(u32, 0);
pub const LVBKIF_SOURCE_HBITMAP = @as(u32, 1);
pub const LVBKIF_SOURCE_URL = @as(u32, 2);
pub const LVBKIF_SOURCE_MASK = @as(u32, 3);
pub const LVBKIF_STYLE_NORMAL = @as(u32, 0);
pub const LVBKIF_STYLE_TILE = @as(u32, 16);
pub const LVBKIF_STYLE_MASK = @as(u32, 16);
pub const LVBKIF_FLAG_TILEOFFSET = @as(u32, 256);
pub const LVBKIF_TYPE_WATERMARK = @as(u32, 268435456);
pub const LVBKIF_FLAG_ALPHABLEND = @as(u32, 536870912);
pub const LVM_SETBKIMAGEA = @as(u32, 4164);
pub const LVM_SETBKIMAGEW = @as(u32, 4234);
pub const LVM_GETBKIMAGEA = @as(u32, 4165);
pub const LVM_GETBKIMAGEW = @as(u32, 4235);
pub const LVM_SETSELECTEDCOLUMN = @as(u32, 4236);
pub const LV_VIEW_ICON = @as(u32, 0);
pub const LV_VIEW_DETAILS = @as(u32, 1);
pub const LV_VIEW_SMALLICON = @as(u32, 2);
pub const LV_VIEW_LIST = @as(u32, 3);
pub const LV_VIEW_TILE = @as(u32, 4);
pub const LV_VIEW_MAX = @as(u32, 4);
pub const LVM_SETVIEW = @as(u32, 4238);
pub const LVM_GETVIEW = @as(u32, 4239);
pub const LVGF_ALIGN = @as(u32, 8);
pub const LVGF_GROUPID = @as(u32, 16);
pub const LVGF_SUBTITLE = @as(u32, 256);
pub const LVGF_TASK = @as(u32, 512);
pub const LVGF_DESCRIPTIONTOP = @as(u32, 1024);
pub const LVGF_DESCRIPTIONBOTTOM = @as(u32, 2048);
pub const LVGF_TITLEIMAGE = @as(u32, 4096);
pub const LVGF_EXTENDEDIMAGE = @as(u32, 8192);
pub const LVGF_ITEMS = @as(u32, 16384);
pub const LVGF_SUBSET = @as(u32, 32768);
pub const LVGF_SUBSETITEMS = @as(u32, 65536);
pub const LVGS_NORMAL = @as(u32, 0);
pub const LVGS_COLLAPSED = @as(u32, 1);
pub const LVGS_HIDDEN = @as(u32, 2);
pub const LVGS_NOHEADER = @as(u32, 4);
pub const LVGS_COLLAPSIBLE = @as(u32, 8);
pub const LVGS_FOCUSED = @as(u32, 16);
pub const LVGS_SELECTED = @as(u32, 32);
pub const LVGS_SUBSETED = @as(u32, 64);
pub const LVGS_SUBSETLINKFOCUSED = @as(u32, 128);
pub const LVGA_FOOTER_LEFT = @as(u32, 8);
pub const LVGA_FOOTER_CENTER = @as(u32, 16);
pub const LVGA_FOOTER_RIGHT = @as(u32, 32);
pub const LVM_INSERTGROUP = @as(u32, 4241);
pub const LVM_SETGROUPINFO = @as(u32, 4243);
pub const LVM_GETGROUPINFO = @as(u32, 4245);
pub const LVM_REMOVEGROUP = @as(u32, 4246);
pub const LVM_MOVEGROUP = @as(u32, 4247);
pub const LVM_GETGROUPCOUNT = @as(u32, 4248);
pub const LVM_GETGROUPINFOBYINDEX = @as(u32, 4249);
pub const LVM_MOVEITEMTOGROUP = @as(u32, 4250);
pub const LVGGR_GROUP = @as(u32, 0);
pub const LVGGR_HEADER = @as(u32, 1);
pub const LVGGR_LABEL = @as(u32, 2);
pub const LVGGR_SUBSETLINK = @as(u32, 3);
pub const LVM_GETGROUPRECT = @as(u32, 4194);
pub const LVGMF_NONE = @as(u32, 0);
pub const LVGMF_BORDERSIZE = @as(u32, 1);
pub const LVGMF_BORDERCOLOR = @as(u32, 2);
pub const LVGMF_TEXTCOLOR = @as(u32, 4);
pub const LVM_SETGROUPMETRICS = @as(u32, 4251);
pub const LVM_GETGROUPMETRICS = @as(u32, 4252);
pub const LVM_ENABLEGROUPVIEW = @as(u32, 4253);
pub const LVM_SORTGROUPS = @as(u32, 4254);
pub const LVM_INSERTGROUPSORTED = @as(u32, 4255);
pub const LVM_REMOVEALLGROUPS = @as(u32, 4256);
pub const LVM_HASGROUP = @as(u32, 4257);
pub const LVM_GETGROUPSTATE = @as(u32, 4188);
pub const LVM_GETFOCUSEDGROUP = @as(u32, 4189);
pub const LVTVIF_AUTOSIZE = @as(u32, 0);
pub const LVTVIF_FIXEDWIDTH = @as(u32, 1);
pub const LVTVIF_FIXEDHEIGHT = @as(u32, 2);
pub const LVTVIF_FIXEDSIZE = @as(u32, 3);
pub const LVTVIM_TILESIZE = @as(u32, 1);
pub const LVTVIM_COLUMNS = @as(u32, 2);
pub const LVTVIM_LABELMARGIN = @as(u32, 4);
pub const LVM_SETTILEVIEWINFO = @as(u32, 4258);
pub const LVM_GETTILEVIEWINFO = @as(u32, 4259);
pub const LVM_SETTILEINFO = @as(u32, 4260);
pub const LVM_GETTILEINFO = @as(u32, 4261);
pub const LVIM_AFTER = @as(u32, 1);
pub const LVM_SETINSERTMARK = @as(u32, 4262);
pub const LVM_GETINSERTMARK = @as(u32, 4263);
pub const LVM_INSERTMARKHITTEST = @as(u32, 4264);
pub const LVM_GETINSERTMARKRECT = @as(u32, 4265);
pub const LVM_SETINSERTMARKCOLOR = @as(u32, 4266);
pub const LVM_GETINSERTMARKCOLOR = @as(u32, 4267);
pub const LVM_SETINFOTIP = @as(u32, 4269);
pub const LVM_GETSELECTEDCOLUMN = @as(u32, 4270);
pub const LVM_ISGROUPVIEWENABLED = @as(u32, 4271);
pub const LVM_GETOUTLINECOLOR = @as(u32, 4272);
pub const LVM_SETOUTLINECOLOR = @as(u32, 4273);
pub const LVM_CANCELEDITLABEL = @as(u32, 4275);
pub const LVM_MAPINDEXTOID = @as(u32, 4276);
pub const LVM_MAPIDTOINDEX = @as(u32, 4277);
pub const LVM_ISITEMVISIBLE = @as(u32, 4278);
pub const LVM_GETEMPTYTEXT = @as(u32, 4300);
pub const LVM_GETFOOTERRECT = @as(u32, 4301);
pub const LVFF_ITEMCOUNT = @as(u32, 1);
pub const LVM_GETFOOTERINFO = @as(u32, 4302);
pub const LVM_GETFOOTERITEMRECT = @as(u32, 4303);
pub const LVFIS_FOCUSED = @as(u32, 1);
pub const LVM_GETFOOTERITEM = @as(u32, 4304);
pub const LVM_GETITEMINDEXRECT = @as(u32, 4305);
pub const LVM_SETITEMINDEXSTATE = @as(u32, 4306);
pub const LVM_GETNEXTITEMINDEX = @as(u32, 4307);
pub const LVKF_ALT = @as(u32, 1);
pub const LVKF_CONTROL = @as(u32, 2);
pub const LVKF_SHIFT = @as(u32, 4);
pub const LVCDRF_NOSELECT = @as(u32, 65536);
pub const LVCDRF_NOGROUPFRAME = @as(u32, 131072);
pub const LVIF_DI_SETITEM = @as(u32, 4096);
pub const LVGIT_UNFOLDED = @as(u32, 1);
pub const LVNSCH_DEFAULT = @as(i32, -1);
pub const LVNSCH_ERROR = @as(i32, -2);
pub const LVNSCH_IGNORE = @as(i32, -3);
pub const TVS_HASBUTTONS = @as(u32, 1);
pub const TVS_HASLINES = @as(u32, 2);
pub const TVS_LINESATROOT = @as(u32, 4);
pub const TVS_EDITLABELS = @as(u32, 8);
pub const TVS_DISABLEDRAGDROP = @as(u32, 16);
pub const TVS_SHOWSELALWAYS = @as(u32, 32);
pub const TVS_RTLREADING = @as(u32, 64);
pub const TVS_NOTOOLTIPS = @as(u32, 128);
pub const TVS_CHECKBOXES = @as(u32, 256);
pub const TVS_TRACKSELECT = @as(u32, 512);
pub const TVS_SINGLEEXPAND = @as(u32, 1024);
pub const TVS_INFOTIP = @as(u32, 2048);
pub const TVS_FULLROWSELECT = @as(u32, 4096);
pub const TVS_NOSCROLL = @as(u32, 8192);
pub const TVS_NONEVENHEIGHT = @as(u32, 16384);
pub const TVS_NOHSCROLL = @as(u32, 32768);
pub const TVS_EX_NOSINGLECOLLAPSE = @as(u32, 1);
pub const TVS_EX_MULTISELECT = @as(u32, 2);
pub const TVS_EX_DOUBLEBUFFER = @as(u32, 4);
pub const TVS_EX_NOINDENTSTATE = @as(u32, 8);
pub const TVS_EX_RICHTOOLTIP = @as(u32, 16);
pub const TVS_EX_AUTOHSCROLL = @as(u32, 32);
pub const TVS_EX_FADEINOUTEXPANDOS = @as(u32, 64);
pub const TVS_EX_PARTIALCHECKBOXES = @as(u32, 128);
pub const TVS_EX_EXCLUSIONCHECKBOXES = @as(u32, 256);
pub const TVS_EX_DIMMEDCHECKBOXES = @as(u32, 512);
pub const TVS_EX_DRAWIMAGEASYNC = @as(u32, 1024);
pub const TVIS_SELECTED = @as(u32, 2);
pub const TVIS_CUT = @as(u32, 4);
pub const TVIS_DROPHILITED = @as(u32, 8);
pub const TVIS_BOLD = @as(u32, 16);
pub const TVIS_EXPANDED = @as(u32, 32);
pub const TVIS_EXPANDEDONCE = @as(u32, 64);
pub const TVIS_EXPANDPARTIAL = @as(u32, 128);
pub const TVIS_OVERLAYMASK = @as(u32, 3840);
pub const TVIS_STATEIMAGEMASK = @as(u32, 61440);
pub const TVIS_USERMASK = @as(u32, 61440);
pub const TVIS_EX_FLAT = @as(u32, 1);
pub const TVIS_EX_DISABLED = @as(u32, 2);
pub const TVIS_EX_ALL = @as(u32, 2);
pub const TVM_INSERTITEMA = @as(u32, 4352);
pub const TVM_INSERTITEMW = @as(u32, 4402);
pub const TVM_DELETEITEM = @as(u32, 4353);
pub const TVM_EXPAND = @as(u32, 4354);
pub const TVE_COLLAPSE = @as(u32, 1);
pub const TVE_EXPAND = @as(u32, 2);
pub const TVE_TOGGLE = @as(u32, 3);
pub const TVE_EXPANDPARTIAL = @as(u32, 16384);
pub const TVE_COLLAPSERESET = @as(u32, 32768);
pub const TVM_GETITEMRECT = @as(u32, 4356);
pub const TVM_GETCOUNT = @as(u32, 4357);
pub const TVM_GETINDENT = @as(u32, 4358);
pub const TVM_SETINDENT = @as(u32, 4359);
pub const TVM_GETIMAGELIST = @as(u32, 4360);
pub const TVSIL_NORMAL = @as(u32, 0);
pub const TVSIL_STATE = @as(u32, 2);
pub const TVM_SETIMAGELIST = @as(u32, 4361);
pub const TVM_GETNEXTITEM = @as(u32, 4362);
pub const TVGN_ROOT = @as(u32, 0);
pub const TVGN_NEXT = @as(u32, 1);
pub const TVGN_PREVIOUS = @as(u32, 2);
pub const TVGN_PARENT = @as(u32, 3);
pub const TVGN_CHILD = @as(u32, 4);
pub const TVGN_FIRSTVISIBLE = @as(u32, 5);
pub const TVGN_NEXTVISIBLE = @as(u32, 6);
pub const TVGN_PREVIOUSVISIBLE = @as(u32, 7);
pub const TVGN_DROPHILITE = @as(u32, 8);
pub const TVGN_CARET = @as(u32, 9);
pub const TVGN_LASTVISIBLE = @as(u32, 10);
pub const TVGN_NEXTSELECTED = @as(u32, 11);
pub const TVSI_NOSINGLEEXPAND = @as(u32, 32768);
pub const TVM_SELECTITEM = @as(u32, 4363);
pub const TVM_GETITEMA = @as(u32, 4364);
pub const TVM_GETITEMW = @as(u32, 4414);
pub const TVM_SETITEMA = @as(u32, 4365);
pub const TVM_SETITEMW = @as(u32, 4415);
pub const TVM_EDITLABELA = @as(u32, 4366);
pub const TVM_EDITLABELW = @as(u32, 4417);
pub const TVM_GETEDITCONTROL = @as(u32, 4367);
pub const TVM_GETVISIBLECOUNT = @as(u32, 4368);
pub const TVM_HITTEST = @as(u32, 4369);
pub const TVM_CREATEDRAGIMAGE = @as(u32, 4370);
pub const TVM_SORTCHILDREN = @as(u32, 4371);
pub const TVM_ENSUREVISIBLE = @as(u32, 4372);
pub const TVM_SORTCHILDRENCB = @as(u32, 4373);
pub const TVM_ENDEDITLABELNOW = @as(u32, 4374);
pub const TVM_GETISEARCHSTRINGA = @as(u32, 4375);
pub const TVM_GETISEARCHSTRINGW = @as(u32, 4416);
pub const TVM_SETTOOLTIPS = @as(u32, 4376);
pub const TVM_GETTOOLTIPS = @as(u32, 4377);
pub const TVM_SETINSERTMARK = @as(u32, 4378);
pub const TVM_SETITEMHEIGHT = @as(u32, 4379);
pub const TVM_GETITEMHEIGHT = @as(u32, 4380);
pub const TVM_SETBKCOLOR = @as(u32, 4381);
pub const TVM_SETTEXTCOLOR = @as(u32, 4382);
pub const TVM_GETBKCOLOR = @as(u32, 4383);
pub const TVM_GETTEXTCOLOR = @as(u32, 4384);
pub const TVM_SETSCROLLTIME = @as(u32, 4385);
pub const TVM_GETSCROLLTIME = @as(u32, 4386);
pub const TVM_SETINSERTMARKCOLOR = @as(u32, 4389);
pub const TVM_GETINSERTMARKCOLOR = @as(u32, 4390);
pub const TVM_SETBORDER = @as(u32, 4387);
pub const TVSBF_XBORDER = @as(u32, 1);
pub const TVSBF_YBORDER = @as(u32, 2);
pub const TVM_GETITEMSTATE = @as(u32, 4391);
pub const TVM_SETLINECOLOR = @as(u32, 4392);
pub const TVM_GETLINECOLOR = @as(u32, 4393);
pub const TVM_MAPACCIDTOHTREEITEM = @as(u32, 4394);
pub const TVM_MAPHTREEITEMTOACCID = @as(u32, 4395);
pub const TVM_SETEXTENDEDSTYLE = @as(u32, 4396);
pub const TVM_GETEXTENDEDSTYLE = @as(u32, 4397);
pub const TVM_SETAUTOSCROLLINFO = @as(u32, 4411);
pub const TVM_SETHOT = @as(u32, 4410);
pub const TVM_GETSELECTEDCOUNT = @as(u32, 4422);
pub const TVM_SHOWINFOTIP = @as(u32, 4423);
pub const TVM_GETITEMPARTRECT = @as(u32, 4424);
pub const TVC_UNKNOWN = @as(u32, 0);
pub const TVC_BYMOUSE = @as(u32, 1);
pub const TVC_BYKEYBOARD = @as(u32, 2);
pub const TVNRET_DEFAULT = @as(u32, 0);
pub const TVNRET_SKIPOLD = @as(u32, 1);
pub const TVNRET_SKIPNEW = @as(u32, 2);
pub const TVCDRF_NOIMAGES = @as(u32, 65536);
pub const CBEM_INSERTITEMA = @as(u32, 1025);
pub const CBEM_SETIMAGELIST = @as(u32, 1026);
pub const CBEM_GETIMAGELIST = @as(u32, 1027);
pub const CBEM_GETITEMA = @as(u32, 1028);
pub const CBEM_SETITEMA = @as(u32, 1029);
pub const CBEM_GETCOMBOCONTROL = @as(u32, 1030);
pub const CBEM_GETEDITCONTROL = @as(u32, 1031);
pub const CBEM_SETEXSTYLE = @as(u32, 1032);
pub const CBEM_SETEXTENDEDSTYLE = @as(u32, 1038);
pub const CBEM_GETEXSTYLE = @as(u32, 1033);
pub const CBEM_GETEXTENDEDSTYLE = @as(u32, 1033);
pub const CBEM_HASEDITCHANGED = @as(u32, 1034);
pub const CBEM_INSERTITEMW = @as(u32, 1035);
pub const CBEM_SETITEMW = @as(u32, 1036);
pub const CBEM_GETITEMW = @as(u32, 1037);
pub const CBES_EX_NOEDITIMAGE = @as(u32, 1);
pub const CBES_EX_NOEDITIMAGEINDENT = @as(u32, 2);
pub const CBES_EX_PATHWORDBREAKPROC = @as(u32, 4);
pub const CBES_EX_NOSIZELIMIT = @as(u32, 8);
pub const CBES_EX_CASESENSITIVE = @as(u32, 16);
pub const CBES_EX_TEXTENDELLIPSIS = @as(u32, 32);
pub const CBENF_KILLFOCUS = @as(u32, 1);
pub const CBENF_RETURN = @as(u32, 2);
pub const CBENF_ESCAPE = @as(u32, 3);
pub const CBENF_DROPDOWN = @as(u32, 4);
pub const CBEMAXSTRLEN = @as(u32, 260);
pub const TCS_SCROLLOPPOSITE = @as(u32, 1);
pub const TCS_BOTTOM = @as(u32, 2);
pub const TCS_RIGHT = @as(u32, 2);
pub const TCS_MULTISELECT = @as(u32, 4);
pub const TCS_FLATBUTTONS = @as(u32, 8);
pub const TCS_FORCEICONLEFT = @as(u32, 16);
pub const TCS_FORCELABELLEFT = @as(u32, 32);
pub const TCS_HOTTRACK = @as(u32, 64);
pub const TCS_VERTICAL = @as(u32, 128);
pub const TCS_TABS = @as(u32, 0);
pub const TCS_BUTTONS = @as(u32, 256);
pub const TCS_SINGLELINE = @as(u32, 0);
pub const TCS_MULTILINE = @as(u32, 512);
pub const TCS_RIGHTJUSTIFY = @as(u32, 0);
pub const TCS_FIXEDWIDTH = @as(u32, 1024);
pub const TCS_RAGGEDRIGHT = @as(u32, 2048);
pub const TCS_FOCUSONBUTTONDOWN = @as(u32, 4096);
pub const TCS_OWNERDRAWFIXED = @as(u32, 8192);
pub const TCS_TOOLTIPS = @as(u32, 16384);
pub const TCS_FOCUSNEVER = @as(u32, 32768);
pub const TCS_EX_FLATSEPARATORS = @as(u32, 1);
pub const TCS_EX_REGISTERDROP = @as(u32, 2);
pub const TCM_GETIMAGELIST = @as(u32, 4866);
pub const TCM_SETIMAGELIST = @as(u32, 4867);
pub const TCM_GETITEMCOUNT = @as(u32, 4868);
pub const TCIS_BUTTONPRESSED = @as(u32, 1);
pub const TCIS_HIGHLIGHTED = @as(u32, 2);
pub const TCM_GETITEMA = @as(u32, 4869);
pub const TCM_GETITEMW = @as(u32, 4924);
pub const TCM_SETITEMA = @as(u32, 4870);
pub const TCM_SETITEMW = @as(u32, 4925);
pub const TCM_INSERTITEMA = @as(u32, 4871);
pub const TCM_INSERTITEMW = @as(u32, 4926);
pub const TCM_DELETEITEM = @as(u32, 4872);
pub const TCM_DELETEALLITEMS = @as(u32, 4873);
pub const TCM_GETITEMRECT = @as(u32, 4874);
pub const TCM_GETCURSEL = @as(u32, 4875);
pub const TCM_SETCURSEL = @as(u32, 4876);
pub const TCM_HITTEST = @as(u32, 4877);
pub const TCM_SETITEMEXTRA = @as(u32, 4878);
pub const TCM_ADJUSTRECT = @as(u32, 4904);
pub const TCM_SETITEMSIZE = @as(u32, 4905);
pub const TCM_REMOVEIMAGE = @as(u32, 4906);
pub const TCM_SETPADDING = @as(u32, 4907);
pub const TCM_GETROWCOUNT = @as(u32, 4908);
pub const TCM_GETTOOLTIPS = @as(u32, 4909);
pub const TCM_SETTOOLTIPS = @as(u32, 4910);
pub const TCM_GETCURFOCUS = @as(u32, 4911);
pub const TCM_SETCURFOCUS = @as(u32, 4912);
pub const TCM_SETMINTABWIDTH = @as(u32, 4913);
pub const TCM_DESELECTALL = @as(u32, 4914);
pub const TCM_HIGHLIGHTITEM = @as(u32, 4915);
pub const TCM_SETEXTENDEDSTYLE = @as(u32, 4916);
pub const TCM_GETEXTENDEDSTYLE = @as(u32, 4917);
pub const ACS_CENTER = @as(u32, 1);
pub const ACS_TRANSPARENT = @as(u32, 2);
pub const ACS_AUTOPLAY = @as(u32, 4);
pub const ACS_TIMER = @as(u32, 8);
pub const ACM_OPENA = @as(u32, 1124);
pub const ACM_OPENW = @as(u32, 1127);
pub const ACM_PLAY = @as(u32, 1125);
pub const ACM_STOP = @as(u32, 1126);
pub const ACM_ISPLAYING = @as(u32, 1128);
pub const ACN_START = @as(u32, 1);
pub const ACN_STOP = @as(u32, 2);
pub const MCM_FIRST = @as(u32, 4096);
pub const MCM_GETCURSEL = @as(u32, 4097);
pub const MCM_SETCURSEL = @as(u32, 4098);
pub const MCM_GETMAXSELCOUNT = @as(u32, 4099);
pub const MCM_SETMAXSELCOUNT = @as(u32, 4100);
pub const MCM_GETSELRANGE = @as(u32, 4101);
pub const MCM_SETSELRANGE = @as(u32, 4102);
pub const MCM_GETMONTHRANGE = @as(u32, 4103);
pub const MCM_SETDAYSTATE = @as(u32, 4104);
pub const MCM_GETMINREQRECT = @as(u32, 4105);
pub const MCM_SETCOLOR = @as(u32, 4106);
pub const MCM_GETCOLOR = @as(u32, 4107);
pub const MCSC_BACKGROUND = @as(u32, 0);
pub const MCSC_TEXT = @as(u32, 1);
pub const MCSC_TITLEBK = @as(u32, 2);
pub const MCSC_TITLETEXT = @as(u32, 3);
pub const MCSC_MONTHBK = @as(u32, 4);
pub const MCSC_TRAILINGTEXT = @as(u32, 5);
pub const MCM_SETTODAY = @as(u32, 4108);
pub const MCM_GETTODAY = @as(u32, 4109);
pub const MCM_HITTEST = @as(u32, 4110);
pub const MCHT_TITLE = @as(u32, 65536);
pub const MCHT_CALENDAR = @as(u32, 131072);
pub const MCHT_TODAYLINK = @as(u32, 196608);
pub const MCHT_CALENDARCONTROL = @as(u32, 1048576);
pub const MCHT_NEXT = @as(u32, 16777216);
pub const MCHT_PREV = @as(u32, 33554432);
pub const MCHT_NOWHERE = @as(u32, 0);
pub const MCM_SETFIRSTDAYOFWEEK = @as(u32, 4111);
pub const MCM_GETFIRSTDAYOFWEEK = @as(u32, 4112);
pub const MCM_GETRANGE = @as(u32, 4113);
pub const MCM_SETRANGE = @as(u32, 4114);
pub const MCM_GETMONTHDELTA = @as(u32, 4115);
pub const MCM_SETMONTHDELTA = @as(u32, 4116);
pub const MCM_GETMAXTODAYWIDTH = @as(u32, 4117);
pub const MCMV_MONTH = @as(u32, 0);
pub const MCMV_YEAR = @as(u32, 1);
pub const MCMV_DECADE = @as(u32, 2);
pub const MCMV_CENTURY = @as(u32, 3);
pub const MCM_GETCURRENTVIEW = @as(u32, 4118);
pub const MCM_GETCALENDARCOUNT = @as(u32, 4119);
pub const MCM_GETCALENDARGRIDINFO = @as(u32, 4120);
pub const MCM_GETCALID = @as(u32, 4123);
pub const MCM_SETCALID = @as(u32, 4124);
pub const MCM_SIZERECTTOMIN = @as(u32, 4125);
pub const MCM_SETCALENDARBORDER = @as(u32, 4126);
pub const MCM_GETCALENDARBORDER = @as(u32, 4127);
pub const MCM_SETCURRENTVIEW = @as(u32, 4128);
pub const MCS_DAYSTATE = @as(u32, 1);
pub const MCS_MULTISELECT = @as(u32, 2);
pub const MCS_WEEKNUMBERS = @as(u32, 4);
pub const MCS_NOTODAYCIRCLE = @as(u32, 8);
pub const MCS_NOTODAY = @as(u32, 16);
pub const MCS_NOTRAILINGDATES = @as(u32, 64);
pub const MCS_SHORTDAYSOFWEEK = @as(u32, 128);
pub const MCS_NOSELCHANGEONNAV = @as(u32, 256);
pub const GMR_VISIBLE = @as(u32, 0);
pub const GMR_DAYSTATE = @as(u32, 1);
pub const DTM_FIRST = @as(u32, 4096);
pub const DTM_GETSYSTEMTIME = @as(u32, 4097);
pub const DTM_SETSYSTEMTIME = @as(u32, 4098);
pub const DTM_GETRANGE = @as(u32, 4099);
pub const DTM_SETRANGE = @as(u32, 4100);
pub const DTM_SETFORMATA = @as(u32, 4101);
pub const DTM_SETFORMATW = @as(u32, 4146);
pub const DTM_SETMCCOLOR = @as(u32, 4102);
pub const DTM_GETMCCOLOR = @as(u32, 4103);
pub const DTM_GETMONTHCAL = @as(u32, 4104);
pub const DTM_SETMCFONT = @as(u32, 4105);
pub const DTM_GETMCFONT = @as(u32, 4106);
pub const DTM_SETMCSTYLE = @as(u32, 4107);
pub const DTM_GETMCSTYLE = @as(u32, 4108);
pub const DTM_CLOSEMONTHCAL = @as(u32, 4109);
pub const DTM_GETDATETIMEPICKERINFO = @as(u32, 4110);
pub const DTM_GETIDEALSIZE = @as(u32, 4111);
pub const DTS_UPDOWN = @as(u32, 1);
pub const DTS_SHOWNONE = @as(u32, 2);
pub const DTS_SHORTDATEFORMAT = @as(u32, 0);
pub const DTS_LONGDATEFORMAT = @as(u32, 4);
pub const DTS_SHORTDATECENTURYFORMAT = @as(u32, 12);
pub const DTS_TIMEFORMAT = @as(u32, 9);
pub const DTS_APPCANPARSE = @as(u32, 16);
pub const DTS_RIGHTALIGN = @as(u32, 32);
pub const GDTR_MIN = @as(u32, 1);
pub const GDTR_MAX = @as(u32, 2);
pub const GDT_ERROR = @as(i32, -1);
pub const GDT_VALID = @as(u32, 0);
pub const GDT_NONE = @as(u32, 1);
pub const IPM_CLEARADDRESS = @as(u32, 1124);
pub const IPM_SETADDRESS = @as(u32, 1125);
pub const IPM_GETADDRESS = @as(u32, 1126);
pub const IPM_SETRANGE = @as(u32, 1127);
pub const IPM_SETFOCUS = @as(u32, 1128);
pub const IPM_ISBLANK = @as(u32, 1129);
pub const PGS_VERT = @as(u32, 0);
pub const PGS_HORZ = @as(u32, 1);
pub const PGS_AUTOSCROLL = @as(u32, 2);
pub const PGS_DRAGNDROP = @as(u32, 4);
pub const PGF_INVISIBLE = @as(u32, 0);
pub const PGF_NORMAL = @as(u32, 1);
pub const PGF_GRAYED = @as(u32, 2);
pub const PGF_DEPRESSED = @as(u32, 4);
pub const PGF_HOT = @as(u32, 8);
pub const PGB_TOPORLEFT = @as(u32, 0);
pub const PGB_BOTTOMORRIGHT = @as(u32, 1);
pub const PGM_SETCHILD = @as(u32, 5121);
pub const PGM_RECALCSIZE = @as(u32, 5122);
pub const PGM_FORWARDMOUSE = @as(u32, 5123);
pub const PGM_SETBKCOLOR = @as(u32, 5124);
pub const PGM_GETBKCOLOR = @as(u32, 5125);
pub const PGM_SETBORDER = @as(u32, 5126);
pub const PGM_GETBORDER = @as(u32, 5127);
pub const PGM_SETPOS = @as(u32, 5128);
pub const PGM_GETPOS = @as(u32, 5129);
pub const PGM_SETBUTTONSIZE = @as(u32, 5130);
pub const PGM_GETBUTTONSIZE = @as(u32, 5131);
pub const PGM_GETBUTTONSTATE = @as(u32, 5132);
pub const PGM_SETSCROLLINFO = @as(u32, 5133);
pub const NFS_EDIT = @as(u32, 1);
pub const NFS_STATIC = @as(u32, 2);
pub const NFS_LISTCOMBO = @as(u32, 4);
pub const NFS_BUTTON = @as(u32, 8);
pub const NFS_ALL = @as(u32, 16);
pub const NFS_USEFONTASSOC = @as(u32, 32);
pub const BCM_GETIDEALSIZE = @as(u32, 5633);
pub const BCM_SETIMAGELIST = @as(u32, 5634);
pub const BCM_GETIMAGELIST = @as(u32, 5635);
pub const BCM_SETTEXTMARGIN = @as(u32, 5636);
pub const BCM_GETTEXTMARGIN = @as(u32, 5637);
pub const BCN_HOTITEMCHANGE = @as(u32, 4294966047);
pub const BST_HOT = @as(u32, 512);
pub const BST_DROPDOWNPUSHED = @as(u32, 1024);
pub const BS_SPLITBUTTON = @as(i32, 12);
pub const BS_DEFSPLITBUTTON = @as(i32, 13);
pub const BS_COMMANDLINK = @as(i32, 14);
pub const BS_DEFCOMMANDLINK = @as(i32, 15);
pub const BCSIF_GLYPH = @as(u32, 1);
pub const BCSIF_IMAGE = @as(u32, 2);
pub const BCSIF_STYLE = @as(u32, 4);
pub const BCSIF_SIZE = @as(u32, 8);
pub const BCSS_NOSPLIT = @as(u32, 1);
pub const BCSS_STRETCH = @as(u32, 2);
pub const BCSS_ALIGNLEFT = @as(u32, 4);
pub const BCSS_IMAGE = @as(u32, 8);
pub const BCM_SETDROPDOWNSTATE = @as(u32, 5638);
pub const BCM_SETSPLITINFO = @as(u32, 5639);
pub const BCM_GETSPLITINFO = @as(u32, 5640);
pub const BCM_SETNOTE = @as(u32, 5641);
pub const BCM_GETNOTE = @as(u32, 5642);
pub const BCM_GETNOTELENGTH = @as(u32, 5643);
pub const BCM_SETSHIELD = @as(u32, 5644);
pub const BCN_DROPDOWN = @as(u32, 4294966048);
pub const ES_EX_ALLOWEOL_CR = @as(i32, 1);
pub const ES_EX_ALLOWEOL_LF = @as(i32, 2);
pub const ES_EX_CONVERT_EOL_ON_PASTE = @as(i32, 4);
pub const ES_EX_ZOOMABLE = @as(i32, 16);
pub const EM_SETCUEBANNER = @as(u32, 5377);
pub const EM_GETCUEBANNER = @as(u32, 5378);
pub const EM_SHOWBALLOONTIP = @as(u32, 5379);
pub const EM_HIDEBALLOONTIP = @as(u32, 5380);
pub const EM_SETHILITE = @as(u32, 5381);
pub const EM_GETHILITE = @as(u32, 5382);
pub const EM_NOSETFOCUS = @as(u32, 5383);
pub const EM_TAKEFOCUS = @as(u32, 5384);
pub const EM_SETEXTENDEDSTYLE = @as(u32, 5386);
pub const EM_GETEXTENDEDSTYLE = @as(u32, 5387);
pub const EM_SETENDOFLINE = @as(u32, 5388);
pub const EM_GETENDOFLINE = @as(u32, 5389);
pub const EM_ENABLESEARCHWEB = @as(u32, 5390);
pub const EM_SEARCHWEB = @as(u32, 5391);
pub const EM_SETCARETINDEX = @as(u32, 5393);
pub const EM_GETCARETINDEX = @as(u32, 5394);
pub const EM_FILELINEFROMCHAR = @as(u32, 5395);
pub const EM_FILELINEINDEX = @as(u32, 5396);
pub const EM_FILELINELENGTH = @as(u32, 5397);
pub const EM_GETFILELINE = @as(u32, 5398);
pub const EM_GETFILELINECOUNT = @as(u32, 5399);
pub const CB_SETMINVISIBLE = @as(u32, 5889);
pub const CB_GETMINVISIBLE = @as(u32, 5890);
pub const CB_SETCUEBANNER = @as(u32, 5891);
pub const CB_GETCUEBANNER = @as(u32, 5892);
pub const WM_MOUSEHOVER = @as(u32, 673);
pub const WM_MOUSELEAVE = @as(u32, 675);
pub const HOVER_DEFAULT = @as(u32, 4294967295);
pub const WSB_PROP_MASK = @as(i32, 4095);
pub const FSB_FLAT_MODE = @as(u32, 2);
pub const FSB_ENCARTA_MODE = @as(u32, 1);
pub const FSB_REGULAR_MODE = @as(u32, 0);
pub const EM_GETSEL = @as(u32, 176);
pub const EM_SETSEL = @as(u32, 177);
pub const EM_GETRECT = @as(u32, 178);
pub const EM_SETRECT = @as(u32, 179);
pub const EM_SETRECTNP = @as(u32, 180);
pub const EM_SCROLL = @as(u32, 181);
pub const EM_LINESCROLL = @as(u32, 182);
pub const EM_GETMODIFY = @as(u32, 184);
pub const EM_SETMODIFY = @as(u32, 185);
pub const EM_GETLINECOUNT = @as(u32, 186);
pub const EM_LINEINDEX = @as(u32, 187);
pub const EM_SETHANDLE = @as(u32, 188);
pub const EM_GETHANDLE = @as(u32, 189);
pub const EM_GETTHUMB = @as(u32, 190);
pub const EM_LINELENGTH = @as(u32, 193);
pub const EM_REPLACESEL = @as(u32, 194);
pub const EM_GETLINE = @as(u32, 196);
pub const EM_LIMITTEXT = @as(u32, 197);
pub const EM_CANUNDO = @as(u32, 198);
pub const EM_UNDO = @as(u32, 199);
pub const EM_FMTLINES = @as(u32, 200);
pub const EM_LINEFROMCHAR = @as(u32, 201);
pub const EM_SETTABSTOPS = @as(u32, 203);
pub const EM_SETPASSWORDCHAR = @as(u32, 204);
pub const EM_EMPTYUNDOBUFFER = @as(u32, 205);
pub const EM_GETFIRSTVISIBLELINE = @as(u32, 206);
pub const EM_SETREADONLY = @as(u32, 207);
pub const EM_SETWORDBREAKPROC = @as(u32, 208);
pub const EM_GETWORDBREAKPROC = @as(u32, 209);
pub const EM_GETPASSWORDCHAR = @as(u32, 210);
pub const EM_SETMARGINS = @as(u32, 211);
pub const EM_GETMARGINS = @as(u32, 212);
pub const EM_SETIMESTATUS = @as(u32, 216);
pub const EM_GETIMESTATUS = @as(u32, 217);
pub const EM_ENABLEFEATURE = @as(u32, 218);

//--------------------------------------------------------------------------------
// Section: Types (500)
//--------------------------------------------------------------------------------
pub const THEME_PROPERTY_SYMBOL_ID = enum(u32) {
    RESERVEDLOW = 0,
    RESERVEDHIGH = 7999,
    DIBDATA = 2,
    GLYPHDIBDATA = 8,
    ENUM = 200,
    STRING = 201,
    INT = 202,
    BOOL = 203,
    COLOR = 204,
    MARGINS = 205,
    FILENAME = 206,
    SIZE = 207,
    POSITION = 208,
    RECT = 209,
    FONT = 210,
    INTLIST = 211,
    HBITMAP = 212,
    DISKSTREAM = 213,
    STREAM = 214,
    BITMAPREF = 215,
    FLOAT = 216,
    FLOATLIST = 217,
    COLORSCHEMES = 401,
    SIZES = 402,
    CHARSET = 403,
    NAME = 600,
    DISPLAYNAME = 601,
    TOOLTIP = 602,
    COMPANY = 603,
    AUTHOR = 604,
    COPYRIGHT = 605,
    URL = 606,
    VERSION = 607,
    DESCRIPTION = 608,
    // FIRST_RCSTRING_NAME = 601, this enum value conflicts with DISPLAYNAME
    // LAST_RCSTRING_NAME = 608, this enum value conflicts with DESCRIPTION
    CAPTIONFONT = 801,
    SMALLCAPTIONFONT = 802,
    MENUFONT = 803,
    STATUSFONT = 804,
    MSGBOXFONT = 805,
    ICONTITLEFONT = 806,
    HEADING1FONT = 807,
    HEADING2FONT = 808,
    BODYFONT = 809,
    // FIRSTFONT = 801, this enum value conflicts with CAPTIONFONT
    // LASTFONT = 809, this enum value conflicts with BODYFONT
    FLATMENUS = 1001,
    // FIRSTBOOL = 1001, this enum value conflicts with FLATMENUS
    // LASTBOOL = 1001, this enum value conflicts with FLATMENUS
    SIZINGBORDERWIDTH = 1201,
    SCROLLBARWIDTH = 1202,
    SCROLLBARHEIGHT = 1203,
    CAPTIONBARWIDTH = 1204,
    CAPTIONBARHEIGHT = 1205,
    SMCAPTIONBARWIDTH = 1206,
    SMCAPTIONBARHEIGHT = 1207,
    MENUBARWIDTH = 1208,
    MENUBARHEIGHT = 1209,
    PADDEDBORDERWIDTH = 1210,
    // FIRSTSIZE = 1201, this enum value conflicts with SIZINGBORDERWIDTH
    // LASTSIZE = 1210, this enum value conflicts with PADDEDBORDERWIDTH
    MINCOLORDEPTH = 1301,
    // FIRSTINT = 1301, this enum value conflicts with MINCOLORDEPTH
    // LASTINT = 1301, this enum value conflicts with MINCOLORDEPTH
    CSSNAME = 1401,
    XMLNAME = 1402,
    LASTUPDATED = 1403,
    ALIAS = 1404,
    // FIRSTSTRING = 1401, this enum value conflicts with CSSNAME
    // LASTSTRING = 1404, this enum value conflicts with ALIAS
    SCROLLBAR = 1601,
    BACKGROUND = 1602,
    ACTIVECAPTION = 1603,
    INACTIVECAPTION = 1604,
    MENU = 1605,
    WINDOW = 1606,
    WINDOWFRAME = 1607,
    MENUTEXT = 1608,
    WINDOWTEXT = 1609,
    CAPTIONTEXT = 1610,
    ACTIVEBORDER = 1611,
    INACTIVEBORDER = 1612,
    APPWORKSPACE = 1613,
    HIGHLIGHT = 1614,
    HIGHLIGHTTEXT = 1615,
    BTNFACE = 1616,
    BTNSHADOW = 1617,
    GRAYTEXT = 1618,
    BTNTEXT = 1619,
    INACTIVECAPTIONTEXT = 1620,
    BTNHIGHLIGHT = 1621,
    DKSHADOW3D = 1622,
    LIGHT3D = 1623,
    INFOTEXT = 1624,
    INFOBK = 1625,
    BUTTONALTERNATEFACE = 1626,
    HOTTRACKING = 1627,
    GRADIENTACTIVECAPTION = 1628,
    GRADIENTINACTIVECAPTION = 1629,
    MENUHILIGHT = 1630,
    MENUBAR = 1631,
    // FIRSTCOLOR = 1601, this enum value conflicts with SCROLLBAR
    // LASTCOLOR = 1631, this enum value conflicts with MENUBAR
    FROMHUE1 = 1801,
    FROMHUE2 = 1802,
    FROMHUE3 = 1803,
    FROMHUE4 = 1804,
    FROMHUE5 = 1805,
    TOHUE1 = 1806,
    TOHUE2 = 1807,
    TOHUE3 = 1808,
    TOHUE4 = 1809,
    TOHUE5 = 1810,
    FROMCOLOR1 = 2001,
    FROMCOLOR2 = 2002,
    FROMCOLOR3 = 2003,
    FROMCOLOR4 = 2004,
    FROMCOLOR5 = 2005,
    TOCOLOR1 = 2006,
    TOCOLOR2 = 2007,
    TOCOLOR3 = 2008,
    TOCOLOR4 = 2009,
    TOCOLOR5 = 2010,
    TRANSPARENT = 2201,
    AUTOSIZE = 2202,
    BORDERONLY = 2203,
    COMPOSITED = 2204,
    BGFILL = 2205,
    GLYPHTRANSPARENT = 2206,
    GLYPHONLY = 2207,
    ALWAYSSHOWSIZINGBAR = 2208,
    MIRRORIMAGE = 2209,
    UNIFORMSIZING = 2210,
    INTEGRALSIZING = 2211,
    SOURCEGROW = 2212,
    SOURCESHRINK = 2213,
    DRAWBORDERS = 2214,
    NOETCHEDEFFECT = 2215,
    TEXTAPPLYOVERLAY = 2216,
    TEXTGLOW = 2217,
    TEXTITALIC = 2218,
    COMPOSITEDOPAQUE = 2219,
    LOCALIZEDMIRRORIMAGE = 2220,
    IMAGECOUNT = 2401,
    ALPHALEVEL = 2402,
    BORDERSIZE = 2403,
    ROUNDCORNERWIDTH = 2404,
    ROUNDCORNERHEIGHT = 2405,
    GRADIENTRATIO1 = 2406,
    GRADIENTRATIO2 = 2407,
    GRADIENTRATIO3 = 2408,
    GRADIENTRATIO4 = 2409,
    GRADIENTRATIO5 = 2410,
    PROGRESSCHUNKSIZE = 2411,
    PROGRESSSPACESIZE = 2412,
    SATURATION = 2413,
    TEXTBORDERSIZE = 2414,
    ALPHATHRESHOLD = 2415,
    WIDTH = 2416,
    HEIGHT = 2417,
    GLYPHINDEX = 2418,
    TRUESIZESTRETCHMARK = 2419,
    MINDPI1 = 2420,
    MINDPI2 = 2421,
    MINDPI3 = 2422,
    MINDPI4 = 2423,
    MINDPI5 = 2424,
    TEXTGLOWSIZE = 2425,
    FRAMESPERSECOND = 2426,
    PIXELSPERFRAME = 2427,
    ANIMATIONDELAY = 2428,
    GLOWINTENSITY = 2429,
    OPACITY = 2430,
    COLORIZATIONCOLOR = 2431,
    COLORIZATIONOPACITY = 2432,
    MINDPI6 = 2433,
    MINDPI7 = 2434,
    GLYPHFONT = 2601,
    IMAGEFILE = 3001,
    IMAGEFILE1 = 3002,
    IMAGEFILE2 = 3003,
    IMAGEFILE3 = 3004,
    IMAGEFILE4 = 3005,
    IMAGEFILE5 = 3006,
    GLYPHIMAGEFILE = 3008,
    IMAGEFILE6 = 3009,
    IMAGEFILE7 = 3010,
    TEXT = 3201,
    CLASSICVALUE = 3202,
    OFFSET = 3401,
    TEXTSHADOWOFFSET = 3402,
    MINSIZE = 3403,
    MINSIZE1 = 3404,
    MINSIZE2 = 3405,
    MINSIZE3 = 3406,
    MINSIZE4 = 3407,
    MINSIZE5 = 3408,
    NORMALSIZE = 3409,
    MINSIZE6 = 3410,
    MINSIZE7 = 3411,
    SIZINGMARGINS = 3601,
    CONTENTMARGINS = 3602,
    CAPTIONMARGINS = 3603,
    BORDERCOLOR = 3801,
    FILLCOLOR = 3802,
    TEXTCOLOR = 3803,
    EDGELIGHTCOLOR = 3804,
    EDGEHIGHLIGHTCOLOR = 3805,
    EDGESHADOWCOLOR = 3806,
    EDGEDKSHADOWCOLOR = 3807,
    EDGEFILLCOLOR = 3808,
    TRANSPARENTCOLOR = 3809,
    GRADIENTCOLOR1 = 3810,
    GRADIENTCOLOR2 = 3811,
    GRADIENTCOLOR3 = 3812,
    GRADIENTCOLOR4 = 3813,
    GRADIENTCOLOR5 = 3814,
    SHADOWCOLOR = 3815,
    GLOWCOLOR = 3816,
    TEXTBORDERCOLOR = 3817,
    TEXTSHADOWCOLOR = 3818,
    GLYPHTEXTCOLOR = 3819,
    GLYPHTRANSPARENTCOLOR = 3820,
    FILLCOLORHINT = 3821,
    BORDERCOLORHINT = 3822,
    ACCENTCOLORHINT = 3823,
    TEXTCOLORHINT = 3824,
    HEADING1TEXTCOLOR = 3825,
    HEADING2TEXTCOLOR = 3826,
    BODYTEXTCOLOR = 3827,
    BGTYPE = 4001,
    BORDERTYPE = 4002,
    FILLTYPE = 4003,
    SIZINGTYPE = 4004,
    HALIGN = 4005,
    CONTENTALIGNMENT = 4006,
    VALIGN = 4007,
    OFFSETTYPE = 4008,
    ICONEFFECT = 4009,
    TEXTSHADOWTYPE = 4010,
    IMAGELAYOUT = 4011,
    GLYPHTYPE = 4012,
    IMAGESELECTTYPE = 4013,
    GLYPHFONTSIZINGTYPE = 4014,
    TRUESIZESCALINGTYPE = 4015,
    USERPICTURE = 5001,
    DEFAULTPANESIZE = 5002,
    BLENDCOLOR = 5003,
    CUSTOMSPLITRECT = 5004,
    ANIMATIONBUTTONRECT = 5005,
    ANIMATIONDURATION = 5006,
    TRANSITIONDURATIONS = 6000,
    SCALEDBACKGROUND = 7001,
    ATLASIMAGE = 8000,
    ATLASINPUTIMAGE = 8001,
    ATLASRECT = 8002,
};
pub const TMT_RESERVEDLOW = THEME_PROPERTY_SYMBOL_ID.RESERVEDLOW;
pub const TMT_RESERVEDHIGH = THEME_PROPERTY_SYMBOL_ID.RESERVEDHIGH;
pub const TMT_DIBDATA = THEME_PROPERTY_SYMBOL_ID.DIBDATA;
pub const TMT_GLYPHDIBDATA = THEME_PROPERTY_SYMBOL_ID.GLYPHDIBDATA;
pub const TMT_ENUM = THEME_PROPERTY_SYMBOL_ID.ENUM;
pub const TMT_STRING = THEME_PROPERTY_SYMBOL_ID.STRING;
pub const TMT_INT = THEME_PROPERTY_SYMBOL_ID.INT;
pub const TMT_BOOL = THEME_PROPERTY_SYMBOL_ID.BOOL;
pub const TMT_COLOR = THEME_PROPERTY_SYMBOL_ID.COLOR;
pub const TMT_MARGINS = THEME_PROPERTY_SYMBOL_ID.MARGINS;
pub const TMT_FILENAME = THEME_PROPERTY_SYMBOL_ID.FILENAME;
pub const TMT_SIZE = THEME_PROPERTY_SYMBOL_ID.SIZE;
pub const TMT_POSITION = THEME_PROPERTY_SYMBOL_ID.POSITION;
pub const TMT_RECT = THEME_PROPERTY_SYMBOL_ID.RECT;
pub const TMT_FONT = THEME_PROPERTY_SYMBOL_ID.FONT;
pub const TMT_INTLIST = THEME_PROPERTY_SYMBOL_ID.INTLIST;
pub const TMT_HBITMAP = THEME_PROPERTY_SYMBOL_ID.HBITMAP;
pub const TMT_DISKSTREAM = THEME_PROPERTY_SYMBOL_ID.DISKSTREAM;
pub const TMT_STREAM = THEME_PROPERTY_SYMBOL_ID.STREAM;
pub const TMT_BITMAPREF = THEME_PROPERTY_SYMBOL_ID.BITMAPREF;
pub const TMT_FLOAT = THEME_PROPERTY_SYMBOL_ID.FLOAT;
pub const TMT_FLOATLIST = THEME_PROPERTY_SYMBOL_ID.FLOATLIST;
pub const TMT_COLORSCHEMES = THEME_PROPERTY_SYMBOL_ID.COLORSCHEMES;
pub const TMT_SIZES = THEME_PROPERTY_SYMBOL_ID.SIZES;
pub const TMT_CHARSET = THEME_PROPERTY_SYMBOL_ID.CHARSET;
pub const TMT_NAME = THEME_PROPERTY_SYMBOL_ID.NAME;
pub const TMT_DISPLAYNAME = THEME_PROPERTY_SYMBOL_ID.DISPLAYNAME;
pub const TMT_TOOLTIP = THEME_PROPERTY_SYMBOL_ID.TOOLTIP;
pub const TMT_COMPANY = THEME_PROPERTY_SYMBOL_ID.COMPANY;
pub const TMT_AUTHOR = THEME_PROPERTY_SYMBOL_ID.AUTHOR;
pub const TMT_COPYRIGHT = THEME_PROPERTY_SYMBOL_ID.COPYRIGHT;
pub const TMT_URL = THEME_PROPERTY_SYMBOL_ID.URL;
pub const TMT_VERSION = THEME_PROPERTY_SYMBOL_ID.VERSION;
pub const TMT_DESCRIPTION = THEME_PROPERTY_SYMBOL_ID.DESCRIPTION;
pub const TMT_FIRST_RCSTRING_NAME = THEME_PROPERTY_SYMBOL_ID.DISPLAYNAME;
pub const TMT_LAST_RCSTRING_NAME = THEME_PROPERTY_SYMBOL_ID.DESCRIPTION;
pub const TMT_CAPTIONFONT = THEME_PROPERTY_SYMBOL_ID.CAPTIONFONT;
pub const TMT_SMALLCAPTIONFONT = THEME_PROPERTY_SYMBOL_ID.SMALLCAPTIONFONT;
pub const TMT_MENUFONT = THEME_PROPERTY_SYMBOL_ID.MENUFONT;
pub const TMT_STATUSFONT = THEME_PROPERTY_SYMBOL_ID.STATUSFONT;
pub const TMT_MSGBOXFONT = THEME_PROPERTY_SYMBOL_ID.MSGBOXFONT;
pub const TMT_ICONTITLEFONT = THEME_PROPERTY_SYMBOL_ID.ICONTITLEFONT;
pub const TMT_HEADING1FONT = THEME_PROPERTY_SYMBOL_ID.HEADING1FONT;
pub const TMT_HEADING2FONT = THEME_PROPERTY_SYMBOL_ID.HEADING2FONT;
pub const TMT_BODYFONT = THEME_PROPERTY_SYMBOL_ID.BODYFONT;
pub const TMT_FIRSTFONT = THEME_PROPERTY_SYMBOL_ID.CAPTIONFONT;
pub const TMT_LASTFONT = THEME_PROPERTY_SYMBOL_ID.BODYFONT;
pub const TMT_FLATMENUS = THEME_PROPERTY_SYMBOL_ID.FLATMENUS;
pub const TMT_FIRSTBOOL = THEME_PROPERTY_SYMBOL_ID.FLATMENUS;
pub const TMT_LASTBOOL = THEME_PROPERTY_SYMBOL_ID.FLATMENUS;
pub const TMT_SIZINGBORDERWIDTH = THEME_PROPERTY_SYMBOL_ID.SIZINGBORDERWIDTH;
pub const TMT_SCROLLBARWIDTH = THEME_PROPERTY_SYMBOL_ID.SCROLLBARWIDTH;
pub const TMT_SCROLLBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.SCROLLBARHEIGHT;
pub const TMT_CAPTIONBARWIDTH = THEME_PROPERTY_SYMBOL_ID.CAPTIONBARWIDTH;
pub const TMT_CAPTIONBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.CAPTIONBARHEIGHT;
pub const TMT_SMCAPTIONBARWIDTH = THEME_PROPERTY_SYMBOL_ID.SMCAPTIONBARWIDTH;
pub const TMT_SMCAPTIONBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.SMCAPTIONBARHEIGHT;
pub const TMT_MENUBARWIDTH = THEME_PROPERTY_SYMBOL_ID.MENUBARWIDTH;
pub const TMT_MENUBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.MENUBARHEIGHT;
pub const TMT_PADDEDBORDERWIDTH = THEME_PROPERTY_SYMBOL_ID.PADDEDBORDERWIDTH;
pub const TMT_FIRSTSIZE = THEME_PROPERTY_SYMBOL_ID.SIZINGBORDERWIDTH;
pub const TMT_LASTSIZE = THEME_PROPERTY_SYMBOL_ID.PADDEDBORDERWIDTH;
pub const TMT_MINCOLORDEPTH = THEME_PROPERTY_SYMBOL_ID.MINCOLORDEPTH;
pub const TMT_FIRSTINT = THEME_PROPERTY_SYMBOL_ID.MINCOLORDEPTH;
pub const TMT_LASTINT = THEME_PROPERTY_SYMBOL_ID.MINCOLORDEPTH;
pub const TMT_CSSNAME = THEME_PROPERTY_SYMBOL_ID.CSSNAME;
pub const TMT_XMLNAME = THEME_PROPERTY_SYMBOL_ID.XMLNAME;
pub const TMT_LASTUPDATED = THEME_PROPERTY_SYMBOL_ID.LASTUPDATED;
pub const TMT_ALIAS = THEME_PROPERTY_SYMBOL_ID.ALIAS;
pub const TMT_FIRSTSTRING = THEME_PROPERTY_SYMBOL_ID.CSSNAME;
pub const TMT_LASTSTRING = THEME_PROPERTY_SYMBOL_ID.ALIAS;
pub const TMT_SCROLLBAR = THEME_PROPERTY_SYMBOL_ID.SCROLLBAR;
pub const TMT_BACKGROUND = THEME_PROPERTY_SYMBOL_ID.BACKGROUND;
pub const TMT_ACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.ACTIVECAPTION;
pub const TMT_INACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.INACTIVECAPTION;
pub const TMT_MENU = THEME_PROPERTY_SYMBOL_ID.MENU;
pub const TMT_WINDOW = THEME_PROPERTY_SYMBOL_ID.WINDOW;
pub const TMT_WINDOWFRAME = THEME_PROPERTY_SYMBOL_ID.WINDOWFRAME;
pub const TMT_MENUTEXT = THEME_PROPERTY_SYMBOL_ID.MENUTEXT;
pub const TMT_WINDOWTEXT = THEME_PROPERTY_SYMBOL_ID.WINDOWTEXT;
pub const TMT_CAPTIONTEXT = THEME_PROPERTY_SYMBOL_ID.CAPTIONTEXT;
pub const TMT_ACTIVEBORDER = THEME_PROPERTY_SYMBOL_ID.ACTIVEBORDER;
pub const TMT_INACTIVEBORDER = THEME_PROPERTY_SYMBOL_ID.INACTIVEBORDER;
pub const TMT_APPWORKSPACE = THEME_PROPERTY_SYMBOL_ID.APPWORKSPACE;
pub const TMT_HIGHLIGHT = THEME_PROPERTY_SYMBOL_ID.HIGHLIGHT;
pub const TMT_HIGHLIGHTTEXT = THEME_PROPERTY_SYMBOL_ID.HIGHLIGHTTEXT;
pub const TMT_BTNFACE = THEME_PROPERTY_SYMBOL_ID.BTNFACE;
pub const TMT_BTNSHADOW = THEME_PROPERTY_SYMBOL_ID.BTNSHADOW;
pub const TMT_GRAYTEXT = THEME_PROPERTY_SYMBOL_ID.GRAYTEXT;
pub const TMT_BTNTEXT = THEME_PROPERTY_SYMBOL_ID.BTNTEXT;
pub const TMT_INACTIVECAPTIONTEXT = THEME_PROPERTY_SYMBOL_ID.INACTIVECAPTIONTEXT;
pub const TMT_BTNHIGHLIGHT = THEME_PROPERTY_SYMBOL_ID.BTNHIGHLIGHT;
pub const TMT_DKSHADOW3D = THEME_PROPERTY_SYMBOL_ID.DKSHADOW3D;
pub const TMT_LIGHT3D = THEME_PROPERTY_SYMBOL_ID.LIGHT3D;
pub const TMT_INFOTEXT = THEME_PROPERTY_SYMBOL_ID.INFOTEXT;
pub const TMT_INFOBK = THEME_PROPERTY_SYMBOL_ID.INFOBK;
pub const TMT_BUTTONALTERNATEFACE = THEME_PROPERTY_SYMBOL_ID.BUTTONALTERNATEFACE;
pub const TMT_HOTTRACKING = THEME_PROPERTY_SYMBOL_ID.HOTTRACKING;
pub const TMT_GRADIENTACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.GRADIENTACTIVECAPTION;
pub const TMT_GRADIENTINACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.GRADIENTINACTIVECAPTION;
pub const TMT_MENUHILIGHT = THEME_PROPERTY_SYMBOL_ID.MENUHILIGHT;
pub const TMT_MENUBAR = THEME_PROPERTY_SYMBOL_ID.MENUBAR;
pub const TMT_FIRSTCOLOR = THEME_PROPERTY_SYMBOL_ID.SCROLLBAR;
pub const TMT_LASTCOLOR = THEME_PROPERTY_SYMBOL_ID.MENUBAR;
pub const TMT_FROMHUE1 = THEME_PROPERTY_SYMBOL_ID.FROMHUE1;
pub const TMT_FROMHUE2 = THEME_PROPERTY_SYMBOL_ID.FROMHUE2;
pub const TMT_FROMHUE3 = THEME_PROPERTY_SYMBOL_ID.FROMHUE3;
pub const TMT_FROMHUE4 = THEME_PROPERTY_SYMBOL_ID.FROMHUE4;
pub const TMT_FROMHUE5 = THEME_PROPERTY_SYMBOL_ID.FROMHUE5;
pub const TMT_TOHUE1 = THEME_PROPERTY_SYMBOL_ID.TOHUE1;
pub const TMT_TOHUE2 = THEME_PROPERTY_SYMBOL_ID.TOHUE2;
pub const TMT_TOHUE3 = THEME_PROPERTY_SYMBOL_ID.TOHUE3;
pub const TMT_TOHUE4 = THEME_PROPERTY_SYMBOL_ID.TOHUE4;
pub const TMT_TOHUE5 = THEME_PROPERTY_SYMBOL_ID.TOHUE5;
pub const TMT_FROMCOLOR1 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR1;
pub const TMT_FROMCOLOR2 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR2;
pub const TMT_FROMCOLOR3 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR3;
pub const TMT_FROMCOLOR4 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR4;
pub const TMT_FROMCOLOR5 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR5;
pub const TMT_TOCOLOR1 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR1;
pub const TMT_TOCOLOR2 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR2;
pub const TMT_TOCOLOR3 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR3;
pub const TMT_TOCOLOR4 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR4;
pub const TMT_TOCOLOR5 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR5;
pub const TMT_TRANSPARENT = THEME_PROPERTY_SYMBOL_ID.TRANSPARENT;
pub const TMT_AUTOSIZE = THEME_PROPERTY_SYMBOL_ID.AUTOSIZE;
pub const TMT_BORDERONLY = THEME_PROPERTY_SYMBOL_ID.BORDERONLY;
pub const TMT_COMPOSITED = THEME_PROPERTY_SYMBOL_ID.COMPOSITED;
pub const TMT_BGFILL = THEME_PROPERTY_SYMBOL_ID.BGFILL;
pub const TMT_GLYPHTRANSPARENT = THEME_PROPERTY_SYMBOL_ID.GLYPHTRANSPARENT;
pub const TMT_GLYPHONLY = THEME_PROPERTY_SYMBOL_ID.GLYPHONLY;
pub const TMT_ALWAYSSHOWSIZINGBAR = THEME_PROPERTY_SYMBOL_ID.ALWAYSSHOWSIZINGBAR;
pub const TMT_MIRRORIMAGE = THEME_PROPERTY_SYMBOL_ID.MIRRORIMAGE;
pub const TMT_UNIFORMSIZING = THEME_PROPERTY_SYMBOL_ID.UNIFORMSIZING;
pub const TMT_INTEGRALSIZING = THEME_PROPERTY_SYMBOL_ID.INTEGRALSIZING;
pub const TMT_SOURCEGROW = THEME_PROPERTY_SYMBOL_ID.SOURCEGROW;
pub const TMT_SOURCESHRINK = THEME_PROPERTY_SYMBOL_ID.SOURCESHRINK;
pub const TMT_DRAWBORDERS = THEME_PROPERTY_SYMBOL_ID.DRAWBORDERS;
pub const TMT_NOETCHEDEFFECT = THEME_PROPERTY_SYMBOL_ID.NOETCHEDEFFECT;
pub const TMT_TEXTAPPLYOVERLAY = THEME_PROPERTY_SYMBOL_ID.TEXTAPPLYOVERLAY;
pub const TMT_TEXTGLOW = THEME_PROPERTY_SYMBOL_ID.TEXTGLOW;
pub const TMT_TEXTITALIC = THEME_PROPERTY_SYMBOL_ID.TEXTITALIC;
pub const TMT_COMPOSITEDOPAQUE = THEME_PROPERTY_SYMBOL_ID.COMPOSITEDOPAQUE;
pub const TMT_LOCALIZEDMIRRORIMAGE = THEME_PROPERTY_SYMBOL_ID.LOCALIZEDMIRRORIMAGE;
pub const TMT_IMAGECOUNT = THEME_PROPERTY_SYMBOL_ID.IMAGECOUNT;
pub const TMT_ALPHALEVEL = THEME_PROPERTY_SYMBOL_ID.ALPHALEVEL;
pub const TMT_BORDERSIZE = THEME_PROPERTY_SYMBOL_ID.BORDERSIZE;
pub const TMT_ROUNDCORNERWIDTH = THEME_PROPERTY_SYMBOL_ID.ROUNDCORNERWIDTH;
pub const TMT_ROUNDCORNERHEIGHT = THEME_PROPERTY_SYMBOL_ID.ROUNDCORNERHEIGHT;
pub const TMT_GRADIENTRATIO1 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO1;
pub const TMT_GRADIENTRATIO2 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO2;
pub const TMT_GRADIENTRATIO3 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO3;
pub const TMT_GRADIENTRATIO4 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO4;
pub const TMT_GRADIENTRATIO5 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO5;
pub const TMT_PROGRESSCHUNKSIZE = THEME_PROPERTY_SYMBOL_ID.PROGRESSCHUNKSIZE;
pub const TMT_PROGRESSSPACESIZE = THEME_PROPERTY_SYMBOL_ID.PROGRESSSPACESIZE;
pub const TMT_SATURATION = THEME_PROPERTY_SYMBOL_ID.SATURATION;
pub const TMT_TEXTBORDERSIZE = THEME_PROPERTY_SYMBOL_ID.TEXTBORDERSIZE;
pub const TMT_ALPHATHRESHOLD = THEME_PROPERTY_SYMBOL_ID.ALPHATHRESHOLD;
pub const TMT_WIDTH = THEME_PROPERTY_SYMBOL_ID.WIDTH;
pub const TMT_HEIGHT = THEME_PROPERTY_SYMBOL_ID.HEIGHT;
pub const TMT_GLYPHINDEX = THEME_PROPERTY_SYMBOL_ID.GLYPHINDEX;
pub const TMT_TRUESIZESTRETCHMARK = THEME_PROPERTY_SYMBOL_ID.TRUESIZESTRETCHMARK;
pub const TMT_MINDPI1 = THEME_PROPERTY_SYMBOL_ID.MINDPI1;
pub const TMT_MINDPI2 = THEME_PROPERTY_SYMBOL_ID.MINDPI2;
pub const TMT_MINDPI3 = THEME_PROPERTY_SYMBOL_ID.MINDPI3;
pub const TMT_MINDPI4 = THEME_PROPERTY_SYMBOL_ID.MINDPI4;
pub const TMT_MINDPI5 = THEME_PROPERTY_SYMBOL_ID.MINDPI5;
pub const TMT_TEXTGLOWSIZE = THEME_PROPERTY_SYMBOL_ID.TEXTGLOWSIZE;
pub const TMT_FRAMESPERSECOND = THEME_PROPERTY_SYMBOL_ID.FRAMESPERSECOND;
pub const TMT_PIXELSPERFRAME = THEME_PROPERTY_SYMBOL_ID.PIXELSPERFRAME;
pub const TMT_ANIMATIONDELAY = THEME_PROPERTY_SYMBOL_ID.ANIMATIONDELAY;
pub const TMT_GLOWINTENSITY = THEME_PROPERTY_SYMBOL_ID.GLOWINTENSITY;
pub const TMT_OPACITY = THEME_PROPERTY_SYMBOL_ID.OPACITY;
pub const TMT_COLORIZATIONCOLOR = THEME_PROPERTY_SYMBOL_ID.COLORIZATIONCOLOR;
pub const TMT_COLORIZATIONOPACITY = THEME_PROPERTY_SYMBOL_ID.COLORIZATIONOPACITY;
pub const TMT_MINDPI6 = THEME_PROPERTY_SYMBOL_ID.MINDPI6;
pub const TMT_MINDPI7 = THEME_PROPERTY_SYMBOL_ID.MINDPI7;
pub const TMT_GLYPHFONT = THEME_PROPERTY_SYMBOL_ID.GLYPHFONT;
pub const TMT_IMAGEFILE = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE;
pub const TMT_IMAGEFILE1 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE1;
pub const TMT_IMAGEFILE2 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE2;
pub const TMT_IMAGEFILE3 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE3;
pub const TMT_IMAGEFILE4 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE4;
pub const TMT_IMAGEFILE5 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE5;
pub const TMT_GLYPHIMAGEFILE = THEME_PROPERTY_SYMBOL_ID.GLYPHIMAGEFILE;
pub const TMT_IMAGEFILE6 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE6;
pub const TMT_IMAGEFILE7 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE7;
pub const TMT_TEXT = THEME_PROPERTY_SYMBOL_ID.TEXT;
pub const TMT_CLASSICVALUE = THEME_PROPERTY_SYMBOL_ID.CLASSICVALUE;
pub const TMT_OFFSET = THEME_PROPERTY_SYMBOL_ID.OFFSET;
pub const TMT_TEXTSHADOWOFFSET = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWOFFSET;
pub const TMT_MINSIZE = THEME_PROPERTY_SYMBOL_ID.MINSIZE;
pub const TMT_MINSIZE1 = THEME_PROPERTY_SYMBOL_ID.MINSIZE1;
pub const TMT_MINSIZE2 = THEME_PROPERTY_SYMBOL_ID.MINSIZE2;
pub const TMT_MINSIZE3 = THEME_PROPERTY_SYMBOL_ID.MINSIZE3;
pub const TMT_MINSIZE4 = THEME_PROPERTY_SYMBOL_ID.MINSIZE4;
pub const TMT_MINSIZE5 = THEME_PROPERTY_SYMBOL_ID.MINSIZE5;
pub const TMT_NORMALSIZE = THEME_PROPERTY_SYMBOL_ID.NORMALSIZE;
pub const TMT_MINSIZE6 = THEME_PROPERTY_SYMBOL_ID.MINSIZE6;
pub const TMT_MINSIZE7 = THEME_PROPERTY_SYMBOL_ID.MINSIZE7;
pub const TMT_SIZINGMARGINS = THEME_PROPERTY_SYMBOL_ID.SIZINGMARGINS;
pub const TMT_CONTENTMARGINS = THEME_PROPERTY_SYMBOL_ID.CONTENTMARGINS;
pub const TMT_CAPTIONMARGINS = THEME_PROPERTY_SYMBOL_ID.CAPTIONMARGINS;
pub const TMT_BORDERCOLOR = THEME_PROPERTY_SYMBOL_ID.BORDERCOLOR;
pub const TMT_FILLCOLOR = THEME_PROPERTY_SYMBOL_ID.FILLCOLOR;
pub const TMT_TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTCOLOR;
pub const TMT_EDGELIGHTCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGELIGHTCOLOR;
pub const TMT_EDGEHIGHLIGHTCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEHIGHLIGHTCOLOR;
pub const TMT_EDGESHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGESHADOWCOLOR;
pub const TMT_EDGEDKSHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEDKSHADOWCOLOR;
pub const TMT_EDGEFILLCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEFILLCOLOR;
pub const TMT_TRANSPARENTCOLOR = THEME_PROPERTY_SYMBOL_ID.TRANSPARENTCOLOR;
pub const TMT_GRADIENTCOLOR1 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR1;
pub const TMT_GRADIENTCOLOR2 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR2;
pub const TMT_GRADIENTCOLOR3 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR3;
pub const TMT_GRADIENTCOLOR4 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR4;
pub const TMT_GRADIENTCOLOR5 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR5;
pub const TMT_SHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.SHADOWCOLOR;
pub const TMT_GLOWCOLOR = THEME_PROPERTY_SYMBOL_ID.GLOWCOLOR;
pub const TMT_TEXTBORDERCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTBORDERCOLOR;
pub const TMT_TEXTSHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWCOLOR;
pub const TMT_GLYPHTEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.GLYPHTEXTCOLOR;
pub const TMT_GLYPHTRANSPARENTCOLOR = THEME_PROPERTY_SYMBOL_ID.GLYPHTRANSPARENTCOLOR;
pub const TMT_FILLCOLORHINT = THEME_PROPERTY_SYMBOL_ID.FILLCOLORHINT;
pub const TMT_BORDERCOLORHINT = THEME_PROPERTY_SYMBOL_ID.BORDERCOLORHINT;
pub const TMT_ACCENTCOLORHINT = THEME_PROPERTY_SYMBOL_ID.ACCENTCOLORHINT;
pub const TMT_TEXTCOLORHINT = THEME_PROPERTY_SYMBOL_ID.TEXTCOLORHINT;
pub const TMT_HEADING1TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.HEADING1TEXTCOLOR;
pub const TMT_HEADING2TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.HEADING2TEXTCOLOR;
pub const TMT_BODYTEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.BODYTEXTCOLOR;
pub const TMT_BGTYPE = THEME_PROPERTY_SYMBOL_ID.BGTYPE;
pub const TMT_BORDERTYPE = THEME_PROPERTY_SYMBOL_ID.BORDERTYPE;
pub const TMT_FILLTYPE = THEME_PROPERTY_SYMBOL_ID.FILLTYPE;
pub const TMT_SIZINGTYPE = THEME_PROPERTY_SYMBOL_ID.SIZINGTYPE;
pub const TMT_HALIGN = THEME_PROPERTY_SYMBOL_ID.HALIGN;
pub const TMT_CONTENTALIGNMENT = THEME_PROPERTY_SYMBOL_ID.CONTENTALIGNMENT;
pub const TMT_VALIGN = THEME_PROPERTY_SYMBOL_ID.VALIGN;
pub const TMT_OFFSETTYPE = THEME_PROPERTY_SYMBOL_ID.OFFSETTYPE;
pub const TMT_ICONEFFECT = THEME_PROPERTY_SYMBOL_ID.ICONEFFECT;
pub const TMT_TEXTSHADOWTYPE = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWTYPE;
pub const TMT_IMAGELAYOUT = THEME_PROPERTY_SYMBOL_ID.IMAGELAYOUT;
pub const TMT_GLYPHTYPE = THEME_PROPERTY_SYMBOL_ID.GLYPHTYPE;
pub const TMT_IMAGESELECTTYPE = THEME_PROPERTY_SYMBOL_ID.IMAGESELECTTYPE;
pub const TMT_GLYPHFONTSIZINGTYPE = THEME_PROPERTY_SYMBOL_ID.GLYPHFONTSIZINGTYPE;
pub const TMT_TRUESIZESCALINGTYPE = THEME_PROPERTY_SYMBOL_ID.TRUESIZESCALINGTYPE;
pub const TMT_USERPICTURE = THEME_PROPERTY_SYMBOL_ID.USERPICTURE;
pub const TMT_DEFAULTPANESIZE = THEME_PROPERTY_SYMBOL_ID.DEFAULTPANESIZE;
pub const TMT_BLENDCOLOR = THEME_PROPERTY_SYMBOL_ID.BLENDCOLOR;
pub const TMT_CUSTOMSPLITRECT = THEME_PROPERTY_SYMBOL_ID.CUSTOMSPLITRECT;
pub const TMT_ANIMATIONBUTTONRECT = THEME_PROPERTY_SYMBOL_ID.ANIMATIONBUTTONRECT;
pub const TMT_ANIMATIONDURATION = THEME_PROPERTY_SYMBOL_ID.ANIMATIONDURATION;
pub const TMT_TRANSITIONDURATIONS = THEME_PROPERTY_SYMBOL_ID.TRANSITIONDURATIONS;
pub const TMT_SCALEDBACKGROUND = THEME_PROPERTY_SYMBOL_ID.SCALEDBACKGROUND;
pub const TMT_ATLASIMAGE = THEME_PROPERTY_SYMBOL_ID.ATLASIMAGE;
pub const TMT_ATLASINPUTIMAGE = THEME_PROPERTY_SYMBOL_ID.ATLASINPUTIMAGE;
pub const TMT_ATLASRECT = THEME_PROPERTY_SYMBOL_ID.ATLASRECT;

pub const TOUCH_FEEDBACK_MODE = enum(u32) {
    DEFAULT = 1,
    INDIRECT = 2,
    NONE = 3,
};
pub const TOUCH_FEEDBACK_DEFAULT = TOUCH_FEEDBACK_MODE.DEFAULT;
pub const TOUCH_FEEDBACK_INDIRECT = TOUCH_FEEDBACK_MODE.INDIRECT;
pub const TOUCH_FEEDBACK_NONE = TOUCH_FEEDBACK_MODE.NONE;

pub const OBJECT_IDENTIFIER = enum(i32) {
    WINDOW = 0,
    SYSMENU = -1,
    TITLEBAR = -2,
    MENU = -3,
    CLIENT = -4,
    VSCROLL = -5,
    HSCROLL = -6,
    SIZEGRIP = -7,
    CARET = -8,
    CURSOR = -9,
    ALERT = -10,
    SOUND = -11,
    QUERYCLASSNAMEIDX = -12,
    NATIVEOM = -16,
};
pub const OBJID_WINDOW = OBJECT_IDENTIFIER.WINDOW;
pub const OBJID_SYSMENU = OBJECT_IDENTIFIER.SYSMENU;
pub const OBJID_TITLEBAR = OBJECT_IDENTIFIER.TITLEBAR;
pub const OBJID_MENU = OBJECT_IDENTIFIER.MENU;
pub const OBJID_CLIENT = OBJECT_IDENTIFIER.CLIENT;
pub const OBJID_VSCROLL = OBJECT_IDENTIFIER.VSCROLL;
pub const OBJID_HSCROLL = OBJECT_IDENTIFIER.HSCROLL;
pub const OBJID_SIZEGRIP = OBJECT_IDENTIFIER.SIZEGRIP;
pub const OBJID_CARET = OBJECT_IDENTIFIER.CARET;
pub const OBJID_CURSOR = OBJECT_IDENTIFIER.CURSOR;
pub const OBJID_ALERT = OBJECT_IDENTIFIER.ALERT;
pub const OBJID_SOUND = OBJECT_IDENTIFIER.SOUND;
pub const OBJID_QUERYCLASSNAMEIDX = OBJECT_IDENTIFIER.QUERYCLASSNAMEIDX;
pub const OBJID_NATIVEOM = OBJECT_IDENTIFIER.NATIVEOM;

pub const CFM_MASK = enum(u32) {
    SUBSCRIPT = 196608,
    EFFECTS = 1073741887,
    ALL = 4160749631,
    BOLD = 1,
    CHARSET = 134217728,
    COLOR = 1073741824,
    FACE = 536870912,
    ITALIC = 2,
    OFFSET = 268435456,
    PROTECTED = 16,
    SIZE = 2147483648,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    LINK = 32,
    SMALLCAPS = 64,
    ALLCAPS = 128,
    HIDDEN = 256,
    OUTLINE = 512,
    SHADOW = 1024,
    EMBOSS = 2048,
    IMPRINT = 4096,
    DISABLED = 8192,
    REVISED = 16384,
    REVAUTHOR = 32768,
    ANIMATION = 262144,
    STYLE = 524288,
    KERNING = 1048576,
    SPACING = 2097152,
    WEIGHT = 4194304,
    UNDERLINETYPE = 8388608,
    COOKIE = 16777216,
    LCID = 33554432,
    BACKCOLOR = 67108864,
    // SUPERSCRIPT = 196608, this enum value conflicts with SUBSCRIPT
    EFFECTS2 = 1141080063,
    ALL2 = 4294967295,
    // FONTBOUND = 1048576, this enum value conflicts with KERNING
    // LINKPROTECTED = 8388608, this enum value conflicts with UNDERLINETYPE
    // EXTENDED = 33554432, this enum value conflicts with LCID
    // MATHNOBUILDUP = 134217728, this enum value conflicts with CHARSET
    // MATH = 268435456, this enum value conflicts with OFFSET
    // MATHORDINARY = 536870912, this enum value conflicts with FACE
    ALLEFFECTS = 2115207167,
    _,
    pub fn initFlags(o: struct {
        SUBSCRIPT: u1 = 0,
        EFFECTS: u1 = 0,
        ALL: u1 = 0,
        BOLD: u1 = 0,
        CHARSET: u1 = 0,
        COLOR: u1 = 0,
        FACE: u1 = 0,
        ITALIC: u1 = 0,
        OFFSET: u1 = 0,
        PROTECTED: u1 = 0,
        SIZE: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        LINK: u1 = 0,
        SMALLCAPS: u1 = 0,
        ALLCAPS: u1 = 0,
        HIDDEN: u1 = 0,
        OUTLINE: u1 = 0,
        SHADOW: u1 = 0,
        EMBOSS: u1 = 0,
        IMPRINT: u1 = 0,
        DISABLED: u1 = 0,
        REVISED: u1 = 0,
        REVAUTHOR: u1 = 0,
        ANIMATION: u1 = 0,
        STYLE: u1 = 0,
        KERNING: u1 = 0,
        SPACING: u1 = 0,
        WEIGHT: u1 = 0,
        UNDERLINETYPE: u1 = 0,
        COOKIE: u1 = 0,
        LCID: u1 = 0,
        BACKCOLOR: u1 = 0,
        EFFECTS2: u1 = 0,
        ALL2: u1 = 0,
        ALLEFFECTS: u1 = 0,
    }) CFM_MASK {
        return @intToEnum(CFM_MASK,
              (if (o.SUBSCRIPT == 1) @enumToInt(CFM_MASK.SUBSCRIPT) else 0)
            | (if (o.EFFECTS == 1) @enumToInt(CFM_MASK.EFFECTS) else 0)
            | (if (o.ALL == 1) @enumToInt(CFM_MASK.ALL) else 0)
            | (if (o.BOLD == 1) @enumToInt(CFM_MASK.BOLD) else 0)
            | (if (o.CHARSET == 1) @enumToInt(CFM_MASK.CHARSET) else 0)
            | (if (o.COLOR == 1) @enumToInt(CFM_MASK.COLOR) else 0)
            | (if (o.FACE == 1) @enumToInt(CFM_MASK.FACE) else 0)
            | (if (o.ITALIC == 1) @enumToInt(CFM_MASK.ITALIC) else 0)
            | (if (o.OFFSET == 1) @enumToInt(CFM_MASK.OFFSET) else 0)
            | (if (o.PROTECTED == 1) @enumToInt(CFM_MASK.PROTECTED) else 0)
            | (if (o.SIZE == 1) @enumToInt(CFM_MASK.SIZE) else 0)
            | (if (o.STRIKEOUT == 1) @enumToInt(CFM_MASK.STRIKEOUT) else 0)
            | (if (o.UNDERLINE == 1) @enumToInt(CFM_MASK.UNDERLINE) else 0)
            | (if (o.LINK == 1) @enumToInt(CFM_MASK.LINK) else 0)
            | (if (o.SMALLCAPS == 1) @enumToInt(CFM_MASK.SMALLCAPS) else 0)
            | (if (o.ALLCAPS == 1) @enumToInt(CFM_MASK.ALLCAPS) else 0)
            | (if (o.HIDDEN == 1) @enumToInt(CFM_MASK.HIDDEN) else 0)
            | (if (o.OUTLINE == 1) @enumToInt(CFM_MASK.OUTLINE) else 0)
            | (if (o.SHADOW == 1) @enumToInt(CFM_MASK.SHADOW) else 0)
            | (if (o.EMBOSS == 1) @enumToInt(CFM_MASK.EMBOSS) else 0)
            | (if (o.IMPRINT == 1) @enumToInt(CFM_MASK.IMPRINT) else 0)
            | (if (o.DISABLED == 1) @enumToInt(CFM_MASK.DISABLED) else 0)
            | (if (o.REVISED == 1) @enumToInt(CFM_MASK.REVISED) else 0)
            | (if (o.REVAUTHOR == 1) @enumToInt(CFM_MASK.REVAUTHOR) else 0)
            | (if (o.ANIMATION == 1) @enumToInt(CFM_MASK.ANIMATION) else 0)
            | (if (o.STYLE == 1) @enumToInt(CFM_MASK.STYLE) else 0)
            | (if (o.KERNING == 1) @enumToInt(CFM_MASK.KERNING) else 0)
            | (if (o.SPACING == 1) @enumToInt(CFM_MASK.SPACING) else 0)
            | (if (o.WEIGHT == 1) @enumToInt(CFM_MASK.WEIGHT) else 0)
            | (if (o.UNDERLINETYPE == 1) @enumToInt(CFM_MASK.UNDERLINETYPE) else 0)
            | (if (o.COOKIE == 1) @enumToInt(CFM_MASK.COOKIE) else 0)
            | (if (o.LCID == 1) @enumToInt(CFM_MASK.LCID) else 0)
            | (if (o.BACKCOLOR == 1) @enumToInt(CFM_MASK.BACKCOLOR) else 0)
            | (if (o.EFFECTS2 == 1) @enumToInt(CFM_MASK.EFFECTS2) else 0)
            | (if (o.ALL2 == 1) @enumToInt(CFM_MASK.ALL2) else 0)
            | (if (o.ALLEFFECTS == 1) @enumToInt(CFM_MASK.ALLEFFECTS) else 0)
        );
    }
};
pub const CFM_SUBSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS = CFM_MASK.EFFECTS;
pub const CFM_ALL = CFM_MASK.ALL;
pub const CFM_BOLD = CFM_MASK.BOLD;
pub const CFM_CHARSET = CFM_MASK.CHARSET;
pub const CFM_COLOR = CFM_MASK.COLOR;
pub const CFM_FACE = CFM_MASK.FACE;
pub const CFM_ITALIC = CFM_MASK.ITALIC;
pub const CFM_OFFSET = CFM_MASK.OFFSET;
pub const CFM_PROTECTED = CFM_MASK.PROTECTED;
pub const CFM_SIZE = CFM_MASK.SIZE;
pub const CFM_STRIKEOUT = CFM_MASK.STRIKEOUT;
pub const CFM_UNDERLINE = CFM_MASK.UNDERLINE;
pub const CFM_LINK = CFM_MASK.LINK;
pub const CFM_SMALLCAPS = CFM_MASK.SMALLCAPS;
pub const CFM_ALLCAPS = CFM_MASK.ALLCAPS;
pub const CFM_HIDDEN = CFM_MASK.HIDDEN;
pub const CFM_OUTLINE = CFM_MASK.OUTLINE;
pub const CFM_SHADOW = CFM_MASK.SHADOW;
pub const CFM_EMBOSS = CFM_MASK.EMBOSS;
pub const CFM_IMPRINT = CFM_MASK.IMPRINT;
pub const CFM_DISABLED = CFM_MASK.DISABLED;
pub const CFM_REVISED = CFM_MASK.REVISED;
pub const CFM_REVAUTHOR = CFM_MASK.REVAUTHOR;
pub const CFM_ANIMATION = CFM_MASK.ANIMATION;
pub const CFM_STYLE = CFM_MASK.STYLE;
pub const CFM_KERNING = CFM_MASK.KERNING;
pub const CFM_SPACING = CFM_MASK.SPACING;
pub const CFM_WEIGHT = CFM_MASK.WEIGHT;
pub const CFM_UNDERLINETYPE = CFM_MASK.UNDERLINETYPE;
pub const CFM_COOKIE = CFM_MASK.COOKIE;
pub const CFM_LCID = CFM_MASK.LCID;
pub const CFM_BACKCOLOR = CFM_MASK.BACKCOLOR;
pub const CFM_SUPERSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS2 = CFM_MASK.EFFECTS2;
pub const CFM_ALL2 = CFM_MASK.ALL2;
pub const CFM_FONTBOUND = CFM_MASK.KERNING;
pub const CFM_LINKPROTECTED = CFM_MASK.UNDERLINETYPE;
pub const CFM_EXTENDED = CFM_MASK.LCID;
pub const CFM_MATHNOBUILDUP = CFM_MASK.CHARSET;
pub const CFM_MATH = CFM_MASK.OFFSET;
pub const CFM_MATHORDINARY = CFM_MASK.FACE;
pub const CFM_ALLEFFECTS = CFM_MASK.ALLEFFECTS;

pub const CFE_EFFECTS = enum(u32) {
    ALLCAPS = 128,
    AUTOBACKCOLOR = 67108864,
    DISABLED = 8192,
    EMBOSS = 2048,
    HIDDEN = 256,
    IMPRINT = 4096,
    OUTLINE = 512,
    REVISED = 16384,
    SHADOW = 1024,
    SMALLCAPS = 64,
    AUTOCOLOR = 1073741824,
    BOLD = 1,
    ITALIC = 2,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    PROTECTED = 16,
    LINK = 32,
    SUBSCRIPT = 65536,
    SUPERSCRIPT = 131072,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    _,
    pub fn initFlags(o: struct {
        ALLCAPS: u1 = 0,
        AUTOBACKCOLOR: u1 = 0,
        DISABLED: u1 = 0,
        EMBOSS: u1 = 0,
        HIDDEN: u1 = 0,
        IMPRINT: u1 = 0,
        OUTLINE: u1 = 0,
        REVISED: u1 = 0,
        SHADOW: u1 = 0,
        SMALLCAPS: u1 = 0,
        AUTOCOLOR: u1 = 0,
        BOLD: u1 = 0,
        ITALIC: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        PROTECTED: u1 = 0,
        LINK: u1 = 0,
        SUBSCRIPT: u1 = 0,
        SUPERSCRIPT: u1 = 0,
        FONTBOUND: u1 = 0,
        LINKPROTECTED: u1 = 0,
        EXTENDED: u1 = 0,
        MATHNOBUILDUP: u1 = 0,
        MATH: u1 = 0,
        MATHORDINARY: u1 = 0,
    }) CFE_EFFECTS {
        return @intToEnum(CFE_EFFECTS,
              (if (o.ALLCAPS == 1) @enumToInt(CFE_EFFECTS.ALLCAPS) else 0)
            | (if (o.AUTOBACKCOLOR == 1) @enumToInt(CFE_EFFECTS.AUTOBACKCOLOR) else 0)
            | (if (o.DISABLED == 1) @enumToInt(CFE_EFFECTS.DISABLED) else 0)
            | (if (o.EMBOSS == 1) @enumToInt(CFE_EFFECTS.EMBOSS) else 0)
            | (if (o.HIDDEN == 1) @enumToInt(CFE_EFFECTS.HIDDEN) else 0)
            | (if (o.IMPRINT == 1) @enumToInt(CFE_EFFECTS.IMPRINT) else 0)
            | (if (o.OUTLINE == 1) @enumToInt(CFE_EFFECTS.OUTLINE) else 0)
            | (if (o.REVISED == 1) @enumToInt(CFE_EFFECTS.REVISED) else 0)
            | (if (o.SHADOW == 1) @enumToInt(CFE_EFFECTS.SHADOW) else 0)
            | (if (o.SMALLCAPS == 1) @enumToInt(CFE_EFFECTS.SMALLCAPS) else 0)
            | (if (o.AUTOCOLOR == 1) @enumToInt(CFE_EFFECTS.AUTOCOLOR) else 0)
            | (if (o.BOLD == 1) @enumToInt(CFE_EFFECTS.BOLD) else 0)
            | (if (o.ITALIC == 1) @enumToInt(CFE_EFFECTS.ITALIC) else 0)
            | (if (o.STRIKEOUT == 1) @enumToInt(CFE_EFFECTS.STRIKEOUT) else 0)
            | (if (o.UNDERLINE == 1) @enumToInt(CFE_EFFECTS.UNDERLINE) else 0)
            | (if (o.PROTECTED == 1) @enumToInt(CFE_EFFECTS.PROTECTED) else 0)
            | (if (o.LINK == 1) @enumToInt(CFE_EFFECTS.LINK) else 0)
            | (if (o.SUBSCRIPT == 1) @enumToInt(CFE_EFFECTS.SUBSCRIPT) else 0)
            | (if (o.SUPERSCRIPT == 1) @enumToInt(CFE_EFFECTS.SUPERSCRIPT) else 0)
            | (if (o.FONTBOUND == 1) @enumToInt(CFE_EFFECTS.FONTBOUND) else 0)
            | (if (o.LINKPROTECTED == 1) @enumToInt(CFE_EFFECTS.LINKPROTECTED) else 0)
            | (if (o.EXTENDED == 1) @enumToInt(CFE_EFFECTS.EXTENDED) else 0)
            | (if (o.MATHNOBUILDUP == 1) @enumToInt(CFE_EFFECTS.MATHNOBUILDUP) else 0)
            | (if (o.MATH == 1) @enumToInt(CFE_EFFECTS.MATH) else 0)
            | (if (o.MATHORDINARY == 1) @enumToInt(CFE_EFFECTS.MATHORDINARY) else 0)
        );
    }
};
// TODO: enum 'CFE_EFFECTS' has known issues with its value aliases

pub const PARAFORMAT_MASK = enum(u32) {
    ALIGNMENT = 8,
    NUMBERING = 32,
    OFFSET = 4,
    OFFSETINDENT = 2147483648,
    RIGHTINDENT = 2,
    RTLPARA = 65536,
    STARTINDENT = 1,
    TABSTOPS = 16,
    _,
    pub fn initFlags(o: struct {
        ALIGNMENT: u1 = 0,
        NUMBERING: u1 = 0,
        OFFSET: u1 = 0,
        OFFSETINDENT: u1 = 0,
        RIGHTINDENT: u1 = 0,
        RTLPARA: u1 = 0,
        STARTINDENT: u1 = 0,
        TABSTOPS: u1 = 0,
    }) PARAFORMAT_MASK {
        return @intToEnum(PARAFORMAT_MASK,
              (if (o.ALIGNMENT == 1) @enumToInt(PARAFORMAT_MASK.ALIGNMENT) else 0)
            | (if (o.NUMBERING == 1) @enumToInt(PARAFORMAT_MASK.NUMBERING) else 0)
            | (if (o.OFFSET == 1) @enumToInt(PARAFORMAT_MASK.OFFSET) else 0)
            | (if (o.OFFSETINDENT == 1) @enumToInt(PARAFORMAT_MASK.OFFSETINDENT) else 0)
            | (if (o.RIGHTINDENT == 1) @enumToInt(PARAFORMAT_MASK.RIGHTINDENT) else 0)
            | (if (o.RTLPARA == 1) @enumToInt(PARAFORMAT_MASK.RTLPARA) else 0)
            | (if (o.STARTINDENT == 1) @enumToInt(PARAFORMAT_MASK.STARTINDENT) else 0)
            | (if (o.TABSTOPS == 1) @enumToInt(PARAFORMAT_MASK.TABSTOPS) else 0)
        );
    }
};
pub const PFM_ALIGNMENT = PARAFORMAT_MASK.ALIGNMENT;
pub const PFM_NUMBERING = PARAFORMAT_MASK.NUMBERING;
pub const PFM_OFFSET = PARAFORMAT_MASK.OFFSET;
pub const PFM_OFFSETINDENT = PARAFORMAT_MASK.OFFSETINDENT;
pub const PFM_RIGHTINDENT = PARAFORMAT_MASK.RIGHTINDENT;
pub const PFM_RTLPARA = PARAFORMAT_MASK.RTLPARA;
pub const PFM_STARTINDENT = PARAFORMAT_MASK.STARTINDENT;
pub const PFM_TABSTOPS = PARAFORMAT_MASK.TABSTOPS;

pub const DRAGLISTINFO_NOTIFICATION_FLAGS = enum(u32) {
    BEGINDRAG = 1157,
    CANCELDRAG = 1160,
    DRAGGING = 1158,
    DROPPED = 1159,
};
pub const DL_BEGINDRAG = DRAGLISTINFO_NOTIFICATION_FLAGS.BEGINDRAG;
pub const DL_CANCELDRAG = DRAGLISTINFO_NOTIFICATION_FLAGS.CANCELDRAG;
pub const DL_DRAGGING = DRAGLISTINFO_NOTIFICATION_FLAGS.DRAGGING;
pub const DL_DROPPED = DRAGLISTINFO_NOTIFICATION_FLAGS.DROPPED;

pub const TEXT_ALIGN_OPTIONS = enum(u32) {
    TA_NOUPDATECP = 0,
    TA_UPDATECP = 1,
    // TA_LEFT = 0, this enum value conflicts with TA_NOUPDATECP
    TA_RIGHT = 2,
    TA_CENTER = 6,
    // TA_TOP = 0, this enum value conflicts with TA_NOUPDATECP
    TA_BOTTOM = 8,
    TA_BASELINE = 24,
    TA_RTLREADING = 256,
    TA_MASK = 287,
    // VTA_BASELINE = 24, this enum value conflicts with TA_BASELINE
    // VTA_LEFT = 8, this enum value conflicts with TA_BOTTOM
    // VTA_RIGHT = 0, this enum value conflicts with TA_NOUPDATECP
    // VTA_CENTER = 6, this enum value conflicts with TA_CENTER
    // VTA_BOTTOM = 2, this enum value conflicts with TA_RIGHT
    // VTA_TOP = 0, this enum value conflicts with TA_NOUPDATECP
};
pub const TA_NOUPDATECP = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;
pub const TA_UPDATECP = TEXT_ALIGN_OPTIONS.TA_UPDATECP;
pub const TA_LEFT = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;
pub const TA_RIGHT = TEXT_ALIGN_OPTIONS.TA_RIGHT;
pub const TA_CENTER = TEXT_ALIGN_OPTIONS.TA_CENTER;
pub const TA_TOP = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;
pub const TA_BOTTOM = TEXT_ALIGN_OPTIONS.TA_BOTTOM;
pub const TA_BASELINE = TEXT_ALIGN_OPTIONS.TA_BASELINE;
pub const TA_RTLREADING = TEXT_ALIGN_OPTIONS.TA_RTLREADING;
pub const TA_MASK = TEXT_ALIGN_OPTIONS.TA_MASK;
pub const VTA_BASELINE = TEXT_ALIGN_OPTIONS.TA_BASELINE;
pub const VTA_LEFT = TEXT_ALIGN_OPTIONS.TA_BOTTOM;
pub const VTA_RIGHT = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;
pub const VTA_CENTER = TEXT_ALIGN_OPTIONS.TA_CENTER;
pub const VTA_BOTTOM = TEXT_ALIGN_OPTIONS.TA_RIGHT;
pub const VTA_TOP = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;

pub const SCROLLBAR_CONSTANTS = enum(u32) {
    CTL = 2,
    HORZ = 0,
    VERT = 1,
    BOTH = 3,
    _,
    pub fn initFlags(o: struct {
        CTL: u1 = 0,
        HORZ: u1 = 0,
        VERT: u1 = 0,
        BOTH: u1 = 0,
    }) SCROLLBAR_CONSTANTS {
        return @intToEnum(SCROLLBAR_CONSTANTS,
              (if (o.CTL == 1) @enumToInt(SCROLLBAR_CONSTANTS.CTL) else 0)
            | (if (o.HORZ == 1) @enumToInt(SCROLLBAR_CONSTANTS.HORZ) else 0)
            | (if (o.VERT == 1) @enumToInt(SCROLLBAR_CONSTANTS.VERT) else 0)
            | (if (o.BOTH == 1) @enumToInt(SCROLLBAR_CONSTANTS.BOTH) else 0)
        );
    }
};
pub const SB_CTL = SCROLLBAR_CONSTANTS.CTL;
pub const SB_HORZ = SCROLLBAR_CONSTANTS.HORZ;
pub const SB_VERT = SCROLLBAR_CONSTANTS.VERT;
pub const SB_BOTH = SCROLLBAR_CONSTANTS.BOTH;

pub const WORD_BREAK_ACTION = enum(u32) {
    CLASSIFY = 3,
    ISDELIMITER = 2,
    LEFT = 0,
    LEFTBREAK = 6,
    MOVEWORDLEFT = 4,
    MOVEWORDRIGHT = 5,
    RIGHT = 1,
    RIGHTBREAK = 7,
};
pub const WB_CLASSIFY = WORD_BREAK_ACTION.CLASSIFY;
pub const WB_ISDELIMITER = WORD_BREAK_ACTION.ISDELIMITER;
pub const WB_LEFT = WORD_BREAK_ACTION.LEFT;
pub const WB_LEFTBREAK = WORD_BREAK_ACTION.LEFTBREAK;
pub const WB_MOVEWORDLEFT = WORD_BREAK_ACTION.MOVEWORDLEFT;
pub const WB_MOVEWORDRIGHT = WORD_BREAK_ACTION.MOVEWORDRIGHT;
pub const WB_RIGHT = WORD_BREAK_ACTION.RIGHT;
pub const WB_RIGHTBREAK = WORD_BREAK_ACTION.RIGHTBREAK;

pub const DPAMM_MESSAGE = enum(u32) {
    MERGE = 1,
    DELETE = 2,
    INSERT = 3,
};
pub const DPAMM_MERGE = DPAMM_MESSAGE.MERGE;
pub const DPAMM_DELETE = DPAMM_MESSAGE.DELETE;
pub const DPAMM_INSERT = DPAMM_MESSAGE.INSERT;

pub const IMAGE_FLAGS = enum(u32) {
    CREATEDIBSECTION = 8192,
    DEFAULTCOLOR = 0,
    DEFAULTSIZE = 64,
    LOADFROMFILE = 16,
    LOADMAP3DCOLORS = 4096,
    LOADTRANSPARENT = 32,
    MONOCHROME = 1,
    SHARED = 32768,
    VGACOLOR = 128,
    COPYDELETEORG = 8,
    COPYFROMRESOURCE = 16384,
    COPYRETURNORG = 4,
    _,
    pub fn initFlags(o: struct {
        CREATEDIBSECTION: u1 = 0,
        DEFAULTCOLOR: u1 = 0,
        DEFAULTSIZE: u1 = 0,
        LOADFROMFILE: u1 = 0,
        LOADMAP3DCOLORS: u1 = 0,
        LOADTRANSPARENT: u1 = 0,
        MONOCHROME: u1 = 0,
        SHARED: u1 = 0,
        VGACOLOR: u1 = 0,
        COPYDELETEORG: u1 = 0,
        COPYFROMRESOURCE: u1 = 0,
        COPYRETURNORG: u1 = 0,
    }) IMAGE_FLAGS {
        return @intToEnum(IMAGE_FLAGS,
              (if (o.CREATEDIBSECTION == 1) @enumToInt(IMAGE_FLAGS.CREATEDIBSECTION) else 0)
            | (if (o.DEFAULTCOLOR == 1) @enumToInt(IMAGE_FLAGS.DEFAULTCOLOR) else 0)
            | (if (o.DEFAULTSIZE == 1) @enumToInt(IMAGE_FLAGS.DEFAULTSIZE) else 0)
            | (if (o.LOADFROMFILE == 1) @enumToInt(IMAGE_FLAGS.LOADFROMFILE) else 0)
            | (if (o.LOADMAP3DCOLORS == 1) @enumToInt(IMAGE_FLAGS.LOADMAP3DCOLORS) else 0)
            | (if (o.LOADTRANSPARENT == 1) @enumToInt(IMAGE_FLAGS.LOADTRANSPARENT) else 0)
            | (if (o.MONOCHROME == 1) @enumToInt(IMAGE_FLAGS.MONOCHROME) else 0)
            | (if (o.SHARED == 1) @enumToInt(IMAGE_FLAGS.SHARED) else 0)
            | (if (o.VGACOLOR == 1) @enumToInt(IMAGE_FLAGS.VGACOLOR) else 0)
            | (if (o.COPYDELETEORG == 1) @enumToInt(IMAGE_FLAGS.COPYDELETEORG) else 0)
            | (if (o.COPYFROMRESOURCE == 1) @enumToInt(IMAGE_FLAGS.COPYFROMRESOURCE) else 0)
            | (if (o.COPYRETURNORG == 1) @enumToInt(IMAGE_FLAGS.COPYRETURNORG) else 0)
        );
    }
};
pub const LR_CREATEDIBSECTION = IMAGE_FLAGS.CREATEDIBSECTION;
pub const LR_DEFAULTCOLOR = IMAGE_FLAGS.DEFAULTCOLOR;
pub const LR_DEFAULTSIZE = IMAGE_FLAGS.DEFAULTSIZE;
pub const LR_LOADFROMFILE = IMAGE_FLAGS.LOADFROMFILE;
pub const LR_LOADMAP3DCOLORS = IMAGE_FLAGS.LOADMAP3DCOLORS;
pub const LR_LOADTRANSPARENT = IMAGE_FLAGS.LOADTRANSPARENT;
pub const LR_MONOCHROME = IMAGE_FLAGS.MONOCHROME;
pub const LR_SHARED = IMAGE_FLAGS.SHARED;
pub const LR_VGACOLOR = IMAGE_FLAGS.VGACOLOR;
pub const LR_COPYDELETEORG = IMAGE_FLAGS.COPYDELETEORG;
pub const LR_COPYFROMRESOURCE = IMAGE_FLAGS.COPYFROMRESOURCE;
pub const LR_COPYRETURNORG = IMAGE_FLAGS.COPYRETURNORG;

pub const DLG_DIR_LIST_FILE_TYPE = enum(u32) {
    ARCHIVE = 32,
    DIRECTORY = 16,
    DRIVES = 16384,
    EXCLUSIVE = 32768,
    HIDDEN = 2,
    READONLY = 1,
    READWRITE = 0,
    SYSTEM = 4,
    POSTMSGS = 8192,
    _,
    pub fn initFlags(o: struct {
        ARCHIVE: u1 = 0,
        DIRECTORY: u1 = 0,
        DRIVES: u1 = 0,
        EXCLUSIVE: u1 = 0,
        HIDDEN: u1 = 0,
        READONLY: u1 = 0,
        READWRITE: u1 = 0,
        SYSTEM: u1 = 0,
        POSTMSGS: u1 = 0,
    }) DLG_DIR_LIST_FILE_TYPE {
        return @intToEnum(DLG_DIR_LIST_FILE_TYPE,
              (if (o.ARCHIVE == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.ARCHIVE) else 0)
            | (if (o.DIRECTORY == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.DIRECTORY) else 0)
            | (if (o.DRIVES == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.DRIVES) else 0)
            | (if (o.EXCLUSIVE == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.EXCLUSIVE) else 0)
            | (if (o.HIDDEN == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.HIDDEN) else 0)
            | (if (o.READONLY == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.READONLY) else 0)
            | (if (o.READWRITE == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.READWRITE) else 0)
            | (if (o.SYSTEM == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.SYSTEM) else 0)
            | (if (o.POSTMSGS == 1) @enumToInt(DLG_DIR_LIST_FILE_TYPE.POSTMSGS) else 0)
        );
    }
};
pub const DDL_ARCHIVE = DLG_DIR_LIST_FILE_TYPE.ARCHIVE;
pub const DDL_DIRECTORY = DLG_DIR_LIST_FILE_TYPE.DIRECTORY;
pub const DDL_DRIVES = DLG_DIR_LIST_FILE_TYPE.DRIVES;
pub const DDL_EXCLUSIVE = DLG_DIR_LIST_FILE_TYPE.EXCLUSIVE;
pub const DDL_HIDDEN = DLG_DIR_LIST_FILE_TYPE.HIDDEN;
pub const DDL_READONLY = DLG_DIR_LIST_FILE_TYPE.READONLY;
pub const DDL_READWRITE = DLG_DIR_LIST_FILE_TYPE.READWRITE;
pub const DDL_SYSTEM = DLG_DIR_LIST_FILE_TYPE.SYSTEM;
pub const DDL_POSTMSGS = DLG_DIR_LIST_FILE_TYPE.POSTMSGS;

pub const OPEN_THEME_DATA_FLAGS = enum(u32) {
    FORCE_RECT_SIZING = 1,
    NONCLIENT = 2,
    _,
    pub fn initFlags(o: struct {
        FORCE_RECT_SIZING: u1 = 0,
        NONCLIENT: u1 = 0,
    }) OPEN_THEME_DATA_FLAGS {
        return @intToEnum(OPEN_THEME_DATA_FLAGS,
              (if (o.FORCE_RECT_SIZING == 1) @enumToInt(OPEN_THEME_DATA_FLAGS.FORCE_RECT_SIZING) else 0)
            | (if (o.NONCLIENT == 1) @enumToInt(OPEN_THEME_DATA_FLAGS.NONCLIENT) else 0)
        );
    }
};
pub const OTD_FORCE_RECT_SIZING = OPEN_THEME_DATA_FLAGS.FORCE_RECT_SIZING;
pub const OTD_NONCLIENT = OPEN_THEME_DATA_FLAGS.NONCLIENT;

pub const GET_THEME_BITMAP_FLAGS = enum(u32) {
    DIRECT = 1,
    COPY = 2,
    VALIDBITS = 3,
};
pub const GBF_DIRECT = GET_THEME_BITMAP_FLAGS.DIRECT;
pub const GBF_COPY = GET_THEME_BITMAP_FLAGS.COPY;
pub const GBF_VALIDBITS = GET_THEME_BITMAP_FLAGS.VALIDBITS;

pub const ENABLE_SCROLL_BAR_ARROWS = enum(u32) {
    DISABLE_BOTH = 3,
    DISABLE_DOWN = 2,
    DISABLE_LEFT = 1,
    // DISABLE_LTUP = 1, this enum value conflicts with DISABLE_LEFT
    // DISABLE_RIGHT = 2, this enum value conflicts with DISABLE_DOWN
    // DISABLE_RTDN = 2, this enum value conflicts with DISABLE_DOWN
    // DISABLE_UP = 1, this enum value conflicts with DISABLE_LEFT
    ENABLE_BOTH = 0,
};
pub const ESB_DISABLE_BOTH = ENABLE_SCROLL_BAR_ARROWS.DISABLE_BOTH;
pub const ESB_DISABLE_DOWN = ENABLE_SCROLL_BAR_ARROWS.DISABLE_DOWN;
pub const ESB_DISABLE_LEFT = ENABLE_SCROLL_BAR_ARROWS.DISABLE_LEFT;
pub const ESB_DISABLE_LTUP = ENABLE_SCROLL_BAR_ARROWS.DISABLE_LEFT;
pub const ESB_DISABLE_RIGHT = ENABLE_SCROLL_BAR_ARROWS.DISABLE_DOWN;
pub const ESB_DISABLE_RTDN = ENABLE_SCROLL_BAR_ARROWS.DISABLE_DOWN;
pub const ESB_DISABLE_UP = ENABLE_SCROLL_BAR_ARROWS.DISABLE_LEFT;
pub const ESB_ENABLE_BOTH = ENABLE_SCROLL_BAR_ARROWS.ENABLE_BOTH;

pub const IMAGE_LIST_DRAW_STYLE = enum(u32) {
    BLEND = 4,
    // BLEND50 = 4, this enum value conflicts with BLEND
    FOCUS = 2,
    MASK = 16,
    NORMAL = 0,
    // SELECTED = 4, this enum value conflicts with BLEND
    _,
    pub fn initFlags(o: struct {
        BLEND: u1 = 0,
        FOCUS: u1 = 0,
        MASK: u1 = 0,
        NORMAL: u1 = 0,
    }) IMAGE_LIST_DRAW_STYLE {
        return @intToEnum(IMAGE_LIST_DRAW_STYLE,
              (if (o.BLEND == 1) @enumToInt(IMAGE_LIST_DRAW_STYLE.BLEND) else 0)
            | (if (o.FOCUS == 1) @enumToInt(IMAGE_LIST_DRAW_STYLE.FOCUS) else 0)
            | (if (o.MASK == 1) @enumToInt(IMAGE_LIST_DRAW_STYLE.MASK) else 0)
            | (if (o.NORMAL == 1) @enumToInt(IMAGE_LIST_DRAW_STYLE.NORMAL) else 0)
        );
    }
};
pub const ILD_BLEND = IMAGE_LIST_DRAW_STYLE.BLEND;
pub const ILD_BLEND50 = IMAGE_LIST_DRAW_STYLE.BLEND;
pub const ILD_FOCUS = IMAGE_LIST_DRAW_STYLE.FOCUS;
pub const ILD_MASK = IMAGE_LIST_DRAW_STYLE.MASK;
pub const ILD_NORMAL = IMAGE_LIST_DRAW_STYLE.NORMAL;
pub const ILD_SELECTED = IMAGE_LIST_DRAW_STYLE.BLEND;

pub const WSB_PROP = enum(i32) {
    CXHSCROLL = 2,
    CXHTHUMB = 16,
    CXVSCROLL = 8,
    CYHSCROLL = 4,
    CYVSCROLL = 1,
    CYVTHUMB = 32,
    HBKGCOLOR = 128,
    HSTYLE = 512,
    PALETTE = 2048,
    VBKGCOLOR = 64,
    VSTYLE = 256,
    WINSTYLE = 1024,
};
pub const WSB_PROP_CXHSCROLL = WSB_PROP.CXHSCROLL;
pub const WSB_PROP_CXHTHUMB = WSB_PROP.CXHTHUMB;
pub const WSB_PROP_CXVSCROLL = WSB_PROP.CXVSCROLL;
pub const WSB_PROP_CYHSCROLL = WSB_PROP.CYHSCROLL;
pub const WSB_PROP_CYVSCROLL = WSB_PROP.CYVSCROLL;
pub const WSB_PROP_CYVTHUMB = WSB_PROP.CYVTHUMB;
pub const WSB_PROP_HBKGCOLOR = WSB_PROP.HBKGCOLOR;
pub const WSB_PROP_HSTYLE = WSB_PROP.HSTYLE;
pub const WSB_PROP_PALETTE = WSB_PROP.PALETTE;
pub const WSB_PROP_VBKGCOLOR = WSB_PROP.VBKGCOLOR;
pub const WSB_PROP_VSTYLE = WSB_PROP.VSTYLE;
pub const WSB_PROP_WINSTYLE = WSB_PROP.WINSTYLE;

pub const PSPCB_MESSAGE = enum(u32) {
    ADDREF = 0,
    CREATE = 2,
    RELEASE = 1,
    SI_INITDIALOG = 1025,
};
pub const PSPCB_ADDREF = PSPCB_MESSAGE.ADDREF;
pub const PSPCB_CREATE = PSPCB_MESSAGE.CREATE;
pub const PSPCB_RELEASE = PSPCB_MESSAGE.RELEASE;
pub const PSPCB_SI_INITDIALOG = PSPCB_MESSAGE.SI_INITDIALOG;

pub const HEADER_CONTROL_NOTIFICATION_BUTTON = enum(u32) {
    LEFT = 0,
    RIGHT = 1,
    MIDDLE = 2,
};
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_LEFT = HEADER_CONTROL_NOTIFICATION_BUTTON.LEFT;
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_RIGHT = HEADER_CONTROL_NOTIFICATION_BUTTON.RIGHT;
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_MIDDLE = HEADER_CONTROL_NOTIFICATION_BUTTON.MIDDLE;

pub const IMAGE_LIST_COPY_FLAGS = enum(u32) {
    MOVE = 0,
    SWAP = 1,
};
pub const ILCF_MOVE = IMAGE_LIST_COPY_FLAGS.MOVE;
pub const ILCF_SWAP = IMAGE_LIST_COPY_FLAGS.SWAP;

pub const DLG_BUTTON_CHECK_STATE = enum(u32) {
    CHECKED = 1,
    INDETERMINATE = 2,
    UNCHECKED = 0,
};
pub const BST_CHECKED = DLG_BUTTON_CHECK_STATE.CHECKED;
pub const BST_INDETERMINATE = DLG_BUTTON_CHECK_STATE.INDETERMINATE;
pub const BST_UNCHECKED = DLG_BUTTON_CHECK_STATE.UNCHECKED;

pub const DRAW_THEME_PARENT_BACKGROUND_FLAGS = enum(u32) {
    WINDOWDC = 1,
    USECTLCOLORSTATIC = 2,
    USEERASEBKGND = 4,
    _,
    pub fn initFlags(o: struct {
        WINDOWDC: u1 = 0,
        USECTLCOLORSTATIC: u1 = 0,
        USEERASEBKGND: u1 = 0,
    }) DRAW_THEME_PARENT_BACKGROUND_FLAGS {
        return @intToEnum(DRAW_THEME_PARENT_BACKGROUND_FLAGS,
              (if (o.WINDOWDC == 1) @enumToInt(DRAW_THEME_PARENT_BACKGROUND_FLAGS.WINDOWDC) else 0)
            | (if (o.USECTLCOLORSTATIC == 1) @enumToInt(DRAW_THEME_PARENT_BACKGROUND_FLAGS.USECTLCOLORSTATIC) else 0)
            | (if (o.USEERASEBKGND == 1) @enumToInt(DRAW_THEME_PARENT_BACKGROUND_FLAGS.USEERASEBKGND) else 0)
        );
    }
};
pub const DTPB_WINDOWDC = DRAW_THEME_PARENT_BACKGROUND_FLAGS.WINDOWDC;
pub const DTPB_USECTLCOLORSTATIC = DRAW_THEME_PARENT_BACKGROUND_FLAGS.USECTLCOLORSTATIC;
pub const DTPB_USEERASEBKGND = DRAW_THEME_PARENT_BACKGROUND_FLAGS.USEERASEBKGND;

pub const RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE = enum(u16) {
    SEL_EMPTY = 0,
    SEL_TEXT = 1,
    SEL_OBJECT = 2,
    SEL_MULTICHAR = 4,
    SEL_MULTIOBJECT = 8,
    GCM_RIGHTMOUSEDROP = 32768,
    _,
    pub fn initFlags(o: struct {
        SEL_EMPTY: u1 = 0,
        SEL_TEXT: u1 = 0,
        SEL_OBJECT: u1 = 0,
        SEL_MULTICHAR: u1 = 0,
        SEL_MULTIOBJECT: u1 = 0,
        GCM_RIGHTMOUSEDROP: u1 = 0,
    }) RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE {
        return @intToEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
              (if (o.SEL_EMPTY == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY) else 0)
            | (if (o.SEL_TEXT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT) else 0)
            | (if (o.SEL_OBJECT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT) else 0)
            | (if (o.SEL_MULTICHAR == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR) else 0)
            | (if (o.SEL_MULTIOBJECT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT) else 0)
            | (if (o.GCM_RIGHTMOUSEDROP == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP) else 0)
        );
    }
};
pub const SEL_EMPTY = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY;
pub const SEL_TEXT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT;
pub const SEL_OBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT;
pub const SEL_MULTICHAR = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR;
pub const SEL_MULTIOBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT;
pub const GCM_RIGHTMOUSEDROP = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP;

pub const IMAGE_LIST_ITEM_FLAGS = enum(u32) {
    ALPHA = 1,
    LOWQUALITY = 2,
};
pub const ILIF_ALPHA = IMAGE_LIST_ITEM_FLAGS.ALPHA;
pub const ILIF_LOWQUALITY = IMAGE_LIST_ITEM_FLAGS.LOWQUALITY;

pub const RICH_EDIT_GET_OBJECT_FLAGS = enum(u32) {
    POLEOBJ = 1,
    PSTG = 2,
    POLESITE = 4,
    NO_INTERFACES = 0,
    ALL_INTERFACES = 7,
    _,
    pub fn initFlags(o: struct {
        POLEOBJ: u1 = 0,
        PSTG: u1 = 0,
        POLESITE: u1 = 0,
        NO_INTERFACES: u1 = 0,
        ALL_INTERFACES: u1 = 0,
    }) RICH_EDIT_GET_OBJECT_FLAGS {
        return @intToEnum(RICH_EDIT_GET_OBJECT_FLAGS,
              (if (o.POLEOBJ == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ) else 0)
            | (if (o.PSTG == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.PSTG) else 0)
            | (if (o.POLESITE == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.POLESITE) else 0)
            | (if (o.NO_INTERFACES == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES) else 0)
            | (if (o.ALL_INTERFACES == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES) else 0)
        );
    }
};
pub const REO_GETOBJ_POLEOBJ = RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ;
pub const REO_GETOBJ_PSTG = RICH_EDIT_GET_OBJECT_FLAGS.PSTG;
pub const REO_GETOBJ_POLESITE = RICH_EDIT_GET_OBJECT_FLAGS.POLESITE;
pub const REO_GETOBJ_NO_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES;
pub const REO_GETOBJ_ALL_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES;

pub const HDI_MASK = enum(u32) {
    WIDTH = 1,
    // HEIGHT = 1, this enum value conflicts with WIDTH
    TEXT = 2,
    FORMAT = 4,
    LPARAM = 8,
    BITMAP = 16,
    IMAGE = 32,
    DI_SETITEM = 64,
    ORDER = 128,
    FILTER = 256,
    STATE = 512,
    _,
    pub fn initFlags(o: struct {
        WIDTH: u1 = 0,
        TEXT: u1 = 0,
        FORMAT: u1 = 0,
        LPARAM: u1 = 0,
        BITMAP: u1 = 0,
        IMAGE: u1 = 0,
        DI_SETITEM: u1 = 0,
        ORDER: u1 = 0,
        FILTER: u1 = 0,
        STATE: u1 = 0,
    }) HDI_MASK {
        return @intToEnum(HDI_MASK,
              (if (o.WIDTH == 1) @enumToInt(HDI_MASK.WIDTH) else 0)
            | (if (o.TEXT == 1) @enumToInt(HDI_MASK.TEXT) else 0)
            | (if (o.FORMAT == 1) @enumToInt(HDI_MASK.FORMAT) else 0)
            | (if (o.LPARAM == 1) @enumToInt(HDI_MASK.LPARAM) else 0)
            | (if (o.BITMAP == 1) @enumToInt(HDI_MASK.BITMAP) else 0)
            | (if (o.IMAGE == 1) @enumToInt(HDI_MASK.IMAGE) else 0)
            | (if (o.DI_SETITEM == 1) @enumToInt(HDI_MASK.DI_SETITEM) else 0)
            | (if (o.ORDER == 1) @enumToInt(HDI_MASK.ORDER) else 0)
            | (if (o.FILTER == 1) @enumToInt(HDI_MASK.FILTER) else 0)
            | (if (o.STATE == 1) @enumToInt(HDI_MASK.STATE) else 0)
        );
    }
};
pub const HDI_WIDTH = HDI_MASK.WIDTH;
pub const HDI_HEIGHT = HDI_MASK.WIDTH;
pub const HDI_TEXT = HDI_MASK.TEXT;
pub const HDI_FORMAT = HDI_MASK.FORMAT;
pub const HDI_LPARAM = HDI_MASK.LPARAM;
pub const HDI_BITMAP = HDI_MASK.BITMAP;
pub const HDI_IMAGE = HDI_MASK.IMAGE;
pub const HDI_DI_SETITEM = HDI_MASK.DI_SETITEM;
pub const HDI_ORDER = HDI_MASK.ORDER;
pub const HDI_FILTER = HDI_MASK.FILTER;
pub const HDI_STATE = HDI_MASK.STATE;

pub const NMREBAR_MASK_FLAGS = enum(u32) {
    ID = 1,
    LPARAM = 4,
    STYLE = 2,
    _,
    pub fn initFlags(o: struct {
        ID: u1 = 0,
        LPARAM: u1 = 0,
        STYLE: u1 = 0,
    }) NMREBAR_MASK_FLAGS {
        return @intToEnum(NMREBAR_MASK_FLAGS,
              (if (o.ID == 1) @enumToInt(NMREBAR_MASK_FLAGS.ID) else 0)
            | (if (o.LPARAM == 1) @enumToInt(NMREBAR_MASK_FLAGS.LPARAM) else 0)
            | (if (o.STYLE == 1) @enumToInt(NMREBAR_MASK_FLAGS.STYLE) else 0)
        );
    }
};
pub const RBNM_ID = NMREBAR_MASK_FLAGS.ID;
pub const RBNM_LPARAM = NMREBAR_MASK_FLAGS.LPARAM;
pub const RBNM_STYLE = NMREBAR_MASK_FLAGS.STYLE;

pub const EDITBALLOONTIP_ICON = enum(u32) {
    ERROR = 3,
    INFO = 1,
    NONE = 0,
    WARNING = 2,
    INFO_LARGE = 4,
    WARNING_LARGE = 5,
    ERROR_LARGE = 6,
};
pub const TTI_ERROR = EDITBALLOONTIP_ICON.ERROR;
pub const TTI_INFO = EDITBALLOONTIP_ICON.INFO;
pub const TTI_NONE = EDITBALLOONTIP_ICON.NONE;
pub const TTI_WARNING = EDITBALLOONTIP_ICON.WARNING;
pub const TTI_INFO_LARGE = EDITBALLOONTIP_ICON.INFO_LARGE;
pub const TTI_WARNING_LARGE = EDITBALLOONTIP_ICON.WARNING_LARGE;
pub const TTI_ERROR_LARGE = EDITBALLOONTIP_ICON.ERROR_LARGE;

pub const LVCOLUMNW_FORMAT = enum(u32) {
    LEFT = 0,
    RIGHT = 1,
    CENTER = 2,
    JUSTIFYMASK = 3,
    IMAGE = 2048,
    BITMAP_ON_RIGHT = 4096,
    COL_HAS_IMAGES = 32768,
    FIXED_WIDTH = 256,
    NO_DPI_SCALE = 262144,
    FIXED_RATIO = 524288,
    SPLITBUTTON = 16777216,
    _,
    pub fn initFlags(o: struct {
        LEFT: u1 = 0,
        RIGHT: u1 = 0,
        CENTER: u1 = 0,
        JUSTIFYMASK: u1 = 0,
        IMAGE: u1 = 0,
        BITMAP_ON_RIGHT: u1 = 0,
        COL_HAS_IMAGES: u1 = 0,
        FIXED_WIDTH: u1 = 0,
        NO_DPI_SCALE: u1 = 0,
        FIXED_RATIO: u1 = 0,
        SPLITBUTTON: u1 = 0,
    }) LVCOLUMNW_FORMAT {
        return @intToEnum(LVCOLUMNW_FORMAT,
              (if (o.LEFT == 1) @enumToInt(LVCOLUMNW_FORMAT.LEFT) else 0)
            | (if (o.RIGHT == 1) @enumToInt(LVCOLUMNW_FORMAT.RIGHT) else 0)
            | (if (o.CENTER == 1) @enumToInt(LVCOLUMNW_FORMAT.CENTER) else 0)
            | (if (o.JUSTIFYMASK == 1) @enumToInt(LVCOLUMNW_FORMAT.JUSTIFYMASK) else 0)
            | (if (o.IMAGE == 1) @enumToInt(LVCOLUMNW_FORMAT.IMAGE) else 0)
            | (if (o.BITMAP_ON_RIGHT == 1) @enumToInt(LVCOLUMNW_FORMAT.BITMAP_ON_RIGHT) else 0)
            | (if (o.COL_HAS_IMAGES == 1) @enumToInt(LVCOLUMNW_FORMAT.COL_HAS_IMAGES) else 0)
            | (if (o.FIXED_WIDTH == 1) @enumToInt(LVCOLUMNW_FORMAT.FIXED_WIDTH) else 0)
            | (if (o.NO_DPI_SCALE == 1) @enumToInt(LVCOLUMNW_FORMAT.NO_DPI_SCALE) else 0)
            | (if (o.FIXED_RATIO == 1) @enumToInt(LVCOLUMNW_FORMAT.FIXED_RATIO) else 0)
            | (if (o.SPLITBUTTON == 1) @enumToInt(LVCOLUMNW_FORMAT.SPLITBUTTON) else 0)
        );
    }
};
pub const LVCFMT_LEFT = LVCOLUMNW_FORMAT.LEFT;
pub const LVCFMT_RIGHT = LVCOLUMNW_FORMAT.RIGHT;
pub const LVCFMT_CENTER = LVCOLUMNW_FORMAT.CENTER;
pub const LVCFMT_JUSTIFYMASK = LVCOLUMNW_FORMAT.JUSTIFYMASK;
pub const LVCFMT_IMAGE = LVCOLUMNW_FORMAT.IMAGE;
pub const LVCFMT_BITMAP_ON_RIGHT = LVCOLUMNW_FORMAT.BITMAP_ON_RIGHT;
pub const LVCFMT_COL_HAS_IMAGES = LVCOLUMNW_FORMAT.COL_HAS_IMAGES;
pub const LVCFMT_FIXED_WIDTH = LVCOLUMNW_FORMAT.FIXED_WIDTH;
pub const LVCFMT_NO_DPI_SCALE = LVCOLUMNW_FORMAT.NO_DPI_SCALE;
pub const LVCFMT_FIXED_RATIO = LVCOLUMNW_FORMAT.FIXED_RATIO;
pub const LVCFMT_SPLITBUTTON = LVCOLUMNW_FORMAT.SPLITBUTTON;

pub const NMPGSCROLL_KEYS = enum(u16) {
    NONE = 0,
    SHIFT = 1,
    CONTROL = 2,
    MENU = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SHIFT: u1 = 0,
        CONTROL: u1 = 0,
        MENU: u1 = 0,
    }) NMPGSCROLL_KEYS {
        return @intToEnum(NMPGSCROLL_KEYS,
              (if (o.NONE == 1) @enumToInt(NMPGSCROLL_KEYS.NONE) else 0)
            | (if (o.SHIFT == 1) @enumToInt(NMPGSCROLL_KEYS.SHIFT) else 0)
            | (if (o.CONTROL == 1) @enumToInt(NMPGSCROLL_KEYS.CONTROL) else 0)
            | (if (o.MENU == 1) @enumToInt(NMPGSCROLL_KEYS.MENU) else 0)
        );
    }
};
pub const PGK_NONE = NMPGSCROLL_KEYS.NONE;
pub const PGK_SHIFT = NMPGSCROLL_KEYS.SHIFT;
pub const PGK_CONTROL = NMPGSCROLL_KEYS.CONTROL;
pub const PGK_MENU = NMPGSCROLL_KEYS.MENU;

pub const COMBOBOX_EX_ITEM_FLAGS = enum(u32) {
    DI_SETITEM = 268435456,
    IMAGE = 2,
    INDENT = 16,
    LPARAM = 32,
    OVERLAY = 8,
    SELECTEDIMAGE = 4,
    TEXT = 1,
    _,
    pub fn initFlags(o: struct {
        DI_SETITEM: u1 = 0,
        IMAGE: u1 = 0,
        INDENT: u1 = 0,
        LPARAM: u1 = 0,
        OVERLAY: u1 = 0,
        SELECTEDIMAGE: u1 = 0,
        TEXT: u1 = 0,
    }) COMBOBOX_EX_ITEM_FLAGS {
        return @intToEnum(COMBOBOX_EX_ITEM_FLAGS,
              (if (o.DI_SETITEM == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.DI_SETITEM) else 0)
            | (if (o.IMAGE == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.IMAGE) else 0)
            | (if (o.INDENT == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.INDENT) else 0)
            | (if (o.LPARAM == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.LPARAM) else 0)
            | (if (o.OVERLAY == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.OVERLAY) else 0)
            | (if (o.SELECTEDIMAGE == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.SELECTEDIMAGE) else 0)
            | (if (o.TEXT == 1) @enumToInt(COMBOBOX_EX_ITEM_FLAGS.TEXT) else 0)
        );
    }
};
pub const CBEIF_DI_SETITEM = COMBOBOX_EX_ITEM_FLAGS.DI_SETITEM;
pub const CBEIF_IMAGE = COMBOBOX_EX_ITEM_FLAGS.IMAGE;
pub const CBEIF_INDENT = COMBOBOX_EX_ITEM_FLAGS.INDENT;
pub const CBEIF_LPARAM = COMBOBOX_EX_ITEM_FLAGS.LPARAM;
pub const CBEIF_OVERLAY = COMBOBOX_EX_ITEM_FLAGS.OVERLAY;
pub const CBEIF_SELECTEDIMAGE = COMBOBOX_EX_ITEM_FLAGS.SELECTEDIMAGE;
pub const CBEIF_TEXT = COMBOBOX_EX_ITEM_FLAGS.TEXT;

pub const TVITEMEXW_CHILDREN = enum(i32) {
    ZERO = 0,
    ONE_OR_MORE = 1,
    CHILDRENCALLBACK = -1,
    CHILDRENAUTO = -2,
};
pub const I_ZERO = TVITEMEXW_CHILDREN.ZERO;
pub const I_ONE_OR_MORE = TVITEMEXW_CHILDREN.ONE_OR_MORE;
pub const I_CHILDRENCALLBACK = TVITEMEXW_CHILDREN.CHILDRENCALLBACK;
pub const I_CHILDRENAUTO = TVITEMEXW_CHILDREN.CHILDRENAUTO;

pub const TVITEM_MASK = enum(u32) {
    CHILDREN = 64,
    DI_SETITEM = 4096,
    HANDLE = 16,
    IMAGE = 2,
    PARAM = 4,
    SELECTEDIMAGE = 32,
    STATE = 8,
    TEXT = 1,
    EXPANDEDIMAGE = 512,
    INTEGRAL = 128,
    STATEEX = 256,
    _,
    pub fn initFlags(o: struct {
        CHILDREN: u1 = 0,
        DI_SETITEM: u1 = 0,
        HANDLE: u1 = 0,
        IMAGE: u1 = 0,
        PARAM: u1 = 0,
        SELECTEDIMAGE: u1 = 0,
        STATE: u1 = 0,
        TEXT: u1 = 0,
        EXPANDEDIMAGE: u1 = 0,
        INTEGRAL: u1 = 0,
        STATEEX: u1 = 0,
    }) TVITEM_MASK {
        return @intToEnum(TVITEM_MASK,
              (if (o.CHILDREN == 1) @enumToInt(TVITEM_MASK.CHILDREN) else 0)
            | (if (o.DI_SETITEM == 1) @enumToInt(TVITEM_MASK.DI_SETITEM) else 0)
            | (if (o.HANDLE == 1) @enumToInt(TVITEM_MASK.HANDLE) else 0)
            | (if (o.IMAGE == 1) @enumToInt(TVITEM_MASK.IMAGE) else 0)
            | (if (o.PARAM == 1) @enumToInt(TVITEM_MASK.PARAM) else 0)
            | (if (o.SELECTEDIMAGE == 1) @enumToInt(TVITEM_MASK.SELECTEDIMAGE) else 0)
            | (if (o.STATE == 1) @enumToInt(TVITEM_MASK.STATE) else 0)
            | (if (o.TEXT == 1) @enumToInt(TVITEM_MASK.TEXT) else 0)
            | (if (o.EXPANDEDIMAGE == 1) @enumToInt(TVITEM_MASK.EXPANDEDIMAGE) else 0)
            | (if (o.INTEGRAL == 1) @enumToInt(TVITEM_MASK.INTEGRAL) else 0)
            | (if (o.STATEEX == 1) @enumToInt(TVITEM_MASK.STATEEX) else 0)
        );
    }
};
pub const TVIF_CHILDREN = TVITEM_MASK.CHILDREN;
pub const TVIF_DI_SETITEM = TVITEM_MASK.DI_SETITEM;
pub const TVIF_HANDLE = TVITEM_MASK.HANDLE;
pub const TVIF_IMAGE = TVITEM_MASK.IMAGE;
pub const TVIF_PARAM = TVITEM_MASK.PARAM;
pub const TVIF_SELECTEDIMAGE = TVITEM_MASK.SELECTEDIMAGE;
pub const TVIF_STATE = TVITEM_MASK.STATE;
pub const TVIF_TEXT = TVITEM_MASK.TEXT;
pub const TVIF_EXPANDEDIMAGE = TVITEM_MASK.EXPANDEDIMAGE;
pub const TVIF_INTEGRAL = TVITEM_MASK.INTEGRAL;
pub const TVIF_STATEEX = TVITEM_MASK.STATEEX;

pub const TCITEMHEADERA_MASK = enum(u32) {
    IMAGE = 2,
    RTLREADING = 4,
    TEXT = 1,
    PARAM = 8,
    STATE = 16,
    _,
    pub fn initFlags(o: struct {
        IMAGE: u1 = 0,
        RTLREADING: u1 = 0,
        TEXT: u1 = 0,
        PARAM: u1 = 0,
        STATE: u1 = 0,
    }) TCITEMHEADERA_MASK {
        return @intToEnum(TCITEMHEADERA_MASK,
              (if (o.IMAGE == 1) @enumToInt(TCITEMHEADERA_MASK.IMAGE) else 0)
            | (if (o.RTLREADING == 1) @enumToInt(TCITEMHEADERA_MASK.RTLREADING) else 0)
            | (if (o.TEXT == 1) @enumToInt(TCITEMHEADERA_MASK.TEXT) else 0)
            | (if (o.PARAM == 1) @enumToInt(TCITEMHEADERA_MASK.PARAM) else 0)
            | (if (o.STATE == 1) @enumToInt(TCITEMHEADERA_MASK.STATE) else 0)
        );
    }
};
pub const TCIF_IMAGE = TCITEMHEADERA_MASK.IMAGE;
pub const TCIF_RTLREADING = TCITEMHEADERA_MASK.RTLREADING;
pub const TCIF_TEXT = TCITEMHEADERA_MASK.TEXT;
pub const TCIF_PARAM = TCITEMHEADERA_MASK.PARAM;
pub const TCIF_STATE = TCITEMHEADERA_MASK.STATE;

pub const TCHITTESTINFO_FLAGS = enum(u32) {
    NOWHERE = 1,
    ONITEM = 6,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
};
pub const TCHT_NOWHERE = TCHITTESTINFO_FLAGS.NOWHERE;
pub const TCHT_ONITEM = TCHITTESTINFO_FLAGS.ONITEM;
pub const TCHT_ONITEMICON = TCHITTESTINFO_FLAGS.ONITEMICON;
pub const TCHT_ONITEMLABEL = TCHITTESTINFO_FLAGS.ONITEMLABEL;

pub const COMBOBOXINFO_BUTTON_STATE = enum(u32) {
    INVISIBLE = 32768,
    PRESSED = 8,
    FOCUSABLE = 1048576,
    OFFSCREEN = 65536,
    UNAVAILABLE = 1,
};
pub const STATE_SYSTEM_INVISIBLE = COMBOBOXINFO_BUTTON_STATE.INVISIBLE;
pub const STATE_SYSTEM_PRESSED = COMBOBOXINFO_BUTTON_STATE.PRESSED;
pub const STATE_SYSTEM_FOCUSABLE = COMBOBOXINFO_BUTTON_STATE.FOCUSABLE;
pub const STATE_SYSTEM_OFFSCREEN = COMBOBOXINFO_BUTTON_STATE.OFFSCREEN;
pub const STATE_SYSTEM_UNAVAILABLE = COMBOBOXINFO_BUTTON_STATE.UNAVAILABLE;

pub const NMCUSTOMDRAW_DRAW_STAGE = enum(u32) {
    POSTPAINT = 2,
    PREERASE = 3,
    PREPAINT = 1,
    ITEMPOSTERASE = 65540,
    ITEMPOSTPAINT = 65538,
    ITEMPREERASE = 65539,
    ITEMPREPAINT = 65537,
    SUBITEM = 131072,
};
pub const CDDS_POSTPAINT = NMCUSTOMDRAW_DRAW_STAGE.POSTPAINT;
pub const CDDS_PREERASE = NMCUSTOMDRAW_DRAW_STAGE.PREERASE;
pub const CDDS_PREPAINT = NMCUSTOMDRAW_DRAW_STAGE.PREPAINT;
pub const CDDS_ITEMPOSTERASE = NMCUSTOMDRAW_DRAW_STAGE.ITEMPOSTERASE;
pub const CDDS_ITEMPOSTPAINT = NMCUSTOMDRAW_DRAW_STAGE.ITEMPOSTPAINT;
pub const CDDS_ITEMPREERASE = NMCUSTOMDRAW_DRAW_STAGE.ITEMPREERASE;
pub const CDDS_ITEMPREPAINT = NMCUSTOMDRAW_DRAW_STAGE.ITEMPREPAINT;
pub const CDDS_SUBITEM = NMCUSTOMDRAW_DRAW_STAGE.SUBITEM;

pub const MCGRIDINFO_PART = enum(u32) {
    CALENDARCONTROL = 0,
    NEXT = 1,
    PREV = 2,
    FOOTER = 3,
    CALENDAR = 4,
    CALENDARHEADER = 5,
    CALENDARBODY = 6,
    CALENDARROW = 7,
    CALENDARCELL = 8,
};
pub const MCGIP_CALENDARCONTROL = MCGRIDINFO_PART.CALENDARCONTROL;
pub const MCGIP_NEXT = MCGRIDINFO_PART.NEXT;
pub const MCGIP_PREV = MCGRIDINFO_PART.PREV;
pub const MCGIP_FOOTER = MCGRIDINFO_PART.FOOTER;
pub const MCGIP_CALENDAR = MCGRIDINFO_PART.CALENDAR;
pub const MCGIP_CALENDARHEADER = MCGRIDINFO_PART.CALENDARHEADER;
pub const MCGIP_CALENDARBODY = MCGRIDINFO_PART.CALENDARBODY;
pub const MCGIP_CALENDARROW = MCGRIDINFO_PART.CALENDARROW;
pub const MCGIP_CALENDARCELL = MCGRIDINFO_PART.CALENDARCELL;

pub const PARAFORMAT_BORDERS = enum(u16) {
    LEFT = 1,
    RIGHT = 2,
    TOP = 4,
    BOTTOM = 8,
    INSIDE = 16,
    OUTSIDE = 32,
    AUTOCOLOR = 64,
    _,
    pub fn initFlags(o: struct {
        LEFT: u1 = 0,
        RIGHT: u1 = 0,
        TOP: u1 = 0,
        BOTTOM: u1 = 0,
        INSIDE: u1 = 0,
        OUTSIDE: u1 = 0,
        AUTOCOLOR: u1 = 0,
    }) PARAFORMAT_BORDERS {
        return @intToEnum(PARAFORMAT_BORDERS,
              (if (o.LEFT == 1) @enumToInt(PARAFORMAT_BORDERS.LEFT) else 0)
            | (if (o.RIGHT == 1) @enumToInt(PARAFORMAT_BORDERS.RIGHT) else 0)
            | (if (o.TOP == 1) @enumToInt(PARAFORMAT_BORDERS.TOP) else 0)
            | (if (o.BOTTOM == 1) @enumToInt(PARAFORMAT_BORDERS.BOTTOM) else 0)
            | (if (o.INSIDE == 1) @enumToInt(PARAFORMAT_BORDERS.INSIDE) else 0)
            | (if (o.OUTSIDE == 1) @enumToInt(PARAFORMAT_BORDERS.OUTSIDE) else 0)
            | (if (o.AUTOCOLOR == 1) @enumToInt(PARAFORMAT_BORDERS.AUTOCOLOR) else 0)
        );
    }
};
pub const PARAFORMAT_BORDERS_LEFT = PARAFORMAT_BORDERS.LEFT;
pub const PARAFORMAT_BORDERS_RIGHT = PARAFORMAT_BORDERS.RIGHT;
pub const PARAFORMAT_BORDERS_TOP = PARAFORMAT_BORDERS.TOP;
pub const PARAFORMAT_BORDERS_BOTTOM = PARAFORMAT_BORDERS.BOTTOM;
pub const PARAFORMAT_BORDERS_INSIDE = PARAFORMAT_BORDERS.INSIDE;
pub const PARAFORMAT_BORDERS_OUTSIDE = PARAFORMAT_BORDERS.OUTSIDE;
pub const PARAFORMAT_BORDERS_AUTOCOLOR = PARAFORMAT_BORDERS.AUTOCOLOR;

pub const LVITEMA_GROUP_ID = enum(i32) {
    CALLBACK = -1,
    NONE = -2,
};
pub const I_GROUPIDCALLBACK = LVITEMA_GROUP_ID.CALLBACK;
pub const I_GROUPIDNONE = LVITEMA_GROUP_ID.NONE;

pub const NMTBHOTITEM_FLAGS = enum(u32) {
    ACCELERATOR = 4,
    ARROWKEYS = 2,
    DUPACCEL = 8,
    ENTERING = 16,
    LEAVING = 32,
    LMOUSE = 128,
    MOUSE = 1,
    OTHER = 0,
    RESELECT = 64,
    TOGGLEDROPDOWN = 256,
    _,
    pub fn initFlags(o: struct {
        ACCELERATOR: u1 = 0,
        ARROWKEYS: u1 = 0,
        DUPACCEL: u1 = 0,
        ENTERING: u1 = 0,
        LEAVING: u1 = 0,
        LMOUSE: u1 = 0,
        MOUSE: u1 = 0,
        OTHER: u1 = 0,
        RESELECT: u1 = 0,
        TOGGLEDROPDOWN: u1 = 0,
    }) NMTBHOTITEM_FLAGS {
        return @intToEnum(NMTBHOTITEM_FLAGS,
              (if (o.ACCELERATOR == 1) @enumToInt(NMTBHOTITEM_FLAGS.ACCELERATOR) else 0)
            | (if (o.ARROWKEYS == 1) @enumToInt(NMTBHOTITEM_FLAGS.ARROWKEYS) else 0)
            | (if (o.DUPACCEL == 1) @enumToInt(NMTBHOTITEM_FLAGS.DUPACCEL) else 0)
            | (if (o.ENTERING == 1) @enumToInt(NMTBHOTITEM_FLAGS.ENTERING) else 0)
            | (if (o.LEAVING == 1) @enumToInt(NMTBHOTITEM_FLAGS.LEAVING) else 0)
            | (if (o.LMOUSE == 1) @enumToInt(NMTBHOTITEM_FLAGS.LMOUSE) else 0)
            | (if (o.MOUSE == 1) @enumToInt(NMTBHOTITEM_FLAGS.MOUSE) else 0)
            | (if (o.OTHER == 1) @enumToInt(NMTBHOTITEM_FLAGS.OTHER) else 0)
            | (if (o.RESELECT == 1) @enumToInt(NMTBHOTITEM_FLAGS.RESELECT) else 0)
            | (if (o.TOGGLEDROPDOWN == 1) @enumToInt(NMTBHOTITEM_FLAGS.TOGGLEDROPDOWN) else 0)
        );
    }
};
pub const HICF_ACCELERATOR = NMTBHOTITEM_FLAGS.ACCELERATOR;
pub const HICF_ARROWKEYS = NMTBHOTITEM_FLAGS.ARROWKEYS;
pub const HICF_DUPACCEL = NMTBHOTITEM_FLAGS.DUPACCEL;
pub const HICF_ENTERING = NMTBHOTITEM_FLAGS.ENTERING;
pub const HICF_LEAVING = NMTBHOTITEM_FLAGS.LEAVING;
pub const HICF_LMOUSE = NMTBHOTITEM_FLAGS.LMOUSE;
pub const HICF_MOUSE = NMTBHOTITEM_FLAGS.MOUSE;
pub const HICF_OTHER = NMTBHOTITEM_FLAGS.OTHER;
pub const HICF_RESELECT = NMTBHOTITEM_FLAGS.RESELECT;
pub const HICF_TOGGLEDROPDOWN = NMTBHOTITEM_FLAGS.TOGGLEDROPDOWN;

pub const LVTILEVIEWINFO_FLAGS = enum(u32) {
    D = 4,
};
pub const LVTVIF_EXTENDED = LVTILEVIEWINFO_FLAGS.D;

pub const NMPGSCROLL_DIR = enum(u32) {
    DOWN = 2,
    LEFT = 4,
    RIGHT = 8,
    UP = 1,
};
pub const PGF_SCROLLDOWN = NMPGSCROLL_DIR.DOWN;
pub const PGF_SCROLLLEFT = NMPGSCROLL_DIR.LEFT;
pub const PGF_SCROLLRIGHT = NMPGSCROLL_DIR.RIGHT;
pub const PGF_SCROLLUP = NMPGSCROLL_DIR.UP;

pub const PARAFORMAT_SHADING_STYLE = enum(u16) {
    NONE = 0,
    DARK_HORIZ = 1,
    DARK_VERT = 2,
    DARK_DOWN_DIAG = 3,
    DARK_UP_DIAG = 4,
    DARK_GRID = 5,
    DARK_TRELLIS = 6,
    LIGHT_HORZ = 7,
    LIGHT_VERT = 8,
    LIGHT_DOWN_DIAG = 9,
    LIGHT_UP_DIAG = 10,
    LIGHT_GRID = 11,
    LIGHT_TRELLIS = 12,
};
pub const PARAFORMAT_SHADING_STYLE_NONE = PARAFORMAT_SHADING_STYLE.NONE;
pub const PARAFORMAT_SHADING_STYLE_DARK_HORIZ = PARAFORMAT_SHADING_STYLE.DARK_HORIZ;
pub const PARAFORMAT_SHADING_STYLE_DARK_VERT = PARAFORMAT_SHADING_STYLE.DARK_VERT;
pub const PARAFORMAT_SHADING_STYLE_DARK_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.DARK_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_UP_DIAG = PARAFORMAT_SHADING_STYLE.DARK_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_GRID = PARAFORMAT_SHADING_STYLE.DARK_GRID;
pub const PARAFORMAT_SHADING_STYLE_DARK_TRELLIS = PARAFORMAT_SHADING_STYLE.DARK_TRELLIS;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_HORZ = PARAFORMAT_SHADING_STYLE.LIGHT_HORZ;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_VERT = PARAFORMAT_SHADING_STYLE.LIGHT_VERT;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_UP_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_GRID = PARAFORMAT_SHADING_STYLE.LIGHT_GRID;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_TRELLIS = PARAFORMAT_SHADING_STYLE.LIGHT_TRELLIS;

pub const LVCOLUMNW_MASK = enum(u32) {
    FMT = 1,
    WIDTH = 2,
    TEXT = 4,
    SUBITEM = 8,
    IMAGE = 16,
    ORDER = 32,
    MINWIDTH = 64,
    DEFAULTWIDTH = 128,
    IDEALWIDTH = 256,
    _,
    pub fn initFlags(o: struct {
        FMT: u1 = 0,
        WIDTH: u1 = 0,
        TEXT: u1 = 0,
        SUBITEM: u1 = 0,
        IMAGE: u1 = 0,
        ORDER: u1 = 0,
        MINWIDTH: u1 = 0,
        DEFAULTWIDTH: u1 = 0,
        IDEALWIDTH: u1 = 0,
    }) LVCOLUMNW_MASK {
        return @intToEnum(LVCOLUMNW_MASK,
              (if (o.FMT == 1) @enumToInt(LVCOLUMNW_MASK.FMT) else 0)
            | (if (o.WIDTH == 1) @enumToInt(LVCOLUMNW_MASK.WIDTH) else 0)
            | (if (o.TEXT == 1) @enumToInt(LVCOLUMNW_MASK.TEXT) else 0)
            | (if (o.SUBITEM == 1) @enumToInt(LVCOLUMNW_MASK.SUBITEM) else 0)
            | (if (o.IMAGE == 1) @enumToInt(LVCOLUMNW_MASK.IMAGE) else 0)
            | (if (o.ORDER == 1) @enumToInt(LVCOLUMNW_MASK.ORDER) else 0)
            | (if (o.MINWIDTH == 1) @enumToInt(LVCOLUMNW_MASK.MINWIDTH) else 0)
            | (if (o.DEFAULTWIDTH == 1) @enumToInt(LVCOLUMNW_MASK.DEFAULTWIDTH) else 0)
            | (if (o.IDEALWIDTH == 1) @enumToInt(LVCOLUMNW_MASK.IDEALWIDTH) else 0)
        );
    }
};
pub const LVCF_FMT = LVCOLUMNW_MASK.FMT;
pub const LVCF_WIDTH = LVCOLUMNW_MASK.WIDTH;
pub const LVCF_TEXT = LVCOLUMNW_MASK.TEXT;
pub const LVCF_SUBITEM = LVCOLUMNW_MASK.SUBITEM;
pub const LVCF_IMAGE = LVCOLUMNW_MASK.IMAGE;
pub const LVCF_ORDER = LVCOLUMNW_MASK.ORDER;
pub const LVCF_MINWIDTH = LVCOLUMNW_MASK.MINWIDTH;
pub const LVCF_DEFAULTWIDTH = LVCOLUMNW_MASK.DEFAULTWIDTH;
pub const LVCF_IDEALWIDTH = LVCOLUMNW_MASK.IDEALWIDTH;

pub const GETTEXTEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    NOHIDDENTEXT = 8,
    RAWTEXT = 4,
    SELECTION = 2,
    USECRLF = 1,
};
pub const GT_DEFAULT = GETTEXTEX_FLAGS.DEFAULT;
pub const GT_NOHIDDENTEXT = GETTEXTEX_FLAGS.NOHIDDENTEXT;
pub const GT_RAWTEXT = GETTEXTEX_FLAGS.RAWTEXT;
pub const GT_SELECTION = GETTEXTEX_FLAGS.SELECTION;
pub const GT_USECRLF = GETTEXTEX_FLAGS.USECRLF;

pub const LVFINDINFOW_FLAGS = enum(u32) {
    PARAM = 1,
    PARTIAL = 8,
    STRING = 2,
    SUBSTRING = 4,
    WRAP = 32,
    NEARESTXY = 64,
    _,
    pub fn initFlags(o: struct {
        PARAM: u1 = 0,
        PARTIAL: u1 = 0,
        STRING: u1 = 0,
        SUBSTRING: u1 = 0,
        WRAP: u1 = 0,
        NEARESTXY: u1 = 0,
    }) LVFINDINFOW_FLAGS {
        return @intToEnum(LVFINDINFOW_FLAGS,
              (if (o.PARAM == 1) @enumToInt(LVFINDINFOW_FLAGS.PARAM) else 0)
            | (if (o.PARTIAL == 1) @enumToInt(LVFINDINFOW_FLAGS.PARTIAL) else 0)
            | (if (o.STRING == 1) @enumToInt(LVFINDINFOW_FLAGS.STRING) else 0)
            | (if (o.SUBSTRING == 1) @enumToInt(LVFINDINFOW_FLAGS.SUBSTRING) else 0)
            | (if (o.WRAP == 1) @enumToInt(LVFINDINFOW_FLAGS.WRAP) else 0)
            | (if (o.NEARESTXY == 1) @enumToInt(LVFINDINFOW_FLAGS.NEARESTXY) else 0)
        );
    }
};
pub const LVFI_PARAM = LVFINDINFOW_FLAGS.PARAM;
pub const LVFI_PARTIAL = LVFINDINFOW_FLAGS.PARTIAL;
pub const LVFI_STRING = LVFINDINFOW_FLAGS.STRING;
pub const LVFI_SUBSTRING = LVFINDINFOW_FLAGS.SUBSTRING;
pub const LVFI_WRAP = LVFINDINFOW_FLAGS.WRAP;
pub const LVFI_NEARESTXY = LVFINDINFOW_FLAGS.NEARESTXY;

pub const BUTTON_IMAGELIST_ALIGN = enum(u32) {
    LEFT = 0,
    RIGHT = 1,
    TOP = 2,
    BOTTOM = 3,
    CENTER = 4,
};
pub const BUTTON_IMAGELIST_ALIGN_LEFT = BUTTON_IMAGELIST_ALIGN.LEFT;
pub const BUTTON_IMAGELIST_ALIGN_RIGHT = BUTTON_IMAGELIST_ALIGN.RIGHT;
pub const BUTTON_IMAGELIST_ALIGN_TOP = BUTTON_IMAGELIST_ALIGN.TOP;
pub const BUTTON_IMAGELIST_ALIGN_BOTTOM = BUTTON_IMAGELIST_ALIGN.BOTTOM;
pub const BUTTON_IMAGELIST_ALIGN_CENTER = BUTTON_IMAGELIST_ALIGN.CENTER;

pub const TBBUTTONINFOW_MASK = enum(u32) {
    BYINDEX = 2147483648,
    COMMAND = 32,
    IMAGE = 1,
    LPARAM = 16,
    SIZE = 64,
    STATE = 4,
    STYLE = 8,
    TEXT = 2,
    _,
    pub fn initFlags(o: struct {
        BYINDEX: u1 = 0,
        COMMAND: u1 = 0,
        IMAGE: u1 = 0,
        LPARAM: u1 = 0,
        SIZE: u1 = 0,
        STATE: u1 = 0,
        STYLE: u1 = 0,
        TEXT: u1 = 0,
    }) TBBUTTONINFOW_MASK {
        return @intToEnum(TBBUTTONINFOW_MASK,
              (if (o.BYINDEX == 1) @enumToInt(TBBUTTONINFOW_MASK.BYINDEX) else 0)
            | (if (o.COMMAND == 1) @enumToInt(TBBUTTONINFOW_MASK.COMMAND) else 0)
            | (if (o.IMAGE == 1) @enumToInt(TBBUTTONINFOW_MASK.IMAGE) else 0)
            | (if (o.LPARAM == 1) @enumToInt(TBBUTTONINFOW_MASK.LPARAM) else 0)
            | (if (o.SIZE == 1) @enumToInt(TBBUTTONINFOW_MASK.SIZE) else 0)
            | (if (o.STATE == 1) @enumToInt(TBBUTTONINFOW_MASK.STATE) else 0)
            | (if (o.STYLE == 1) @enumToInt(TBBUTTONINFOW_MASK.STYLE) else 0)
            | (if (o.TEXT == 1) @enumToInt(TBBUTTONINFOW_MASK.TEXT) else 0)
        );
    }
};
pub const TBIF_BYINDEX = TBBUTTONINFOW_MASK.BYINDEX;
pub const TBIF_COMMAND = TBBUTTONINFOW_MASK.COMMAND;
pub const TBIF_IMAGE = TBBUTTONINFOW_MASK.IMAGE;
pub const TBIF_LPARAM = TBBUTTONINFOW_MASK.LPARAM;
pub const TBIF_SIZE = TBBUTTONINFOW_MASK.SIZE;
pub const TBIF_STATE = TBBUTTONINFOW_MASK.STATE;
pub const TBIF_STYLE = TBBUTTONINFOW_MASK.STYLE;
pub const TBIF_TEXT = TBBUTTONINFOW_MASK.TEXT;

pub const TBINSERTMARK_FLAGS = enum(u32) {
    NONE = 0,
    AFTER = 1,
    BACKGROUND = 2,
};
pub const TBIMHT_NONE = TBINSERTMARK_FLAGS.NONE;
pub const TBIMHT_AFTER = TBINSERTMARK_FLAGS.AFTER;
pub const TBIMHT_BACKGROUND = TBINSERTMARK_FLAGS.BACKGROUND;

pub const LVGROUP_MASK = enum(u32) {
    NONE = 0,
    HEADER = 1,
    FOOTER = 2,
    STATE = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        HEADER: u1 = 0,
        FOOTER: u1 = 0,
        STATE: u1 = 0,
    }) LVGROUP_MASK {
        return @intToEnum(LVGROUP_MASK,
              (if (o.NONE == 1) @enumToInt(LVGROUP_MASK.NONE) else 0)
            | (if (o.HEADER == 1) @enumToInt(LVGROUP_MASK.HEADER) else 0)
            | (if (o.FOOTER == 1) @enumToInt(LVGROUP_MASK.FOOTER) else 0)
            | (if (o.STATE == 1) @enumToInt(LVGROUP_MASK.STATE) else 0)
        );
    }
};
pub const LVGF_NONE = LVGROUP_MASK.NONE;
pub const LVGF_HEADER = LVGROUP_MASK.HEADER;
pub const LVGF_FOOTER = LVGROUP_MASK.FOOTER;
pub const LVGF_STATE = LVGROUP_MASK.STATE;

pub const BP_PAINTPARAMS_FLAGS = enum(u32) {
    ERASE = 1,
    NOCLIP = 2,
    NONCLIENT = 4,
    _,
    pub fn initFlags(o: struct {
        ERASE: u1 = 0,
        NOCLIP: u1 = 0,
        NONCLIENT: u1 = 0,
    }) BP_PAINTPARAMS_FLAGS {
        return @intToEnum(BP_PAINTPARAMS_FLAGS,
              (if (o.ERASE == 1) @enumToInt(BP_PAINTPARAMS_FLAGS.ERASE) else 0)
            | (if (o.NOCLIP == 1) @enumToInt(BP_PAINTPARAMS_FLAGS.NOCLIP) else 0)
            | (if (o.NONCLIENT == 1) @enumToInt(BP_PAINTPARAMS_FLAGS.NONCLIENT) else 0)
        );
    }
};
pub const BPPF_ERASE = BP_PAINTPARAMS_FLAGS.ERASE;
pub const BPPF_NOCLIP = BP_PAINTPARAMS_FLAGS.NOCLIP;
pub const BPPF_NONCLIENT = BP_PAINTPARAMS_FLAGS.NONCLIENT;

pub const TVHITTESTINFO_FLAGS = enum(u32) {
    ABOVE = 256,
    BELOW = 512,
    NOWHERE = 1,
    ONITEM = 70,
    ONITEMBUTTON = 16,
    ONITEMICON = 2,
    ONITEMINDENT = 8,
    ONITEMLABEL = 4,
    ONITEMRIGHT = 32,
    ONITEMSTATEICON = 64,
    TOLEFT = 2048,
    TORIGHT = 1024,
    _,
    pub fn initFlags(o: struct {
        ABOVE: u1 = 0,
        BELOW: u1 = 0,
        NOWHERE: u1 = 0,
        ONITEM: u1 = 0,
        ONITEMBUTTON: u1 = 0,
        ONITEMICON: u1 = 0,
        ONITEMINDENT: u1 = 0,
        ONITEMLABEL: u1 = 0,
        ONITEMRIGHT: u1 = 0,
        ONITEMSTATEICON: u1 = 0,
        TOLEFT: u1 = 0,
        TORIGHT: u1 = 0,
    }) TVHITTESTINFO_FLAGS {
        return @intToEnum(TVHITTESTINFO_FLAGS,
              (if (o.ABOVE == 1) @enumToInt(TVHITTESTINFO_FLAGS.ABOVE) else 0)
            | (if (o.BELOW == 1) @enumToInt(TVHITTESTINFO_FLAGS.BELOW) else 0)
            | (if (o.NOWHERE == 1) @enumToInt(TVHITTESTINFO_FLAGS.NOWHERE) else 0)
            | (if (o.ONITEM == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEM) else 0)
            | (if (o.ONITEMBUTTON == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMBUTTON) else 0)
            | (if (o.ONITEMICON == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMICON) else 0)
            | (if (o.ONITEMINDENT == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMINDENT) else 0)
            | (if (o.ONITEMLABEL == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMLABEL) else 0)
            | (if (o.ONITEMRIGHT == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMRIGHT) else 0)
            | (if (o.ONITEMSTATEICON == 1) @enumToInt(TVHITTESTINFO_FLAGS.ONITEMSTATEICON) else 0)
            | (if (o.TOLEFT == 1) @enumToInt(TVHITTESTINFO_FLAGS.TOLEFT) else 0)
            | (if (o.TORIGHT == 1) @enumToInt(TVHITTESTINFO_FLAGS.TORIGHT) else 0)
        );
    }
};
pub const TVHT_ABOVE = TVHITTESTINFO_FLAGS.ABOVE;
pub const TVHT_BELOW = TVHITTESTINFO_FLAGS.BELOW;
pub const TVHT_NOWHERE = TVHITTESTINFO_FLAGS.NOWHERE;
pub const TVHT_ONITEM = TVHITTESTINFO_FLAGS.ONITEM;
pub const TVHT_ONITEMBUTTON = TVHITTESTINFO_FLAGS.ONITEMBUTTON;
pub const TVHT_ONITEMICON = TVHITTESTINFO_FLAGS.ONITEMICON;
pub const TVHT_ONITEMINDENT = TVHITTESTINFO_FLAGS.ONITEMINDENT;
pub const TVHT_ONITEMLABEL = TVHITTESTINFO_FLAGS.ONITEMLABEL;
pub const TVHT_ONITEMRIGHT = TVHITTESTINFO_FLAGS.ONITEMRIGHT;
pub const TVHT_ONITEMSTATEICON = TVHITTESTINFO_FLAGS.ONITEMSTATEICON;
pub const TVHT_TOLEFT = TVHITTESTINFO_FLAGS.TOLEFT;
pub const TVHT_TORIGHT = TVHITTESTINFO_FLAGS.TORIGHT;

pub const DRAWITEMSTRUCT_CTL_TYPE = enum(u32) {
    BUTTON = 4,
    COMBOBOX = 3,
    LISTBOX = 2,
    LISTVIEW = 102,
    MENU = 1,
    STATIC = 5,
    TAB = 101,
};
pub const ODT_BUTTON = DRAWITEMSTRUCT_CTL_TYPE.BUTTON;
pub const ODT_COMBOBOX = DRAWITEMSTRUCT_CTL_TYPE.COMBOBOX;
pub const ODT_LISTBOX = DRAWITEMSTRUCT_CTL_TYPE.LISTBOX;
pub const ODT_LISTVIEW = DRAWITEMSTRUCT_CTL_TYPE.LISTVIEW;
pub const ODT_MENU = DRAWITEMSTRUCT_CTL_TYPE.MENU;
pub const ODT_STATIC = DRAWITEMSTRUCT_CTL_TYPE.STATIC;
pub const ODT_TAB = DRAWITEMSTRUCT_CTL_TYPE.TAB;

pub const NMPGCALCSIZE_FLAGS = enum(u32) {
    HEIGHT = 2,
    WIDTH = 1,
};
pub const PGF_CALCHEIGHT = NMPGCALCSIZE_FLAGS.HEIGHT;
pub const PGF_CALCWIDTH = NMPGCALCSIZE_FLAGS.WIDTH;

pub const ENDCOMPOSITIONNOTIFY_CODE = enum(u32) {
    ENDCOMPOSITION = 1,
    NEWTEXT = 2,
};
pub const ECN_ENDCOMPOSITION = ENDCOMPOSITIONNOTIFY_CODE.ENDCOMPOSITION;
pub const ECN_NEWTEXT = ENDCOMPOSITIONNOTIFY_CODE.NEWTEXT;

pub const NMLVCUSTOMDRAW_ALIGN = enum(u32) {
    CENTER = 2,
    LEFT = 1,
    RIGHT = 4,
};
pub const LVGA_HEADER_CENTER = NMLVCUSTOMDRAW_ALIGN.CENTER;
pub const LVGA_HEADER_LEFT = NMLVCUSTOMDRAW_ALIGN.LEFT;
pub const LVGA_HEADER_RIGHT = NMLVCUSTOMDRAW_ALIGN.RIGHT;

pub const IMECOMPTEXT_FLAGS = enum(u32) {
    R = 1,
};
pub const ICT_RESULTREADSTR = IMECOMPTEXT_FLAGS.R;

pub const MCGRIDINFO_FLAGS = enum(u32) {
    DATE = 1,
    RECT = 2,
    NAME = 4,
    _,
    pub fn initFlags(o: struct {
        DATE: u1 = 0,
        RECT: u1 = 0,
        NAME: u1 = 0,
    }) MCGRIDINFO_FLAGS {
        return @intToEnum(MCGRIDINFO_FLAGS,
              (if (o.DATE == 1) @enumToInt(MCGRIDINFO_FLAGS.DATE) else 0)
            | (if (o.RECT == 1) @enumToInt(MCGRIDINFO_FLAGS.RECT) else 0)
            | (if (o.NAME == 1) @enumToInt(MCGRIDINFO_FLAGS.NAME) else 0)
        );
    }
};
pub const MCGIF_DATE = MCGRIDINFO_FLAGS.DATE;
pub const MCGIF_RECT = MCGRIDINFO_FLAGS.RECT;
pub const MCGIF_NAME = MCGRIDINFO_FLAGS.NAME;

pub const GETTEXTLENGTHEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    USECRLF = 1,
    PRECISE = 2,
    CLOSE = 4,
    NUMCHARS = 8,
    NUMBYTES = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        USECRLF: u1 = 0,
        PRECISE: u1 = 0,
        CLOSE: u1 = 0,
        NUMCHARS: u1 = 0,
        NUMBYTES: u1 = 0,
    }) GETTEXTLENGTHEX_FLAGS {
        return @intToEnum(GETTEXTLENGTHEX_FLAGS,
              (if (o.DEFAULT == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.DEFAULT) else 0)
            | (if (o.USECRLF == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.USECRLF) else 0)
            | (if (o.PRECISE == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.PRECISE) else 0)
            | (if (o.CLOSE == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.CLOSE) else 0)
            | (if (o.NUMCHARS == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.NUMCHARS) else 0)
            | (if (o.NUMBYTES == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.NUMBYTES) else 0)
        );
    }
};
pub const GTL_DEFAULT = GETTEXTLENGTHEX_FLAGS.DEFAULT;
pub const GTL_USECRLF = GETTEXTLENGTHEX_FLAGS.USECRLF;
pub const GTL_PRECISE = GETTEXTLENGTHEX_FLAGS.PRECISE;
pub const GTL_CLOSE = GETTEXTLENGTHEX_FLAGS.CLOSE;
pub const GTL_NUMCHARS = GETTEXTLENGTHEX_FLAGS.NUMCHARS;
pub const GTL_NUMBYTES = GETTEXTLENGTHEX_FLAGS.NUMBYTES;

pub const LVHITTESTINFO_FLAGS = enum(u32) {
    ABOVE = 8,
    BELOW = 16,
    NOWHERE = 1,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
    // ONITEMSTATEICON = 8, this enum value conflicts with ABOVE
    TOLEFT = 64,
    TORIGHT = 32,
    EX_GROUP_HEADER = 268435456,
    EX_GROUP_FOOTER = 536870912,
    EX_GROUP_COLLAPSE = 1073741824,
    EX_GROUP_BACKGROUND = 2147483648,
    EX_GROUP_STATEICON = 16777216,
    EX_GROUP_SUBSETLINK = 33554432,
    EX_GROUP = 4076863488,
    EX_ONCONTENTS = 67108864,
    EX_FOOTER = 134217728,
    _,
    pub fn initFlags(o: struct {
        ABOVE: u1 = 0,
        BELOW: u1 = 0,
        NOWHERE: u1 = 0,
        ONITEMICON: u1 = 0,
        ONITEMLABEL: u1 = 0,
        TOLEFT: u1 = 0,
        TORIGHT: u1 = 0,
        EX_GROUP_HEADER: u1 = 0,
        EX_GROUP_FOOTER: u1 = 0,
        EX_GROUP_COLLAPSE: u1 = 0,
        EX_GROUP_BACKGROUND: u1 = 0,
        EX_GROUP_STATEICON: u1 = 0,
        EX_GROUP_SUBSETLINK: u1 = 0,
        EX_GROUP: u1 = 0,
        EX_ONCONTENTS: u1 = 0,
        EX_FOOTER: u1 = 0,
    }) LVHITTESTINFO_FLAGS {
        return @intToEnum(LVHITTESTINFO_FLAGS,
              (if (o.ABOVE == 1) @enumToInt(LVHITTESTINFO_FLAGS.ABOVE) else 0)
            | (if (o.BELOW == 1) @enumToInt(LVHITTESTINFO_FLAGS.BELOW) else 0)
            | (if (o.NOWHERE == 1) @enumToInt(LVHITTESTINFO_FLAGS.NOWHERE) else 0)
            | (if (o.ONITEMICON == 1) @enumToInt(LVHITTESTINFO_FLAGS.ONITEMICON) else 0)
            | (if (o.ONITEMLABEL == 1) @enumToInt(LVHITTESTINFO_FLAGS.ONITEMLABEL) else 0)
            | (if (o.TOLEFT == 1) @enumToInt(LVHITTESTINFO_FLAGS.TOLEFT) else 0)
            | (if (o.TORIGHT == 1) @enumToInt(LVHITTESTINFO_FLAGS.TORIGHT) else 0)
            | (if (o.EX_GROUP_HEADER == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_HEADER) else 0)
            | (if (o.EX_GROUP_FOOTER == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_FOOTER) else 0)
            | (if (o.EX_GROUP_COLLAPSE == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_COLLAPSE) else 0)
            | (if (o.EX_GROUP_BACKGROUND == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_BACKGROUND) else 0)
            | (if (o.EX_GROUP_STATEICON == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_STATEICON) else 0)
            | (if (o.EX_GROUP_SUBSETLINK == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP_SUBSETLINK) else 0)
            | (if (o.EX_GROUP == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_GROUP) else 0)
            | (if (o.EX_ONCONTENTS == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_ONCONTENTS) else 0)
            | (if (o.EX_FOOTER == 1) @enumToInt(LVHITTESTINFO_FLAGS.EX_FOOTER) else 0)
        );
    }
};
pub const LVHT_ABOVE = LVHITTESTINFO_FLAGS.ABOVE;
pub const LVHT_BELOW = LVHITTESTINFO_FLAGS.BELOW;
pub const LVHT_NOWHERE = LVHITTESTINFO_FLAGS.NOWHERE;
pub const LVHT_ONITEMICON = LVHITTESTINFO_FLAGS.ONITEMICON;
pub const LVHT_ONITEMLABEL = LVHITTESTINFO_FLAGS.ONITEMLABEL;
pub const LVHT_ONITEMSTATEICON = LVHITTESTINFO_FLAGS.ABOVE;
pub const LVHT_TOLEFT = LVHITTESTINFO_FLAGS.TOLEFT;
pub const LVHT_TORIGHT = LVHITTESTINFO_FLAGS.TORIGHT;
pub const LVHT_EX_GROUP_HEADER = LVHITTESTINFO_FLAGS.EX_GROUP_HEADER;
pub const LVHT_EX_GROUP_FOOTER = LVHITTESTINFO_FLAGS.EX_GROUP_FOOTER;
pub const LVHT_EX_GROUP_COLLAPSE = LVHITTESTINFO_FLAGS.EX_GROUP_COLLAPSE;
pub const LVHT_EX_GROUP_BACKGROUND = LVHITTESTINFO_FLAGS.EX_GROUP_BACKGROUND;
pub const LVHT_EX_GROUP_STATEICON = LVHITTESTINFO_FLAGS.EX_GROUP_STATEICON;
pub const LVHT_EX_GROUP_SUBSETLINK = LVHITTESTINFO_FLAGS.EX_GROUP_SUBSETLINK;
pub const LVHT_EX_GROUP = LVHITTESTINFO_FLAGS.EX_GROUP;
pub const LVHT_EX_ONCONTENTS = LVHITTESTINFO_FLAGS.EX_ONCONTENTS;
pub const LVHT_EX_FOOTER = LVHITTESTINFO_FLAGS.EX_FOOTER;

pub const INITCOMMONCONTROLSEX_ICC = enum(u32) {
    ANIMATE_CLASS = 128,
    BAR_CLASSES = 4,
    COOL_CLASSES = 1024,
    DATE_CLASSES = 256,
    HOTKEY_CLASS = 64,
    INTERNET_CLASSES = 2048,
    LINK_CLASS = 32768,
    LISTVIEW_CLASSES = 1,
    NATIVEFNTCTL_CLASS = 8192,
    PAGESCROLLER_CLASS = 4096,
    PROGRESS_CLASS = 32,
    STANDARD_CLASSES = 16384,
    TAB_CLASSES = 8,
    TREEVIEW_CLASSES = 2,
    UPDOWN_CLASS = 16,
    USEREX_CLASSES = 512,
    WIN95_CLASSES = 255,
    _,
    pub fn initFlags(o: struct {
        ANIMATE_CLASS: u1 = 0,
        BAR_CLASSES: u1 = 0,
        COOL_CLASSES: u1 = 0,
        DATE_CLASSES: u1 = 0,
        HOTKEY_CLASS: u1 = 0,
        INTERNET_CLASSES: u1 = 0,
        LINK_CLASS: u1 = 0,
        LISTVIEW_CLASSES: u1 = 0,
        NATIVEFNTCTL_CLASS: u1 = 0,
        PAGESCROLLER_CLASS: u1 = 0,
        PROGRESS_CLASS: u1 = 0,
        STANDARD_CLASSES: u1 = 0,
        TAB_CLASSES: u1 = 0,
        TREEVIEW_CLASSES: u1 = 0,
        UPDOWN_CLASS: u1 = 0,
        USEREX_CLASSES: u1 = 0,
        WIN95_CLASSES: u1 = 0,
    }) INITCOMMONCONTROLSEX_ICC {
        return @intToEnum(INITCOMMONCONTROLSEX_ICC,
              (if (o.ANIMATE_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.ANIMATE_CLASS) else 0)
            | (if (o.BAR_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.BAR_CLASSES) else 0)
            | (if (o.COOL_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.COOL_CLASSES) else 0)
            | (if (o.DATE_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.DATE_CLASSES) else 0)
            | (if (o.HOTKEY_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.HOTKEY_CLASS) else 0)
            | (if (o.INTERNET_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.INTERNET_CLASSES) else 0)
            | (if (o.LINK_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.LINK_CLASS) else 0)
            | (if (o.LISTVIEW_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.LISTVIEW_CLASSES) else 0)
            | (if (o.NATIVEFNTCTL_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.NATIVEFNTCTL_CLASS) else 0)
            | (if (o.PAGESCROLLER_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.PAGESCROLLER_CLASS) else 0)
            | (if (o.PROGRESS_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.PROGRESS_CLASS) else 0)
            | (if (o.STANDARD_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.STANDARD_CLASSES) else 0)
            | (if (o.TAB_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.TAB_CLASSES) else 0)
            | (if (o.TREEVIEW_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.TREEVIEW_CLASSES) else 0)
            | (if (o.UPDOWN_CLASS == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.UPDOWN_CLASS) else 0)
            | (if (o.USEREX_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.USEREX_CLASSES) else 0)
            | (if (o.WIN95_CLASSES == 1) @enumToInt(INITCOMMONCONTROLSEX_ICC.WIN95_CLASSES) else 0)
        );
    }
};
pub const ICC_ANIMATE_CLASS = INITCOMMONCONTROLSEX_ICC.ANIMATE_CLASS;
pub const ICC_BAR_CLASSES = INITCOMMONCONTROLSEX_ICC.BAR_CLASSES;
pub const ICC_COOL_CLASSES = INITCOMMONCONTROLSEX_ICC.COOL_CLASSES;
pub const ICC_DATE_CLASSES = INITCOMMONCONTROLSEX_ICC.DATE_CLASSES;
pub const ICC_HOTKEY_CLASS = INITCOMMONCONTROLSEX_ICC.HOTKEY_CLASS;
pub const ICC_INTERNET_CLASSES = INITCOMMONCONTROLSEX_ICC.INTERNET_CLASSES;
pub const ICC_LINK_CLASS = INITCOMMONCONTROLSEX_ICC.LINK_CLASS;
pub const ICC_LISTVIEW_CLASSES = INITCOMMONCONTROLSEX_ICC.LISTVIEW_CLASSES;
pub const ICC_NATIVEFNTCTL_CLASS = INITCOMMONCONTROLSEX_ICC.NATIVEFNTCTL_CLASS;
pub const ICC_PAGESCROLLER_CLASS = INITCOMMONCONTROLSEX_ICC.PAGESCROLLER_CLASS;
pub const ICC_PROGRESS_CLASS = INITCOMMONCONTROLSEX_ICC.PROGRESS_CLASS;
pub const ICC_STANDARD_CLASSES = INITCOMMONCONTROLSEX_ICC.STANDARD_CLASSES;
pub const ICC_TAB_CLASSES = INITCOMMONCONTROLSEX_ICC.TAB_CLASSES;
pub const ICC_TREEVIEW_CLASSES = INITCOMMONCONTROLSEX_ICC.TREEVIEW_CLASSES;
pub const ICC_UPDOWN_CLASS = INITCOMMONCONTROLSEX_ICC.UPDOWN_CLASS;
pub const ICC_USEREX_CLASSES = INITCOMMONCONTROLSEX_ICC.USEREX_CLASSES;
pub const ICC_WIN95_CLASSES = INITCOMMONCONTROLSEX_ICC.WIN95_CLASSES;

pub const NMLVCUSTOMDRAW_ITEM_TYPE = enum(u32) {
    ITEM = 0,
    GROUP = 1,
    ITEMSLIST = 2,
};
pub const LVCDI_ITEM = NMLVCUSTOMDRAW_ITEM_TYPE.ITEM;
pub const LVCDI_GROUP = NMLVCUSTOMDRAW_ITEM_TYPE.GROUP;
pub const LVCDI_ITEMSLIST = NMLVCUSTOMDRAW_ITEM_TYPE.ITEMSLIST;

pub const NMTBDISPINFOW_MASK = enum(u32) {
    IMAGE = 1,
    TEXT = 2,
    DI_SETITEM = 268435456,
    _,
    pub fn initFlags(o: struct {
        IMAGE: u1 = 0,
        TEXT: u1 = 0,
        DI_SETITEM: u1 = 0,
    }) NMTBDISPINFOW_MASK {
        return @intToEnum(NMTBDISPINFOW_MASK,
              (if (o.IMAGE == 1) @enumToInt(NMTBDISPINFOW_MASK.IMAGE) else 0)
            | (if (o.TEXT == 1) @enumToInt(NMTBDISPINFOW_MASK.TEXT) else 0)
            | (if (o.DI_SETITEM == 1) @enumToInt(NMTBDISPINFOW_MASK.DI_SETITEM) else 0)
        );
    }
};
pub const TBNF_IMAGE = NMTBDISPINFOW_MASK.IMAGE;
pub const TBNF_TEXT = NMTBDISPINFOW_MASK.TEXT;
pub const TBNF_DI_SETITEM = NMTBDISPINFOW_MASK.DI_SETITEM;

pub const SCROLLINFO_MASK = enum(u32) {
    ALL = 23,
    DISABLENOSCROLL = 8,
    PAGE = 2,
    POS = 4,
    RANGE = 1,
    TRACKPOS = 16,
    _,
    pub fn initFlags(o: struct {
        ALL: u1 = 0,
        DISABLENOSCROLL: u1 = 0,
        PAGE: u1 = 0,
        POS: u1 = 0,
        RANGE: u1 = 0,
        TRACKPOS: u1 = 0,
    }) SCROLLINFO_MASK {
        return @intToEnum(SCROLLINFO_MASK,
              (if (o.ALL == 1) @enumToInt(SCROLLINFO_MASK.ALL) else 0)
            | (if (o.DISABLENOSCROLL == 1) @enumToInt(SCROLLINFO_MASK.DISABLENOSCROLL) else 0)
            | (if (o.PAGE == 1) @enumToInt(SCROLLINFO_MASK.PAGE) else 0)
            | (if (o.POS == 1) @enumToInt(SCROLLINFO_MASK.POS) else 0)
            | (if (o.RANGE == 1) @enumToInt(SCROLLINFO_MASK.RANGE) else 0)
            | (if (o.TRACKPOS == 1) @enumToInt(SCROLLINFO_MASK.TRACKPOS) else 0)
        );
    }
};
pub const SIF_ALL = SCROLLINFO_MASK.ALL;
pub const SIF_DISABLENOSCROLL = SCROLLINFO_MASK.DISABLENOSCROLL;
pub const SIF_PAGE = SCROLLINFO_MASK.PAGE;
pub const SIF_POS = SCROLLINFO_MASK.POS;
pub const SIF_RANGE = SCROLLINFO_MASK.RANGE;
pub const SIF_TRACKPOS = SCROLLINFO_MASK.TRACKPOS;

pub const REOBJECT_FLAGS = enum(u32) {
    ALIGNTORIGHT = 256,
    BELOWBASELINE = 2,
    BLANK = 16,
    CANROTATE = 128,
    DONTNEEDPALETTE = 32,
    DYNAMICSIZE = 8,
    GETMETAFILE = 4194304,
    HILITED = 16777216,
    INPLACEACTIVE = 33554432,
    INVERTEDSELECT = 4,
    LINK = 2147483648,
    LINKAVAILABLE = 8388608,
    OPEN = 67108864,
    OWNERDRAWSELECT = 64,
    RESIZABLE = 1,
    SELECTED = 134217728,
    STATIC = 1073741824,
    USEASBACKGROUND = 1024,
    WRAPTEXTAROUND = 512,
    _,
    pub fn initFlags(o: struct {
        ALIGNTORIGHT: u1 = 0,
        BELOWBASELINE: u1 = 0,
        BLANK: u1 = 0,
        CANROTATE: u1 = 0,
        DONTNEEDPALETTE: u1 = 0,
        DYNAMICSIZE: u1 = 0,
        GETMETAFILE: u1 = 0,
        HILITED: u1 = 0,
        INPLACEACTIVE: u1 = 0,
        INVERTEDSELECT: u1 = 0,
        LINK: u1 = 0,
        LINKAVAILABLE: u1 = 0,
        OPEN: u1 = 0,
        OWNERDRAWSELECT: u1 = 0,
        RESIZABLE: u1 = 0,
        SELECTED: u1 = 0,
        STATIC: u1 = 0,
        USEASBACKGROUND: u1 = 0,
        WRAPTEXTAROUND: u1 = 0,
    }) REOBJECT_FLAGS {
        return @intToEnum(REOBJECT_FLAGS,
              (if (o.ALIGNTORIGHT == 1) @enumToInt(REOBJECT_FLAGS.ALIGNTORIGHT) else 0)
            | (if (o.BELOWBASELINE == 1) @enumToInt(REOBJECT_FLAGS.BELOWBASELINE) else 0)
            | (if (o.BLANK == 1) @enumToInt(REOBJECT_FLAGS.BLANK) else 0)
            | (if (o.CANROTATE == 1) @enumToInt(REOBJECT_FLAGS.CANROTATE) else 0)
            | (if (o.DONTNEEDPALETTE == 1) @enumToInt(REOBJECT_FLAGS.DONTNEEDPALETTE) else 0)
            | (if (o.DYNAMICSIZE == 1) @enumToInt(REOBJECT_FLAGS.DYNAMICSIZE) else 0)
            | (if (o.GETMETAFILE == 1) @enumToInt(REOBJECT_FLAGS.GETMETAFILE) else 0)
            | (if (o.HILITED == 1) @enumToInt(REOBJECT_FLAGS.HILITED) else 0)
            | (if (o.INPLACEACTIVE == 1) @enumToInt(REOBJECT_FLAGS.INPLACEACTIVE) else 0)
            | (if (o.INVERTEDSELECT == 1) @enumToInt(REOBJECT_FLAGS.INVERTEDSELECT) else 0)
            | (if (o.LINK == 1) @enumToInt(REOBJECT_FLAGS.LINK) else 0)
            | (if (o.LINKAVAILABLE == 1) @enumToInt(REOBJECT_FLAGS.LINKAVAILABLE) else 0)
            | (if (o.OPEN == 1) @enumToInt(REOBJECT_FLAGS.OPEN) else 0)
            | (if (o.OWNERDRAWSELECT == 1) @enumToInt(REOBJECT_FLAGS.OWNERDRAWSELECT) else 0)
            | (if (o.RESIZABLE == 1) @enumToInt(REOBJECT_FLAGS.RESIZABLE) else 0)
            | (if (o.SELECTED == 1) @enumToInt(REOBJECT_FLAGS.SELECTED) else 0)
            | (if (o.STATIC == 1) @enumToInt(REOBJECT_FLAGS.STATIC) else 0)
            | (if (o.USEASBACKGROUND == 1) @enumToInt(REOBJECT_FLAGS.USEASBACKGROUND) else 0)
            | (if (o.WRAPTEXTAROUND == 1) @enumToInt(REOBJECT_FLAGS.WRAPTEXTAROUND) else 0)
        );
    }
};
pub const REO_ALIGNTORIGHT = REOBJECT_FLAGS.ALIGNTORIGHT;
pub const REO_BELOWBASELINE = REOBJECT_FLAGS.BELOWBASELINE;
pub const REO_BLANK = REOBJECT_FLAGS.BLANK;
pub const REO_CANROTATE = REOBJECT_FLAGS.CANROTATE;
pub const REO_DONTNEEDPALETTE = REOBJECT_FLAGS.DONTNEEDPALETTE;
pub const REO_DYNAMICSIZE = REOBJECT_FLAGS.DYNAMICSIZE;
pub const REO_GETMETAFILE = REOBJECT_FLAGS.GETMETAFILE;
pub const REO_HILITED = REOBJECT_FLAGS.HILITED;
pub const REO_INPLACEACTIVE = REOBJECT_FLAGS.INPLACEACTIVE;
pub const REO_INVERTEDSELECT = REOBJECT_FLAGS.INVERTEDSELECT;
pub const REO_LINK = REOBJECT_FLAGS.LINK;
pub const REO_LINKAVAILABLE = REOBJECT_FLAGS.LINKAVAILABLE;
pub const REO_OPEN = REOBJECT_FLAGS.OPEN;
pub const REO_OWNERDRAWSELECT = REOBJECT_FLAGS.OWNERDRAWSELECT;
pub const REO_RESIZABLE = REOBJECT_FLAGS.RESIZABLE;
pub const REO_SELECTED = REOBJECT_FLAGS.SELECTED;
pub const REO_STATIC = REOBJECT_FLAGS.STATIC;
pub const REO_USEASBACKGROUND = REOBJECT_FLAGS.USEASBACKGROUND;
pub const REO_WRAPTEXTAROUND = REOBJECT_FLAGS.WRAPTEXTAROUND;

pub const NMLVEMPTYMARKUP_FLAGS = enum(u32) {
    D = 1,
};
pub const EMF_CENTERED = NMLVEMPTYMARKUP_FLAGS.D;

pub const PARAFORMAT_NUMBERING_STYLE = enum(u16) {
    PAREN = 0,
    PARENS = 256,
    PERIOD = 512,
    PLAIN = 768,
    NONUMBER = 1024,
    NEWNUMBER = 32768,
};
pub const PFNS_PAREN = PARAFORMAT_NUMBERING_STYLE.PAREN;
pub const PFNS_PARENS = PARAFORMAT_NUMBERING_STYLE.PARENS;
pub const PFNS_PERIOD = PARAFORMAT_NUMBERING_STYLE.PERIOD;
pub const PFNS_PLAIN = PARAFORMAT_NUMBERING_STYLE.PLAIN;
pub const PFNS_NONUMBER = PARAFORMAT_NUMBERING_STYLE.NONUMBER;
pub const PFNS_NEWNUMBER = PARAFORMAT_NUMBERING_STYLE.NEWNUMBER;

pub const LVFOOTERITEM_MASK = enum(u32) {
    TEXT = 1,
    STATE = 2,
};
pub const LVFIF_TEXT = LVFOOTERITEM_MASK.TEXT;
pub const LVFIF_STATE = LVFOOTERITEM_MASK.STATE;

pub const PARAFORMAT_ALIGNMENT = enum(u16) {
    CENTER = 3,
    LEFT = 1,
    RIGHT = 2,
};
pub const PFA_CENTER = PARAFORMAT_ALIGNMENT.CENTER;
pub const PFA_LEFT = PARAFORMAT_ALIGNMENT.LEFT;
pub const PFA_RIGHT = PARAFORMAT_ALIGNMENT.RIGHT;

pub const IMAGELIST_CREATION_FLAGS = enum(u32) {
    MASK = 1,
    COLOR = 0,
    COLORDDB = 254,
    COLOR4 = 4,
    COLOR8 = 8,
    COLOR16 = 16,
    COLOR24 = 24,
    COLOR32 = 32,
    PALETTE = 2048,
    MIRROR = 8192,
    PERITEMMIRROR = 32768,
    ORIGINALSIZE = 65536,
    HIGHQUALITYSCALE = 131072,
    _,
    pub fn initFlags(o: struct {
        MASK: u1 = 0,
        COLOR: u1 = 0,
        COLORDDB: u1 = 0,
        COLOR4: u1 = 0,
        COLOR8: u1 = 0,
        COLOR16: u1 = 0,
        COLOR24: u1 = 0,
        COLOR32: u1 = 0,
        PALETTE: u1 = 0,
        MIRROR: u1 = 0,
        PERITEMMIRROR: u1 = 0,
        ORIGINALSIZE: u1 = 0,
        HIGHQUALITYSCALE: u1 = 0,
    }) IMAGELIST_CREATION_FLAGS {
        return @intToEnum(IMAGELIST_CREATION_FLAGS,
              (if (o.MASK == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.MASK) else 0)
            | (if (o.COLOR == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR) else 0)
            | (if (o.COLORDDB == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLORDDB) else 0)
            | (if (o.COLOR4 == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR4) else 0)
            | (if (o.COLOR8 == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR8) else 0)
            | (if (o.COLOR16 == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR16) else 0)
            | (if (o.COLOR24 == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR24) else 0)
            | (if (o.COLOR32 == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.COLOR32) else 0)
            | (if (o.PALETTE == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.PALETTE) else 0)
            | (if (o.MIRROR == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.MIRROR) else 0)
            | (if (o.PERITEMMIRROR == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.PERITEMMIRROR) else 0)
            | (if (o.ORIGINALSIZE == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.ORIGINALSIZE) else 0)
            | (if (o.HIGHQUALITYSCALE == 1) @enumToInt(IMAGELIST_CREATION_FLAGS.HIGHQUALITYSCALE) else 0)
        );
    }
};
pub const ILC_MASK = IMAGELIST_CREATION_FLAGS.MASK;
pub const ILC_COLOR = IMAGELIST_CREATION_FLAGS.COLOR;
pub const ILC_COLORDDB = IMAGELIST_CREATION_FLAGS.COLORDDB;
pub const ILC_COLOR4 = IMAGELIST_CREATION_FLAGS.COLOR4;
pub const ILC_COLOR8 = IMAGELIST_CREATION_FLAGS.COLOR8;
pub const ILC_COLOR16 = IMAGELIST_CREATION_FLAGS.COLOR16;
pub const ILC_COLOR24 = IMAGELIST_CREATION_FLAGS.COLOR24;
pub const ILC_COLOR32 = IMAGELIST_CREATION_FLAGS.COLOR32;
pub const ILC_PALETTE = IMAGELIST_CREATION_FLAGS.PALETTE;
pub const ILC_MIRROR = IMAGELIST_CREATION_FLAGS.MIRROR;
pub const ILC_PERITEMMIRROR = IMAGELIST_CREATION_FLAGS.PERITEMMIRROR;
pub const ILC_ORIGINALSIZE = IMAGELIST_CREATION_FLAGS.ORIGINALSIZE;
pub const ILC_HIGHQUALITYSCALE = IMAGELIST_CREATION_FLAGS.HIGHQUALITYSCALE;

pub const _IMAGELIST = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};


pub const _TREEITEM = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const _DSA = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const _DPA = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};





























// TODO: this type has a FreeFunc 'DestroyPropertySheetPage', what can Zig do with this information?
pub const HPROPSHEETPAGE = *opaque{};

// TODO: this type has a FreeFunc 'ImageList_Destroy', what can Zig do with this information?
pub const HIMAGELIST = *opaque{};

pub const HSYNTHETICPOINTERDEVICE = *opaque{};

pub const HTREEITEM = *opaque{};

pub const LPFNPSPCALLBACKA = fn(
    hwnd: ?HWND,
    uMsg: PSPCB_MESSAGE,
    ppsp: ?*PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFNPSPCALLBACKW = fn(
    hwnd: ?HWND,
    uMsg: PSPCB_MESSAGE,
    ppsp: ?*PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PROPSHEETPAGEA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u8,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszTitle: ?[*:0]const u8,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
};

pub const PROPSHEETPAGEA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u8,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszTitle: ?[*:0]const u8,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u8,
    pszHeaderSubTitle: ?[*:0]const u8,
};

pub const PROPSHEETPAGEA_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u8,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszTitle: ?[*:0]const u8,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u8,
    pszHeaderSubTitle: ?[*:0]const u8,
    hActCtx: ?HANDLE,
};

pub const PROPSHEETPAGEA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u8,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszTitle: ?[*:0]const u8,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u8,
    pszHeaderSubTitle: ?[*:0]const u8,
    hActCtx: ?HANDLE,
    Anonymous3: extern union {
        hbmHeader: ?HBITMAP,
        pszbmHeader: ?[*:0]const u8,
    },
};

pub const PROPSHEETPAGEW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u16,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszTitle: ?[*:0]const u16,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
};

pub const PROPSHEETPAGEW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u16,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszTitle: ?[*:0]const u16,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u16,
    pszHeaderSubTitle: ?[*:0]const u16,
};

pub const PROPSHEETPAGEW_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u16,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszTitle: ?[*:0]const u16,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u16,
    pszHeaderSubTitle: ?[*:0]const u16,
    hActCtx: ?HANDLE,
};

pub const PROPSHEETPAGEW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        pszTemplate: ?[*:0]const u16,
        pResource: ?*DLGTEMPLATE,
    },
    Anonymous2: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszTitle: ?[*:0]const u16,
    pfnDlgProc: ?DLGPROC,
    lParam: LPARAM,
    pfnCallback: ?LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?[*:0]const u16,
    pszHeaderSubTitle: ?[*:0]const u16,
    hActCtx: ?HANDLE,
    Anonymous3: extern union {
        hbmHeader: ?HBITMAP,
        pszbmHeader: ?[*:0]const u16,
    },
};

pub const PFNPROPSHEETCALLBACK = fn(
    param0: ?HWND,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PROPSHEETHEADERA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszCaption: ?[*:0]const u8,
    nPages: u32,
    Anonymous2: extern union {
        nStartPage: u32,
        pStartPage: ?[*:0]const u8,
    },
    Anonymous3: extern union {
        ppsp: ?*PROPSHEETPAGEA,
        phpage: ?*?HPROPSHEETPAGE,
    },
    pfnCallback: ?PFNPROPSHEETCALLBACK,
};

pub const PROPSHEETHEADERA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u8,
    },
    pszCaption: ?[*:0]const u8,
    nPages: u32,
    Anonymous2: extern union {
        nStartPage: u32,
        pStartPage: ?[*:0]const u8,
    },
    Anonymous3: extern union {
        ppsp: ?*PROPSHEETPAGEA,
        phpage: ?*?HPROPSHEETPAGE,
    },
    pfnCallback: ?PFNPROPSHEETCALLBACK,
    Anonymous4: extern union {
        hbmWatermark: ?HBITMAP,
        pszbmWatermark: ?[*:0]const u8,
    },
    hplWatermark: ?HPALETTE,
    Anonymous5: extern union {
        hbmHeader: ?HBITMAP,
        pszbmHeader: ?[*:0]const u8,
    },
};

pub const PROPSHEETHEADERW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszCaption: ?[*:0]const u16,
    nPages: u32,
    Anonymous2: extern union {
        nStartPage: u32,
        pStartPage: ?[*:0]const u16,
    },
    Anonymous3: extern union {
        ppsp: ?*PROPSHEETPAGEW,
        phpage: ?*?HPROPSHEETPAGE,
    },
    pfnCallback: ?PFNPROPSHEETCALLBACK,
};

pub const PROPSHEETHEADERW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    hInstance: ?HINSTANCE,
    Anonymous1: extern union {
        hIcon: ?HICON,
        pszIcon: ?[*:0]const u16,
    },
    pszCaption: ?[*:0]const u16,
    nPages: u32,
    Anonymous2: extern union {
        nStartPage: u32,
        pStartPage: ?[*:0]const u16,
    },
    Anonymous3: extern union {
        ppsp: ?*PROPSHEETPAGEW,
        phpage: ?*?HPROPSHEETPAGE,
    },
    pfnCallback: ?PFNPROPSHEETCALLBACK,
    Anonymous4: extern union {
        hbmWatermark: ?HBITMAP,
        pszbmWatermark: ?[*:0]const u16,
    },
    hplWatermark: ?HPALETTE,
    Anonymous5: extern union {
        hbmHeader: ?HBITMAP,
        pszbmHeader: ?[*:0]const u16,
    },
};

pub const LPFNSVADDPROPSHEETPAGE = fn(
    param0: ?HPROPSHEETPAGE,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNADDPROPSHEETPAGES = fn(
    param0: ?*c_void,
    param1: ?LPFNSVADDPROPSHEETPAGE,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSHNOTIFY = extern struct {
    hdr: NMHDR,
    lParam: LPARAM,
};

pub const INITCOMMONCONTROLSEX = extern struct {
    dwSize: u32,
    dwICC: INITCOMMONCONTROLSEX_ICC,
};

pub const COLORSCHEME = extern struct {
    dwSize: u32,
    clrBtnHighlight: u32,
    clrBtnShadow: u32,
};

pub const NMTOOLTIPSCREATED = extern struct {
    hdr: NMHDR,
    hwndToolTips: ?HWND,
};

pub const NMMOUSE = extern struct {
    hdr: NMHDR,
    dwItemSpec: usize,
    dwItemData: usize,
    pt: POINT,
    dwHitInfo: LPARAM,
};

pub const NMOBJECTNOTIFY = extern struct {
    hdr: NMHDR,
    iItem: i32,
    piid: ?*const Guid,
    pObject: ?*c_void,
    hResult: HRESULT,
    dwFlags: u32,
};

pub const NMKEY = extern struct {
    hdr: NMHDR,
    nVKey: u32,
    uFlags: u32,
};

pub const NMCHAR = extern struct {
    hdr: NMHDR,
    ch: u32,
    dwItemPrev: u32,
    dwItemNext: u32,
};

pub const NMCUSTOMTEXT = extern struct {
    hdr: NMHDR,
    hDC: ?HDC,
    lpString: ?[*:0]const u16,
    nCount: i32,
    lpRect: ?*RECT,
    uFormat: u32,
    fLink: BOOL,
};

pub const NMCUSTOMDRAW = extern struct {
    hdr: NMHDR,
    dwDrawStage: NMCUSTOMDRAW_DRAW_STAGE,
    hdc: ?HDC,
    rc: RECT,
    dwItemSpec: usize,
    uItemState: u32,
    lItemlParam: LPARAM,
};

pub const NMTTCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    uDrawFlags: u32,
};

pub const NMCUSTOMSPLITRECTINFO = extern struct {
    hdr: NMHDR,
    rcClient: RECT,
    rcButton: RECT,
    rcSplit: RECT,
};

pub const IMAGELISTDRAWPARAMS = extern struct {
    cbSize: u32,
    himl: ?HIMAGELIST,
    i: i32,
    hdcDst: ?HDC,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    xBitmap: i32,
    yBitmap: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
    dwRop: u32,
    fState: u32,
    Frame: u32,
    crEffect: u32,
};

pub const IMAGEINFO = extern struct {
    hbmImage: ?HBITMAP,
    hbmMask: ?HBITMAP,
    Unused1: i32,
    Unused2: i32,
    rcImage: RECT,
};

pub const HD_TEXTFILTERA = extern struct {
    pszText: ?PSTR,
    cchTextMax: i32,
};

pub const HD_TEXTFILTERW = extern struct {
    pszText: ?PWSTR,
    cchTextMax: i32,
};

pub const HDITEMA = extern struct {
    mask: HDI_MASK,
    cxy: i32,
    pszText: ?PSTR,
    hbm: ?HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: ?*c_void,
    state: u32,
};

pub const HDITEMW = extern struct {
    mask: HDI_MASK,
    cxy: i32,
    pszText: ?PWSTR,
    hbm: ?HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: ?*c_void,
    state: u32,
};

pub const HDLAYOUT = extern struct {
    prc: ?*RECT,
    pwpos: ?*WINDOWPOS,
};

pub const HDHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
};

pub const NMHEADERA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: HEADER_CONTROL_NOTIFICATION_BUTTON,
    pitem: ?*HDITEMA,
};

pub const NMHEADERW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: HEADER_CONTROL_NOTIFICATION_BUTTON,
    pitem: ?*HDITEMW,
};

pub const NMHDDISPINFOW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: HDI_MASK,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDDISPINFOA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: HDI_MASK,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDFILTERBTNCLICK = extern struct {
    hdr: NMHDR,
    iItem: i32,
    rc: RECT,
};

pub const COLORMAP = extern struct {
    from: u32,
    to: u32,
};

pub const NMTBCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    hbrMonoDither: ?HBRUSH,
    hbrLines: ?HBRUSH,
    hpenLines: ?HPEN,
    clrText: u32,
    clrMark: u32,
    clrTextHighlight: u32,
    clrBtnFace: u32,
    clrBtnHighlight: u32,
    clrHighlightHotTrack: u32,
    rcText: RECT,
    nStringBkMode: i32,
    nHLStringBkMode: i32,
    iListGap: i32,
};

pub const TBADDBITMAP = extern struct {
    hInst: ?HINSTANCE,
    nID: usize,
};

pub const TBSAVEPARAMSA = extern struct {
    hkr: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValueName: ?[*:0]const u8,
};

pub const TBSAVEPARAMSW = extern struct {
    hkr: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValueName: ?[*:0]const u16,
};

pub const TBINSERTMARK = extern struct {
    iButton: i32,
    dwFlags: TBINSERTMARK_FLAGS,
};

pub const TBREPLACEBITMAP = extern struct {
    hInstOld: ?HINSTANCE,
    nIDOld: usize,
    hInstNew: ?HINSTANCE,
    nIDNew: usize,
    nButtons: i32,
};

pub const TBBUTTONINFOA = extern struct {
    cbSize: u32,
    dwMask: TBBUTTONINFOW_MASK,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: usize,
    pszText: ?PSTR,
    cchText: i32,
};

pub const TBBUTTONINFOW = extern struct {
    cbSize: u32,
    dwMask: TBBUTTONINFOW_MASK,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: usize,
    pszText: ?PWSTR,
    cchText: i32,
};

pub const TBMETRICS = extern struct {
    cbSize: u32,
    dwMask: u32,
    cxPad: i32,
    cyPad: i32,
    cxBarPad: i32,
    cyBarPad: i32,
    cxButtonSpacing: i32,
    cyButtonSpacing: i32,
};

pub const NMTBHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: NMTBHOTITEM_FLAGS,
};

pub const NMTBSAVE = extern struct {
    hdr: NMHDR,
    pData: ?*u32,
    pCurrent: ?*u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    tbButton: TBBUTTON,
};

pub const NMTBRESTORE = extern struct {
    hdr: NMHDR,
    pData: ?*u32,
    pCurrent: ?*u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    cbBytesPerRecord: i32,
    tbButton: TBBUTTON,
};

pub const NMTBGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: ?PSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBDISPINFOA = extern struct {
    hdr: NMHDR,
    dwMask: NMTBDISPINFOW_MASK,
    idCommand: i32,
    lParam: usize,
    iImage: i32,
    pszText: ?PSTR,
    cchText: i32,
};

pub const NMTBDISPINFOW = extern struct {
    hdr: NMHDR,
    dwMask: NMTBDISPINFOW_MASK,
    idCommand: i32,
    lParam: usize,
    iImage: i32,
    pszText: ?PWSTR,
    cchText: i32,
};

pub const NMTOOLBARA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: ?PSTR,
    rcButton: RECT,
};

pub const NMTOOLBARW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: ?PWSTR,
    rcButton: RECT,
};

pub const REBARINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    himl: ?HIMAGELIST,
};

pub const REBARBANDINFOA = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: ?PSTR,
    cch: u32,
    iImage: i32,
    hwndChild: ?HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: ?HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const REBARBANDINFOW = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: ?PWSTR,
    cch: u32,
    iImage: i32,
    hwndChild: ?HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: ?HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const NMREBARCHILDSIZE = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    rcChild: RECT,
    rcBand: RECT,
};

pub const NMREBAR = extern struct {
    hdr: NMHDR,
    dwMask: NMREBAR_MASK_FLAGS,
    uBand: u32,
    fStyle: u32,
    wID: u32,
    lParam: LPARAM,
};

pub const NMRBAUTOSIZE = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    rcTarget: RECT,
    rcActual: RECT,
};

pub const NMREBARCHEVRON = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    rc: RECT,
    lParamNM: LPARAM,
};

pub const NMREBARSPLITTER = extern struct {
    hdr: NMHDR,
    rcSizing: RECT,
};

pub const NMREBARAUTOBREAK = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    uMsg: u32,
    fStyleCurrent: u32,
    fAutoBreak: BOOL,
};

pub const RBHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iBand: i32,
};

pub const TTTOOLINFOA = extern struct {
    cbSize: u32,
    uFlags: TTTOOLINFO_FLAGS,
    hwnd: ?HWND,
    uId: usize,
    rect: RECT,
    hinst: ?HINSTANCE,
    lpszText: ?PSTR,
    lParam: LPARAM,
    lpReserved: ?*c_void,
};

pub const TTTOOLINFOW = extern struct {
    cbSize: u32,
    uFlags: TTTOOLINFO_FLAGS,
    hwnd: ?HWND,
    uId: usize,
    rect: RECT,
    hinst: ?HINSTANCE,
    lpszText: ?PWSTR,
    lParam: LPARAM,
    lpReserved: ?*c_void,
};

pub const TTGETTITLE = extern struct {
    dwSize: u32,
    uTitleBitmap: u32,
    cch: u32,
    pszTitle: ?PWSTR,
};

pub const TTHITTESTINFOA = extern struct {
    hwnd: ?HWND,
    pt: POINT,
    ti: TTTOOLINFOA,
};

pub const TTHITTESTINFOW = extern struct {
    hwnd: ?HWND,
    pt: POINT,
    ti: TTTOOLINFOW,
};

pub const NMTTDISPINFOA = extern struct {
    hdr: NMHDR,
    lpszText: ?PSTR,
    szText: [80]CHAR,
    hinst: ?HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTTDISPINFOW = extern struct {
    hdr: NMHDR,
    lpszText: ?PWSTR,
    szText: [80]u16,
    hinst: ?HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTRBTHUMBPOSCHANGING = extern struct {
    hdr: NMHDR,
    dwPos: u32,
    nReason: i32,
};

pub const DRAGLISTINFO = extern struct {
    uNotification: DRAGLISTINFO_NOTIFICATION_FLAGS,
    hWnd: ?HWND,
    ptCursor: POINT,
};

pub const UDACCEL = extern struct {
    nSec: u32,
    nInc: u32,
};

pub const NMUPDOWN = extern struct {
    hdr: NMHDR,
    iPos: i32,
    iDelta: i32,
};

pub const PBRANGE = extern struct {
    iLow: i32,
    iHigh: i32,
};

pub const LITEM = extern struct {
    mask: u32,
    iLink: i32,
    state: u32,
    stateMask: u32,
    szID: [48]u16,
    szUrl: [2084]u16,
};

pub const LHITTESTINFO = extern struct {
    pt: POINT,
    item: LITEM,
};

pub const NMLINK = extern struct {
    hdr: NMHDR,
    item: LITEM,
};

pub const LVITEMA = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: LVITEMA_GROUP_ID,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
    iGroup: i32,
};

pub const LVITEMW = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: LVITEMA_GROUP_ID,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
    iGroup: i32,
};

pub const LVFINDINFOA = extern struct {
    flags: LVFINDINFOW_FLAGS,
    psz: ?[*:0]const u8,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVFINDINFOW = extern struct {
    flags: LVFINDINFOW_FLAGS,
    psz: ?[*:0]const u16,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVHITTESTINFO = extern struct {
    pt: POINT,
    flags: LVHITTESTINFO_FLAGS,
    iItem: i32,
    iSubItem: i32,
    iGroup: i32,
};

pub const LVCOLUMNA = extern struct {
    mask: LVCOLUMNW_MASK,
    fmt: LVCOLUMNW_FORMAT,
    cx: i32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const LVCOLUMNW = extern struct {
    mask: LVCOLUMNW_MASK,
    fmt: LVCOLUMNW_FORMAT,
    cx: i32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const PFNLVCOMPARE = fn(
    param0: LPARAM,
    param1: LPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVBKIMAGEA = extern struct {
    ulFlags: u32,
    hbm: ?HBITMAP,
    pszImage: ?PSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVBKIMAGEW = extern struct {
    ulFlags: u32,
    hbm: ?HBITMAP,
    pszImage: ?PWSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVGROUP = extern struct {
    cbSize: u32,
    mask: LVGROUP_MASK,
    pszHeader: ?PWSTR,
    cchHeader: i32,
    pszFooter: ?PWSTR,
    cchFooter: i32,
    iGroupId: i32,
    stateMask: u32,
    state: u32,
    uAlign: u32,
    pszSubtitle: ?PWSTR,
    cchSubtitle: u32,
    pszTask: ?PWSTR,
    cchTask: u32,
    pszDescriptionTop: ?PWSTR,
    cchDescriptionTop: u32,
    pszDescriptionBottom: ?PWSTR,
    cchDescriptionBottom: u32,
    iTitleImage: i32,
    iExtendedImage: i32,
    iFirstItem: i32,
    cItems: u32,
    pszSubsetTitle: ?PWSTR,
    cchSubsetTitle: u32,
};

pub const LVGROUPMETRICS = extern struct {
    cbSize: u32,
    mask: u32,
    Left: u32,
    Top: u32,
    Right: u32,
    Bottom: u32,
    crLeft: u32,
    crTop: u32,
    crRight: u32,
    crBottom: u32,
    crHeader: u32,
    crFooter: u32,
};

pub const PFNLVGROUPCOMPARE = fn(
    param0: i32,
    param1: i32,
    param2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVINSERTGROUPSORTED = extern struct {
    pfnGroupCompare: ?PFNLVGROUPCOMPARE,
    pvData: ?*c_void,
    lvGroup: LVGROUP,
};

pub const LVTILEVIEWINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwFlags: LVTILEVIEWINFO_FLAGS,
    sizeTile: SIZE,
    cLines: i32,
    rcLabelMargin: RECT,
};

pub const LVTILEINFO = extern struct {
    cbSize: u32,
    iItem: i32,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
};

pub const LVINSERTMARK = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iItem: i32,
    dwReserved: u32,
};

pub const LVSETINFOTIP = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pszText: ?PWSTR,
    iItem: i32,
    iSubItem: i32,
};

pub const LVFOOTERINFO = extern struct {
    mask: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    cItems: u32,
};

pub const LVFOOTERITEM = extern struct {
    mask: LVFOOTERITEM_MASK,
    iItem: i32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    state: u32,
    stateMask: u32,
};

pub const LVITEMINDEX = extern struct {
    iItem: i32,
    iGroup: i32,
};

pub const NMLISTVIEW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
};

pub const NMITEMACTIVATE = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
    uKeyFlags: u32,
};

pub const NMLVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iSubItem: i32,
    dwItemType: NMLVCUSTOMDRAW_ITEM_TYPE,
    clrFace: u32,
    iIconEffect: i32,
    iIconPhase: i32,
    iPartId: i32,
    iStateId: i32,
    rcText: RECT,
    uAlign: NMLVCUSTOMDRAW_ALIGN,
};

pub const NMLVCACHEHINT = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
};

pub const NMLVFINDITEMA = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOA,
};

pub const NMLVFINDITEMW = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOW,
};

pub const NMLVODSTATECHANGE = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
    uNewState: u32,
    uOldState: u32,
};

pub const NMLVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: LVITEMA,
};

pub const NMLVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: LVITEMW,
};

pub const NMLVKEYDOWN = packed struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMLVLINK = extern struct {
    hdr: NMHDR,
    link: LITEM,
    iItem: i32,
    iSubItem: i32,
};

pub const NMLVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVSCROLL = extern struct {
    hdr: NMHDR,
    dx: i32,
    dy: i32,
};

pub const NMLVEMPTYMARKUP = extern struct {
    hdr: NMHDR,
    dwFlags: NMLVEMPTYMARKUP_FLAGS,
    szMarkup: [2084]u16,
};

pub const NMTVSTATEIMAGECHANGING = extern struct {
    hdr: NMHDR,
    hti: ?*_TREEITEM,
    iOldStateImageIndex: i32,
    iNewStateImageIndex: i32,
};

pub const TVITEMA = extern struct {
    mask: TVITEM_MASK,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
};

pub const TVITEMW = extern struct {
    mask: TVITEM_MASK,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
};

pub const TVITEMEXA = extern struct {
    mask: TVITEM_MASK,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: ?HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVITEMEXW = extern struct {
    mask: TVITEM_MASK,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: ?HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVINSERTSTRUCTA = extern struct {
    hParent: ?*_TREEITEM,
    hInsertAfter: ?*_TREEITEM,
    Anonymous: extern union {
        itemex: TVITEMEXA,
        item: TVITEMA,
    },
};

pub const TVINSERTSTRUCTW = extern struct {
    hParent: ?*_TREEITEM,
    hInsertAfter: ?*_TREEITEM,
    Anonymous: extern union {
        itemex: TVITEMEXW,
        item: TVITEMW,
    },
};

pub const TVHITTESTINFO = extern struct {
    pt: POINT,
    flags: TVHITTESTINFO_FLAGS,
    hItem: ?*_TREEITEM,
};

pub const TVITEMPART = enum(i32) {
    N = 1,
};
pub const TVGIPR_BUTTON = TVITEMPART.N;

pub const TVGETITEMPARTRECTINFO = extern struct {
    hti: ?*_TREEITEM,
    prc: ?*RECT,
    partID: TVITEMPART,
};

pub const PFNTVCOMPARE = fn(
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParamSort: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const TVSORTCB = extern struct {
    hParent: ?*_TREEITEM,
    lpfnCompare: ?PFNTVCOMPARE,
    lParam: LPARAM,
};

pub const NMTREEVIEWA = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMA,
    itemNew: TVITEMA,
    ptDrag: POINT,
};

pub const NMTREEVIEWW = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMW,
    itemNew: TVITEMW,
    ptDrag: POINT,
};

pub const NMTVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: TVITEMA,
};

pub const NMTVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: TVITEMW,
};

pub const NMTVDISPINFOEXA = extern struct {
    hdr: NMHDR,
    item: TVITEMEXA,
};

pub const NMTVDISPINFOEXW = extern struct {
    hdr: NMHDR,
    item: TVITEMEXW,
};

pub const NMTVKEYDOWN = packed struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMTVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iLevel: i32,
};

pub const NMTVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: ?PSTR,
    cchTextMax: i32,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: ?PWSTR,
    cchTextMax: i32,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVITEMCHANGE = extern struct {
    hdr: NMHDR,
    uChanged: u32,
    hItem: ?*_TREEITEM,
    uStateNew: u32,
    uStateOld: u32,
    lParam: LPARAM,
};

pub const NMTVASYNCDRAW = extern struct {
    hdr: NMHDR,
    pimldp: ?*IMAGELISTDRAWPARAMS,
    hr: HRESULT,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
    dwRetFlags: u32,
    iRetImageIndex: i32,
};

pub const COMBOBOXEXITEMA = extern struct {
    mask: COMBOBOX_EX_ITEM_FLAGS,
    iItem: isize,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const COMBOBOXEXITEMW = extern struct {
    mask: COMBOBOX_EX_ITEM_FLAGS,
    iItem: isize,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const NMCOMBOBOXEXA = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMA,
};

pub const NMCOMBOBOXEXW = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMW,
};

pub const NMCBEDRAGBEGINW = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]u16,
};

pub const NMCBEDRAGBEGINA = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]CHAR,
};

pub const NMCBEENDEDITW = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]u16,
    iWhy: i32,
};

pub const NMCBEENDEDITA = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]CHAR,
    iWhy: i32,
};

pub const TCITEMHEADERA = extern struct {
    mask: TCITEMHEADERA_MASK,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMHEADERW = extern struct {
    mask: TCITEMHEADERA_MASK,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMA = extern struct {
    mask: TCITEMHEADERA_MASK,
    dwState: u32,
    dwStateMask: u32,
    pszText: ?PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCITEMW = extern struct {
    mask: TCITEMHEADERA_MASK,
    dwState: u32,
    dwStateMask: u32,
    pszText: ?PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCHITTESTINFO = extern struct {
    pt: POINT,
    flags: TCHITTESTINFO_FLAGS,
};

pub const NMTCKEYDOWN = packed struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const MCHITTESTINFO = extern struct {
    cbSize: u32,
    pt: POINT,
    uHit: u32,
    st: SYSTEMTIME,
    rc: RECT,
    iOffset: i32,
    iRow: i32,
    iCol: i32,
};

pub const MCGRIDINFO = extern struct {
    cbSize: u32,
    dwPart: MCGRIDINFO_PART,
    dwFlags: MCGRIDINFO_FLAGS,
    iCalendar: i32,
    iRow: i32,
    iCol: i32,
    bSelected: BOOL,
    stStart: SYSTEMTIME,
    stEnd: SYSTEMTIME,
    rc: RECT,
    pszName: ?PWSTR,
    cchName: usize,
};

pub const NMSELCHANGE = extern struct {
    nmhdr: NMHDR,
    stSelStart: SYSTEMTIME,
    stSelEnd: SYSTEMTIME,
};

pub const NMDAYSTATE = extern struct {
    nmhdr: NMHDR,
    stStart: SYSTEMTIME,
    cDayState: i32,
    prgDayState: ?*u32,
};

pub const NMVIEWCHANGE = extern struct {
    nmhdr: NMHDR,
    dwOldView: u32,
    dwNewView: u32,
};

pub const DATETIMEPICKERINFO = extern struct {
    cbSize: u32,
    rcCheck: RECT,
    stateCheck: u32,
    rcButton: RECT,
    stateButton: u32,
    hwndEdit: ?HWND,
    hwndUD: ?HWND,
    hwndDropDown: ?HWND,
};

pub const NMDATETIMECHANGE = extern struct {
    nmhdr: NMHDR,
    dwFlags: u32,
    st: SYSTEMTIME,
};

pub const NMDATETIMESTRINGA = extern struct {
    nmhdr: NMHDR,
    pszUserString: ?[*:0]const u8,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMESTRINGW = extern struct {
    nmhdr: NMHDR,
    pszUserString: ?[*:0]const u16,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMEWMKEYDOWNA = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: ?[*:0]const u8,
    st: SYSTEMTIME,
};

pub const NMDATETIMEWMKEYDOWNW = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: ?[*:0]const u16,
    st: SYSTEMTIME,
};

pub const NMDATETIMEFORMATA = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?[*:0]const u8,
    st: SYSTEMTIME,
    pszDisplay: ?[*:0]const u8,
    szDisplay: [64]CHAR,
};

pub const NMDATETIMEFORMATW = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?[*:0]const u16,
    st: SYSTEMTIME,
    pszDisplay: ?[*:0]const u16,
    szDisplay: [64]u16,
};

pub const NMDATETIMEFORMATQUERYA = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?[*:0]const u8,
    szMax: SIZE,
};

pub const NMDATETIMEFORMATQUERYW = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?[*:0]const u16,
    szMax: SIZE,
};

pub const NMIPADDRESS = extern struct {
    hdr: NMHDR,
    iField: i32,
    iValue: i32,
};

pub const NMPGSCROLL = packed struct {
    hdr: NMHDR,
    fwKeys: NMPGSCROLL_KEYS,
    rcParent: RECT,
    iDir: NMPGSCROLL_DIR,
    iXpos: i32,
    iYpos: i32,
    iScroll: i32,
};

pub const NMPGCALCSIZE = extern struct {
    hdr: NMHDR,
    dwFlag: NMPGCALCSIZE_FLAGS,
    iWidth: i32,
    iHeight: i32,
};

pub const NMPGHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};

pub const BUTTON_IMAGELIST = extern struct {
    himl: ?HIMAGELIST,
    margin: RECT,
    uAlign: BUTTON_IMAGELIST_ALIGN,
};

pub const NMBCHOTITEM = extern struct {
    hdr: NMHDR,
    dwFlags: NMTBHOTITEM_FLAGS,
};

pub const BUTTON_SPLITINFO = extern struct {
    mask: u32,
    himlGlyph: ?HIMAGELIST,
    uSplitStyle: u32,
    size: SIZE,
};

pub const NMBCDROPDOWN = extern struct {
    hdr: NMHDR,
    rcButton: RECT,
};

pub const EDITBALLOONTIP = extern struct {
    cbStruct: u32,
    pszTitle: ?[*:0]const u16,
    pszText: ?[*:0]const u16,
    ttiIcon: EDITBALLOONTIP_ICON,
};

pub const EC_ENDOFLINE = enum(i32) {
    DETECTFROMCONTENT = 0,
    CRLF = 1,
    CR = 2,
    LF = 3,
};
pub const EC_ENDOFLINE_DETECTFROMCONTENT = EC_ENDOFLINE.DETECTFROMCONTENT;
pub const EC_ENDOFLINE_CRLF = EC_ENDOFLINE.CRLF;
pub const EC_ENDOFLINE_CR = EC_ENDOFLINE.CR;
pub const EC_ENDOFLINE_LF = EC_ENDOFLINE.LF;

pub const EC_SEARCHWEB_ENTRYPOINT = enum(i32) {
    EXTERNAL = 0,
    CONTEXTMENU = 1,
};
pub const EC_SEARCHWEB_ENTRYPOINT_EXTERNAL = EC_SEARCHWEB_ENTRYPOINT.EXTERNAL;
pub const EC_SEARCHWEB_ENTRYPOINT_CONTEXTMENU = EC_SEARCHWEB_ENTRYPOINT.CONTEXTMENU;

pub const NMSEARCHWEB = extern struct {
    hdr: NMHDR,
    entrypoint: EC_SEARCHWEB_ENTRYPOINT,
    hasQueryText: BOOL,
    invokeSucceeded: BOOL,
};

pub const PFTASKDIALOGCALLBACK = fn(
    hwnd: ?HWND,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    lpRefData: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const TASKDIALOG_FLAGS = enum(i32) {
    ENABLE_HYPERLINKS = 1,
    USE_HICON_MAIN = 2,
    USE_HICON_FOOTER = 4,
    ALLOW_DIALOG_CANCELLATION = 8,
    USE_COMMAND_LINKS = 16,
    USE_COMMAND_LINKS_NO_ICON = 32,
    EXPAND_FOOTER_AREA = 64,
    EXPANDED_BY_DEFAULT = 128,
    VERIFICATION_FLAG_CHECKED = 256,
    SHOW_PROGRESS_BAR = 512,
    SHOW_MARQUEE_PROGRESS_BAR = 1024,
    CALLBACK_TIMER = 2048,
    POSITION_RELATIVE_TO_WINDOW = 4096,
    RTL_LAYOUT = 8192,
    NO_DEFAULT_RADIO_BUTTON = 16384,
    CAN_BE_MINIMIZED = 32768,
    NO_SET_FOREGROUND = 65536,
    SIZE_TO_CONTENT = 16777216,
};
pub const TDF_ENABLE_HYPERLINKS = TASKDIALOG_FLAGS.ENABLE_HYPERLINKS;
pub const TDF_USE_HICON_MAIN = TASKDIALOG_FLAGS.USE_HICON_MAIN;
pub const TDF_USE_HICON_FOOTER = TASKDIALOG_FLAGS.USE_HICON_FOOTER;
pub const TDF_ALLOW_DIALOG_CANCELLATION = TASKDIALOG_FLAGS.ALLOW_DIALOG_CANCELLATION;
pub const TDF_USE_COMMAND_LINKS = TASKDIALOG_FLAGS.USE_COMMAND_LINKS;
pub const TDF_USE_COMMAND_LINKS_NO_ICON = TASKDIALOG_FLAGS.USE_COMMAND_LINKS_NO_ICON;
pub const TDF_EXPAND_FOOTER_AREA = TASKDIALOG_FLAGS.EXPAND_FOOTER_AREA;
pub const TDF_EXPANDED_BY_DEFAULT = TASKDIALOG_FLAGS.EXPANDED_BY_DEFAULT;
pub const TDF_VERIFICATION_FLAG_CHECKED = TASKDIALOG_FLAGS.VERIFICATION_FLAG_CHECKED;
pub const TDF_SHOW_PROGRESS_BAR = TASKDIALOG_FLAGS.SHOW_PROGRESS_BAR;
pub const TDF_SHOW_MARQUEE_PROGRESS_BAR = TASKDIALOG_FLAGS.SHOW_MARQUEE_PROGRESS_BAR;
pub const TDF_CALLBACK_TIMER = TASKDIALOG_FLAGS.CALLBACK_TIMER;
pub const TDF_POSITION_RELATIVE_TO_WINDOW = TASKDIALOG_FLAGS.POSITION_RELATIVE_TO_WINDOW;
pub const TDF_RTL_LAYOUT = TASKDIALOG_FLAGS.RTL_LAYOUT;
pub const TDF_NO_DEFAULT_RADIO_BUTTON = TASKDIALOG_FLAGS.NO_DEFAULT_RADIO_BUTTON;
pub const TDF_CAN_BE_MINIMIZED = TASKDIALOG_FLAGS.CAN_BE_MINIMIZED;
pub const TDF_NO_SET_FOREGROUND = TASKDIALOG_FLAGS.NO_SET_FOREGROUND;
pub const TDF_SIZE_TO_CONTENT = TASKDIALOG_FLAGS.SIZE_TO_CONTENT;

pub const TASKDIALOG_MESSAGES = enum(i32) {
    NAVIGATE_PAGE = 1125,
    CLICK_BUTTON = 1126,
    SET_MARQUEE_PROGRESS_BAR = 1127,
    SET_PROGRESS_BAR_STATE = 1128,
    SET_PROGRESS_BAR_RANGE = 1129,
    SET_PROGRESS_BAR_POS = 1130,
    SET_PROGRESS_BAR_MARQUEE = 1131,
    SET_ELEMENT_TEXT = 1132,
    CLICK_RADIO_BUTTON = 1134,
    ENABLE_BUTTON = 1135,
    ENABLE_RADIO_BUTTON = 1136,
    CLICK_VERIFICATION = 1137,
    UPDATE_ELEMENT_TEXT = 1138,
    SET_BUTTON_ELEVATION_REQUIRED_STATE = 1139,
    UPDATE_ICON = 1140,
};
pub const TDM_NAVIGATE_PAGE = TASKDIALOG_MESSAGES.NAVIGATE_PAGE;
pub const TDM_CLICK_BUTTON = TASKDIALOG_MESSAGES.CLICK_BUTTON;
pub const TDM_SET_MARQUEE_PROGRESS_BAR = TASKDIALOG_MESSAGES.SET_MARQUEE_PROGRESS_BAR;
pub const TDM_SET_PROGRESS_BAR_STATE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_STATE;
pub const TDM_SET_PROGRESS_BAR_RANGE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_RANGE;
pub const TDM_SET_PROGRESS_BAR_POS = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_POS;
pub const TDM_SET_PROGRESS_BAR_MARQUEE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_MARQUEE;
pub const TDM_SET_ELEMENT_TEXT = TASKDIALOG_MESSAGES.SET_ELEMENT_TEXT;
pub const TDM_CLICK_RADIO_BUTTON = TASKDIALOG_MESSAGES.CLICK_RADIO_BUTTON;
pub const TDM_ENABLE_BUTTON = TASKDIALOG_MESSAGES.ENABLE_BUTTON;
pub const TDM_ENABLE_RADIO_BUTTON = TASKDIALOG_MESSAGES.ENABLE_RADIO_BUTTON;
pub const TDM_CLICK_VERIFICATION = TASKDIALOG_MESSAGES.CLICK_VERIFICATION;
pub const TDM_UPDATE_ELEMENT_TEXT = TASKDIALOG_MESSAGES.UPDATE_ELEMENT_TEXT;
pub const TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = TASKDIALOG_MESSAGES.SET_BUTTON_ELEVATION_REQUIRED_STATE;
pub const TDM_UPDATE_ICON = TASKDIALOG_MESSAGES.UPDATE_ICON;

pub const TASKDIALOG_NOTIFICATIONS = enum(i32) {
    CREATED = 0,
    NAVIGATED = 1,
    BUTTON_CLICKED = 2,
    HYPERLINK_CLICKED = 3,
    TIMER = 4,
    DESTROYED = 5,
    RADIO_BUTTON_CLICKED = 6,
    DIALOG_CONSTRUCTED = 7,
    VERIFICATION_CLICKED = 8,
    HELP = 9,
    EXPANDO_BUTTON_CLICKED = 10,
};
pub const TDN_CREATED = TASKDIALOG_NOTIFICATIONS.CREATED;
pub const TDN_NAVIGATED = TASKDIALOG_NOTIFICATIONS.NAVIGATED;
pub const TDN_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.BUTTON_CLICKED;
pub const TDN_HYPERLINK_CLICKED = TASKDIALOG_NOTIFICATIONS.HYPERLINK_CLICKED;
pub const TDN_TIMER = TASKDIALOG_NOTIFICATIONS.TIMER;
pub const TDN_DESTROYED = TASKDIALOG_NOTIFICATIONS.DESTROYED;
pub const TDN_RADIO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.RADIO_BUTTON_CLICKED;
pub const TDN_DIALOG_CONSTRUCTED = TASKDIALOG_NOTIFICATIONS.DIALOG_CONSTRUCTED;
pub const TDN_VERIFICATION_CLICKED = TASKDIALOG_NOTIFICATIONS.VERIFICATION_CLICKED;
pub const TDN_HELP = TASKDIALOG_NOTIFICATIONS.HELP;
pub const TDN_EXPANDO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.EXPANDO_BUTTON_CLICKED;

pub const TASKDIALOG_BUTTON = packed struct {
    nButtonID: i32,
    pszButtonText: ?[*:0]const u16,
};

pub const TASKDIALOG_ELEMENTS = enum(i32) {
    CONTENT = 0,
    EXPANDED_INFORMATION = 1,
    FOOTER = 2,
    MAIN_INSTRUCTION = 3,
};
pub const TDE_CONTENT = TASKDIALOG_ELEMENTS.CONTENT;
pub const TDE_EXPANDED_INFORMATION = TASKDIALOG_ELEMENTS.EXPANDED_INFORMATION;
pub const TDE_FOOTER = TASKDIALOG_ELEMENTS.FOOTER;
pub const TDE_MAIN_INSTRUCTION = TASKDIALOG_ELEMENTS.MAIN_INSTRUCTION;

pub const TASKDIALOG_ICON_ELEMENTS = enum(i32) {
    MAIN = 0,
    FOOTER = 1,
};
pub const TDIE_ICON_MAIN = TASKDIALOG_ICON_ELEMENTS.MAIN;
pub const TDIE_ICON_FOOTER = TASKDIALOG_ICON_ELEMENTS.FOOTER;

pub const TASKDIALOG_COMMON_BUTTON_FLAGS = enum(i32) {
    OK_BUTTON = 1,
    YES_BUTTON = 2,
    NO_BUTTON = 4,
    CANCEL_BUTTON = 8,
    RETRY_BUTTON = 16,
    CLOSE_BUTTON = 32,
};
pub const TDCBF_OK_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.OK_BUTTON;
pub const TDCBF_YES_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.YES_BUTTON;
pub const TDCBF_NO_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.NO_BUTTON;
pub const TDCBF_CANCEL_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.CANCEL_BUTTON;
pub const TDCBF_RETRY_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.RETRY_BUTTON;
pub const TDCBF_CLOSE_BUTTON = TASKDIALOG_COMMON_BUTTON_FLAGS.CLOSE_BUTTON;

pub const TASKDIALOGCONFIG = packed struct {
    cbSize: u32,
    hwndParent: ?HWND,
    hInstance: ?HINSTANCE,
    dwFlags: TASKDIALOG_FLAGS,
    dwCommonButtons: TASKDIALOG_COMMON_BUTTON_FLAGS,
    pszWindowTitle: ?[*:0]const u16,
    Anonymous1: packed union {
        hMainIcon: ?HICON,
        pszMainIcon: ?[*:0]const u16,
    },
    pszMainInstruction: ?[*:0]const u16,
    pszContent: ?[*:0]const u16,
    cButtons: u32,
    pButtons: ?*const TASKDIALOG_BUTTON,
    nDefaultButton: i32,
    cRadioButtons: u32,
    pRadioButtons: ?*const TASKDIALOG_BUTTON,
    nDefaultRadioButton: i32,
    pszVerificationText: ?[*:0]const u16,
    pszExpandedInformation: ?[*:0]const u16,
    pszExpandedControlText: ?[*:0]const u16,
    pszCollapsedControlText: ?[*:0]const u16,
    Anonymous2: packed union {
        hFooterIcon: ?HICON,
        pszFooterIcon: ?[*:0]const u16,
    },
    pszFooter: ?[*:0]const u16,
    pfCallback: ?PFTASKDIALOGCALLBACK,
    lpCallbackData: isize,
    cxWidth: u32,
};

pub const PFNDAENUMCALLBACK = fn(
    p: ?*c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDAENUMCALLBACKCONST = fn(
    p: ?*const c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARE = fn(
    p1: ?*c_void,
    p2: ?*c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARECONST = fn(
    p1: ?*const c_void,
    p2: ?*const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DPASTREAMINFO = extern struct {
    iPos: i32,
    pvItem: ?*c_void,
};

pub const PFNDPASTREAM = fn(
    pinfo: ?*DPASTREAMINFO,
    pstream: ?*IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDPAMERGE = fn(
    uMsg: DPAMM_MESSAGE,
    pvDest: ?*c_void,
    pvSrc: ?*c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFNDPAMERGECONST = fn(
    uMsg: DPAMM_MESSAGE,
    pvDest: ?*const c_void,
    pvSrc: ?*const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const _LI_METRIC = enum(i32) {
    SMALL = 0,
    LARGE = 1,
};
pub const LIM_SMALL = _LI_METRIC.SMALL;
pub const LIM_LARGE = _LI_METRIC.LARGE;

const CLSID_ImageList_Value = @import("../zig.zig").Guid.initString("7c476ba2-02b1-48f4-8048-b24619ddc058");
pub const CLSID_ImageList = &CLSID_ImageList_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList_Value = @import("../zig.zig").Guid.initString("46eb5926-582e-4017-9fdf-e8998daa0950");
pub const IID_IImageList = &IID_IImageList_Value;
pub const IImageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const IImageList,
            hbmImage: ?HBITMAP,
            hbmMask: ?HBITMAP,
            pi: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceIcon: fn(
            self: *const IImageList,
            i: i32,
            hicon: ?HICON,
            pi: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayImage: fn(
            self: *const IImageList,
            iImage: i32,
            iOverlay: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace: fn(
            self: *const IImageList,
            i: i32,
            hbmImage: ?HBITMAP,
            hbmMask: ?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMasked: fn(
            self: *const IImageList,
            hbmImage: ?HBITMAP,
            crMask: u32,
            pi: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Draw: fn(
            self: *const IImageList,
            pimldp: ?*IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IImageList,
            i: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const IImageList,
            i: i32,
            flags: u32,
            picon: ?*?HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageInfo: fn(
            self: *const IImageList,
            i: i32,
            pImageInfo: ?*IMAGEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IImageList,
            iDst: i32,
            punkSrc: ?*IUnknown,
            iSrc: i32,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: fn(
            self: *const IImageList,
            i1: i32,
            punk2: ?*IUnknown,
            i2: i32,
            dx: i32,
            dy: i32,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IImageList,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageRect: fn(
            self: *const IImageList,
            i: i32,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconSize: fn(
            self: *const IImageList,
            cx: ?*i32,
            cy: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconSize: fn(
            self: *const IImageList,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageCount: fn(
            self: *const IImageList,
            pi: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImageCount: fn(
            self: *const IImageList,
            uNewCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBkColor: fn(
            self: *const IImageList,
            clrBk: u32,
            pclr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBkColor: fn(
            self: *const IImageList,
            pclr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDrag: fn(
            self: *const IImageList,
            iTrack: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDrag: fn(
            self: *const IImageList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragEnter: fn(
            self: *const IImageList,
            hwndLock: ?HWND,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeave: fn(
            self: *const IImageList,
            hwndLock: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragMove: fn(
            self: *const IImageList,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDragCursorImage: fn(
            self: *const IImageList,
            punk: ?*IUnknown,
            iDrag: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragShowNolock: fn(
            self: *const IImageList,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragImage: fn(
            self: *const IImageList,
            ppt: ?*POINT,
            pptHotspot: ?*POINT,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFlags: fn(
            self: *const IImageList,
            i: i32,
            dwFlags: ?*IMAGE_LIST_ITEM_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayImage: fn(
            self: *const IImageList,
            iOverlay: i32,
            piIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Add(self: *const T, hbmImage: ?HBITMAP, hbmMask: ?HBITMAP, pi: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Add(@ptrCast(*const IImageList, self), hbmImage, hbmMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ReplaceIcon(self: *const T, i: i32, hicon: ?HICON, pi: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ReplaceIcon(@ptrCast(*const IImageList, self), i, hicon, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetOverlayImage(self: *const T, iImage: i32, iOverlay: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetOverlayImage(@ptrCast(*const IImageList, self), iImage, iOverlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Replace(self: *const T, i: i32, hbmImage: ?HBITMAP, hbmMask: ?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Replace(@ptrCast(*const IImageList, self), i, hbmImage, hbmMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_AddMasked(self: *const T, hbmImage: ?HBITMAP, crMask: u32, pi: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).AddMasked(@ptrCast(*const IImageList, self), hbmImage, crMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Draw(self: *const T, pimldp: ?*IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Draw(@ptrCast(*const IImageList, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Remove(self: *const T, i: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Remove(@ptrCast(*const IImageList, self), i);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIcon(self: *const T, i: i32, flags: u32, picon: ?*?HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIcon(@ptrCast(*const IImageList, self), i, flags, picon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageInfo(self: *const T, i: i32, pImageInfo: ?*IMAGEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageInfo(@ptrCast(*const IImageList, self), i, pImageInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Copy(self: *const T, iDst: i32, punkSrc: ?*IUnknown, iSrc: i32, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Copy(@ptrCast(*const IImageList, self), iDst, punkSrc, iSrc, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Merge(self: *const T, i1_: i32, punk2: ?*IUnknown, i2_: i32, dx: i32, dy: i32, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Merge(@ptrCast(*const IImageList, self), i1_, punk2, i2_, dx, dy, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Clone(self: *const T, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Clone(@ptrCast(*const IImageList, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageRect(self: *const T, i: i32, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageRect(@ptrCast(*const IImageList, self), i, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIconSize(self: *const T, cx: ?*i32, cy: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetIconSize(self: *const T, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageCount(self: *const T, pi: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageCount(@ptrCast(*const IImageList, self), pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetImageCount(self: *const T, uNewCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetImageCount(@ptrCast(*const IImageList, self), uNewCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetBkColor(self: *const T, clrBk: u32, pclr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetBkColor(@ptrCast(*const IImageList, self), clrBk, pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetBkColor(self: *const T, pclr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetBkColor(@ptrCast(*const IImageList, self), pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_BeginDrag(self: *const T, iTrack: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).BeginDrag(@ptrCast(*const IImageList, self), iTrack, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_EndDrag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).EndDrag(@ptrCast(*const IImageList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragEnter(self: *const T, hwndLock: ?HWND, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragEnter(@ptrCast(*const IImageList, self), hwndLock, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragLeave(self: *const T, hwndLock: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragLeave(@ptrCast(*const IImageList, self), hwndLock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragMove(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragMove(@ptrCast(*const IImageList, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetDragCursorImage(self: *const T, punk: ?*IUnknown, iDrag: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetDragCursorImage(@ptrCast(*const IImageList, self), punk, iDrag, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragShowNolock(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragShowNolock(@ptrCast(*const IImageList, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetDragImage(self: *const T, ppt: ?*POINT, pptHotspot: ?*POINT, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetDragImage(@ptrCast(*const IImageList, self), ppt, pptHotspot, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetItemFlags(self: *const T, i: i32, dwFlags: ?*IMAGE_LIST_ITEM_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetItemFlags(@ptrCast(*const IImageList, self), i, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetOverlayImage(self: *const T, iOverlay: i32, piIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetOverlayImage(@ptrCast(*const IImageList, self), iOverlay, piIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAGELISTSTATS = extern struct {
    cbSize: u32,
    cAlloc: i32,
    cUsed: i32,
    cStandby: i32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList2_Value = @import("../zig.zig").Guid.initString("192b9d83-50fc-457b-90a0-2b82a8b5dae1");
pub const IID_IImageList2 = &IID_IImageList2_Value;
pub const IImageList2 = extern struct {
    pub const VTable = extern struct {
        base: IImageList.VTable,
        Resize: fn(
            self: *const IImageList2,
            cxNewIconSize: i32,
            cyNewIconSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
            pcx: ?*i32,
            pcy: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallback: fn(
            self: *const IImageList2,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallback: fn(
            self: *const IImageList2,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceImagePresent: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardImages: fn(
            self: *const IImageList2,
            iFirstImage: i32,
            iLastImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreloadImages: fn(
            self: *const IImageList2,
            pimldp: ?*IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IImageList2,
            pils: ?*IMAGELISTSTATS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IImageList2,
            cx: i32,
            cy: i32,
            flags: IMAGELIST_CREATION_FLAGS,
            cInitial: i32,
            cGrow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace2: fn(
            self: *const IImageList2,
            i: i32,
            hbmImage: ?HBITMAP,
            hbmMask: ?HBITMAP,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceFromImageList: fn(
            self: *const IImageList2,
            i: i32,
            pil: ?*IImageList,
            iSrc: i32,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IImageList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Resize(self: *const T, cxNewIconSize: i32, cyNewIconSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Resize(@ptrCast(*const IImageList2, self), cxNewIconSize, cyNewIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetOriginalSize(self: *const T, iImage: i32, dwFlags: u32, pcx: ?*i32, pcy: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetOriginalSize(@ptrCast(*const IImageList2, self), iImage, dwFlags, pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetOriginalSize(self: *const T, iImage: i32, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetOriginalSize(@ptrCast(*const IImageList2, self), iImage, cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetCallback(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetCallback(@ptrCast(*const IImageList2, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetCallback(self: *const T, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetCallback(@ptrCast(*const IImageList2, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ForceImagePresent(self: *const T, iImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ForceImagePresent(@ptrCast(*const IImageList2, self), iImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_DiscardImages(self: *const T, iFirstImage: i32, iLastImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).DiscardImages(@ptrCast(*const IImageList2, self), iFirstImage, iLastImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_PreloadImages(self: *const T, pimldp: ?*IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).PreloadImages(@ptrCast(*const IImageList2, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetStatistics(self: *const T, pils: ?*IMAGELISTSTATS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetStatistics(@ptrCast(*const IImageList2, self), pils);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Initialize(self: *const T, cx: i32, cy: i32, flags: IMAGELIST_CREATION_FLAGS, cInitial: i32, cGrow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Initialize(@ptrCast(*const IImageList2, self), cx, cy, flags, cInitial, cGrow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Replace2(self: *const T, i: i32, hbmImage: ?HBITMAP, hbmMask: ?HBITMAP, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Replace2(@ptrCast(*const IImageList2, self), i, hbmImage, hbmMask, punk, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ReplaceFromImageList(self: *const T, i: i32, pil: ?*IImageList, iSrc: i32, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ReplaceFromImageList(@ptrCast(*const IImageList2, self), i, pil, iSrc, punk, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TEXTMODE = enum(i32) {
    PLAINTEXT = 1,
    RICHTEXT = 2,
    SINGLELEVELUNDO = 4,
    MULTILEVELUNDO = 8,
    SINGLECODEPAGE = 16,
    MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: IMECOMPTEXT_FLAGS,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = fn(
    langid: u16,
    pszBefore: ?[*:0]const u16,
    pszAfter: ?PWSTR,
    cchAfter: i32,
    pcchReplaced: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EDITWORDBREAKPROCEX = fn(
    pchText: ?PSTR,
    cchText: i32,
    bCharSet: u8,
    action: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]CHAR,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const EDITSTREAMCALLBACK = fn(
    dwCookie: usize,
    pbBuff: ?*u8,
    cb: i32,
    pcb: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: PARAFORMAT_MASK,
    wNumbering: u16,
    Anonymous: extern union {
        wReserved: u16,
        wEffects: u16,
    },
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: PARAFORMAT_ALIGNMENT,
    cTabCount: i16,
    rgxTabs: [32]u32,
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: PARAFORMAT_SHADING_STYLE,
    wNumberingStart: u16,
    wNumberingStyle: PARAFORMAT_NUMBERING_STYLE,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: PARAFORMAT_BORDERS,
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const UNDONAMEID = enum(i32) {
    UNKNOWN = 0,
    TYPING = 1,
    DELETE = 2,
    DRAGDROP = 3,
    CUT = 4,
    PASTE = 5,
    AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UNKNOWN;
pub const UID_TYPING = UNDONAMEID.TYPING;
pub const UID_DELETE = UNDONAMEID.DELETE;
pub const UID_DRAGDROP = UNDONAMEID.DRAGDROP;
pub const UID_CUT = UNDONAMEID.CUT;
pub const UID_PASTE = UNDONAMEID.PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: GETTEXTLENGTHEX_FLAGS,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = enum(i32) {
    Nil = 0,
    Normal = 1,
    AddBefore = 2,
    ChangeBefore = 3,
    DeleteBefore = 4,
    ChangeAfter = 5,
    DelAndChange = 6,
};
pub const khyphNil = KHYPH.Nil;
pub const khyphNormal = KHYPH.Normal;
pub const khyphAddBefore = KHYPH.AddBefore;
pub const khyphChangeBefore = KHYPH.ChangeBefore;
pub const khyphDeleteBefore = KHYPH.DeleteBefore;
pub const khyphChangeAfter = KHYPH.ChangeAfter;
pub const khyphDelAndChange = KHYPH.DelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const tomConstants = enum(i32) {
    False = 0,
    True = -1,
    Undefined = -9999999,
    Toggle = -9999998,
    AutoColor = -9999997,
    Default = -9999996,
    Suspend = -9999995,
    Resume = -9999994,
    // ApplyNow = 0, this enum value conflicts with False
    ApplyLater = 1,
    TrackParms = 2,
    CacheParms = 3,
    ApplyTmp = 4,
    DisableSmartFont = 8,
    EnableSmartFont = 9,
    UsePoints = 10,
    UseTwips = 11,
    Backward = -1073741823,
    Forward = 1073741823,
    // Move = 0, this enum value conflicts with False
    // Extend = 1, this enum value conflicts with ApplyLater
    // NoSelection = 0, this enum value conflicts with False
    // SelectionIP = 1, this enum value conflicts with ApplyLater
    // SelectionNormal = 2, this enum value conflicts with TrackParms
    // SelectionFrame = 3, this enum value conflicts with CacheParms
    // SelectionColumn = 4, this enum value conflicts with ApplyTmp
    SelectionRow = 5,
    SelectionBlock = 6,
    SelectionInlineShape = 7,
    // SelectionShape = 8, this enum value conflicts with DisableSmartFont
    // SelStartActive = 1, this enum value conflicts with ApplyLater
    // SelAtEOL = 2, this enum value conflicts with TrackParms
    // SelOvertype = 4, this enum value conflicts with ApplyTmp
    // SelActive = 8, this enum value conflicts with DisableSmartFont
    SelReplace = 16,
    // End = 0, this enum value conflicts with False
    Start = 32,
    // CollapseEnd = 0, this enum value conflicts with False
    // CollapseStart = 1, this enum value conflicts with ApplyLater
    ClientCoord = 256,
    AllowOffClient = 512,
    Transform = 1024,
    ObjectArg = 2048,
    AtEnd = 4096,
    // None = 0, this enum value conflicts with False
    // Single = 1, this enum value conflicts with ApplyLater
    // Words = 2, this enum value conflicts with TrackParms
    // Double = 3, this enum value conflicts with CacheParms
    // Dotted = 4, this enum value conflicts with ApplyTmp
    // Dash = 5, this enum value conflicts with SelectionRow
    // DashDot = 6, this enum value conflicts with SelectionBlock
    // DashDotDot = 7, this enum value conflicts with SelectionInlineShape
    // Wave = 8, this enum value conflicts with DisableSmartFont
    // Thick = 9, this enum value conflicts with EnableSmartFont
    // Hair = 10, this enum value conflicts with UsePoints
    // DoubleWave = 11, this enum value conflicts with UseTwips
    HeavyWave = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    // ThickDashDotDot = 16, this enum value conflicts with SelReplace
    ThickDotted = 17,
    ThickLongDash = 18,
    // LineSpaceSingle = 0, this enum value conflicts with False
    // LineSpace1pt5 = 1, this enum value conflicts with ApplyLater
    // LineSpaceDouble = 2, this enum value conflicts with TrackParms
    // LineSpaceAtLeast = 3, this enum value conflicts with CacheParms
    // LineSpaceExactly = 4, this enum value conflicts with ApplyTmp
    // LineSpaceMultiple = 5, this enum value conflicts with SelectionRow
    // LineSpacePercent = 6, this enum value conflicts with SelectionBlock
    // AlignLeft = 0, this enum value conflicts with False
    // AlignCenter = 1, this enum value conflicts with ApplyLater
    // AlignRight = 2, this enum value conflicts with TrackParms
    // AlignJustify = 3, this enum value conflicts with CacheParms
    // AlignDecimal = 3, this enum value conflicts with CacheParms
    // AlignBar = 4, this enum value conflicts with ApplyTmp
    // DefaultTab = 5, this enum value conflicts with SelectionRow
    // AlignInterWord = 3, this enum value conflicts with CacheParms
    // AlignNewspaper = 4, this enum value conflicts with ApplyTmp
    // AlignInterLetter = 5, this enum value conflicts with SelectionRow
    // AlignScaled = 6, this enum value conflicts with SelectionBlock
    // Spaces = 0, this enum value conflicts with False
    // Dots = 1, this enum value conflicts with ApplyLater
    // Dashes = 2, this enum value conflicts with TrackParms
    // Lines = 3, this enum value conflicts with CacheParms
    // ThickLines = 4, this enum value conflicts with ApplyTmp
    // Equals = 5, this enum value conflicts with SelectionRow
    TabBack = -3,
    TabNext = -2,
    // TabHere = -1, this enum value conflicts with True
    // ListNone = 0, this enum value conflicts with False
    // ListBullet = 1, this enum value conflicts with ApplyLater
    // ListNumberAsArabic = 2, this enum value conflicts with TrackParms
    // ListNumberAsLCLetter = 3, this enum value conflicts with CacheParms
    // ListNumberAsUCLetter = 4, this enum value conflicts with ApplyTmp
    // ListNumberAsLCRoman = 5, this enum value conflicts with SelectionRow
    // ListNumberAsUCRoman = 6, this enum value conflicts with SelectionBlock
    // ListNumberAsSequence = 7, this enum value conflicts with SelectionInlineShape
    // ListNumberedCircle = 8, this enum value conflicts with DisableSmartFont
    // ListNumberedBlackCircleWingding = 9, this enum value conflicts with EnableSmartFont
    // ListNumberedWhiteCircleWingding = 10, this enum value conflicts with UsePoints
    // ListNumberedArabicWide = 11, this enum value conflicts with UseTwips
    // ListNumberedChS = 12, this enum value conflicts with HeavyWave
    // ListNumberedChT = 13, this enum value conflicts with LongDash
    // ListNumberedJpnChS = 14, this enum value conflicts with ThickDash
    // ListNumberedJpnKor = 15, this enum value conflicts with ThickDashDot
    // ListNumberedArabic1 = 16, this enum value conflicts with SelReplace
    // ListNumberedArabic2 = 17, this enum value conflicts with ThickDotted
    // ListNumberedHebrew = 18, this enum value conflicts with ThickLongDash
    ListNumberedThaiAlpha = 19,
    ListNumberedThaiNum = 20,
    ListNumberedHindiAlpha = 21,
    ListNumberedHindiAlpha1 = 22,
    ListNumberedHindiNum = 23,
    ListParentheses = 65536,
    ListPeriod = 131072,
    ListPlain = 196608,
    ListNoNumber = 262144,
    ListMinus = 524288,
    IgnoreNumberStyle = 16777216,
    // ParaStyleNormal = -1, this enum value conflicts with True
    // ParaStyleHeading1 = -2, this enum value conflicts with TabNext
    // ParaStyleHeading2 = -3, this enum value conflicts with TabBack
    ParaStyleHeading3 = -4,
    ParaStyleHeading4 = -5,
    ParaStyleHeading5 = -6,
    ParaStyleHeading6 = -7,
    ParaStyleHeading7 = -8,
    ParaStyleHeading8 = -9,
    ParaStyleHeading9 = -10,
    // Character = 1, this enum value conflicts with ApplyLater
    // Word = 2, this enum value conflicts with TrackParms
    // Sentence = 3, this enum value conflicts with CacheParms
    // Paragraph = 4, this enum value conflicts with ApplyTmp
    // Line = 5, this enum value conflicts with SelectionRow
    // Story = 6, this enum value conflicts with SelectionBlock
    // Screen = 7, this enum value conflicts with SelectionInlineShape
    // Section = 8, this enum value conflicts with DisableSmartFont
    // TableColumn = 9, this enum value conflicts with EnableSmartFont
    // Column = 9, this enum value conflicts with EnableSmartFont
    // Row = 10, this enum value conflicts with UsePoints
    // Window = 11, this enum value conflicts with UseTwips
    // Cell = 12, this enum value conflicts with HeavyWave
    // CharFormat = 13, this enum value conflicts with LongDash
    // ParaFormat = 14, this enum value conflicts with ThickDash
    // Table = 15, this enum value conflicts with ThickDashDot
    // Object = 16, this enum value conflicts with SelReplace
    // Page = 17, this enum value conflicts with ThickDotted
    // HardParagraph = 18, this enum value conflicts with ThickLongDash
    // Cluster = 19, this enum value conflicts with ListNumberedThaiAlpha
    // InlineObject = 20, this enum value conflicts with ListNumberedThaiNum
    // InlineObjectArg = 21, this enum value conflicts with ListNumberedHindiAlpha
    // LeafLine = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // LayoutColumn = 23, this enum value conflicts with ListNumberedHindiNum
    ProcessId = 1073741825,
    // MatchWord = 2, this enum value conflicts with TrackParms
    // MatchCase = 4, this enum value conflicts with ApplyTmp
    // MatchPattern = 8, this enum value conflicts with DisableSmartFont
    // UnknownStory = 0, this enum value conflicts with False
    // MainTextStory = 1, this enum value conflicts with ApplyLater
    // FootnotesStory = 2, this enum value conflicts with TrackParms
    // EndnotesStory = 3, this enum value conflicts with CacheParms
    // CommentsStory = 4, this enum value conflicts with ApplyTmp
    // TextFrameStory = 5, this enum value conflicts with SelectionRow
    // EvenPagesHeaderStory = 6, this enum value conflicts with SelectionBlock
    // PrimaryHeaderStory = 7, this enum value conflicts with SelectionInlineShape
    // EvenPagesFooterStory = 8, this enum value conflicts with DisableSmartFont
    // PrimaryFooterStory = 9, this enum value conflicts with EnableSmartFont
    // FirstPageHeaderStory = 10, this enum value conflicts with UsePoints
    // FirstPageFooterStory = 11, this enum value conflicts with UseTwips
    ScratchStory = 127,
    FindStory = 128,
    ReplaceStory = 129,
    // StoryInactive = 0, this enum value conflicts with False
    // StoryActiveDisplay = 1, this enum value conflicts with ApplyLater
    // StoryActiveUI = 2, this enum value conflicts with TrackParms
    // StoryActiveDisplayUI = 3, this enum value conflicts with CacheParms
    // NoAnimation = 0, this enum value conflicts with False
    // LasVegasLights = 1, this enum value conflicts with ApplyLater
    // BlinkingBackground = 2, this enum value conflicts with TrackParms
    // SparkleText = 3, this enum value conflicts with CacheParms
    // MarchingBlackAnts = 4, this enum value conflicts with ApplyTmp
    // MarchingRedAnts = 5, this enum value conflicts with SelectionRow
    // Shimmer = 6, this enum value conflicts with SelectionBlock
    // WipeDown = 7, this enum value conflicts with SelectionInlineShape
    // WipeRight = 8, this enum value conflicts with DisableSmartFont
    // AnimationMax = 8, this enum value conflicts with DisableSmartFont
    // LowerCase = 0, this enum value conflicts with False
    // UpperCase = 1, this enum value conflicts with ApplyLater
    // TitleCase = 2, this enum value conflicts with TrackParms
    // SentenceCase = 4, this enum value conflicts with ApplyTmp
    // ToggleCase = 5, this enum value conflicts with SelectionRow
    // ReadOnly = 256, this enum value conflicts with ClientCoord
    // ShareDenyRead = 512, this enum value conflicts with AllowOffClient
    // ShareDenyWrite = 1024, this enum value conflicts with Transform
    // PasteFile = 4096, this enum value conflicts with AtEnd
    // CreateNew = 16, this enum value conflicts with SelReplace
    // CreateAlways = 32, this enum value conflicts with Start
    OpenExisting = 48,
    OpenAlways = 64,
    TruncateExisting = 80,
    // RTF = 1, this enum value conflicts with ApplyLater
    // Text = 2, this enum value conflicts with TrackParms
    // HTML = 3, this enum value conflicts with CacheParms
    // WordDocument = 4, this enum value conflicts with ApplyTmp
    Bold = -2147483647,
    Italic = -2147483646,
    Underline = -2147483644,
    Strikeout = -2147483640,
    Protected = -2147483632,
    Link = -2147483616,
    SmallCaps = -2147483584,
    AllCaps = -2147483520,
    Hidden = -2147483392,
    Outline = -2147483136,
    Shadow = -2147482624,
    Emboss = -2147481600,
    Imprint = -2147479552,
    Disabled = -2147475456,
    Revised = -2147467264,
    SubscriptCF = -2147418112,
    SuperscriptCF = -2147352576,
    FontBound = -2146435072,
    LinkProtected = -2139095040,
    InlineObjectStart = -2130706432,
    ExtendedChar = -2113929216,
    AutoBackColor = -2080374784,
    MathZoneNoBuildUp = -2013265920,
    MathZone = -1879048192,
    MathZoneOrdinary = -1610612736,
    AutoTextColor = -1073741824,
    // MathZoneDisplay = 262144, this enum value conflicts with ListNoNumber
    // ParaEffectRTL = 1, this enum value conflicts with ApplyLater
    // ParaEffectKeep = 2, this enum value conflicts with TrackParms
    // ParaEffectKeepNext = 4, this enum value conflicts with ApplyTmp
    // ParaEffectPageBreakBefore = 8, this enum value conflicts with DisableSmartFont
    // ParaEffectNoLineNumber = 16, this enum value conflicts with SelReplace
    // ParaEffectNoWidowControl = 32, this enum value conflicts with Start
    // ParaEffectDoNotHyphen = 64, this enum value conflicts with OpenAlways
    // ParaEffectSideBySide = 128, this enum value conflicts with FindStory
    // ParaEffectCollapsed = 256, this enum value conflicts with ClientCoord
    // ParaEffectOutlineLevel = 512, this enum value conflicts with AllowOffClient
    // ParaEffectBox = 1024, this enum value conflicts with Transform
    // ParaEffectTableRowDelimiter = 4096, this enum value conflicts with AtEnd
    ParaEffectTable = 16384,
    // ModWidthPairs = 1, this enum value conflicts with ApplyLater
    // ModWidthSpace = 2, this enum value conflicts with TrackParms
    // AutoSpaceAlpha = 4, this enum value conflicts with ApplyTmp
    // AutoSpaceNumeric = 8, this enum value conflicts with DisableSmartFont
    // AutoSpaceParens = 16, this enum value conflicts with SelReplace
    // EmbeddedFont = 32, this enum value conflicts with Start
    // Doublestrike = 64, this enum value conflicts with OpenAlways
    // Overlapping = 128, this enum value conflicts with FindStory
    // NormalCaret = 0, this enum value conflicts with False
    // KoreanBlockCaret = 1, this enum value conflicts with ApplyLater
    // NullCaret = 2, this enum value conflicts with TrackParms
    // IncludeInset = 1, this enum value conflicts with ApplyLater
    // UnicodeBiDi = 1, this enum value conflicts with ApplyLater
    // MathCFCheck = 4, this enum value conflicts with ApplyTmp
    // Unlink = 8, this enum value conflicts with DisableSmartFont
    // Unhide = 16, this enum value conflicts with SelReplace
    // CheckTextLimit = 32, this enum value conflicts with Start
    // IgnoreCurrentFont = 0, this enum value conflicts with False
    // MatchCharRep = 1, this enum value conflicts with ApplyLater
    // MatchFontSignature = 2, this enum value conflicts with TrackParms
    // MatchAscii = 4, this enum value conflicts with ApplyTmp
    // GetHeightOnly = 8, this enum value conflicts with DisableSmartFont
    // MatchMathFont = 16, this enum value conflicts with SelReplace
    Charset = -2147483648,
    CharRepFromLcid = 1073741824,
    // Ansi = 0, this enum value conflicts with False
    // EastEurope = 1, this enum value conflicts with ApplyLater
    // Cyrillic = 2, this enum value conflicts with TrackParms
    // Greek = 3, this enum value conflicts with CacheParms
    // Turkish = 4, this enum value conflicts with ApplyTmp
    // Hebrew = 5, this enum value conflicts with SelectionRow
    // Arabic = 6, this enum value conflicts with SelectionBlock
    // Baltic = 7, this enum value conflicts with SelectionInlineShape
    // Vietnamese = 8, this enum value conflicts with DisableSmartFont
    // DefaultCharRep = 9, this enum value conflicts with EnableSmartFont
    // Symbol = 10, this enum value conflicts with UsePoints
    // Thai = 11, this enum value conflicts with UseTwips
    // ShiftJIS = 12, this enum value conflicts with HeavyWave
    // GB2312 = 13, this enum value conflicts with LongDash
    // Hangul = 14, this enum value conflicts with ThickDash
    // BIG5 = 15, this enum value conflicts with ThickDashDot
    // PC437 = 16, this enum value conflicts with SelReplace
    // OEM = 17, this enum value conflicts with ThickDotted
    // Mac = 18, this enum value conflicts with ThickLongDash
    // Armenian = 19, this enum value conflicts with ListNumberedThaiAlpha
    // Syriac = 20, this enum value conflicts with ListNumberedThaiNum
    // Thaana = 21, this enum value conflicts with ListNumberedHindiAlpha
    // Devanagari = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // Bengali = 23, this enum value conflicts with ListNumberedHindiNum
    Gurmukhi = 24,
    Gujarati = 25,
    Oriya = 26,
    Tamil = 27,
    Telugu = 28,
    Kannada = 29,
    Malayalam = 30,
    Sinhala = 31,
    // Lao = 32, this enum value conflicts with Start
    Tibetan = 33,
    Myanmar = 34,
    Georgian = 35,
    Jamo = 36,
    Ethiopic = 37,
    Cherokee = 38,
    Aboriginal = 39,
    Ogham = 40,
    Runic = 41,
    Khmer = 42,
    Mongolian = 43,
    Braille = 44,
    Yi = 45,
    Limbu = 46,
    TaiLe = 47,
    // NewTaiLue = 48, this enum value conflicts with OpenExisting
    SylotiNagri = 49,
    Kharoshthi = 50,
    Kayahli = 51,
    Usymbol = 52,
    Emoji = 53,
    Glagolitic = 54,
    Lisu = 55,
    Vai = 56,
    NKo = 57,
    Osmanya = 58,
    PhagsPa = 59,
    Gothic = 60,
    Deseret = 61,
    Tifinagh = 62,
    CharRepMax = 63,
    // RE10Mode = 1, this enum value conflicts with ApplyLater
    // UseAtFont = 2, this enum value conflicts with TrackParms
    // TextFlowMask = 12, this enum value conflicts with HeavyWave
    // TextFlowES = 0, this enum value conflicts with False
    // TextFlowSW = 4, this enum value conflicts with ApplyTmp
    // TextFlowWN = 8, this enum value conflicts with DisableSmartFont
    // TextFlowNE = 12, this enum value conflicts with HeavyWave
    // NoIME = 524288, this enum value conflicts with ListMinus
    // SelfIME = 262144, this enum value conflicts with ListNoNumber
    // NoUpScroll = 65536, this enum value conflicts with ListParentheses
    // NoVpScroll = 262144, this enum value conflicts with ListNoNumber
    // NoLink = 0, this enum value conflicts with False
    // ClientLink = 1, this enum value conflicts with ApplyLater
    // FriendlyLinkName = 2, this enum value conflicts with TrackParms
    // FriendlyLinkAddress = 3, this enum value conflicts with CacheParms
    // AutoLinkURL = 4, this enum value conflicts with ApplyTmp
    // AutoLinkEmail = 5, this enum value conflicts with SelectionRow
    // AutoLinkPhone = 6, this enum value conflicts with SelectionBlock
    // AutoLinkPath = 7, this enum value conflicts with SelectionInlineShape
    // CompressNone = 0, this enum value conflicts with False
    // CompressPunctuation = 1, this enum value conflicts with ApplyLater
    // CompressPunctuationAndKana = 2, this enum value conflicts with TrackParms
    // CompressMax = 2, this enum value conflicts with TrackParms
    // UnderlinePositionAuto = 0, this enum value conflicts with False
    // UnderlinePositionBelow = 1, this enum value conflicts with ApplyLater
    // UnderlinePositionAbove = 2, this enum value conflicts with TrackParms
    // UnderlinePositionMax = 2, this enum value conflicts with TrackParms
    // FontAlignmentAuto = 0, this enum value conflicts with False
    // FontAlignmentTop = 1, this enum value conflicts with ApplyLater
    // FontAlignmentBaseline = 2, this enum value conflicts with TrackParms
    // FontAlignmentBottom = 3, this enum value conflicts with CacheParms
    // FontAlignmentCenter = 4, this enum value conflicts with ApplyTmp
    // FontAlignmentMax = 4, this enum value conflicts with ApplyTmp
    // RubyBelow = 128, this enum value conflicts with FindStory
    // RubyAlignCenter = 0, this enum value conflicts with False
    // RubyAlign010 = 1, this enum value conflicts with ApplyLater
    // RubyAlign121 = 2, this enum value conflicts with TrackParms
    // RubyAlignLeft = 3, this enum value conflicts with CacheParms
    // RubyAlignRight = 4, this enum value conflicts with ApplyTmp
    // LimitsDefault = 0, this enum value conflicts with False
    // LimitsUnderOver = 1, this enum value conflicts with ApplyLater
    // LimitsSubSup = 2, this enum value conflicts with TrackParms
    // UpperLimitAsSuperScript = 3, this enum value conflicts with CacheParms
    // LimitsOpposite = 4, this enum value conflicts with ApplyTmp
    // ShowLLimPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // ShowULimPlaceHldr = 16, this enum value conflicts with SelReplace
    // DontGrowWithContent = 64, this enum value conflicts with OpenAlways
    // GrowWithContent = 128, this enum value conflicts with FindStory
    // SubSupAlign = 1, this enum value conflicts with ApplyLater
    // LimitAlignMask = 3, this enum value conflicts with CacheParms
    // LimitAlignCenter = 0, this enum value conflicts with False
    // LimitAlignLeft = 1, this enum value conflicts with ApplyLater
    // LimitAlignRight = 2, this enum value conflicts with TrackParms
    // ShowDegPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // AlignDefault = 0, this enum value conflicts with False
    // AlignMatchAscentDescent = 2, this enum value conflicts with TrackParms
    // MathVariant = 32, this enum value conflicts with Start
    // StyleDefault = 0, this enum value conflicts with False
    // StyleScriptScriptCramped = 1, this enum value conflicts with ApplyLater
    // StyleScriptScript = 2, this enum value conflicts with TrackParms
    // StyleScriptCramped = 3, this enum value conflicts with CacheParms
    // StyleScript = 4, this enum value conflicts with ApplyTmp
    // StyleTextCramped = 5, this enum value conflicts with SelectionRow
    // StyleText = 6, this enum value conflicts with SelectionBlock
    // StyleDisplayCramped = 7, this enum value conflicts with SelectionInlineShape
    // StyleDisplay = 8, this enum value conflicts with DisableSmartFont
    // MathRelSize = 64, this enum value conflicts with OpenAlways
    DecDecSize = 254,
    DecSize = 255,
    IncSize = 65,
    IncIncSize = 66,
    // GravityUI = 0, this enum value conflicts with False
    // GravityBack = 1, this enum value conflicts with ApplyLater
    // GravityFore = 2, this enum value conflicts with TrackParms
    // GravityIn = 3, this enum value conflicts with CacheParms
    // GravityOut = 4, this enum value conflicts with ApplyTmp
    GravityBackward = 536870912,
    // GravityForward = 1073741824, this enum value conflicts with CharRepFromLcid
    // AdjustCRLF = 1, this enum value conflicts with ApplyLater
    // UseCRLF = 2, this enum value conflicts with TrackParms
    // Textize = 4, this enum value conflicts with ApplyTmp
    // AllowFinalEOP = 8, this enum value conflicts with DisableSmartFont
    // FoldMathAlpha = 16, this enum value conflicts with SelReplace
    // NoHidden = 32, this enum value conflicts with Start
    // IncludeNumbering = 64, this enum value conflicts with OpenAlways
    // TranslateTableCell = 128, this enum value conflicts with FindStory
    // NoMathZoneBrackets = 256, this enum value conflicts with ClientCoord
    // ConvertMathChar = 512, this enum value conflicts with AllowOffClient
    // NoUCGreekItalic = 1024, this enum value conflicts with Transform
    // AllowMathBold = 2048, this enum value conflicts with ObjectArg
    // LanguageTag = 4096, this enum value conflicts with AtEnd
    ConvertRTF = 8192,
    // ApplyRtfDocProps = 16384, this enum value conflicts with ParaEffectTable
    // PhantomShow = 1, this enum value conflicts with ApplyLater
    // PhantomZeroWidth = 2, this enum value conflicts with TrackParms
    // PhantomZeroAscent = 4, this enum value conflicts with ApplyTmp
    // PhantomZeroDescent = 8, this enum value conflicts with DisableSmartFont
    // PhantomTransparent = 16, this enum value conflicts with SelReplace
    // PhantomASmash = 5, this enum value conflicts with SelectionRow
    // PhantomDSmash = 9, this enum value conflicts with EnableSmartFont
    // PhantomHSmash = 3, this enum value conflicts with CacheParms
    // PhantomSmash = 13, this enum value conflicts with LongDash
    // PhantomHorz = 12, this enum value conflicts with HeavyWave
    // PhantomVert = 2, this enum value conflicts with TrackParms
    // BoxHideTop = 1, this enum value conflicts with ApplyLater
    // BoxHideBottom = 2, this enum value conflicts with TrackParms
    // BoxHideLeft = 4, this enum value conflicts with ApplyTmp
    // BoxHideRight = 8, this enum value conflicts with DisableSmartFont
    // BoxStrikeH = 16, this enum value conflicts with SelReplace
    // BoxStrikeV = 32, this enum value conflicts with Start
    // BoxStrikeTLBR = 64, this enum value conflicts with OpenAlways
    // BoxStrikeBLTR = 128, this enum value conflicts with FindStory
    // BoxAlignCenter = 1, this enum value conflicts with ApplyLater
    // SpaceMask = 28, this enum value conflicts with Telugu
    // SpaceDefault = 0, this enum value conflicts with False
    // SpaceUnary = 4, this enum value conflicts with ApplyTmp
    // SpaceBinary = 8, this enum value conflicts with DisableSmartFont
    // SpaceRelational = 12, this enum value conflicts with HeavyWave
    // SpaceSkip = 16, this enum value conflicts with SelReplace
    // SpaceOrd = 20, this enum value conflicts with ListNumberedThaiNum
    // SpaceDifferential = 24, this enum value conflicts with Gurmukhi
    // SizeText = 32, this enum value conflicts with Start
    // SizeScript = 64, this enum value conflicts with OpenAlways
    SizeScriptScript = 96,
    // NoBreak = 128, this enum value conflicts with FindStory
    // TransparentForPositioning = 256, this enum value conflicts with ClientCoord
    // TransparentForSpacing = 512, this enum value conflicts with AllowOffClient
    // StretchCharBelow = 0, this enum value conflicts with False
    // StretchCharAbove = 1, this enum value conflicts with ApplyLater
    // StretchBaseBelow = 2, this enum value conflicts with TrackParms
    // StretchBaseAbove = 3, this enum value conflicts with CacheParms
    // MatrixAlignMask = 3, this enum value conflicts with CacheParms
    // MatrixAlignCenter = 0, this enum value conflicts with False
    // MatrixAlignTopRow = 1, this enum value conflicts with ApplyLater
    // MatrixAlignBottomRow = 3, this enum value conflicts with CacheParms
    // ShowMatPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // EqArrayLayoutWidth = 1, this enum value conflicts with ApplyLater
    // EqArrayAlignMask = 12, this enum value conflicts with HeavyWave
    // EqArrayAlignCenter = 0, this enum value conflicts with False
    // EqArrayAlignTopRow = 4, this enum value conflicts with ApplyTmp
    // EqArrayAlignBottomRow = 12, this enum value conflicts with HeavyWave
    // MathManualBreakMask = 127, this enum value conflicts with ScratchStory
    MathBreakLeft = 125,
    MathBreakCenter = 126,
    // MathBreakRight = 127, this enum value conflicts with ScratchStory
    // MathEqAlign = 128, this enum value conflicts with FindStory
    MathArgShadingStart = 593,
    MathArgShadingEnd = 594,
    MathObjShadingStart = 595,
    MathObjShadingEnd = 596,
    // FunctionTypeNone = 0, this enum value conflicts with False
    // FunctionTypeTakesArg = 1, this enum value conflicts with ApplyLater
    // FunctionTypeTakesLim = 2, this enum value conflicts with TrackParms
    // FunctionTypeTakesLim2 = 3, this enum value conflicts with CacheParms
    // FunctionTypeIsLim = 4, this enum value conflicts with ApplyTmp
    // MathParaAlignDefault = 0, this enum value conflicts with False
    // MathParaAlignCenterGroup = 1, this enum value conflicts with ApplyLater
    // MathParaAlignCenter = 2, this enum value conflicts with TrackParms
    // MathParaAlignLeft = 3, this enum value conflicts with CacheParms
    // MathParaAlignRight = 4, this enum value conflicts with ApplyTmp
    // MathDispAlignMask = 3, this enum value conflicts with CacheParms
    // MathDispAlignCenterGroup = 0, this enum value conflicts with False
    // MathDispAlignCenter = 1, this enum value conflicts with ApplyLater
    // MathDispAlignLeft = 2, this enum value conflicts with TrackParms
    // MathDispAlignRight = 3, this enum value conflicts with CacheParms
    // MathDispIntUnderOver = 4, this enum value conflicts with ApplyTmp
    // MathDispFracTeX = 8, this enum value conflicts with DisableSmartFont
    // MathDispNaryGrow = 16, this enum value conflicts with SelReplace
    // MathDocEmptyArgMask = 96, this enum value conflicts with SizeScriptScript
    // MathDocEmptyArgAuto = 0, this enum value conflicts with False
    // MathDocEmptyArgAlways = 32, this enum value conflicts with Start
    // MathDocEmptyArgNever = 64, this enum value conflicts with OpenAlways
    // MathDocSbSpOpUnchanged = 128, this enum value conflicts with FindStory
    MathDocDiffMask = 768,
    // MathDocDiffDefault = 0, this enum value conflicts with False
    // MathDocDiffUpright = 256, this enum value conflicts with ClientCoord
    // MathDocDiffItalic = 512, this enum value conflicts with AllowOffClient
    // MathDocDiffOpenItalic = 768, this enum value conflicts with MathDocDiffMask
    // MathDispNarySubSup = 1024, this enum value conflicts with Transform
    // MathDispDef = 2048, this enum value conflicts with ObjectArg
    // MathEnableRtl = 4096, this enum value conflicts with AtEnd
    // MathBrkBinMask = 196608, this enum value conflicts with ListPlain
    // MathBrkBinBefore = 0, this enum value conflicts with False
    // MathBrkBinAfter = 65536, this enum value conflicts with ListParentheses
    // MathBrkBinDup = 131072, this enum value conflicts with ListPeriod
    MathBrkBinSubMask = 786432,
    // MathBrkBinSubMM = 0, this enum value conflicts with False
    // MathBrkBinSubPM = 262144, this enum value conflicts with ListNoNumber
    // MathBrkBinSubMP = 524288, this enum value conflicts with ListMinus
    SelRange = 597,
    // Hstring = 596, this enum value conflicts with MathObjShadingEnd
    FontPropTeXStyle = 828,
    FontPropAlign = 829,
    FontStretch = 830,
    FontStyle = 831,
    // FontStyleUpright = 0, this enum value conflicts with False
    // FontStyleOblique = 1, this enum value conflicts with ApplyLater
    // FontStyleItalic = 2, this enum value conflicts with TrackParms
    // FontStretchDefault = 0, this enum value conflicts with False
    // FontStretchUltraCondensed = 1, this enum value conflicts with ApplyLater
    // FontStretchExtraCondensed = 2, this enum value conflicts with TrackParms
    // FontStretchCondensed = 3, this enum value conflicts with CacheParms
    // FontStretchSemiCondensed = 4, this enum value conflicts with ApplyTmp
    // FontStretchNormal = 5, this enum value conflicts with SelectionRow
    // FontStretchSemiExpanded = 6, this enum value conflicts with SelectionBlock
    // FontStretchExpanded = 7, this enum value conflicts with SelectionInlineShape
    // FontStretchExtraExpanded = 8, this enum value conflicts with DisableSmartFont
    // FontStretchUltraExpanded = 9, this enum value conflicts with EnableSmartFont
    // FontWeightDefault = 0, this enum value conflicts with False
    FontWeightThin = 100,
    FontWeightExtraLight = 200,
    FontWeightLight = 300,
    FontWeightNormal = 400,
    // FontWeightRegular = 400, this enum value conflicts with FontWeightNormal
    FontWeightMedium = 500,
    FontWeightSemiBold = 600,
    FontWeightBold = 700,
    FontWeightExtraBold = 800,
    FontWeightBlack = 900,
    // FontWeightHeavy = 900, this enum value conflicts with FontWeightBlack
    FontWeightExtraBlack = 950,
    ParaPropMathAlign = 1079,
    // DocMathBuild = 128, this enum value conflicts with FindStory
    // MathLMargin = 129, this enum value conflicts with ReplaceStory
    MathRMargin = 130,
    MathWrapIndent = 131,
    MathWrapRight = 132,
    MathPostSpace = 134,
    MathPreSpace = 133,
    MathInterSpace = 135,
    MathIntraSpace = 136,
    CanCopy = 137,
    CanRedo = 138,
    CanUndo = 139,
    UndoLimit = 140,
    DocAutoLink = 141,
    EllipsisMode = 142,
    EllipsisState = 143,
    // EllipsisNone = 0, this enum value conflicts with False
    // EllipsisEnd = 1, this enum value conflicts with ApplyLater
    // EllipsisWord = 3, this enum value conflicts with CacheParms
    // EllipsisPresent = 1, this enum value conflicts with ApplyLater
    // VTopCell = 1, this enum value conflicts with ApplyLater
    // VLowCell = 2, this enum value conflicts with TrackParms
    // HStartCell = 4, this enum value conflicts with ApplyTmp
    // HContCell = 8, this enum value conflicts with DisableSmartFont
    // RowUpdate = 1, this enum value conflicts with ApplyLater
    // RowApplyDefault = 0, this enum value conflicts with False
    // CellStructureChangeOnly = 1, this enum value conflicts with ApplyLater
    RowHeightActual = 2059,
};
pub const tomFalse = tomConstants.False;
pub const tomTrue = tomConstants.True;
pub const tomUndefined = tomConstants.Undefined;
pub const tomToggle = tomConstants.Toggle;
pub const tomAutoColor = tomConstants.AutoColor;
pub const tomDefault = tomConstants.Default;
pub const tomSuspend = tomConstants.Suspend;
pub const tomResume = tomConstants.Resume;
pub const tomApplyNow = tomConstants.False;
pub const tomApplyLater = tomConstants.ApplyLater;
pub const tomTrackParms = tomConstants.TrackParms;
pub const tomCacheParms = tomConstants.CacheParms;
pub const tomApplyTmp = tomConstants.ApplyTmp;
pub const tomDisableSmartFont = tomConstants.DisableSmartFont;
pub const tomEnableSmartFont = tomConstants.EnableSmartFont;
pub const tomUsePoints = tomConstants.UsePoints;
pub const tomUseTwips = tomConstants.UseTwips;
pub const tomBackward = tomConstants.Backward;
pub const tomForward = tomConstants.Forward;
pub const tomMove = tomConstants.False;
pub const tomExtend = tomConstants.ApplyLater;
pub const tomNoSelection = tomConstants.False;
pub const tomSelectionIP = tomConstants.ApplyLater;
pub const tomSelectionNormal = tomConstants.TrackParms;
pub const tomSelectionFrame = tomConstants.CacheParms;
pub const tomSelectionColumn = tomConstants.ApplyTmp;
pub const tomSelectionRow = tomConstants.SelectionRow;
pub const tomSelectionBlock = tomConstants.SelectionBlock;
pub const tomSelectionInlineShape = tomConstants.SelectionInlineShape;
pub const tomSelectionShape = tomConstants.DisableSmartFont;
pub const tomSelStartActive = tomConstants.ApplyLater;
pub const tomSelAtEOL = tomConstants.TrackParms;
pub const tomSelOvertype = tomConstants.ApplyTmp;
pub const tomSelActive = tomConstants.DisableSmartFont;
pub const tomSelReplace = tomConstants.SelReplace;
pub const tomEnd = tomConstants.False;
pub const tomStart = tomConstants.Start;
pub const tomCollapseEnd = tomConstants.False;
pub const tomCollapseStart = tomConstants.ApplyLater;
pub const tomClientCoord = tomConstants.ClientCoord;
pub const tomAllowOffClient = tomConstants.AllowOffClient;
pub const tomTransform = tomConstants.Transform;
pub const tomObjectArg = tomConstants.ObjectArg;
pub const tomAtEnd = tomConstants.AtEnd;
pub const tomNone = tomConstants.False;
pub const tomSingle = tomConstants.ApplyLater;
pub const tomWords = tomConstants.TrackParms;
pub const tomDouble = tomConstants.CacheParms;
pub const tomDotted = tomConstants.ApplyTmp;
pub const tomDash = tomConstants.SelectionRow;
pub const tomDashDot = tomConstants.SelectionBlock;
pub const tomDashDotDot = tomConstants.SelectionInlineShape;
pub const tomWave = tomConstants.DisableSmartFont;
pub const tomThick = tomConstants.EnableSmartFont;
pub const tomHair = tomConstants.UsePoints;
pub const tomDoubleWave = tomConstants.UseTwips;
pub const tomHeavyWave = tomConstants.HeavyWave;
pub const tomLongDash = tomConstants.LongDash;
pub const tomThickDash = tomConstants.ThickDash;
pub const tomThickDashDot = tomConstants.ThickDashDot;
pub const tomThickDashDotDot = tomConstants.SelReplace;
pub const tomThickDotted = tomConstants.ThickDotted;
pub const tomThickLongDash = tomConstants.ThickLongDash;
pub const tomLineSpaceSingle = tomConstants.False;
pub const tomLineSpace1pt5 = tomConstants.ApplyLater;
pub const tomLineSpaceDouble = tomConstants.TrackParms;
pub const tomLineSpaceAtLeast = tomConstants.CacheParms;
pub const tomLineSpaceExactly = tomConstants.ApplyTmp;
pub const tomLineSpaceMultiple = tomConstants.SelectionRow;
pub const tomLineSpacePercent = tomConstants.SelectionBlock;
pub const tomAlignLeft = tomConstants.False;
pub const tomAlignCenter = tomConstants.ApplyLater;
pub const tomAlignRight = tomConstants.TrackParms;
pub const tomAlignJustify = tomConstants.CacheParms;
pub const tomAlignDecimal = tomConstants.CacheParms;
pub const tomAlignBar = tomConstants.ApplyTmp;
pub const tomDefaultTab = tomConstants.SelectionRow;
pub const tomAlignInterWord = tomConstants.CacheParms;
pub const tomAlignNewspaper = tomConstants.ApplyTmp;
pub const tomAlignInterLetter = tomConstants.SelectionRow;
pub const tomAlignScaled = tomConstants.SelectionBlock;
pub const tomSpaces = tomConstants.False;
pub const tomDots = tomConstants.ApplyLater;
pub const tomDashes = tomConstants.TrackParms;
pub const tomLines = tomConstants.CacheParms;
pub const tomThickLines = tomConstants.ApplyTmp;
pub const tomEquals = tomConstants.SelectionRow;
pub const tomTabBack = tomConstants.TabBack;
pub const tomTabNext = tomConstants.TabNext;
pub const tomTabHere = tomConstants.True;
pub const tomListNone = tomConstants.False;
pub const tomListBullet = tomConstants.ApplyLater;
pub const tomListNumberAsArabic = tomConstants.TrackParms;
pub const tomListNumberAsLCLetter = tomConstants.CacheParms;
pub const tomListNumberAsUCLetter = tomConstants.ApplyTmp;
pub const tomListNumberAsLCRoman = tomConstants.SelectionRow;
pub const tomListNumberAsUCRoman = tomConstants.SelectionBlock;
pub const tomListNumberAsSequence = tomConstants.SelectionInlineShape;
pub const tomListNumberedCircle = tomConstants.DisableSmartFont;
pub const tomListNumberedBlackCircleWingding = tomConstants.EnableSmartFont;
pub const tomListNumberedWhiteCircleWingding = tomConstants.UsePoints;
pub const tomListNumberedArabicWide = tomConstants.UseTwips;
pub const tomListNumberedChS = tomConstants.HeavyWave;
pub const tomListNumberedChT = tomConstants.LongDash;
pub const tomListNumberedJpnChS = tomConstants.ThickDash;
pub const tomListNumberedJpnKor = tomConstants.ThickDashDot;
pub const tomListNumberedArabic1 = tomConstants.SelReplace;
pub const tomListNumberedArabic2 = tomConstants.ThickDotted;
pub const tomListNumberedHebrew = tomConstants.ThickLongDash;
pub const tomListNumberedThaiAlpha = tomConstants.ListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.ListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.ListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.ListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.ListNumberedHindiNum;
pub const tomListParentheses = tomConstants.ListParentheses;
pub const tomListPeriod = tomConstants.ListPeriod;
pub const tomListPlain = tomConstants.ListPlain;
pub const tomListNoNumber = tomConstants.ListNoNumber;
pub const tomListMinus = tomConstants.ListMinus;
pub const tomIgnoreNumberStyle = tomConstants.IgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.True;
pub const tomParaStyleHeading1 = tomConstants.TabNext;
pub const tomParaStyleHeading2 = tomConstants.TabBack;
pub const tomParaStyleHeading3 = tomConstants.ParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.ParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.ParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.ParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.ParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.ParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.ParaStyleHeading9;
pub const tomCharacter = tomConstants.ApplyLater;
pub const tomWord = tomConstants.TrackParms;
pub const tomSentence = tomConstants.CacheParms;
pub const tomParagraph = tomConstants.ApplyTmp;
pub const tomLine = tomConstants.SelectionRow;
pub const tomStory = tomConstants.SelectionBlock;
pub const tomScreen = tomConstants.SelectionInlineShape;
pub const tomSection = tomConstants.DisableSmartFont;
pub const tomTableColumn = tomConstants.EnableSmartFont;
pub const tomColumn = tomConstants.EnableSmartFont;
pub const tomRow = tomConstants.UsePoints;
pub const tomWindow = tomConstants.UseTwips;
pub const tomCell = tomConstants.HeavyWave;
pub const tomCharFormat = tomConstants.LongDash;
pub const tomParaFormat = tomConstants.ThickDash;
pub const tomTable = tomConstants.ThickDashDot;
pub const tomObject = tomConstants.SelReplace;
pub const tomPage = tomConstants.ThickDotted;
pub const tomHardParagraph = tomConstants.ThickLongDash;
pub const tomCluster = tomConstants.ListNumberedThaiAlpha;
pub const tomInlineObject = tomConstants.ListNumberedThaiNum;
pub const tomInlineObjectArg = tomConstants.ListNumberedHindiAlpha;
pub const tomLeafLine = tomConstants.ListNumberedHindiAlpha1;
pub const tomLayoutColumn = tomConstants.ListNumberedHindiNum;
pub const tomProcessId = tomConstants.ProcessId;
pub const tomMatchWord = tomConstants.TrackParms;
pub const tomMatchCase = tomConstants.ApplyTmp;
pub const tomMatchPattern = tomConstants.DisableSmartFont;
pub const tomUnknownStory = tomConstants.False;
pub const tomMainTextStory = tomConstants.ApplyLater;
pub const tomFootnotesStory = tomConstants.TrackParms;
pub const tomEndnotesStory = tomConstants.CacheParms;
pub const tomCommentsStory = tomConstants.ApplyTmp;
pub const tomTextFrameStory = tomConstants.SelectionRow;
pub const tomEvenPagesHeaderStory = tomConstants.SelectionBlock;
pub const tomPrimaryHeaderStory = tomConstants.SelectionInlineShape;
pub const tomEvenPagesFooterStory = tomConstants.DisableSmartFont;
pub const tomPrimaryFooterStory = tomConstants.EnableSmartFont;
pub const tomFirstPageHeaderStory = tomConstants.UsePoints;
pub const tomFirstPageFooterStory = tomConstants.UseTwips;
pub const tomScratchStory = tomConstants.ScratchStory;
pub const tomFindStory = tomConstants.FindStory;
pub const tomReplaceStory = tomConstants.ReplaceStory;
pub const tomStoryInactive = tomConstants.False;
pub const tomStoryActiveDisplay = tomConstants.ApplyLater;
pub const tomStoryActiveUI = tomConstants.TrackParms;
pub const tomStoryActiveDisplayUI = tomConstants.CacheParms;
pub const tomNoAnimation = tomConstants.False;
pub const tomLasVegasLights = tomConstants.ApplyLater;
pub const tomBlinkingBackground = tomConstants.TrackParms;
pub const tomSparkleText = tomConstants.CacheParms;
pub const tomMarchingBlackAnts = tomConstants.ApplyTmp;
pub const tomMarchingRedAnts = tomConstants.SelectionRow;
pub const tomShimmer = tomConstants.SelectionBlock;
pub const tomWipeDown = tomConstants.SelectionInlineShape;
pub const tomWipeRight = tomConstants.DisableSmartFont;
pub const tomAnimationMax = tomConstants.DisableSmartFont;
pub const tomLowerCase = tomConstants.False;
pub const tomUpperCase = tomConstants.ApplyLater;
pub const tomTitleCase = tomConstants.TrackParms;
pub const tomSentenceCase = tomConstants.ApplyTmp;
pub const tomToggleCase = tomConstants.SelectionRow;
pub const tomReadOnly = tomConstants.ClientCoord;
pub const tomShareDenyRead = tomConstants.AllowOffClient;
pub const tomShareDenyWrite = tomConstants.Transform;
pub const tomPasteFile = tomConstants.AtEnd;
pub const tomCreateNew = tomConstants.SelReplace;
pub const tomCreateAlways = tomConstants.Start;
pub const tomOpenExisting = tomConstants.OpenExisting;
pub const tomOpenAlways = tomConstants.OpenAlways;
pub const tomTruncateExisting = tomConstants.TruncateExisting;
pub const tomRTF = tomConstants.ApplyLater;
pub const tomText = tomConstants.TrackParms;
pub const tomHTML = tomConstants.CacheParms;
pub const tomWordDocument = tomConstants.ApplyTmp;
pub const tomBold = tomConstants.Bold;
pub const tomItalic = tomConstants.Italic;
pub const tomUnderline = tomConstants.Underline;
pub const tomStrikeout = tomConstants.Strikeout;
pub const tomProtected = tomConstants.Protected;
pub const tomLink = tomConstants.Link;
pub const tomSmallCaps = tomConstants.SmallCaps;
pub const tomAllCaps = tomConstants.AllCaps;
pub const tomHidden = tomConstants.Hidden;
pub const tomOutline = tomConstants.Outline;
pub const tomShadow = tomConstants.Shadow;
pub const tomEmboss = tomConstants.Emboss;
pub const tomImprint = tomConstants.Imprint;
pub const tomDisabled = tomConstants.Disabled;
pub const tomRevised = tomConstants.Revised;
pub const tomSubscriptCF = tomConstants.SubscriptCF;
pub const tomSuperscriptCF = tomConstants.SuperscriptCF;
pub const tomFontBound = tomConstants.FontBound;
pub const tomLinkProtected = tomConstants.LinkProtected;
pub const tomInlineObjectStart = tomConstants.InlineObjectStart;
pub const tomExtendedChar = tomConstants.ExtendedChar;
pub const tomAutoBackColor = tomConstants.AutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.MathZoneNoBuildUp;
pub const tomMathZone = tomConstants.MathZone;
pub const tomMathZoneOrdinary = tomConstants.MathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.AutoTextColor;
pub const tomMathZoneDisplay = tomConstants.ListNoNumber;
pub const tomParaEffectRTL = tomConstants.ApplyLater;
pub const tomParaEffectKeep = tomConstants.TrackParms;
pub const tomParaEffectKeepNext = tomConstants.ApplyTmp;
pub const tomParaEffectPageBreakBefore = tomConstants.DisableSmartFont;
pub const tomParaEffectNoLineNumber = tomConstants.SelReplace;
pub const tomParaEffectNoWidowControl = tomConstants.Start;
pub const tomParaEffectDoNotHyphen = tomConstants.OpenAlways;
pub const tomParaEffectSideBySide = tomConstants.FindStory;
pub const tomParaEffectCollapsed = tomConstants.ClientCoord;
pub const tomParaEffectOutlineLevel = tomConstants.AllowOffClient;
pub const tomParaEffectBox = tomConstants.Transform;
pub const tomParaEffectTableRowDelimiter = tomConstants.AtEnd;
pub const tomParaEffectTable = tomConstants.ParaEffectTable;
pub const tomModWidthPairs = tomConstants.ApplyLater;
pub const tomModWidthSpace = tomConstants.TrackParms;
pub const tomAutoSpaceAlpha = tomConstants.ApplyTmp;
pub const tomAutoSpaceNumeric = tomConstants.DisableSmartFont;
pub const tomAutoSpaceParens = tomConstants.SelReplace;
pub const tomEmbeddedFont = tomConstants.Start;
pub const tomDoublestrike = tomConstants.OpenAlways;
pub const tomOverlapping = tomConstants.FindStory;
pub const tomNormalCaret = tomConstants.False;
pub const tomKoreanBlockCaret = tomConstants.ApplyLater;
pub const tomNullCaret = tomConstants.TrackParms;
pub const tomIncludeInset = tomConstants.ApplyLater;
pub const tomUnicodeBiDi = tomConstants.ApplyLater;
pub const tomMathCFCheck = tomConstants.ApplyTmp;
pub const tomUnlink = tomConstants.DisableSmartFont;
pub const tomUnhide = tomConstants.SelReplace;
pub const tomCheckTextLimit = tomConstants.Start;
pub const tomIgnoreCurrentFont = tomConstants.False;
pub const tomMatchCharRep = tomConstants.ApplyLater;
pub const tomMatchFontSignature = tomConstants.TrackParms;
pub const tomMatchAscii = tomConstants.ApplyTmp;
pub const tomGetHeightOnly = tomConstants.DisableSmartFont;
pub const tomMatchMathFont = tomConstants.SelReplace;
pub const tomCharset = tomConstants.Charset;
pub const tomCharRepFromLcid = tomConstants.CharRepFromLcid;
pub const tomAnsi = tomConstants.False;
pub const tomEastEurope = tomConstants.ApplyLater;
pub const tomCyrillic = tomConstants.TrackParms;
pub const tomGreek = tomConstants.CacheParms;
pub const tomTurkish = tomConstants.ApplyTmp;
pub const tomHebrew = tomConstants.SelectionRow;
pub const tomArabic = tomConstants.SelectionBlock;
pub const tomBaltic = tomConstants.SelectionInlineShape;
pub const tomVietnamese = tomConstants.DisableSmartFont;
pub const tomDefaultCharRep = tomConstants.EnableSmartFont;
pub const tomSymbol = tomConstants.UsePoints;
pub const tomThai = tomConstants.UseTwips;
pub const tomShiftJIS = tomConstants.HeavyWave;
pub const tomGB2312 = tomConstants.LongDash;
pub const tomHangul = tomConstants.ThickDash;
pub const tomBIG5 = tomConstants.ThickDashDot;
pub const tomPC437 = tomConstants.SelReplace;
pub const tomOEM = tomConstants.ThickDotted;
pub const tomMac = tomConstants.ThickLongDash;
pub const tomArmenian = tomConstants.ListNumberedThaiAlpha;
pub const tomSyriac = tomConstants.ListNumberedThaiNum;
pub const tomThaana = tomConstants.ListNumberedHindiAlpha;
pub const tomDevanagari = tomConstants.ListNumberedHindiAlpha1;
pub const tomBengali = tomConstants.ListNumberedHindiNum;
pub const tomGurmukhi = tomConstants.Gurmukhi;
pub const tomGujarati = tomConstants.Gujarati;
pub const tomOriya = tomConstants.Oriya;
pub const tomTamil = tomConstants.Tamil;
pub const tomTelugu = tomConstants.Telugu;
pub const tomKannada = tomConstants.Kannada;
pub const tomMalayalam = tomConstants.Malayalam;
pub const tomSinhala = tomConstants.Sinhala;
pub const tomLao = tomConstants.Start;
pub const tomTibetan = tomConstants.Tibetan;
pub const tomMyanmar = tomConstants.Myanmar;
pub const tomGeorgian = tomConstants.Georgian;
pub const tomJamo = tomConstants.Jamo;
pub const tomEthiopic = tomConstants.Ethiopic;
pub const tomCherokee = tomConstants.Cherokee;
pub const tomAboriginal = tomConstants.Aboriginal;
pub const tomOgham = tomConstants.Ogham;
pub const tomRunic = tomConstants.Runic;
pub const tomKhmer = tomConstants.Khmer;
pub const tomMongolian = tomConstants.Mongolian;
pub const tomBraille = tomConstants.Braille;
pub const tomYi = tomConstants.Yi;
pub const tomLimbu = tomConstants.Limbu;
pub const tomTaiLe = tomConstants.TaiLe;
pub const tomNewTaiLue = tomConstants.OpenExisting;
pub const tomSylotiNagri = tomConstants.SylotiNagri;
pub const tomKharoshthi = tomConstants.Kharoshthi;
pub const tomKayahli = tomConstants.Kayahli;
pub const tomUsymbol = tomConstants.Usymbol;
pub const tomEmoji = tomConstants.Emoji;
pub const tomGlagolitic = tomConstants.Glagolitic;
pub const tomLisu = tomConstants.Lisu;
pub const tomVai = tomConstants.Vai;
pub const tomNKo = tomConstants.NKo;
pub const tomOsmanya = tomConstants.Osmanya;
pub const tomPhagsPa = tomConstants.PhagsPa;
pub const tomGothic = tomConstants.Gothic;
pub const tomDeseret = tomConstants.Deseret;
pub const tomTifinagh = tomConstants.Tifinagh;
pub const tomCharRepMax = tomConstants.CharRepMax;
pub const tomRE10Mode = tomConstants.ApplyLater;
pub const tomUseAtFont = tomConstants.TrackParms;
pub const tomTextFlowMask = tomConstants.HeavyWave;
pub const tomTextFlowES = tomConstants.False;
pub const tomTextFlowSW = tomConstants.ApplyTmp;
pub const tomTextFlowWN = tomConstants.DisableSmartFont;
pub const tomTextFlowNE = tomConstants.HeavyWave;
pub const tomNoIME = tomConstants.ListMinus;
pub const tomSelfIME = tomConstants.ListNoNumber;
pub const tomNoUpScroll = tomConstants.ListParentheses;
pub const tomNoVpScroll = tomConstants.ListNoNumber;
pub const tomNoLink = tomConstants.False;
pub const tomClientLink = tomConstants.ApplyLater;
pub const tomFriendlyLinkName = tomConstants.TrackParms;
pub const tomFriendlyLinkAddress = tomConstants.CacheParms;
pub const tomAutoLinkURL = tomConstants.ApplyTmp;
pub const tomAutoLinkEmail = tomConstants.SelectionRow;
pub const tomAutoLinkPhone = tomConstants.SelectionBlock;
pub const tomAutoLinkPath = tomConstants.SelectionInlineShape;
pub const tomCompressNone = tomConstants.False;
pub const tomCompressPunctuation = tomConstants.ApplyLater;
pub const tomCompressPunctuationAndKana = tomConstants.TrackParms;
pub const tomCompressMax = tomConstants.TrackParms;
pub const tomUnderlinePositionAuto = tomConstants.False;
pub const tomUnderlinePositionBelow = tomConstants.ApplyLater;
pub const tomUnderlinePositionAbove = tomConstants.TrackParms;
pub const tomUnderlinePositionMax = tomConstants.TrackParms;
pub const tomFontAlignmentAuto = tomConstants.False;
pub const tomFontAlignmentTop = tomConstants.ApplyLater;
pub const tomFontAlignmentBaseline = tomConstants.TrackParms;
pub const tomFontAlignmentBottom = tomConstants.CacheParms;
pub const tomFontAlignmentCenter = tomConstants.ApplyTmp;
pub const tomFontAlignmentMax = tomConstants.ApplyTmp;
pub const tomRubyBelow = tomConstants.FindStory;
pub const tomRubyAlignCenter = tomConstants.False;
pub const tomRubyAlign010 = tomConstants.ApplyLater;
pub const tomRubyAlign121 = tomConstants.TrackParms;
pub const tomRubyAlignLeft = tomConstants.CacheParms;
pub const tomRubyAlignRight = tomConstants.ApplyTmp;
pub const tomLimitsDefault = tomConstants.False;
pub const tomLimitsUnderOver = tomConstants.ApplyLater;
pub const tomLimitsSubSup = tomConstants.TrackParms;
pub const tomUpperLimitAsSuperScript = tomConstants.CacheParms;
pub const tomLimitsOpposite = tomConstants.ApplyTmp;
pub const tomShowLLimPlaceHldr = tomConstants.DisableSmartFont;
pub const tomShowULimPlaceHldr = tomConstants.SelReplace;
pub const tomDontGrowWithContent = tomConstants.OpenAlways;
pub const tomGrowWithContent = tomConstants.FindStory;
pub const tomSubSupAlign = tomConstants.ApplyLater;
pub const tomLimitAlignMask = tomConstants.CacheParms;
pub const tomLimitAlignCenter = tomConstants.False;
pub const tomLimitAlignLeft = tomConstants.ApplyLater;
pub const tomLimitAlignRight = tomConstants.TrackParms;
pub const tomShowDegPlaceHldr = tomConstants.DisableSmartFont;
pub const tomAlignDefault = tomConstants.False;
pub const tomAlignMatchAscentDescent = tomConstants.TrackParms;
pub const tomMathVariant = tomConstants.Start;
pub const tomStyleDefault = tomConstants.False;
pub const tomStyleScriptScriptCramped = tomConstants.ApplyLater;
pub const tomStyleScriptScript = tomConstants.TrackParms;
pub const tomStyleScriptCramped = tomConstants.CacheParms;
pub const tomStyleScript = tomConstants.ApplyTmp;
pub const tomStyleTextCramped = tomConstants.SelectionRow;
pub const tomStyleText = tomConstants.SelectionBlock;
pub const tomStyleDisplayCramped = tomConstants.SelectionInlineShape;
pub const tomStyleDisplay = tomConstants.DisableSmartFont;
pub const tomMathRelSize = tomConstants.OpenAlways;
pub const tomDecDecSize = tomConstants.DecDecSize;
pub const tomDecSize = tomConstants.DecSize;
pub const tomIncSize = tomConstants.IncSize;
pub const tomIncIncSize = tomConstants.IncIncSize;
pub const tomGravityUI = tomConstants.False;
pub const tomGravityBack = tomConstants.ApplyLater;
pub const tomGravityFore = tomConstants.TrackParms;
pub const tomGravityIn = tomConstants.CacheParms;
pub const tomGravityOut = tomConstants.ApplyTmp;
pub const tomGravityBackward = tomConstants.GravityBackward;
pub const tomGravityForward = tomConstants.CharRepFromLcid;
pub const tomAdjustCRLF = tomConstants.ApplyLater;
pub const tomUseCRLF = tomConstants.TrackParms;
pub const tomTextize = tomConstants.ApplyTmp;
pub const tomAllowFinalEOP = tomConstants.DisableSmartFont;
pub const tomFoldMathAlpha = tomConstants.SelReplace;
pub const tomNoHidden = tomConstants.Start;
pub const tomIncludeNumbering = tomConstants.OpenAlways;
pub const tomTranslateTableCell = tomConstants.FindStory;
pub const tomNoMathZoneBrackets = tomConstants.ClientCoord;
pub const tomConvertMathChar = tomConstants.AllowOffClient;
pub const tomNoUCGreekItalic = tomConstants.Transform;
pub const tomAllowMathBold = tomConstants.ObjectArg;
pub const tomLanguageTag = tomConstants.AtEnd;
pub const tomConvertRTF = tomConstants.ConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.ParaEffectTable;
pub const tomPhantomShow = tomConstants.ApplyLater;
pub const tomPhantomZeroWidth = tomConstants.TrackParms;
pub const tomPhantomZeroAscent = tomConstants.ApplyTmp;
pub const tomPhantomZeroDescent = tomConstants.DisableSmartFont;
pub const tomPhantomTransparent = tomConstants.SelReplace;
pub const tomPhantomASmash = tomConstants.SelectionRow;
pub const tomPhantomDSmash = tomConstants.EnableSmartFont;
pub const tomPhantomHSmash = tomConstants.CacheParms;
pub const tomPhantomSmash = tomConstants.LongDash;
pub const tomPhantomHorz = tomConstants.HeavyWave;
pub const tomPhantomVert = tomConstants.TrackParms;
pub const tomBoxHideTop = tomConstants.ApplyLater;
pub const tomBoxHideBottom = tomConstants.TrackParms;
pub const tomBoxHideLeft = tomConstants.ApplyTmp;
pub const tomBoxHideRight = tomConstants.DisableSmartFont;
pub const tomBoxStrikeH = tomConstants.SelReplace;
pub const tomBoxStrikeV = tomConstants.Start;
pub const tomBoxStrikeTLBR = tomConstants.OpenAlways;
pub const tomBoxStrikeBLTR = tomConstants.FindStory;
pub const tomBoxAlignCenter = tomConstants.ApplyLater;
pub const tomSpaceMask = tomConstants.Telugu;
pub const tomSpaceDefault = tomConstants.False;
pub const tomSpaceUnary = tomConstants.ApplyTmp;
pub const tomSpaceBinary = tomConstants.DisableSmartFont;
pub const tomSpaceRelational = tomConstants.HeavyWave;
pub const tomSpaceSkip = tomConstants.SelReplace;
pub const tomSpaceOrd = tomConstants.ListNumberedThaiNum;
pub const tomSpaceDifferential = tomConstants.Gurmukhi;
pub const tomSizeText = tomConstants.Start;
pub const tomSizeScript = tomConstants.OpenAlways;
pub const tomSizeScriptScript = tomConstants.SizeScriptScript;
pub const tomNoBreak = tomConstants.FindStory;
pub const tomTransparentForPositioning = tomConstants.ClientCoord;
pub const tomTransparentForSpacing = tomConstants.AllowOffClient;
pub const tomStretchCharBelow = tomConstants.False;
pub const tomStretchCharAbove = tomConstants.ApplyLater;
pub const tomStretchBaseBelow = tomConstants.TrackParms;
pub const tomStretchBaseAbove = tomConstants.CacheParms;
pub const tomMatrixAlignMask = tomConstants.CacheParms;
pub const tomMatrixAlignCenter = tomConstants.False;
pub const tomMatrixAlignTopRow = tomConstants.ApplyLater;
pub const tomMatrixAlignBottomRow = tomConstants.CacheParms;
pub const tomShowMatPlaceHldr = tomConstants.DisableSmartFont;
pub const tomEqArrayLayoutWidth = tomConstants.ApplyLater;
pub const tomEqArrayAlignMask = tomConstants.HeavyWave;
pub const tomEqArrayAlignCenter = tomConstants.False;
pub const tomEqArrayAlignTopRow = tomConstants.ApplyTmp;
pub const tomEqArrayAlignBottomRow = tomConstants.HeavyWave;
pub const tomMathManualBreakMask = tomConstants.ScratchStory;
pub const tomMathBreakLeft = tomConstants.MathBreakLeft;
pub const tomMathBreakCenter = tomConstants.MathBreakCenter;
pub const tomMathBreakRight = tomConstants.ScratchStory;
pub const tomMathEqAlign = tomConstants.FindStory;
pub const tomMathArgShadingStart = tomConstants.MathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.MathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.MathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.MathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.False;
pub const tomFunctionTypeTakesArg = tomConstants.ApplyLater;
pub const tomFunctionTypeTakesLim = tomConstants.TrackParms;
pub const tomFunctionTypeTakesLim2 = tomConstants.CacheParms;
pub const tomFunctionTypeIsLim = tomConstants.ApplyTmp;
pub const tomMathParaAlignDefault = tomConstants.False;
pub const tomMathParaAlignCenterGroup = tomConstants.ApplyLater;
pub const tomMathParaAlignCenter = tomConstants.TrackParms;
pub const tomMathParaAlignLeft = tomConstants.CacheParms;
pub const tomMathParaAlignRight = tomConstants.ApplyTmp;
pub const tomMathDispAlignMask = tomConstants.CacheParms;
pub const tomMathDispAlignCenterGroup = tomConstants.False;
pub const tomMathDispAlignCenter = tomConstants.ApplyLater;
pub const tomMathDispAlignLeft = tomConstants.TrackParms;
pub const tomMathDispAlignRight = tomConstants.CacheParms;
pub const tomMathDispIntUnderOver = tomConstants.ApplyTmp;
pub const tomMathDispFracTeX = tomConstants.DisableSmartFont;
pub const tomMathDispNaryGrow = tomConstants.SelReplace;
pub const tomMathDocEmptyArgMask = tomConstants.SizeScriptScript;
pub const tomMathDocEmptyArgAuto = tomConstants.False;
pub const tomMathDocEmptyArgAlways = tomConstants.Start;
pub const tomMathDocEmptyArgNever = tomConstants.OpenAlways;
pub const tomMathDocSbSpOpUnchanged = tomConstants.FindStory;
pub const tomMathDocDiffMask = tomConstants.MathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.False;
pub const tomMathDocDiffUpright = tomConstants.ClientCoord;
pub const tomMathDocDiffItalic = tomConstants.AllowOffClient;
pub const tomMathDocDiffOpenItalic = tomConstants.MathDocDiffMask;
pub const tomMathDispNarySubSup = tomConstants.Transform;
pub const tomMathDispDef = tomConstants.ObjectArg;
pub const tomMathEnableRtl = tomConstants.AtEnd;
pub const tomMathBrkBinMask = tomConstants.ListPlain;
pub const tomMathBrkBinBefore = tomConstants.False;
pub const tomMathBrkBinAfter = tomConstants.ListParentheses;
pub const tomMathBrkBinDup = tomConstants.ListPeriod;
pub const tomMathBrkBinSubMask = tomConstants.MathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.False;
pub const tomMathBrkBinSubPM = tomConstants.ListNoNumber;
pub const tomMathBrkBinSubMP = tomConstants.ListMinus;
pub const tomSelRange = tomConstants.SelRange;
pub const tomHstring = tomConstants.MathObjShadingEnd;
pub const tomFontPropTeXStyle = tomConstants.FontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.FontPropAlign;
pub const tomFontStretch = tomConstants.FontStretch;
pub const tomFontStyle = tomConstants.FontStyle;
pub const tomFontStyleUpright = tomConstants.False;
pub const tomFontStyleOblique = tomConstants.ApplyLater;
pub const tomFontStyleItalic = tomConstants.TrackParms;
pub const tomFontStretchDefault = tomConstants.False;
pub const tomFontStretchUltraCondensed = tomConstants.ApplyLater;
pub const tomFontStretchExtraCondensed = tomConstants.TrackParms;
pub const tomFontStretchCondensed = tomConstants.CacheParms;
pub const tomFontStretchSemiCondensed = tomConstants.ApplyTmp;
pub const tomFontStretchNormal = tomConstants.SelectionRow;
pub const tomFontStretchSemiExpanded = tomConstants.SelectionBlock;
pub const tomFontStretchExpanded = tomConstants.SelectionInlineShape;
pub const tomFontStretchExtraExpanded = tomConstants.DisableSmartFont;
pub const tomFontStretchUltraExpanded = tomConstants.EnableSmartFont;
pub const tomFontWeightDefault = tomConstants.False;
pub const tomFontWeightThin = tomConstants.FontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.FontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.FontWeightLight;
pub const tomFontWeightNormal = tomConstants.FontWeightNormal;
pub const tomFontWeightRegular = tomConstants.FontWeightNormal;
pub const tomFontWeightMedium = tomConstants.FontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.FontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.FontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.FontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.FontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.FontWeightBlack;
pub const tomFontWeightExtraBlack = tomConstants.FontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.ParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.FindStory;
pub const tomMathLMargin = tomConstants.ReplaceStory;
pub const tomMathRMargin = tomConstants.MathRMargin;
pub const tomMathWrapIndent = tomConstants.MathWrapIndent;
pub const tomMathWrapRight = tomConstants.MathWrapRight;
pub const tomMathPostSpace = tomConstants.MathPostSpace;
pub const tomMathPreSpace = tomConstants.MathPreSpace;
pub const tomMathInterSpace = tomConstants.MathInterSpace;
pub const tomMathIntraSpace = tomConstants.MathIntraSpace;
pub const tomCanCopy = tomConstants.CanCopy;
pub const tomCanRedo = tomConstants.CanRedo;
pub const tomCanUndo = tomConstants.CanUndo;
pub const tomUndoLimit = tomConstants.UndoLimit;
pub const tomDocAutoLink = tomConstants.DocAutoLink;
pub const tomEllipsisMode = tomConstants.EllipsisMode;
pub const tomEllipsisState = tomConstants.EllipsisState;
pub const tomEllipsisNone = tomConstants.False;
pub const tomEllipsisEnd = tomConstants.ApplyLater;
pub const tomEllipsisWord = tomConstants.CacheParms;
pub const tomEllipsisPresent = tomConstants.ApplyLater;
pub const tomVTopCell = tomConstants.ApplyLater;
pub const tomVLowCell = tomConstants.TrackParms;
pub const tomHStartCell = tomConstants.ApplyTmp;
pub const tomHContCell = tomConstants.DisableSmartFont;
pub const tomRowUpdate = tomConstants.ApplyLater;
pub const tomRowApplyDefault = tomConstants.False;
pub const tomCellStructureChangeOnly = tomConstants.ApplyLater;
pub const tomRowHeightActual = tomConstants.RowHeightActual;

pub const OBJECTTYPE = enum(i32) {
    SimpleText = 0,
    Ruby = 1,
    HorzVert = 2,
    Warichu = 3,
    Eq = 9,
    Math = 10,
    // Accent = 10, this enum value conflicts with Math
    Box = 11,
    BoxedFormula = 12,
    Brackets = 13,
    BracketsWithSeps = 14,
    EquationArray = 15,
    Fraction = 16,
    FunctionApply = 17,
    LeftSubSup = 18,
    LowerLimit = 19,
    Matrix = 20,
    Nary = 21,
    OpChar = 22,
    Overbar = 23,
    Phantom = 24,
    Radical = 25,
    SlashedFraction = 26,
    Stack = 27,
    StretchStack = 28,
    Subscript = 29,
    SubSup = 30,
    Superscript = 31,
    Underbar = 32,
    UpperLimit = 33,
    // ObjectMax = 33, this enum value conflicts with UpperLimit
};
pub const tomSimpleText = OBJECTTYPE.SimpleText;
pub const tomRuby = OBJECTTYPE.Ruby;
pub const tomHorzVert = OBJECTTYPE.HorzVert;
pub const tomWarichu = OBJECTTYPE.Warichu;
pub const tomEq = OBJECTTYPE.Eq;
pub const tomMath = OBJECTTYPE.Math;
pub const tomAccent = OBJECTTYPE.Math;
pub const tomBox = OBJECTTYPE.Box;
pub const tomBoxedFormula = OBJECTTYPE.BoxedFormula;
pub const tomBrackets = OBJECTTYPE.Brackets;
pub const tomBracketsWithSeps = OBJECTTYPE.BracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.EquationArray;
pub const tomFraction = OBJECTTYPE.Fraction;
pub const tomFunctionApply = OBJECTTYPE.FunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.LeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.LowerLimit;
pub const tomMatrix = OBJECTTYPE.Matrix;
pub const tomNary = OBJECTTYPE.Nary;
pub const tomOpChar = OBJECTTYPE.OpChar;
pub const tomOverbar = OBJECTTYPE.Overbar;
pub const tomPhantom = OBJECTTYPE.Phantom;
pub const tomRadical = OBJECTTYPE.Radical;
pub const tomSlashedFraction = OBJECTTYPE.SlashedFraction;
pub const tomStack = OBJECTTYPE.Stack;
pub const tomStretchStack = OBJECTTYPE.StretchStack;
pub const tomSubscript = OBJECTTYPE.Subscript;
pub const tomSubSup = OBJECTTYPE.SubSup;
pub const tomSuperscript = OBJECTTYPE.Superscript;
pub const tomUnderbar = OBJECTTYPE.Underbar;
pub const tomUpperLimit = OBJECTTYPE.UpperLimit;
pub const tomObjectMax = OBJECTTYPE.UpperLimit;

pub const MANCODE = enum(i32) {
    BOLD = 16,
    ITAL = 32,
    GREEK = 64,
    ROMN = 0,
    SCRP = 1,
    FRAK = 2,
    OPEN = 3,
    SANS = 4,
    MONO = 5,
    MATH = 6,
    ISOL = 7,
    INIT = 8,
    TAIL = 9,
    STRCH = 10,
    LOOP = 11,
    OPENA = 12,
};
pub const MBOLD = MANCODE.BOLD;
pub const MITAL = MANCODE.ITAL;
pub const MGREEK = MANCODE.GREEK;
pub const MROMN = MANCODE.ROMN;
pub const MSCRP = MANCODE.SCRP;
pub const MFRAK = MANCODE.FRAK;
pub const MOPEN = MANCODE.OPEN;
pub const MSANS = MANCODE.SANS;
pub const MMONO = MANCODE.MONO;
pub const MMATH = MANCODE.MATH;
pub const MISOL = MANCODE.ISOL;
pub const MINIT = MANCODE.INIT;
pub const MTAIL = MANCODE.TAIL;
pub const MSTRCH = MANCODE.STRCH;
pub const MLOOP = MANCODE.LOOP;
pub const MOPENA = MANCODE.OPENA;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextDocument_Value = @import("../zig.zig").Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: fn(
            self: *const ITextDocument,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextDocument,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryCount: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges: fn(
            self: *const ITextDocument,
            ppStories: ?*?*ITextStoryRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSaved: fn(
            self: *const ITextDocument,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSaved: fn(
            self: *const ITextDocument,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTabStop: fn(
            self: *const ITextDocument,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTabStop: fn(
            self: *const ITextDocument,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        New: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const ITextDocument,
            pVar: ?*VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const ITextDocument,
            pVar: ?*VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range: fn(
            self: *const ITextDocument,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: fn(
            self: *const ITextDocument,
            x: i32,
            y: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetName(@ptrCast(*const ITextDocument, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSelection(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSelection(@ptrCast(*const ITextDocument, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryCount(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryRanges(self: *const T, ppStories: ?*?*ITextStoryRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryRanges(@ptrCast(*const ITextDocument, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSaved(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSaved(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetSaved(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetSaved(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetDefaultTabStop(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetDefaultTabStop(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetDefaultTabStop(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetDefaultTabStop(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_New(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).New(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Open(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Open(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Save(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Save(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Freeze(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Freeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Unfreeze(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Unfreeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_BeginEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).BeginEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_EndEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).EndEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Undo(self: *const T, Count: i32, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Undo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Redo(self: *const T, Count: i32, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Redo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Range(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Range(@ptrCast(*const ITextDocument, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_RangeFromPoint(self: *const T, x: i32, y: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextDocument, self), x, y, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextRange_Value = @import("../zig.zig").Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: fn(
            self: *const ITextRange,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar: fn(
            self: *const ITextRange,
            pChar: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChar: fn(
            self: *const ITextRange,
            Char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITextRange,
            pcpFirst: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStart: fn(
            self: *const ITextRange,
            cpFirst: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITextRange,
            pcpLim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnd: fn(
            self: *const ITextRange,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: fn(
            self: *const ITextRange,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const ITextRange,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara: fn(
            self: *const ITextRange,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara: fn(
            self: *const ITextRange,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryLength: fn(
            self: *const ITextRange,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryType: fn(
            self: *const ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const ITextRange,
            bStart: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const ITextRange,
            Unit: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            pIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            Index: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: fn(
            self: *const ITextRange,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InRange: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InStory: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStart: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEnd: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindText: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextStart: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextEnd: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cut: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
            Format: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPaste: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
            Format: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanEdit: fn(
            self: *const ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCase: fn(
            self: *const ITextRange,
            Type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPoint: fn(
            self: *const ITextRange,
            Type: i32,
            px: ?*i32,
            py: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoint: fn(
            self: *const ITextRange,
            x: i32,
            y: i32,
            Type: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const ITextRange,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedObject: fn(
            self: *const ITextRange,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetText(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetText(@ptrCast(*const ITextRange, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetText(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetText(@ptrCast(*const ITextRange, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetChar(self: *const T, pChar: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetChar(@ptrCast(*const ITextRange, self), pChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetChar(self: *const T, Char: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetChar(@ptrCast(*const ITextRange, self), Char);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetDuplicate(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFormattedText(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFormattedText(self: *const T, pRange: ?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextRange, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStart(self: *const T, pcpFirst: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStart(@ptrCast(*const ITextRange, self), pcpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetStart(self: *const T, cpFirst: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetStart(@ptrCast(*const ITextRange, self), cpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEnd(self: *const T, pcpLim: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEnd(@ptrCast(*const ITextRange, self), pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetEnd(self: *const T, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetEnd(@ptrCast(*const ITextRange, self), cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFont(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFont(@ptrCast(*const ITextRange, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFont(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFont(@ptrCast(*const ITextRange, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPara(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPara(@ptrCast(*const ITextRange, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPara(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPara(@ptrCast(*const ITextRange, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryLength(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryLength(@ptrCast(*const ITextRange, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryType(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Collapse(self: *const T, bStart: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Collapse(@ptrCast(*const ITextRange, self), bStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Expand(self: *const T, Unit: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Expand(@ptrCast(*const ITextRange, self), Unit, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetIndex(self: *const T, Unit: i32, pIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetIndex(@ptrCast(*const ITextRange, self), Unit, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetIndex(self: *const T, Unit: i32, Index: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetIndex(@ptrCast(*const ITextRange, self), Unit, Index, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetRange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetRange(@ptrCast(*const ITextRange, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InRange(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InRange(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InStory(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InStory(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_IsEqual(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Select(@ptrCast(*const ITextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_StartOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).StartOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_EndOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).EndOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Move(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Move(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStart(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStart(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEnd(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEnd(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindText(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindText(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextStart(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextStart(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextEnd(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextEnd(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Delete(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Delete(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Cut(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Cut(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Copy(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Copy(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Paste(self: *const T, pVar: ?*VARIANT, Format: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Paste(@ptrCast(*const ITextRange, self), pVar, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanPaste(self: *const T, pVar: ?*VARIANT, Format: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanPaste(@ptrCast(*const ITextRange, self), pVar, Format, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanEdit(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanEdit(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ChangeCase(self: *const T, Type: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ChangeCase(@ptrCast(*const ITextRange, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPoint(self: *const T, Type: i32, px: ?*i32, py: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPoint(@ptrCast(*const ITextRange, self), Type, px, py);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPoint(self: *const T, x: i32, y: i32, Type: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPoint(@ptrCast(*const ITextRange, self), x, y, Type, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ScrollIntoView(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRange, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEmbeddedObject(self: *const T, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEmbeddedObject(@ptrCast(*const ITextRange, self), ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextSelection_Value = @import("../zig.zig").Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: fn(
            self: *const ITextSelection,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const ITextSelection,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextSelection,
            pType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveLeft: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRight: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUp: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDown: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HomeKey: fn(
            self: *const ITextSelection,
            Unit: tomConstants,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndKey: fn(
            self: *const ITextSelection,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TypeText: fn(
            self: *const ITextSelection,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetFlags(@ptrCast(*const ITextSelection, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_SetFlags(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).SetFlags(@ptrCast(*const ITextSelection, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetType(self: *const T, pType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetType(@ptrCast(*const ITextSelection, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveLeft(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveLeft(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveRight(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveRight(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveUp(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveUp(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveDown(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveDown(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_HomeKey(self: *const T, Unit: tomConstants, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).HomeKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_EndKey(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).EndKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_TypeText(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).TypeText(@ptrCast(*const ITextSelection, self), bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextFont_Value = @import("../zig.zig").Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextFont,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextFont,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCaps: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnimation: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackColor: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBold: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmboss: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmboss: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeColor: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetForeColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHidden: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHidden: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngrave: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngrave: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItalic: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItalic: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKerning: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKerning: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageID: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLanguageID: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ITextFont,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ITextFont,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutline: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtected: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProtected: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShadow: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShadow: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSmallCaps: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSmallCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpacing: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrikeThrough: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrikeThrough: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscript: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuperscript: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSuperscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderline: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWeight: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWeight: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetDuplicate(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextFont, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetDuplicate(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextFont, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).CanChange(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_IsEqual(self: *const T, pFont: ?*ITextFont, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).IsEqual(@ptrCast(*const ITextFont, self), pFont, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_Reset(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).Reset(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStyle(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStyle(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStyle(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAllCaps(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAllCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAllCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAllCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAnimation(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAnimation(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAnimation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAnimation(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBackColor(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBackColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBackColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBackColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBold(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBold(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBold(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBold(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEmboss(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEmboss(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEmboss(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEmboss(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetForeColor(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetForeColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetForeColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetForeColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetHidden(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetHidden(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetHidden(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetHidden(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEngrave(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEngrave(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEngrave(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEngrave(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetItalic(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetItalic(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetItalic(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetItalic(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetKerning(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetKerning(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetKerning(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetKerning(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetLanguageID(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetLanguageID(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetLanguageID(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetLanguageID(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetName(@ptrCast(*const ITextFont, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetName(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetName(@ptrCast(*const ITextFont, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetOutline(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetOutline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetOutline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetOutline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetPosition(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetPosition(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetPosition(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetPosition(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetProtected(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetProtected(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetProtected(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetProtected(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetShadow(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetShadow(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetShadow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetShadow(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSize(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSize(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSize(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSize(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSmallCaps(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSmallCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSmallCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSmallCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSpacing(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSpacing(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSpacing(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSpacing(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStrikeThrough(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStrikeThrough(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStrikeThrough(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStrikeThrough(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSubscript(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSubscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSubscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSubscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSuperscript(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSuperscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSuperscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSuperscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetUnderline(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetUnderline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetUnderline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetUnderline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetWeight(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetWeight(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetWeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetWeight(@ptrCast(*const ITextFont, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextPara_Value = @import("../zig.zig").Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextPara,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlignment: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHyphenation: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHyphenation: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstLineIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeftIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacing: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacingRule: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListAlignment: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListLevelIndex: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListLevelIndex: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListStart: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListStart: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListTab: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListTab: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListType: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListType: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNoLineNumber: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoLineNumber: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageBreakBefore: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageBreakBefore: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRightIndent: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndents: fn(
            self: *const ITextPara,
            First: f32,
            Left: f32,
            Right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineSpacing: fn(
            self: *const ITextPara,
            Rule: i32,
            Spacing: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceAfter: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceAfter: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceBefore: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceBefore: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWidowControl: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWidowControl: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTabCount: fn(
            self: *const ITextPara,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: fn(
            self: *const ITextPara,
            tbPos: f32,
            tbAlign: i32,
            tbLeader: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllTabs: fn(
            self: *const ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: fn(
            self: *const ITextPara,
            tbPos: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTab: fn(
            self: *const ITextPara,
            iTab: i32,
            ptbPos: ?*f32,
            ptbAlign: ?*i32,
            ptbLeader: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetDuplicate(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextPara, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetDuplicate(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextPara, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).CanChange(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_IsEqual(self: *const T, pPara: ?*ITextPara, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).IsEqual(@ptrCast(*const ITextPara, self), pPara, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).Reset(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetStyle(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetStyle(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetStyle(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetHyphenation(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetHyphenation(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetHyphenation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetHyphenation(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetFirstLineIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetFirstLineIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepTogether(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepWithNext(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLeftIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLeftIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacing(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacing(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacingRule(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacingRule(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListLevelIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListLevelIndex(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListLevelIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListLevelIndex(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListStart(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListStart(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListTab(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListTab(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListTab(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListTab(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListType(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListType(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetNoLineNumber(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetNoLineNumber(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetNoLineNumber(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetNoLineNumber(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetPageBreakBefore(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetPageBreakBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetPageBreakBefore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetPageBreakBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetRightIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetRightIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetRightIndent(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetRightIndent(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetIndents(self: *const T, First: f32, Left: f32, Right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetIndents(@ptrCast(*const ITextPara, self), First, Left, Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetLineSpacing(self: *const T, Rule: i32, Spacing: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetLineSpacing(@ptrCast(*const ITextPara, self), Rule, Spacing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceAfter(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceAfter(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceAfter(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceAfter(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceBefore(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceBefore(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetWidowControl(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetWidowControl(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetWidowControl(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetWidowControl(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTabCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTabCount(@ptrCast(*const ITextPara, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_AddTab(self: *const T, tbPos: f32, tbAlign: i32, tbLeader: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).AddTab(@ptrCast(*const ITextPara, self), tbPos, tbAlign, tbLeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_ClearAllTabs(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).ClearAllTabs(@ptrCast(*const ITextPara, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_DeleteTab(self: *const T, tbPos: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).DeleteTab(@ptrCast(*const ITextPara, self), tbPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTab(self: *const T, iTab: i32, ptbPos: ?*f32, ptbAlign: ?*i32, ptbLeader: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTab(@ptrCast(*const ITextPara, self), iTab, ptbPos, ptbAlign, ptbLeader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextStoryRanges_Value = @import("../zig.zig").Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: fn(
            self: *const ITextStoryRanges,
            ppunkEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const ITextStoryRanges,
            Index: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStoryRanges,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges__NewEnum(self: *const T, ppunkEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable)._NewEnum(@ptrCast(*const ITextStoryRanges, self), ppunkEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).Item(@ptrCast(*const ITextStoryRanges, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).GetCount(@ptrCast(*const ITextStoryRanges, self), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDocument2_Value = @import("../zig.zig").Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplays: fn(
            self: *const ITextDocument2,
            ppDisplays: ?*?*ITextDisplays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentFont: fn(
            self: *const ITextDocument2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPara: fn(
            self: *const ITextDocument2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEastAsianFlags: fn(
            self: *const ITextDocument2,
            pFlags: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerator: fn(
            self: *const ITextDocument2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIMEInProgress: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2,
            ppSel: ?*?*ITextSelection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges2: fn(
            self: *const ITextDocument2,
            ppStories: ?*?*ITextStoryRanges2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypographyOptions: fn(
            self: *const ITextDocument2,
            pOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2,
            pHwnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMsgFilter: fn(
            self: *const ITextDocument2,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2,
            Type: tomConstants,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2,
            pContext: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2,
            cp: i32,
            CharRep: i32,
            Options: i32,
            curCharRep: i32,
            curFontSize: i32,
            pbstr: ?*?BSTR,
            pPitchAndFamily: ?*i32,
            pNewFontSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrings: fn(
            self: *const ITextDocument2,
            ppStrs: ?*?*ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range2: fn(
            self: *const ITextDocument2,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint2: fn(
            self: *const ITextDocument2,
            x: i32,
            y: i32,
            Type: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypographyOptions: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathProperties: fn(
            self: *const ITextDocument2,
            pOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathProperties: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveStory: fn(
            self: *const ITextDocument2,
            pStory: ?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStory: fn(
            self: *const ITextDocument2,
            Index: i32,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCaretType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetCaretType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDisplays(self: *const T, ppDisplays: ?*?*ITextDisplays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDisplays(@ptrCast(*const ITextDocument2, self), ppDisplays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentFont(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentFont(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentFont(@ptrCast(*const ITextDocument2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentPara(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentPara(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentPara(@ptrCast(*const ITextDocument2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEastAsianFlags(self: *const T, pFlags: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEastAsianFlags(@ptrCast(*const ITextDocument2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetGenerator(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetGenerator(@ptrCast(*const ITextDocument2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetIMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetIMEInProgress(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNotificationMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetNotificationMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStoryRanges2(self: *const T, ppStories: ?*?*ITextStoryRanges2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStoryRanges2(@ptrCast(*const ITextDocument2, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetTypographyOptions(self: *const T, pOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetTypographyOptions(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetVersion(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetVersion(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetWindow(self: *const T, pHwnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetClientRect(self: *const T, Type: tomConstants, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEffectColor(self: *const T, Index: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetImmContext(self: *const T, pContext: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Options: i32, curCharRep: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2, self), cp, CharRep, Options, curCharRep, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextDocument2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStrings(self: *const T, ppStrs: ?*?*ITextStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStrings(@ptrCast(*const ITextDocument2, self), ppStrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Range2(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Range2(@ptrCast(*const ITextDocument2, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_RangeFromPoint2(self: *const T, x: i32, y: i32, Type: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).RangeFromPoint2(@ptrCast(*const ITextDocument2, self), x, y, Type, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2, self), pVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetEffectColor(self: *const T, Index: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextDocument2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetTypographyOptions(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetTypographyOptions(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Update(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMathProperties(self: *const T, pOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMathProperties(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetMathProperties(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetMathProperties(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetActiveStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetActiveStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetActiveStory(self: *const T, pStory: ?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetActiveStory(@ptrCast(*const ITextDocument2, self), pStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMainStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMainStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNewStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNewStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStory(self: *const T, Index: i32, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStory(@ptrCast(*const ITextDocument2, self), Index, ppStory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRange2_Value = @import("../zig.zig").Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: fn(
            self: *const ITextRange2,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCells: fn(
            self: *const ITextRange2,
            ppCells: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: fn(
            self: *const ITextRange2,
            ppColumn: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextRange2,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont2: fn(
            self: *const ITextRange2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont2: fn(
            self: *const ITextRange2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText2: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const ITextRange2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const ITextRange2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara2: fn(
            self: *const ITextRange2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara2: fn(
            self: *const ITextRange2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRow: fn(
            self: *const ITextRange2,
            ppRow: ?*?*ITextRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartPara: fn(
            self: *const ITextRange2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const ITextRange2,
            ppTable: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const ITextRange2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURL: fn(
            self: *const ITextRange2,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubrange: fn(
            self: *const ITextRange2,
            cp1: i32,
            cp2: i32,
            Activate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpMath: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubrange: fn(
            self: *const ITextRange2,
            cpFirst: i32,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
            Count: i32,
            Flags: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar2: fn(
            self: *const ITextRange2,
            pChar: ?*i32,
            Offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropCap: fn(
            self: *const ITextRange2,
            pcLine: ?*i32,
            pPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInlineObject: fn(
            self: *const ITextRange2,
            pType: ?*i32,
            pAlign: ?*i32,
            pChar: ?*i32,
            pChar1: ?*i32,
            pChar2: ?*i32,
            pCount: ?*i32,
            pTeXStyle: ?*i32,
            pcCol: ?*i32,
            pLevel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: fn(
            self: *const ITextRange2,
            Type: i32,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
            pHit: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubrange: fn(
            self: *const ITextRange2,
            iSubrange: i32,
            pcpFirst: ?*i32,
            pcpLim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HexToUnicode: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTable: fn(
            self: *const ITextRange2,
            cCol: i32,
            cRow: i32,
            AutoFit: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Linearize: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveSubrange: fn(
            self: *const ITextRange2,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDropCap: fn(
            self: *const ITextRange2,
            cLine: i32,
            Position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnicodeToHex: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInlineObject: fn(
            self: *const ITextRange2,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathFunctionType: fn(
            self: *const ITextRange2,
            bstr: ?BSTR,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertImage: fn(
            self: *const ITextRange2,
            width: i32,
            height: i32,
            ascent: i32,
            Type: TEXT_ALIGN_OPTIONS,
            bstrAltText: ?BSTR,
            pStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextSelection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCch(self: *const T, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCch(@ptrCast(*const ITextRange2, self), pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCells(self: *const T, ppCells: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCells(@ptrCast(*const ITextRange2, self), ppCells);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetColumn(self: *const T, ppColumn: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetColumn(@ptrCast(*const ITextRange2, self), ppColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCount(@ptrCast(*const ITextRange2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDuplicate2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFont2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFont2(@ptrCast(*const ITextRange2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFont2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFont2(@ptrCast(*const ITextRange2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFormattedText2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFormattedText2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFormattedText2(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFormattedText2(@ptrCast(*const ITextRange2, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetGravity(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetGravity(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetGravity(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetGravity(@ptrCast(*const ITextRange2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetPara2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetPara2(@ptrCast(*const ITextRange2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetPara2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetPara2(@ptrCast(*const ITextRange2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRow(self: *const T, ppRow: ?*?*ITextRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRow(@ptrCast(*const ITextRange2, self), ppRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetStartPara(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetStartPara(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetTable(self: *const T, ppTable: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetTable(@ptrCast(*const ITextRange2, self), ppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetURL(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetURL(@ptrCast(*const ITextRange2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetURL(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetURL(@ptrCast(*const ITextRange2, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_AddSubrange(self: *const T, cp1: i32, cp2: i32, Activate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).AddSubrange(@ptrCast(*const ITextRange2, self), cp1, cp2, Activate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_BuildUpMath(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).BuildUpMath(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_DeleteSubrange(self: *const T, cpFirst: i32, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).DeleteSubrange(@ptrCast(*const ITextRange2, self), cpFirst, cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Find(self: *const T, pRange: ?*ITextRange2, Count: i32, Flags: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Find(@ptrCast(*const ITextRange2, self), pRange, Count, Flags, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetChar2(self: *const T, pChar: ?*i32, Offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetChar2(@ptrCast(*const ITextRange2, self), pChar, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDropCap(self: *const T, pcLine: ?*i32, pPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDropCap(@ptrCast(*const ITextRange2, self), pcLine, pPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetInlineObject(self: *const T, pType: ?*i32, pAlign: ?*i32, pChar: ?*i32, pChar1: ?*i32, pChar2: ?*i32, pCount: ?*i32, pTeXStyle: ?*i32, pcCol: ?*i32, pLevel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetInlineObject(@ptrCast(*const ITextRange2, self), pType, pAlign, pChar, pChar1, pChar2, pCount, pTeXStyle, pcCol, pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRange2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32, pHit: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRect(@ptrCast(*const ITextRange2, self), Type, pLeft, pTop, pRight, pBottom, pHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetSubrange(self: *const T, iSubrange: i32, pcpFirst: ?*i32, pcpLim: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetSubrange(@ptrCast(*const ITextRange2, self), iSubrange, pcpFirst, pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetText2(self: *const T, Flags: i32, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetText2(@ptrCast(*const ITextRange2, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_HexToUnicode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).HexToUnicode(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertTable(self: *const T, cCol: i32, cRow: i32, AutoFit: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertTable(@ptrCast(*const ITextRange2, self), cCol, cRow, AutoFit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Linearize(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Linearize(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetActiveSubrange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetActiveSubrange(@ptrCast(*const ITextRange2, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetDropCap(self: *const T, cLine: i32, Position: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetDropCap(@ptrCast(*const ITextRange2, self), cLine, Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRange2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetText2(self: *const T, Flags: i32, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetText2(@ptrCast(*const ITextRange2, self), Flags, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_UnicodeToHex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).UnicodeToHex(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetInlineObject(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetInlineObject(@ptrCast(*const ITextRange2, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetMathFunctionType(self: *const T, bstr: ?BSTR, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetMathFunctionType(@ptrCast(*const ITextRange2, self), bstr, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertImage(self: *const T, width: i32, height: i32, ascent: i32, Type: TEXT_ALIGN_OPTIONS, bstrAltText: ?BSTR, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertImage(@ptrCast(*const ITextRange2, self), width, height, ascent, Type, bstrAltText, pStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextSelection2_Value = @import("../zig.zig").Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextFont2_Value = @import("../zig.zig").Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: fn(
            self: *const ITextFont2,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoLigatures: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutoLigatures: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceAlpha: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceAlpha: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceNumeric: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceNumeric: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceParens: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceParens: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharRep: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCharRep: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionMode: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompressionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDoubleStrike: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDoubleStrike: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextFont2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkType: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathZone: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathZone: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthPairs: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthPairs: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthSpace: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthSpace: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOldNumbers: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOldNumbers: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlapping: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlapping: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionSubSuper: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositionSubSuper: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScaling: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaling: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceExtension: fn(
            self: *const ITextFont2,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceExtension: fn(
            self: *const ITextFont2,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects2: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const ITextFont2,
            Index: i32,
            pType: ?*i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects2: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextFont.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCount(@ptrCast(*const ITextFont2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutoLigatures(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutoLigatures(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutoLigatures(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutoLigatures(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceAlpha(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceAlpha(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceAlpha(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceAlpha(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceNumeric(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceNumeric(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceNumeric(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceNumeric(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceParens(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceParens(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceParens(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceParens(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCharRep(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCharRep(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCharRep(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCharRep(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCompressionMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCompressionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCompressionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCompressionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCookie(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCookie(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCookie(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCookie(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDoubleStrike(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDoubleStrike(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDoubleStrike(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDoubleStrike(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDuplicate2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextFont2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDuplicate2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextFont2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetLinkType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetLinkType(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetMathZone(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetMathZone(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetMathZone(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetMathZone(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthPairs(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthPairs(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthPairs(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthPairs(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthSpace(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthSpace(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthSpace(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthSpace(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOldNumbers(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOldNumbers(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOldNumbers(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOldNumbers(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOverlapping(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOverlapping(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOverlapping(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOverlapping(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPositionSubSuper(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPositionSubSuper(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetPositionSubSuper(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetPositionSubSuper(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetScaling(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetScaling(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetScaling(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetScaling(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetSpaceExtension(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetSpaceExtension(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetSpaceExtension(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetSpaceExtension(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetUnderlinePositionMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetUnderlinePositionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects2(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects2(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextFont2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPropertyInfo(self: *const T, Index: i32, pType: ?*i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const ITextFont2, self), Index, pType, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_IsEqual2(self: *const T, pFont: ?*ITextFont2, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextFont2, self), pFont, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects2(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects2(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextFont2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextPara2_Value = @import("../zig.zig").Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: fn(
            self: *const ITextPara2,
            ppBorders: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextPara2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontAlignment: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFontAlignment: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHangingPunctuation: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHangingPunctuation: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapToGrid: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapToGrid: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextPara2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextPara.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetBorders(self: *const T, ppBorders: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetBorders(@ptrCast(*const ITextPara2, self), ppBorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetDuplicate2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextPara2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetDuplicate2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextPara2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetFontAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetFontAlignment(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetFontAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetFontAlignment(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetHangingPunctuation(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetHangingPunctuation(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetHangingPunctuation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetHangingPunctuation(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetSnapToGrid(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetSnapToGrid(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetSnapToGrid(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetSnapToGrid(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetTrimPunctuationAtStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetTrimPunctuationAtStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextPara2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextPara2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_IsEqual2(self: *const T, pPara: ?*ITextPara2, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextPara2, self), pPara, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextPara2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextPara2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoryRanges2_Value = @import("../zig.zig").Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: fn(
            self: *const ITextStoryRanges2,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoryRanges.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges2_Item2(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges2.VTable, self.vtable).Item2(@ptrCast(*const ITextStoryRanges2, self), Index, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStory_Value = @import("../zig.zig").Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActive: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplay: fn(
            self: *const ITextStory,
            ppDisplay: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: fn(
            self: *const ITextStory,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStory,
            Flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStory,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStory,
            Flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetActive(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetActive(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetActive(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetActive(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetDisplay(self: *const T, ppDisplay: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetDisplay(@ptrCast(*const ITextStory, self), ppDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetIndex(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetType(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetType(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetProperty(@ptrCast(*const ITextStory, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetRange(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetRange(@ptrCast(*const ITextStory, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetText(self: *const T, Flags: i32, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetText(@ptrCast(*const ITextStory, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetFormattedText(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStory, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetProperty(@ptrCast(*const ITextStory, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetText(self: *const T, Flags: i32, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetText(@ptrCast(*const ITextStory, self), Flags, bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStrings_Value = @import("../zig.zig").Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const ITextStrings,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStrings,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cat2: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatTop2: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRange: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeFunction: fn(
            self: *const ITextStrings,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCch: fn(
            self: *const ITextStrings,
            iString: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertNullStr: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveBoundary: fn(
            self: *const ITextStrings,
            iString: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrefixTop: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITextStrings,
            iString: i32,
            cString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStrings,
            pRangeD: ?*ITextRange2,
            pRangeS: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpCp: fn(
            self: *const ITextStrings,
            iString: i32,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuffixTop: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Swap: fn(
            self: *const ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Item(@ptrCast(*const ITextStrings, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCount(@ptrCast(*const ITextStrings, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Add(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Add(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Append(self: *const T, pRange: ?*ITextRange2, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Append(@ptrCast(*const ITextStrings, self), pRange, iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Cat2(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Cat2(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_CatTop2(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).CatTop2(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_DeleteRange(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).DeleteRange(@ptrCast(*const ITextStrings, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_EncodeFunction(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).EncodeFunction(@ptrCast(*const ITextStrings, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCch(self: *const T, iString: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCch(@ptrCast(*const ITextStrings, self), iString, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_InsertNullStr(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).InsertNullStr(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_MoveBoundary(self: *const T, iString: i32, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).MoveBoundary(@ptrCast(*const ITextStrings, self), iString, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_PrefixTop(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).PrefixTop(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Remove(self: *const T, iString: i32, cString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Remove(@ptrCast(*const ITextStrings, self), iString, cString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetFormattedText(self: *const T, pRangeD: ?*ITextRange2, pRangeS: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStrings, self), pRangeD, pRangeS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetOpCp(self: *const T, iString: i32, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetOpCp(@ptrCast(*const ITextStrings, self), iString, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SuffixTop(self: *const T, bstr: ?BSTR, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SuffixTop(@ptrCast(*const ITextStrings, self), bstr, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Swap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Swap(@ptrCast(*const ITextStrings, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRow_Value = @import("../zig.zig").Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCount: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCount: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCountCache: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCountCache: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellIndex: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellIndex: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMargin: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMargin: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeight: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeight: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndent: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndent: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNestLevel: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRTL: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRTL: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellAlignment: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorBack: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorBack: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorFore: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorFore: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMergeFlags: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMergeFlags: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellShading: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellShading: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellVerticalText: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellVerticalText: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellWidth: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellWidth: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderColors: fn(
            self: *const ITextRow,
            pcrLeft: ?*i32,
            pcrTop: ?*i32,
            pcrRight: ?*i32,
            pcrBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderWidths: fn(
            self: *const ITextRow,
            pduLeft: ?*i32,
            pduTop: ?*i32,
            pduRight: ?*i32,
            pduBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderColors: fn(
            self: *const ITextRow,
            crLeft: i32,
            crTop: i32,
            crRight: i32,
            crBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderWidths: fn(
            self: *const ITextRow,
            duLeft: i32,
            duTop: i32,
            duRight: i32,
            duBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: fn(
            self: *const ITextRow,
            cRow: i32,
            Flags: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: fn(
            self: *const ITextRow,
            cRow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRow,
            pRow: ?*ITextRow,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCount(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCount(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCount(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCount(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCountCache(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCountCache(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCountCache(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCountCache(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellIndex(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellIndex(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMargin(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMargin(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMargin(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMargin(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetHeight(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetHeight(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetHeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetHeight(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetIndent(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetIndent(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetIndent(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetIndent(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepTogether(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepWithNext(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetNestLevel(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetNestLevel(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetRTL(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetRTL(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetRTL(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetRTL(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorBack(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorBack(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorBack(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorBack(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorFore(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorFore(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorFore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorFore(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMergeFlags(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMergeFlags(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMergeFlags(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMergeFlags(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellShading(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellShading(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellShading(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellShading(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellVerticalText(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellVerticalText(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellVerticalText(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellVerticalText(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellWidth(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellWidth(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellWidth(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellWidth(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderColors(self: *const T, pcrLeft: ?*i32, pcrTop: ?*i32, pcrRight: ?*i32, pcrBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderColors(@ptrCast(*const ITextRow, self), pcrLeft, pcrTop, pcrRight, pcrBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderWidths(self: *const T, pduLeft: ?*i32, pduTop: ?*i32, pduRight: ?*i32, pduBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderWidths(@ptrCast(*const ITextRow, self), pduLeft, pduTop, pduRight, pduBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderColors(self: *const T, crLeft: i32, crTop: i32, crRight: i32, crBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderColors(@ptrCast(*const ITextRow, self), crLeft, crTop, crRight, crBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderWidths(self: *const T, duLeft: i32, duTop: i32, duRight: i32, duBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderWidths(@ptrCast(*const ITextRow, self), duLeft, duTop, duRight, duBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Apply(self: *const T, cRow: i32, Flags: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Apply(@ptrCast(*const ITextRow, self), cRow, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).CanChange(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRow, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Insert(self: *const T, cRow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Insert(@ptrCast(*const ITextRow, self), cRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_IsEqual(self: *const T, pRow: ?*ITextRow, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRow, self), pRow, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Reset(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRow, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDisplays_Value = @import("../zig.zig").Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = @import("../zig.zig").Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: fn(
            self: *const ITextDocument2Old,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            pcr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretType: fn(
            self: *const ITextDocument2Old,
            pCaretType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2Old,
            CaretType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2Old,
            pContext: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2Old,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2Old,
            cp: i32,
            CharRep: i32,
            Option: i32,
            CharRepCur: i32,
            curFontSize: i32,
            pbstr: ?*?BSTR,
            pPitchAndFamily: ?*i32,
            pNewFontSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2Old,
            pMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2Old,
            Type: i32,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2Old,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2Old,
            phWnd: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFEFlags: fn(
            self: *const ITextDocument2Old,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2Old,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IMEInProgress: fn(
            self: *const ITextDocument2Old,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2Old,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2Old,
            ppITextFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2Old,
            ppITextPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2Old,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2Old,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2Old, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetEffectColor(self: *const T, Index: i32, cr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, cr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetEffectColor(self: *const T, Index: i32, pcr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, pcr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCaretType(self: *const T, pCaretType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2Old, self), pCaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetCaretType(self: *const T, CaretType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2Old, self), CaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetImmContext(self: *const T, pContext: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2Old, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2Old, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Option: i32, CharRepCur: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2Old, self), cp, CharRep, Option, CharRepCur, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetNotificationMode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2Old, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetNotificationMode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetClientRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2Old, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2Old, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetWindow(self: *const T, phWnd: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2Old, self), phWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetFEFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetFEFlags(@ptrCast(*const ITextDocument2Old, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2Old, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_IMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).IMEInProgress(@ptrCast(*const ITextDocument2Old, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Update(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2Old, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentFont(self: *const T, ppITextFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2Old, self), ppITextFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentPara(self: *const T, ppITextPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2Old, self), ppITextPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2Old, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2Old, self), pVoid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: ?*IOleObject,
    pstg: ?*IStorage,
    polesite: ?*IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: REOBJECT_FLAGS,
    dwUser: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOle_Value = @import("../zig.zig").Guid.initString("00020d00-0000-0000-c000-000000000046");
pub const IID_IRichEditOle = &IID_IRichEditOle_Value;
pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: fn(
            self: *const IRichEditOle,
            lplpolesite: ?*?*IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetLinkCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpreobject: ?*REOBJECT,
            dwFlags: RICH_EDIT_GET_OBJECT_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertObject: fn(
            self: *const IRichEditOle,
            lpreobject: ?*REOBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            rclsidNew: ?*const Guid,
            lpstrUserTypeNew: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAs: fn(
            self: *const IRichEditOle,
            rclsid: ?*const Guid,
            rclsidAs: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: fn(
            self: *const IRichEditOle,
            lpstrContainerApp: ?[*:0]const u8,
            lpstrContainerObj: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkAvailable: fn(
            self: *const IRichEditOle,
            iob: i32,
            fAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDvaspect: fn(
            self: *const IRichEditOle,
            iob: i32,
            dvaspect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: fn(
            self: *const IRichEditOle,
            iob: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpstg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPlaceDeactivate: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOle,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOle,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportDataObject: fn(
            self: *const IRichEditOle,
            lpdataobj: ?*IDataObject,
            cf: u16,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClientSite(self: *const T, lplpolesite: ?*?*IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClientSite(@ptrCast(*const IRichEditOle, self), lplpolesite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObjectCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObjectCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetLinkCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetLinkCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObject(self: *const T, iob: i32, lpreobject: ?*REOBJECT, dwFlags: RICH_EDIT_GET_OBJECT_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObject(@ptrCast(*const IRichEditOle, self), iob, lpreobject, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InsertObject(self: *const T, lpreobject: ?*REOBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InsertObject(@ptrCast(*const IRichEditOle, self), lpreobject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ConvertObject(self: *const T, iob: i32, rclsidNew: ?*const Guid, lpstrUserTypeNew: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ConvertObject(@ptrCast(*const IRichEditOle, self), iob, rclsidNew, lpstrUserTypeNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ActivateAs(self: *const T, rclsid: ?*const Guid, rclsidAs: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ActivateAs(@ptrCast(*const IRichEditOle, self), rclsid, rclsidAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetHostNames(self: *const T, lpstrContainerApp: ?[*:0]const u8, lpstrContainerObj: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetHostNames(@ptrCast(*const IRichEditOle, self), lpstrContainerApp, lpstrContainerObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetLinkAvailable(self: *const T, iob: i32, fAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetLinkAvailable(@ptrCast(*const IRichEditOle, self), iob, fAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetDvaspect(self: *const T, iob: i32, dvaspect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetDvaspect(@ptrCast(*const IRichEditOle, self), iob, dvaspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_HandsOffStorage(self: *const T, iob: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).HandsOffStorage(@ptrCast(*const IRichEditOle, self), iob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SaveCompleted(self: *const T, iob: i32, lpstg: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SaveCompleted(@ptrCast(*const IRichEditOle, self), iob, lpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InPlaceDeactivate(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOle, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOle, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ImportDataObject(self: *const T, lpdataobj: ?*IDataObject, cf: u16, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ImportDataObject(@ptrCast(*const IRichEditOle, self), lpdataobj, cf, hMetaPict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOleCallback_Value = @import("../zig.zig").Guid.initString("00020d03-0000-0000-c000-000000000046");
pub const IID_IRichEditOleCallback = &IID_IRichEditOleCallback_Value;
pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: fn(
            self: *const IRichEditOleCallback,
            lplpstg: ?*?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceContext: fn(
            self: *const IRichEditOleCallback,
            lplpFrame: ?*?*IOleInPlaceFrame,
            lplpDoc: ?*?*IOleInPlaceUIWindow,
            lpFrameInfo: ?*OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContainerUI: fn(
            self: *const IRichEditOleCallback,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertObject: fn(
            self: *const IRichEditOleCallback,
            lpclsid: ?*Guid,
            lpstg: ?*IStorage,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteObject: fn(
            self: *const IRichEditOleCallback,
            lpoleobj: ?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAcceptData: fn(
            self: *const IRichEditOleCallback,
            lpdataobj: ?*IDataObject,
            lpcfFormat: ?*u16,
            reco: u32,
            fReally: BOOL,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOleCallback,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOleCallback,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragDropEffect: fn(
            self: *const IRichEditOleCallback,
            fDrag: BOOL,
            grfKeyState: u32,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextMenu: fn(
            self: *const IRichEditOleCallback,
            seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
            lpoleobj: ?*IOleObject,
            lpchrg: ?*CHARRANGE,
            lphmenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetNewStorage(self: *const T, lplpstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetNewStorage(@ptrCast(*const IRichEditOleCallback, self), lplpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetInPlaceContext(self: *const T, lplpFrame: ?*?*IOleInPlaceFrame, lplpDoc: ?*?*IOleInPlaceUIWindow, lpFrameInfo: ?*OIFI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetInPlaceContext(@ptrCast(*const IRichEditOleCallback, self), lplpFrame, lplpDoc, lpFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ShowContainerUI(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ShowContainerUI(@ptrCast(*const IRichEditOleCallback, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryInsertObject(self: *const T, lpclsid: ?*Guid, lpstg: ?*IStorage, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryInsertObject(@ptrCast(*const IRichEditOleCallback, self), lpclsid, lpstg, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_DeleteObject(self: *const T, lpoleobj: ?*IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).DeleteObject(@ptrCast(*const IRichEditOleCallback, self), lpoleobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryAcceptData(self: *const T, lpdataobj: ?*IDataObject, lpcfFormat: ?*u16, reco: u32, fReally: BOOL, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryAcceptData(@ptrCast(*const IRichEditOleCallback, self), lpdataobj, lpcfFormat, reco, fReally, hMetaPict);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOleCallback, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOleCallback, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetDragDropEffect(self: *const T, fDrag: BOOL, grfKeyState: u32, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetDragDropEffect(@ptrCast(*const IRichEditOleCallback, self), fDrag, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetContextMenu(self: *const T, seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, lpoleobj: ?*IOleObject, lpchrg: ?*CHARRANGE, lphmenu: ?*?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetContextMenu(@ptrCast(*const IRichEditOleCallback, self), seltype, lpoleobj, lpchrg, lphmenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TXTBACKSTYLE = enum(i32) {
    TRANSPARENT = 0,
    OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.OPAQUE;

pub const TXTHITRESULT = enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = enum(i32) {
    FITTOCONTENT2 = 0,
    FITTOCONTENT = 1,
    ROUNDTOLINE = 2,
    FITTOCONTENT3 = 3,
    FITTOCONTENTWSP = 4,
    INCLUDELASTLINE = 1073741824,
    EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.EMU;

pub const TXTVIEW = enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = enum(i32) {
    GENERIC = 0,
    TEXTCHANGED = 1,
    NEWUNDO = 2,
    NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: CHANGETYPE,
    pvCookieData: ?*c_void,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: fn(
            self: *const ITextServices,
            msg: u32,
            wparam: WPARAM,
            lparam: LPARAM,
            plresult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDraw: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*c_void,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcBounds: ?*RECTL,
            lprcWBounds: ?*RECTL,
            lprcUpdate: ?*RECT,
            pfnContinue: isize,
            dwContinue: u32,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHScroll: fn(
            self: *const ITextServices,
            plMin: ?*i32,
            plMax: ?*i32,
            plPos: ?*i32,
            plPage: ?*i32,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetVScroll: fn(
            self: *const ITextServices,
            plMin: ?*i32,
            plMax: ?*i32,
            plPos: ?*i32,
            plPage: ?*i32,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxSetCursor: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*c_void,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcClient: ?*RECT,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxQueryHitPoint: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*c_void,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcClient: ?*RECT,
            x: i32,
            y: i32,
            pHitResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceActivate: fn(
            self: *const ITextServices,
            prcClient: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIActivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetText: fn(
            self: *const ITextServices,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetText: fn(
            self: *const ITextServices,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCurTargetX: fn(
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetBaseLinePos: fn(
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetNaturalSize: fn(
            self: *const ITextServices,
            dwAspect: u32,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetDropTarget: fn(
            self: *const ITextServices,
            ppDropTarget: ?*?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxPropertyBitsChange: fn(
            self: *const ITextServices,
            dwMask: u32,
            dwBits: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCachedSize: fn(
            self: *const ITextServices,
            pdwWidth: ?*u32,
            pdwHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSendMessage(self: *const T, msg: u32, wparam: WPARAM, lparam: LPARAM, plresult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSendMessage(@ptrCast(*const ITextServices, self), msg, wparam, lparam, plresult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxDraw(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*c_void, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcBounds: ?*RECTL, lprcWBounds: ?*RECTL, lprcUpdate: ?*RECT, pfnContinue: isize, dwContinue: u32, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxDraw(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate, pfnContinue, dwContinue, lViewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetHScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetHScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetVScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetVScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxSetCursor(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*c_void, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxSetCursor(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxQueryHitPoint(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*c_void, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32, pHitResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxQueryHitPoint(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceActivate(self: *const T, prcClient: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceActivate(@ptrCast(*const ITextServices, self), prcClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIActivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetText(self: *const T, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetText(@ptrCast(*const ITextServices, self), pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSetText(self: *const T, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSetText(@ptrCast(*const ITextServices, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCurTargetX(self: *const T, param0: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCurTargetX(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetBaseLinePos(self: *const T, param0: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetBaseLinePos(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetNaturalSize(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetNaturalSize(@ptrCast(*const ITextServices, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetDropTarget(self: *const T, ppDropTarget: ?*?*IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetDropTarget(@ptrCast(*const ITextServices, self), ppDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxPropertyBitsChange(self: *const T, dwMask: u32, dwBits: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxPropertyBitsChange(@ptrCast(*const ITextServices, self), dwMask, dwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCachedSize(self: *const T, pdwWidth: ?*u32, pdwHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCachedSize(@ptrCast(*const ITextServices, self), pdwWidth, pdwHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = enum(i32) {
    NONE = 0,
    CUSTOM = 1,
    RTL = 2,
    ITALIC = 32,
    NULL = 64,
    ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CUSTOM;
pub const CARET_RTL = CARET_FLAGS.RTL;
pub const CARET_ITALIC = CARET_FLAGS.ITALIC;
pub const CARET_NULL = CARET_FLAGS.NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.ROTATE90;

pub const CARET_INFO = extern union {
    hbitmap: ?HBITMAP,
    caretFlags: CARET_FLAGS,
};

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HDC,
        TxReleaseDC: fn(
            self: *const ITextHost,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        TxShowScrollBar: fn(
            self: *const ITextHost,
            fnBar: i32,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxEnableScrollBar: fn(
            self: *const ITextHost,
            fuSBFlags: SCROLLBAR_CONSTANTS,
            fuArrowflags: ENABLE_SCROLL_BAR_ARROWS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollRange: fn(
            self: *const ITextHost,
            fnBar: i32,
            nMinPos: i32,
            nMaxPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollPos: fn(
            self: *const ITextHost,
            fnBar: i32,
            nPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxInvalidateRect: fn(
            self: *const ITextHost,
            prc: ?*RECT,
            fMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxViewChange: fn(
            self: *const ITextHost,
            fUpdate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxCreateCaret: fn(
            self: *const ITextHost,
            hbmp: ?HBITMAP,
            xWidth: i32,
            yHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxShowCaret: fn(
            self: *const ITextHost,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetCaretPos: fn(
            self: *const ITextHost,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
            uTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxKillTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScrollWindowEx: fn(
            self: *const ITextHost,
            dx: i32,
            dy: i32,
            lprcScroll: ?*RECT,
            lprcClip: ?*RECT,
            hrgnUpdate: ?HRGN,
            lprcUpdate: ?*RECT,
            fuScroll: SHOW_WINDOW_CMD,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCapture: fn(
            self: *const ITextHost,
            fCapture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetFocus: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCursor: fn(
            self: *const ITextHost,
            hcur: ?HCURSOR,
            fText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScreenToClient: fn(
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxClientToScreen: fn(
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxActivate: fn(
            self: *const ITextHost,
            plOldState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDeactivate: fn(
            self: *const ITextHost,
            lNewState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetClientRect: fn(
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetViewInset: fn(
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCharFormat: fn(
            self: *const ITextHost,
            ppCF: ?*const ?*CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetParaFormat: fn(
            self: *const ITextHost,
            ppPF: ?*const ?*PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetSysColor: fn(
            self: *const ITextHost,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        TxGetBackStyle: fn(
            self: *const ITextHost,
            pstyle: ?*TXTBACKSTYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetMaxLength: fn(
            self: *const ITextHost,
            plength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetScrollBars: fn(
            self: *const ITextHost,
            pdwScrollBar: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPasswordChar: fn(
            self: *const ITextHost,
            pch: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetAcceleratorPos: fn(
            self: *const ITextHost,
            pcp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetExtent: fn(
            self: *const ITextHost,
            lpExtent: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxCharFormatChange: fn(
            self: *const ITextHost,
            pCF: ?*const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxParaFormatChange: fn(
            self: *const ITextHost,
            pPF: ?*const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPropertyBits: fn(
            self: *const ITextHost,
            dwMask: u32,
            pdwBits: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxNotify: fn(
            self: *const ITextHost,
            iNotify: u32,
            pv: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxImmGetContext: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HIMC,
        TxImmReleaseContext: fn(
            self: *const ITextHost,
            himc: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetSelectionBarWidth: fn(
            self: *const ITextHost,
            lSelBarWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetDC(self: *const T) callconv(.Inline) ?HDC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetDC(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxReleaseDC(self: *const T, hdc: ?HDC) callconv(.Inline) i32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxReleaseDC(@ptrCast(*const ITextHost, self), hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowScrollBar(self: *const T, fnBar: i32, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowScrollBar(@ptrCast(*const ITextHost, self), fnBar, fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxEnableScrollBar(self: *const T, fuSBFlags: SCROLLBAR_CONSTANTS, fuArrowflags: ENABLE_SCROLL_BAR_ARROWS) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxEnableScrollBar(@ptrCast(*const ITextHost, self), fuSBFlags, fuArrowflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollRange(self: *const T, fnBar: i32, nMinPos: i32, nMaxPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollRange(@ptrCast(*const ITextHost, self), fnBar, nMinPos, nMaxPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollPos(self: *const T, fnBar: i32, nPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollPos(@ptrCast(*const ITextHost, self), fnBar, nPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxInvalidateRect(self: *const T, prc: ?*RECT, fMode: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxInvalidateRect(@ptrCast(*const ITextHost, self), prc, fMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxViewChange(self: *const T, fUpdate: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxViewChange(@ptrCast(*const ITextHost, self), fUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxCreateCaret(self: *const T, hbmp: ?HBITMAP, xWidth: i32, yHeight: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxCreateCaret(@ptrCast(*const ITextHost, self), hbmp, xWidth, yHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowCaret(self: *const T, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowCaret(@ptrCast(*const ITextHost, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCaretPos(self: *const T, x: i32, y: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCaretPos(@ptrCast(*const ITextHost, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetTimer(self: *const T, idTimer: u32, uTimeout: u32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetTimer(@ptrCast(*const ITextHost, self), idTimer, uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxKillTimer(self: *const T, idTimer: u32) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxKillTimer(@ptrCast(*const ITextHost, self), idTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScrollWindowEx(self: *const T, dx: i32, dy: i32, lprcScroll: ?*RECT, lprcClip: ?*RECT, hrgnUpdate: ?HRGN, lprcUpdate: ?*RECT, fuScroll: SHOW_WINDOW_CMD) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScrollWindowEx(@ptrCast(*const ITextHost, self), dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCapture(self: *const T, fCapture: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCapture(@ptrCast(*const ITextHost, self), fCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetFocus(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetFocus(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCursor(self: *const T, hcur: ?HCURSOR, fText: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCursor(@ptrCast(*const ITextHost, self), hcur, fText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScreenToClient(self: *const T, lppt: ?*POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScreenToClient(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxClientToScreen(self: *const T, lppt: ?*POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxClientToScreen(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxActivate(self: *const T, plOldState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxActivate(@ptrCast(*const ITextHost, self), plOldState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxDeactivate(self: *const T, lNewState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxDeactivate(@ptrCast(*const ITextHost, self), lNewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetClientRect(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetClientRect(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetViewInset(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetViewInset(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetCharFormat(self: *const T, ppCF: ?*const ?*CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetCharFormat(@ptrCast(*const ITextHost, self), ppCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetParaFormat(self: *const T, ppPF: ?*const ?*PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetParaFormat(@ptrCast(*const ITextHost, self), ppPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSysColor(self: *const T, nIndex: i32) callconv(.Inline) u32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSysColor(@ptrCast(*const ITextHost, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetBackStyle(self: *const T, pstyle: ?*TXTBACKSTYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetBackStyle(@ptrCast(*const ITextHost, self), pstyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetMaxLength(self: *const T, plength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetMaxLength(@ptrCast(*const ITextHost, self), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetScrollBars(self: *const T, pdwScrollBar: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetScrollBars(@ptrCast(*const ITextHost, self), pdwScrollBar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPasswordChar(self: *const T, pch: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPasswordChar(@ptrCast(*const ITextHost, self), pch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetAcceleratorPos(self: *const T, pcp: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetAcceleratorPos(@ptrCast(*const ITextHost, self), pcp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetExtent(self: *const T, lpExtent: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetExtent(@ptrCast(*const ITextHost, self), lpExtent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxCharFormatChange(self: *const T, pCF: ?*const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxCharFormatChange(@ptrCast(*const ITextHost, self), pCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxParaFormatChange(self: *const T, pPF: ?*const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxParaFormatChange(@ptrCast(*const ITextHost, self), pPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPropertyBits(self: *const T, dwMask: u32, pdwBits: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPropertyBits(@ptrCast(*const ITextHost, self), dwMask, pdwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxNotify(self: *const T, iNotify: u32, pv: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxNotify(@ptrCast(*const ITextHost, self), iNotify, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmGetContext(self: *const T) callconv(.Inline) ?HIMC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmGetContext(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmReleaseContext(self: *const T, himc: ?HIMC) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmReleaseContext(@ptrCast(*const ITextHost, self), himc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSelectionBarWidth(self: *const T, lSelBarWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSelectionBarWidth(@ptrCast(*const ITextHost, self), lSelBarWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditWindowlessAccessibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: fn(
            self: *const IRicheditWindowlessAccessibility,
            pSite: ?*IRawElementProviderWindowlessSite,
            ppProvider: ?*?*IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditWindowlessAccessibility_CreateProvider(self: *const T, pSite: ?*IRawElementProviderWindowlessSite, ppProvider: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditWindowlessAccessibility.VTable, self.vtable).CreateProvider(@ptrCast(*const IRicheditWindowlessAccessibility, self), pSite, ppProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRichEditUiaInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoundaryRectangle: fn(
            self: *const IRichEditUiaInformation,
            pUiaRect: ?*UiaRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVisible: fn(
            self: *const IRichEditUiaInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_GetBoundaryRectangle(self: *const T, pUiaRect: ?*UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).GetBoundaryRectangle(@ptrCast(*const IRichEditUiaInformation, self), pUiaRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_IsVisible(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).IsVisible(@ptrCast(*const IRichEditUiaInformation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: fn(
            self: *const IRicheditUiaOverrides,
            propertyId: i32,
            pRetValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditUiaOverrides_GetPropertyOverrideValue(self: *const T, propertyId: i32, pRetValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditUiaOverrides.VTable, self.vtable).GetPropertyOverrideValue(@ptrCast(*const IRicheditUiaOverrides, self), propertyId, pRetValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = fn(
    punkOuter: ?*IUnknown,
    pITextHost: ?*ITextHost,
    ppUnk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PShutdownTextServices = fn(
    pTextServices: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxGetWindow: fn(
            self: *const ITextHost2,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetForegroundWindow: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPalette: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) ?HPALETTE,
        TxGetEastAsianFlags: fn(
            self: *const ITextHost2,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetCursor2: fn(
            self: *const ITextHost2,
            hcur: ?HCURSOR,
            bText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?HCURSOR,
        TxFreeTextServicesNotification: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetEditStyle: fn(
            self: *const ITextHost2,
            dwItem: u32,
            pdwData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetWindowStyles: fn(
            self: *const ITextHost2,
            pdwStyle: ?*u32,
            pdwExStyle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxShowDropCaret: fn(
            self: *const ITextHost2,
            fShow: BOOL,
            hdc: ?HDC,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDestroyCaret: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHorzExtent: fn(
            self: *const ITextHost2,
            plHorzExtent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxIsDoubleClickPending(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxIsDoubleClickPending(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindow(@ptrCast(*const ITextHost2, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetForegroundWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetForegroundWindow(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetPalette(self: *const T) callconv(.Inline) ?HPALETTE {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetPalette(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEastAsianFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEastAsianFlags(@ptrCast(*const ITextHost2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetCursor2(self: *const T, hcur: ?HCURSOR, bText: BOOL) callconv(.Inline) ?HCURSOR {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetCursor2(@ptrCast(*const ITextHost2, self), hcur, bText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxFreeTextServicesNotification(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxFreeTextServicesNotification(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEditStyle(self: *const T, dwItem: u32, pdwData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEditStyle(@ptrCast(*const ITextHost2, self), dwItem, pdwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindowStyles(self: *const T, pdwStyle: ?*u32, pdwExStyle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindowStyles(@ptrCast(*const ITextHost2, self), pdwStyle, pdwExStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxShowDropCaret(self: *const T, fShow: BOOL, hdc: ?HDC, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxShowDropCaret(@ptrCast(*const ITextHost2, self), fShow, hdc, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxDestroyCaret(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxDestroyCaret(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetHorzExtent(self: *const T, plHorzExtent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetHorzExtent(@ptrCast(*const ITextHost2, self), plHorzExtent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: fn(
            self: *const ITextServices2,
            dwAspect: u32,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
            pascent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDrawD2D: fn(
            self: *const ITextServices2,
            pRenderTarget: ?*ID2D1RenderTarget,
            lprcBounds: ?*RECTL,
            lprcUpdate: ?*RECT,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxGetNaturalSize2(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32, pascent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxGetNaturalSize2(@ptrCast(*const ITextServices2, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight, pascent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxDrawD2D(self: *const T, pRenderTarget: ?*ID2D1RenderTarget, lprcBounds: ?*RECTL, lprcUpdate: ?*RECT, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxDrawD2D(@ptrCast(*const ITextServices2, self), pRenderTarget, lprcBounds, lprcUpdate, lViewId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TA_PROPERTY = enum(i32) {
    FLAGS = 0,
    TRANSFORMCOUNT = 1,
    STAGGERDELAY = 2,
    STAGGERDELAYCAP = 3,
    STAGGERDELAYFACTOR = 4,
    ZORDER = 5,
};
pub const TAP_FLAGS = TA_PROPERTY.FLAGS;
pub const TAP_TRANSFORMCOUNT = TA_PROPERTY.TRANSFORMCOUNT;
pub const TAP_STAGGERDELAY = TA_PROPERTY.STAGGERDELAY;
pub const TAP_STAGGERDELAYCAP = TA_PROPERTY.STAGGERDELAYCAP;
pub const TAP_STAGGERDELAYFACTOR = TA_PROPERTY.STAGGERDELAYFACTOR;
pub const TAP_ZORDER = TA_PROPERTY.ZORDER;

pub const TA_PROPERTY_FLAG = enum(u32) {
    NONE = 0,
    HASSTAGGER = 1,
    ISRTLAWARE = 2,
    ALLOWCOLLECTION = 4,
    HASBACKGROUND = 8,
    HASPERSPECTIVE = 16,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        HASSTAGGER: u1 = 0,
        ISRTLAWARE: u1 = 0,
        ALLOWCOLLECTION: u1 = 0,
        HASBACKGROUND: u1 = 0,
        HASPERSPECTIVE: u1 = 0,
    }) TA_PROPERTY_FLAG {
        return @intToEnum(TA_PROPERTY_FLAG,
              (if (o.NONE == 1) @enumToInt(TA_PROPERTY_FLAG.NONE) else 0)
            | (if (o.HASSTAGGER == 1) @enumToInt(TA_PROPERTY_FLAG.HASSTAGGER) else 0)
            | (if (o.ISRTLAWARE == 1) @enumToInt(TA_PROPERTY_FLAG.ISRTLAWARE) else 0)
            | (if (o.ALLOWCOLLECTION == 1) @enumToInt(TA_PROPERTY_FLAG.ALLOWCOLLECTION) else 0)
            | (if (o.HASBACKGROUND == 1) @enumToInt(TA_PROPERTY_FLAG.HASBACKGROUND) else 0)
            | (if (o.HASPERSPECTIVE == 1) @enumToInt(TA_PROPERTY_FLAG.HASPERSPECTIVE) else 0)
        );
    }
};
pub const TAPF_NONE = TA_PROPERTY_FLAG.NONE;
pub const TAPF_HASSTAGGER = TA_PROPERTY_FLAG.HASSTAGGER;
pub const TAPF_ISRTLAWARE = TA_PROPERTY_FLAG.ISRTLAWARE;
pub const TAPF_ALLOWCOLLECTION = TA_PROPERTY_FLAG.ALLOWCOLLECTION;
pub const TAPF_HASBACKGROUND = TA_PROPERTY_FLAG.HASBACKGROUND;
pub const TAPF_HASPERSPECTIVE = TA_PROPERTY_FLAG.HASPERSPECTIVE;

pub const TA_TRANSFORM_TYPE = enum(i32) {
    TRANSLATE_2D = 0,
    SCALE_2D = 1,
    OPACITY = 2,
    CLIP = 3,
};
pub const TATT_TRANSLATE_2D = TA_TRANSFORM_TYPE.TRANSLATE_2D;
pub const TATT_SCALE_2D = TA_TRANSFORM_TYPE.SCALE_2D;
pub const TATT_OPACITY = TA_TRANSFORM_TYPE.OPACITY;
pub const TATT_CLIP = TA_TRANSFORM_TYPE.CLIP;

pub const TA_TRANSFORM_FLAG = enum(i32) {
    NONE = 0,
    TARGETVALUES_USER = 1,
    HASINITIALVALUES = 2,
    HASORIGINVALUES = 4,
};
pub const TATF_NONE = TA_TRANSFORM_FLAG.NONE;
pub const TATF_TARGETVALUES_USER = TA_TRANSFORM_FLAG.TARGETVALUES_USER;
pub const TATF_HASINITIALVALUES = TA_TRANSFORM_FLAG.HASINITIALVALUES;
pub const TATF_HASORIGINVALUES = TA_TRANSFORM_FLAG.HASORIGINVALUES;

pub const TA_TRANSFORM = extern struct {
    eTransformType: TA_TRANSFORM_TYPE,
    dwTimingFunctionId: u32,
    dwStartTime: u32,
    dwDurationTime: u32,
    eFlags: TA_TRANSFORM_FLAG,
};

pub const TA_TRANSFORM_2D = extern struct {
    header: TA_TRANSFORM,
    rX: f32,
    rY: f32,
    rInitialX: f32,
    rInitialY: f32,
    rOriginX: f32,
    rOriginY: f32,
};

pub const TA_TRANSFORM_OPACITY = extern struct {
    header: TA_TRANSFORM,
    rOpacity: f32,
    rInitialOpacity: f32,
};

pub const TA_TRANSFORM_CLIP = extern struct {
    header: TA_TRANSFORM,
    rLeft: f32,
    rTop: f32,
    rRight: f32,
    rBottom: f32,
    rInitialLeft: f32,
    rInitialTop: f32,
    rInitialRight: f32,
    rInitialBottom: f32,
};

pub const TA_TIMINGFUNCTION_TYPE = enum(i32) {
    UNDEFINED = 0,
    CUBIC_BEZIER = 1,
};
pub const TTFT_UNDEFINED = TA_TIMINGFUNCTION_TYPE.UNDEFINED;
pub const TTFT_CUBIC_BEZIER = TA_TIMINGFUNCTION_TYPE.CUBIC_BEZIER;

pub const TA_TIMINGFUNCTION = extern struct {
    eTimingFunctionType: TA_TIMINGFUNCTION_TYPE,
};

pub const TA_CUBIC_BEZIER = extern struct {
    header: TA_TIMINGFUNCTION,
    rX0: f32,
    rY0: f32,
    rX1: f32,
    rY1: f32,
};

pub const DTBGOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    rcClip: RECT,
};

pub const THEMESIZE = enum(i32) {
    MIN = 0,
    TRUE = 1,
    DRAW = 2,
};
pub const TS_MIN = THEMESIZE.MIN;
pub const TS_TRUE = THEMESIZE.TRUE;
pub const TS_DRAW = THEMESIZE.DRAW;

pub const MARGINS = extern struct {
    cxLeftWidth: i32,
    cxRightWidth: i32,
    cyTopHeight: i32,
    cyBottomHeight: i32,
};

pub const INTLIST = extern struct {
    iValueCount: i32,
    iValues: [402]i32,
};

pub const PROPERTYORIGIN = enum(i32) {
    STATE = 0,
    PART = 1,
    CLASS = 2,
    GLOBAL = 3,
    NOTFOUND = 4,
};
pub const PO_STATE = PROPERTYORIGIN.STATE;
pub const PO_PART = PROPERTYORIGIN.PART;
pub const PO_CLASS = PROPERTYORIGIN.CLASS;
pub const PO_GLOBAL = PROPERTYORIGIN.GLOBAL;
pub const PO_NOTFOUND = PROPERTYORIGIN.NOTFOUND;

pub const WINDOWTHEMEATTRIBUTETYPE = enum(i32) {
    T = 1,
};
pub const WTA_NONCLIENT = WINDOWTHEMEATTRIBUTETYPE.T;

pub const WTA_OPTIONS = extern struct {
    dwFlags: u32,
    dwMask: u32,
};

pub const DTT_CALLBACK_PROC = fn(
    hdc: ?HDC,
    pszText: [*:0]u16,
    cchText: i32,
    prc: ?*RECT,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DTTOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    crText: u32,
    crBorder: u32,
    crShadow: u32,
    iTextShadowType: i32,
    ptShadowOffset: POINT,
    iBorderSize: i32,
    iFontPropId: i32,
    iColorPropId: i32,
    iStateId: i32,
    fApplyOverlay: BOOL,
    iGlowSize: i32,
    pfnDrawTextCallback: ?DTT_CALLBACK_PROC,
    lParam: LPARAM,
};

pub const BP_BUFFERFORMAT = enum(i32) {
    COMPATIBLEBITMAP = 0,
    DIB = 1,
    TOPDOWNDIB = 2,
    TOPDOWNMONODIB = 3,
};
pub const BPBF_COMPATIBLEBITMAP = BP_BUFFERFORMAT.COMPATIBLEBITMAP;
pub const BPBF_DIB = BP_BUFFERFORMAT.DIB;
pub const BPBF_TOPDOWNDIB = BP_BUFFERFORMAT.TOPDOWNDIB;
pub const BPBF_TOPDOWNMONODIB = BP_BUFFERFORMAT.TOPDOWNMONODIB;

pub const BP_ANIMATIONSTYLE = enum(i32) {
    NONE = 0,
    LINEAR = 1,
    CUBIC = 2,
    SINE = 3,
};
pub const BPAS_NONE = BP_ANIMATIONSTYLE.NONE;
pub const BPAS_LINEAR = BP_ANIMATIONSTYLE.LINEAR;
pub const BPAS_CUBIC = BP_ANIMATIONSTYLE.CUBIC;
pub const BPAS_SINE = BP_ANIMATIONSTYLE.SINE;

pub const BP_ANIMATIONPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    style: BP_ANIMATIONSTYLE,
    dwDuration: u32,
};

pub const BP_PAINTPARAMS = extern struct {
    cbSize: u32,
    dwFlags: BP_PAINTPARAMS_FLAGS,
    prcExclude: ?*const RECT,
    pBlendFunction: ?*const BLENDFUNCTION,
};

pub const BGTYPE = enum(i32) {
    IMAGEFILE = 0,
    BORDERFILL = 1,
    NONE = 2,
};
pub const BT_IMAGEFILE = BGTYPE.IMAGEFILE;
pub const BT_BORDERFILL = BGTYPE.BORDERFILL;
pub const BT_NONE = BGTYPE.NONE;

pub const IMAGELAYOUT = enum(i32) {
    VERTICAL = 0,
    HORIZONTAL = 1,
};
pub const IL_VERTICAL = IMAGELAYOUT.VERTICAL;
pub const IL_HORIZONTAL = IMAGELAYOUT.HORIZONTAL;

pub const BORDERTYPE = enum(i32) {
    RECT = 0,
    ROUNDRECT = 1,
    ELLIPSE = 2,
};
pub const BT_RECT = BORDERTYPE.RECT;
pub const BT_ROUNDRECT = BORDERTYPE.ROUNDRECT;
pub const BT_ELLIPSE = BORDERTYPE.ELLIPSE;

pub const FILLTYPE = enum(i32) {
    SOLID = 0,
    VERTGRADIENT = 1,
    HORZGRADIENT = 2,
    RADIALGRADIENT = 3,
    TILEIMAGE = 4,
};
pub const FT_SOLID = FILLTYPE.SOLID;
pub const FT_VERTGRADIENT = FILLTYPE.VERTGRADIENT;
pub const FT_HORZGRADIENT = FILLTYPE.HORZGRADIENT;
pub const FT_RADIALGRADIENT = FILLTYPE.RADIALGRADIENT;
pub const FT_TILEIMAGE = FILLTYPE.TILEIMAGE;

pub const SIZINGTYPE = enum(i32) {
    TRUESIZE = 0,
    STRETCH = 1,
    TILE = 2,
};
pub const ST_TRUESIZE = SIZINGTYPE.TRUESIZE;
pub const ST_STRETCH = SIZINGTYPE.STRETCH;
pub const ST_TILE = SIZINGTYPE.TILE;

pub const HALIGN = enum(i32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
};
pub const HA_LEFT = HALIGN.LEFT;
pub const HA_CENTER = HALIGN.CENTER;
pub const HA_RIGHT = HALIGN.RIGHT;

pub const CONTENTALIGNMENT = enum(i32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
};
pub const CA_LEFT = CONTENTALIGNMENT.LEFT;
pub const CA_CENTER = CONTENTALIGNMENT.CENTER;
pub const CA_RIGHT = CONTENTALIGNMENT.RIGHT;

pub const VALIGN = enum(i32) {
    TOP = 0,
    CENTER = 1,
    BOTTOM = 2,
};
pub const VA_TOP = VALIGN.TOP;
pub const VA_CENTER = VALIGN.CENTER;
pub const VA_BOTTOM = VALIGN.BOTTOM;

pub const OFFSETTYPE = enum(i32) {
    TOPLEFT = 0,
    TOPRIGHT = 1,
    TOPMIDDLE = 2,
    BOTTOMLEFT = 3,
    BOTTOMRIGHT = 4,
    BOTTOMMIDDLE = 5,
    MIDDLELEFT = 6,
    MIDDLERIGHT = 7,
    LEFTOFCAPTION = 8,
    RIGHTOFCAPTION = 9,
    LEFTOFLASTBUTTON = 10,
    RIGHTOFLASTBUTTON = 11,
    ABOVELASTBUTTON = 12,
    BELOWLASTBUTTON = 13,
};
pub const OT_TOPLEFT = OFFSETTYPE.TOPLEFT;
pub const OT_TOPRIGHT = OFFSETTYPE.TOPRIGHT;
pub const OT_TOPMIDDLE = OFFSETTYPE.TOPMIDDLE;
pub const OT_BOTTOMLEFT = OFFSETTYPE.BOTTOMLEFT;
pub const OT_BOTTOMRIGHT = OFFSETTYPE.BOTTOMRIGHT;
pub const OT_BOTTOMMIDDLE = OFFSETTYPE.BOTTOMMIDDLE;
pub const OT_MIDDLELEFT = OFFSETTYPE.MIDDLELEFT;
pub const OT_MIDDLERIGHT = OFFSETTYPE.MIDDLERIGHT;
pub const OT_LEFTOFCAPTION = OFFSETTYPE.LEFTOFCAPTION;
pub const OT_RIGHTOFCAPTION = OFFSETTYPE.RIGHTOFCAPTION;
pub const OT_LEFTOFLASTBUTTON = OFFSETTYPE.LEFTOFLASTBUTTON;
pub const OT_RIGHTOFLASTBUTTON = OFFSETTYPE.RIGHTOFLASTBUTTON;
pub const OT_ABOVELASTBUTTON = OFFSETTYPE.ABOVELASTBUTTON;
pub const OT_BELOWLASTBUTTON = OFFSETTYPE.BELOWLASTBUTTON;

pub const ICONEFFECT = enum(i32) {
    NONE = 0,
    GLOW = 1,
    SHADOW = 2,
    PULSE = 3,
    ALPHA = 4,
};
pub const ICE_NONE = ICONEFFECT.NONE;
pub const ICE_GLOW = ICONEFFECT.GLOW;
pub const ICE_SHADOW = ICONEFFECT.SHADOW;
pub const ICE_PULSE = ICONEFFECT.PULSE;
pub const ICE_ALPHA = ICONEFFECT.ALPHA;

pub const TEXTSHADOWTYPE = enum(i32) {
    NONE = 0,
    SINGLE = 1,
    CONTINUOUS = 2,
};
pub const TST_NONE = TEXTSHADOWTYPE.NONE;
pub const TST_SINGLE = TEXTSHADOWTYPE.SINGLE;
pub const TST_CONTINUOUS = TEXTSHADOWTYPE.CONTINUOUS;

pub const GLYPHTYPE = enum(i32) {
    NONE = 0,
    IMAGEGLYPH = 1,
    FONTGLYPH = 2,
};
pub const GT_NONE = GLYPHTYPE.NONE;
pub const GT_IMAGEGLYPH = GLYPHTYPE.IMAGEGLYPH;
pub const GT_FONTGLYPH = GLYPHTYPE.FONTGLYPH;

pub const IMAGESELECTTYPE = enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const IST_NONE = IMAGESELECTTYPE.NONE;
pub const IST_SIZE = IMAGESELECTTYPE.SIZE;
pub const IST_DPI = IMAGESELECTTYPE.DPI;

pub const TRUESIZESCALINGTYPE = enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const TSST_NONE = TRUESIZESCALINGTYPE.NONE;
pub const TSST_SIZE = TRUESIZESCALINGTYPE.SIZE;
pub const TSST_DPI = TRUESIZESCALINGTYPE.DPI;

pub const GLYPHFONTSIZINGTYPE = enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const GFST_NONE = GLYPHFONTSIZINGTYPE.NONE;
pub const GFST_SIZE = GLYPHFONTSIZINGTYPE.SIZE;
pub const GFST_DPI = GLYPHFONTSIZINGTYPE.DPI;

pub const LINKPARTS = enum(i32) {
    K = 1,
};
pub const LP_HYPERLINK = LINKPARTS.K;

pub const HYPERLINKSTATES = enum(i32) {
    NORMALTEXT = 1,
    LINKTEXT = 2,
};
pub const HLS_NORMALTEXT = HYPERLINKSTATES.NORMALTEXT;
pub const HLS_LINKTEXT = HYPERLINKSTATES.LINKTEXT;

pub const EMPTYMARKUPPARTS = enum(i32) {
    T = 1,
};
pub const EMP_MARKUPTEXT = EMPTYMARKUPPARTS.T;

pub const MARKUPTEXTSTATES = enum(i32) {
    NORMALTEXT = 1,
    LINKTEXT = 2,
};
pub const EMT_NORMALTEXT = MARKUPTEXTSTATES.NORMALTEXT;
pub const EMT_LINKTEXT = MARKUPTEXTSTATES.LINKTEXT;

pub const STATICPARTS = enum(i32) {
    T = 1,
};
pub const STAT_TEXT = STATICPARTS.T;

pub const PAGEPARTS = enum(i32) {
    UP = 1,
    DOWN = 2,
    UPHORZ = 3,
    DOWNHORZ = 4,
};
pub const PGRP_UP = PAGEPARTS.UP;
pub const PGRP_DOWN = PAGEPARTS.DOWN;
pub const PGRP_UPHORZ = PAGEPARTS.UPHORZ;
pub const PGRP_DOWNHORZ = PAGEPARTS.DOWNHORZ;

pub const MONTHCALPARTS = enum(i32) {
    BACKGROUND = 1,
    BORDERS = 2,
    GRIDBACKGROUND = 3,
    COLHEADERSPLITTER = 4,
    GRIDCELLBACKGROUND = 5,
    GRIDCELL = 6,
    GRIDCELLUPPER = 7,
    TRAILINGGRIDCELL = 8,
    TRAILINGGRIDCELLUPPER = 9,
    NAVNEXT = 10,
    NAVPREV = 11,
};
pub const MC_BACKGROUND = MONTHCALPARTS.BACKGROUND;
pub const MC_BORDERS = MONTHCALPARTS.BORDERS;
pub const MC_GRIDBACKGROUND = MONTHCALPARTS.GRIDBACKGROUND;
pub const MC_COLHEADERSPLITTER = MONTHCALPARTS.COLHEADERSPLITTER;
pub const MC_GRIDCELLBACKGROUND = MONTHCALPARTS.GRIDCELLBACKGROUND;
pub const MC_GRIDCELL = MONTHCALPARTS.GRIDCELL;
pub const MC_GRIDCELLUPPER = MONTHCALPARTS.GRIDCELLUPPER;
pub const MC_TRAILINGGRIDCELL = MONTHCALPARTS.TRAILINGGRIDCELL;
pub const MC_TRAILINGGRIDCELLUPPER = MONTHCALPARTS.TRAILINGGRIDCELLUPPER;
pub const MC_NAVNEXT = MONTHCALPARTS.NAVNEXT;
pub const MC_NAVPREV = MONTHCALPARTS.NAVPREV;

pub const GRIDCELLBACKGROUNDSTATES = enum(i32) {
    SELECTED = 1,
    HOT = 2,
    SELECTEDHOT = 3,
    SELECTEDNOTFOCUSED = 4,
    TODAY = 5,
    TODAYSELECTED = 6,
};
pub const MCGCB_SELECTED = GRIDCELLBACKGROUNDSTATES.SELECTED;
pub const MCGCB_HOT = GRIDCELLBACKGROUNDSTATES.HOT;
pub const MCGCB_SELECTEDHOT = GRIDCELLBACKGROUNDSTATES.SELECTEDHOT;
pub const MCGCB_SELECTEDNOTFOCUSED = GRIDCELLBACKGROUNDSTATES.SELECTEDNOTFOCUSED;
pub const MCGCB_TODAY = GRIDCELLBACKGROUNDSTATES.TODAY;
pub const MCGCB_TODAYSELECTED = GRIDCELLBACKGROUNDSTATES.TODAYSELECTED;

pub const GRIDCELLSTATES = enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    TODAY = 4,
    TODAYSELECTED = 5,
    SELECTED = 6,
    SELECTEDHOT = 7,
};
pub const MCGC_HOT = GRIDCELLSTATES.HOT;
pub const MCGC_HASSTATE = GRIDCELLSTATES.HASSTATE;
pub const MCGC_HASSTATEHOT = GRIDCELLSTATES.HASSTATEHOT;
pub const MCGC_TODAY = GRIDCELLSTATES.TODAY;
pub const MCGC_TODAYSELECTED = GRIDCELLSTATES.TODAYSELECTED;
pub const MCGC_SELECTED = GRIDCELLSTATES.SELECTED;
pub const MCGC_SELECTEDHOT = GRIDCELLSTATES.SELECTEDHOT;

pub const GRIDCELLUPPERSTATES = enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    SELECTED = 4,
    SELECTEDHOT = 5,
};
pub const MCGCU_HOT = GRIDCELLUPPERSTATES.HOT;
pub const MCGCU_HASSTATE = GRIDCELLUPPERSTATES.HASSTATE;
pub const MCGCU_HASSTATEHOT = GRIDCELLUPPERSTATES.HASSTATEHOT;
pub const MCGCU_SELECTED = GRIDCELLUPPERSTATES.SELECTED;
pub const MCGCU_SELECTEDHOT = GRIDCELLUPPERSTATES.SELECTEDHOT;

pub const TRAILINGGRIDCELLSTATES = enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    TODAY = 4,
    TODAYSELECTED = 5,
    SELECTED = 6,
    SELECTEDHOT = 7,
};
pub const MCTGC_HOT = TRAILINGGRIDCELLSTATES.HOT;
pub const MCTGC_HASSTATE = TRAILINGGRIDCELLSTATES.HASSTATE;
pub const MCTGC_HASSTATEHOT = TRAILINGGRIDCELLSTATES.HASSTATEHOT;
pub const MCTGC_TODAY = TRAILINGGRIDCELLSTATES.TODAY;
pub const MCTGC_TODAYSELECTED = TRAILINGGRIDCELLSTATES.TODAYSELECTED;
pub const MCTGC_SELECTED = TRAILINGGRIDCELLSTATES.SELECTED;
pub const MCTGC_SELECTEDHOT = TRAILINGGRIDCELLSTATES.SELECTEDHOT;

pub const TRAILINGGRIDCELLUPPERSTATES = enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    SELECTED = 4,
    SELECTEDHOT = 5,
};
pub const MCTGCU_HOT = TRAILINGGRIDCELLUPPERSTATES.HOT;
pub const MCTGCU_HASSTATE = TRAILINGGRIDCELLUPPERSTATES.HASSTATE;
pub const MCTGCU_HASSTATEHOT = TRAILINGGRIDCELLUPPERSTATES.HASSTATEHOT;
pub const MCTGCU_SELECTED = TRAILINGGRIDCELLUPPERSTATES.SELECTED;
pub const MCTGCU_SELECTEDHOT = TRAILINGGRIDCELLUPPERSTATES.SELECTEDHOT;

pub const NAVNEXTSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
};
pub const MCNN_NORMAL = NAVNEXTSTATES.NORMAL;
pub const MCNN_HOT = NAVNEXTSTATES.HOT;
pub const MCNN_PRESSED = NAVNEXTSTATES.PRESSED;
pub const MCNN_DISABLED = NAVNEXTSTATES.DISABLED;

pub const NAVPREVSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
};
pub const MCNP_NORMAL = NAVPREVSTATES.NORMAL;
pub const MCNP_HOT = NAVPREVSTATES.HOT;
pub const MCNP_PRESSED = NAVPREVSTATES.PRESSED;
pub const MCNP_DISABLED = NAVPREVSTATES.DISABLED;

pub const CLOCKPARTS = enum(i32) {
    E = 1,
};
pub const CLP_TIME = CLOCKPARTS.E;

pub const CLOCKSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const CLS_NORMAL = CLOCKSTATES.NORMAL;
pub const CLS_HOT = CLOCKSTATES.HOT;
pub const CLS_PRESSED = CLOCKSTATES.PRESSED;

pub const TRAYNOTIFYPARTS = enum(i32) {
    BACKGROUND = 1,
    ANIMBACKGROUND = 2,
};
pub const TNP_BACKGROUND = TRAYNOTIFYPARTS.BACKGROUND;
pub const TNP_ANIMBACKGROUND = TRAYNOTIFYPARTS.ANIMBACKGROUND;

pub const TASKBARPARTS = enum(i32) {
    BACKGROUNDBOTTOM = 1,
    BACKGROUNDRIGHT = 2,
    BACKGROUNDTOP = 3,
    BACKGROUNDLEFT = 4,
    SIZINGBARBOTTOM = 5,
    SIZINGBARRIGHT = 6,
    SIZINGBARTOP = 7,
    SIZINGBARLEFT = 8,
};
pub const TBP_BACKGROUNDBOTTOM = TASKBARPARTS.BACKGROUNDBOTTOM;
pub const TBP_BACKGROUNDRIGHT = TASKBARPARTS.BACKGROUNDRIGHT;
pub const TBP_BACKGROUNDTOP = TASKBARPARTS.BACKGROUNDTOP;
pub const TBP_BACKGROUNDLEFT = TASKBARPARTS.BACKGROUNDLEFT;
pub const TBP_SIZINGBARBOTTOM = TASKBARPARTS.SIZINGBARBOTTOM;
pub const TBP_SIZINGBARRIGHT = TASKBARPARTS.SIZINGBARRIGHT;
pub const TBP_SIZINGBARTOP = TASKBARPARTS.SIZINGBARTOP;
pub const TBP_SIZINGBARLEFT = TASKBARPARTS.SIZINGBARLEFT;

pub const TASKBANDPARTS = enum(i32) {
    GROUPCOUNT = 1,
    FLASHBUTTON = 2,
    FLASHBUTTONGROUPMENU = 3,
};
pub const TDP_GROUPCOUNT = TASKBANDPARTS.GROUPCOUNT;
pub const TDP_FLASHBUTTON = TASKBANDPARTS.FLASHBUTTON;
pub const TDP_FLASHBUTTONGROUPMENU = TASKBANDPARTS.FLASHBUTTONGROUPMENU;

pub const STARTPANELPARTS = enum(i32) {
    USERPANE = 1,
    MOREPROGRAMS = 2,
    MOREPROGRAMSARROW = 3,
    PROGLIST = 4,
    PROGLISTSEPARATOR = 5,
    PLACESLIST = 6,
    PLACESLISTSEPARATOR = 7,
    LOGOFF = 8,
    LOGOFFBUTTONS = 9,
    USERPICTURE = 10,
    PREVIEW = 11,
    MOREPROGRAMSTAB = 12,
    NSCHOST = 13,
    SOFTWAREEXPLORER = 14,
    OPENBOX = 15,
    SEARCHVIEW = 16,
    MOREPROGRAMSARROWBACK = 17,
    TOPMATCH = 18,
    LOGOFFSPLITBUTTONDROPDOWN = 19,
};
pub const SPP_USERPANE = STARTPANELPARTS.USERPANE;
pub const SPP_MOREPROGRAMS = STARTPANELPARTS.MOREPROGRAMS;
pub const SPP_MOREPROGRAMSARROW = STARTPANELPARTS.MOREPROGRAMSARROW;
pub const SPP_PROGLIST = STARTPANELPARTS.PROGLIST;
pub const SPP_PROGLISTSEPARATOR = STARTPANELPARTS.PROGLISTSEPARATOR;
pub const SPP_PLACESLIST = STARTPANELPARTS.PLACESLIST;
pub const SPP_PLACESLISTSEPARATOR = STARTPANELPARTS.PLACESLISTSEPARATOR;
pub const SPP_LOGOFF = STARTPANELPARTS.LOGOFF;
pub const SPP_LOGOFFBUTTONS = STARTPANELPARTS.LOGOFFBUTTONS;
pub const SPP_USERPICTURE = STARTPANELPARTS.USERPICTURE;
pub const SPP_PREVIEW = STARTPANELPARTS.PREVIEW;
pub const SPP_MOREPROGRAMSTAB = STARTPANELPARTS.MOREPROGRAMSTAB;
pub const SPP_NSCHOST = STARTPANELPARTS.NSCHOST;
pub const SPP_SOFTWAREEXPLORER = STARTPANELPARTS.SOFTWAREEXPLORER;
pub const SPP_OPENBOX = STARTPANELPARTS.OPENBOX;
pub const SPP_SEARCHVIEW = STARTPANELPARTS.SEARCHVIEW;
pub const SPP_MOREPROGRAMSARROWBACK = STARTPANELPARTS.MOREPROGRAMSARROWBACK;
pub const SPP_TOPMATCH = STARTPANELPARTS.TOPMATCH;
pub const SPP_LOGOFFSPLITBUTTONDROPDOWN = STARTPANELPARTS.LOGOFFSPLITBUTTONDROPDOWN;

pub const MOREPROGRAMSTABSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPMPT_NORMAL = MOREPROGRAMSTABSTATES.NORMAL;
pub const SPMPT_HOT = MOREPROGRAMSTABSTATES.HOT;
pub const SPMPT_SELECTED = MOREPROGRAMSTABSTATES.SELECTED;
pub const SPMPT_DISABLED = MOREPROGRAMSTABSTATES.DISABLED;
pub const SPMPT_FOCUSED = MOREPROGRAMSTABSTATES.FOCUSED;

pub const SOFTWAREEXPLORERSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPSE_NORMAL = SOFTWAREEXPLORERSTATES.NORMAL;
pub const SPSE_HOT = SOFTWAREEXPLORERSTATES.HOT;
pub const SPSE_SELECTED = SOFTWAREEXPLORERSTATES.SELECTED;
pub const SPSE_DISABLED = SOFTWAREEXPLORERSTATES.DISABLED;
pub const SPSE_FOCUSED = SOFTWAREEXPLORERSTATES.FOCUSED;

pub const OPENBOXSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPOB_NORMAL = OPENBOXSTATES.NORMAL;
pub const SPOB_HOT = OPENBOXSTATES.HOT;
pub const SPOB_SELECTED = OPENBOXSTATES.SELECTED;
pub const SPOB_DISABLED = OPENBOXSTATES.DISABLED;
pub const SPOB_FOCUSED = OPENBOXSTATES.FOCUSED;

pub const MOREPROGRAMSARROWSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPS_NORMAL = MOREPROGRAMSARROWSTATES.NORMAL;
pub const SPS_HOT = MOREPROGRAMSARROWSTATES.HOT;
pub const SPS_PRESSED = MOREPROGRAMSARROWSTATES.PRESSED;

pub const MOREPROGRAMSARROWBACKSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPSB_NORMAL = MOREPROGRAMSARROWBACKSTATES.NORMAL;
pub const SPSB_HOT = MOREPROGRAMSARROWBACKSTATES.HOT;
pub const SPSB_PRESSED = MOREPROGRAMSARROWBACKSTATES.PRESSED;

pub const LOGOFFBUTTONSSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPLS_NORMAL = LOGOFFBUTTONSSTATES.NORMAL;
pub const SPLS_HOT = LOGOFFBUTTONSSTATES.HOT;
pub const SPLS_PRESSED = LOGOFFBUTTONSSTATES.PRESSED;

pub const MENUBANDPARTS = enum(i32) {
    NEWAPPBUTTON = 1,
    SEPERATOR = 2,
};
pub const MDP_NEWAPPBUTTON = MENUBANDPARTS.NEWAPPBUTTON;
pub const MDP_SEPERATOR = MENUBANDPARTS.SEPERATOR;

pub const MENUBANDSTATES = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
    CHECKED = 5,
    HOTCHECKED = 6,
};
pub const MDS_NORMAL = MENUBANDSTATES.NORMAL;
pub const MDS_HOT = MENUBANDSTATES.HOT;
pub const MDS_PRESSED = MENUBANDSTATES.PRESSED;
pub const MDS_DISABLED = MENUBANDSTATES.DISABLED;
pub const MDS_CHECKED = MENUBANDSTATES.CHECKED;
pub const MDS_HOTCHECKED = MENUBANDSTATES.HOTCHECKED;

pub const EDITWORDBREAKPROCA = fn(
    lpch: ?PSTR,
    ichCurrent: i32,
    cch: i32,
    code: WORD_BREAK_ACTION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EDITWORDBREAKPROCW = fn(
    lpch: ?PWSTR,
    ichCurrent: i32,
    cch: i32,
    code: WORD_BREAK_ACTION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NMHDR = extern struct {
    hwndFrom: ?HWND,
    idFrom: usize,
    code: u32,
};

pub const MEASUREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemWidth: u32,
    itemHeight: u32,
    itemData: usize,
};

pub const DRAWITEMSTRUCT = extern struct {
    CtlType: DRAWITEMSTRUCT_CTL_TYPE,
    CtlID: u32,
    itemID: u32,
    itemAction: u32,
    itemState: u32,
    hwndItem: ?HWND,
    hDC: ?HDC,
    rcItem: RECT,
    itemData: usize,
};

pub const DELETEITEMSTRUCT = extern struct {
    CtlType: DRAWITEMSTRUCT_CTL_TYPE,
    CtlID: u32,
    itemID: u32,
    hwndItem: ?HWND,
    itemData: usize,
};

pub const COMPAREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    hwndItem: ?HWND,
    itemID1: u32,
    itemData1: usize,
    itemID2: u32,
    itemData2: usize,
    dwLocaleId: u32,
};

pub const POINTER_FEEDBACK_MODE = enum(i32) {
    DEFAULT = 1,
    INDIRECT = 2,
    NONE = 3,
};
pub const POINTER_FEEDBACK_DEFAULT = POINTER_FEEDBACK_MODE.DEFAULT;
pub const POINTER_FEEDBACK_INDIRECT = POINTER_FEEDBACK_MODE.INDIRECT;
pub const POINTER_FEEDBACK_NONE = POINTER_FEEDBACK_MODE.NONE;

pub const USAGE_PROPERTIES = extern struct {
    level: u16,
    page: u16,
    usage: u16,
    logicalMinimum: i32,
    logicalMaximum: i32,
    unit: u16,
    exponent: u16,
    count: u8,
    physicalMinimum: i32,
    physicalMaximum: i32,
};

pub const POINTER_TYPE_INFO = extern struct {
    type: POINTER_INPUT_TYPE,
    Anonymous: extern union {
        touchInfo: POINTER_TOUCH_INFO,
        penInfo: POINTER_PEN_INFO,
    },
};

pub const INPUT_INJECTION_VALUE = extern struct {
    page: u16,
    usage: u16,
    value: i32,
    index: u16,
};

pub const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = extern struct {
    score: u16,
    adjustedPoint: POINT,
};

pub const TOUCH_HIT_TESTING_INPUT = extern struct {
    pointerId: u32,
    point: POINT,
    boundingBox: RECT,
    nonOccludedBoundingBox: RECT,
    orientation: u32,
};

pub const FEEDBACK_TYPE = enum(i32) {
    TOUCH_CONTACTVISUALIZATION = 1,
    PEN_BARRELVISUALIZATION = 2,
    PEN_TAP = 3,
    PEN_DOUBLETAP = 4,
    PEN_PRESSANDHOLD = 5,
    PEN_RIGHTTAP = 6,
    TOUCH_TAP = 7,
    TOUCH_DOUBLETAP = 8,
    TOUCH_PRESSANDHOLD = 9,
    TOUCH_RIGHTTAP = 10,
    GESTURE_PRESSANDTAP = 11,
    MAX = -1,
};
pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION = FEEDBACK_TYPE.TOUCH_CONTACTVISUALIZATION;
pub const FEEDBACK_PEN_BARRELVISUALIZATION = FEEDBACK_TYPE.PEN_BARRELVISUALIZATION;
pub const FEEDBACK_PEN_TAP = FEEDBACK_TYPE.PEN_TAP;
pub const FEEDBACK_PEN_DOUBLETAP = FEEDBACK_TYPE.PEN_DOUBLETAP;
pub const FEEDBACK_PEN_PRESSANDHOLD = FEEDBACK_TYPE.PEN_PRESSANDHOLD;
pub const FEEDBACK_PEN_RIGHTTAP = FEEDBACK_TYPE.PEN_RIGHTTAP;
pub const FEEDBACK_TOUCH_TAP = FEEDBACK_TYPE.TOUCH_TAP;
pub const FEEDBACK_TOUCH_DOUBLETAP = FEEDBACK_TYPE.TOUCH_DOUBLETAP;
pub const FEEDBACK_TOUCH_PRESSANDHOLD = FEEDBACK_TYPE.TOUCH_PRESSANDHOLD;
pub const FEEDBACK_TOUCH_RIGHTTAP = FEEDBACK_TYPE.TOUCH_RIGHTTAP;
pub const FEEDBACK_GESTURE_PRESSANDTAP = FEEDBACK_TYPE.GESTURE_PRESSANDTAP;
pub const FEEDBACK_MAX = FEEDBACK_TYPE.MAX;

pub const SCROLLINFO = extern struct {
    cbSize: u32,
    fMask: SCROLLINFO_MASK,
    nMin: i32,
    nMax: i32,
    nPage: u32,
    nPos: i32,
    nTrackPos: i32,
};

pub const SCROLLBARINFO = extern struct {
    cbSize: u32,
    rcScrollBar: RECT,
    dxyLineButton: i32,
    xyThumbTop: i32,
    xyThumbBottom: i32,
    reserved: i32,
    rgstate: [6]u32,
};

pub const COMBOBOXINFO = extern struct {
    cbSize: u32,
    rcItem: RECT,
    rcButton: RECT,
    stateButton: COMBOBOXINFO_BUTTON_STATE,
    hwndCombo: ?HWND,
    hwndItem: ?HWND,
    hwndList: ?HWND,
};

pub const POINTER_DEVICE_TYPE = enum(i32) {
    INTEGRATED_PEN = 1,
    EXTERNAL_PEN = 2,
    TOUCH = 3,
    TOUCH_PAD = 4,
    MAX = -1,
};
pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN = POINTER_DEVICE_TYPE.INTEGRATED_PEN;
pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN = POINTER_DEVICE_TYPE.EXTERNAL_PEN;
pub const POINTER_DEVICE_TYPE_TOUCH = POINTER_DEVICE_TYPE.TOUCH;
pub const POINTER_DEVICE_TYPE_TOUCH_PAD = POINTER_DEVICE_TYPE.TOUCH_PAD;
pub const POINTER_DEVICE_TYPE_MAX = POINTER_DEVICE_TYPE.MAX;

pub const POINTER_DEVICE_INFO = extern struct {
    displayOrientation: u32,
    device: ?HANDLE,
    pointerDeviceType: POINTER_DEVICE_TYPE,
    monitor: ?HMONITOR,
    startingCursorId: u32,
    maxActiveContacts: u16,
    productString: [520]u16,
};

pub const POINTER_DEVICE_PROPERTY = extern struct {
    logicalMin: i32,
    logicalMax: i32,
    physicalMin: i32,
    physicalMax: i32,
    unit: u32,
    unitExponent: u32,
    usagePageId: u16,
    usageId: u16,
};

pub const POINTER_DEVICE_CURSOR_TYPE = enum(i32) {
    UNKNOWN = 0,
    TIP = 1,
    ERASER = 2,
    MAX = -1,
};
pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = POINTER_DEVICE_CURSOR_TYPE.UNKNOWN;
pub const POINTER_DEVICE_CURSOR_TYPE_TIP = POINTER_DEVICE_CURSOR_TYPE.TIP;
pub const POINTER_DEVICE_CURSOR_TYPE_ERASER = POINTER_DEVICE_CURSOR_TYPE.ERASER;
pub const POINTER_DEVICE_CURSOR_TYPE_MAX = POINTER_DEVICE_CURSOR_TYPE.MAX;

pub const POINTER_DEVICE_CURSOR_INFO = extern struct {
    cursorId: u32,
    cursor: POINTER_DEVICE_CURSOR_TYPE,
};

pub const INPUT_MESSAGE_DEVICE_TYPE = enum(i32) {
    UNAVAILABLE = 0,
    KEYBOARD = 1,
    MOUSE = 2,
    TOUCH = 4,
    PEN = 8,
    TOUCHPAD = 16,
};
pub const IMDT_UNAVAILABLE = INPUT_MESSAGE_DEVICE_TYPE.UNAVAILABLE;
pub const IMDT_KEYBOARD = INPUT_MESSAGE_DEVICE_TYPE.KEYBOARD;
pub const IMDT_MOUSE = INPUT_MESSAGE_DEVICE_TYPE.MOUSE;
pub const IMDT_TOUCH = INPUT_MESSAGE_DEVICE_TYPE.TOUCH;
pub const IMDT_PEN = INPUT_MESSAGE_DEVICE_TYPE.PEN;
pub const IMDT_TOUCHPAD = INPUT_MESSAGE_DEVICE_TYPE.TOUCHPAD;

pub const INPUT_MESSAGE_ORIGIN_ID = enum(i32) {
    UNAVAILABLE = 0,
    HARDWARE = 1,
    INJECTED = 2,
    SYSTEM = 4,
};
pub const IMO_UNAVAILABLE = INPUT_MESSAGE_ORIGIN_ID.UNAVAILABLE;
pub const IMO_HARDWARE = INPUT_MESSAGE_ORIGIN_ID.HARDWARE;
pub const IMO_INJECTED = INPUT_MESSAGE_ORIGIN_ID.INJECTED;
pub const IMO_SYSTEM = INPUT_MESSAGE_ORIGIN_ID.SYSTEM;

pub const INPUT_MESSAGE_SOURCE = extern struct {
    deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    originId: INPUT_MESSAGE_ORIGIN_ID,
};






























pub const TBBUTTON = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        iBitmap: i32,
        idCommand: i32,
        fsState: u8,
        fsStyle: u8,
        bReserved: [6]u8,
        dwData: usize,
        iString: isize,
    },
    .X86 => extern struct {
        iBitmap: i32,
        idCommand: i32,
        fsState: u8,
        fsStyle: u8,
        bReserved: [2]u8,
        dwData: usize,
        iString: isize,
    },
};
pub const RICHEDIT_IMAGE_PARAMETERS = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        xWidth: i32,
        yHeight: i32,
        Ascent: i32,
        Type: TEXT_ALIGN_OPTIONS,
        pwszAlternateText: ?[*:0]const u16,
        pIStream: ?*IStream,
    },
    .X86 => extern struct {
        xWidth: i32,
        yHeight: i32,
        Ascent: i32,
        Type: TEXT_ALIGN_OPTIONS,
        pwszAlternateText: ?[*:0]const u16,
        pIStream: ?*IStream,
    },
};
pub const ENDCOMPOSITIONNOTIFY = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        dwCode: ENDCOMPOSITIONNOTIFY_CODE,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        dwCode: ENDCOMPOSITIONNOTIFY_CODE,
    },
};
pub const TEXTRANGEA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?PSTR,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?PSTR,
    },
};
pub const TEXTRANGEW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?PWSTR,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?PWSTR,
    },
};
pub const EDITSTREAM = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        dwCookie: usize,
        dwError: u32,
        pfnCallback: ?EDITSTREAMCALLBACK,
    },
    .X86 => extern struct {
        dwCookie: usize,
        dwError: u32,
        pfnCallback: ?EDITSTREAMCALLBACK,
    },
};
pub const FINDTEXTA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u8,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u8,
    },
};
pub const FINDTEXTW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u16,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u16,
    },
};
pub const FINDTEXTEXA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u8,
        chrgText: CHARRANGE,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u8,
        chrgText: CHARRANGE,
    },
};
pub const FINDTEXTEXW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u16,
        chrgText: CHARRANGE,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        lpstrText: ?[*:0]const u16,
        chrgText: CHARRANGE,
    },
};
pub const FORMATRANGE = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        hdc: ?HDC,
        hdcTarget: ?HDC,
        rc: RECT,
        rcPage: RECT,
        chrg: CHARRANGE,
    },
    .X86 => extern struct {
        hdc: ?HDC,
        hdcTarget: ?HDC,
        rc: RECT,
        rcPage: RECT,
        chrg: CHARRANGE,
    },
};
pub const MSGFILTER = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    },
};
pub const REQRESIZE = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        rc: RECT,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        rc: RECT,
    },
};
pub const SELCHANGE = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        chrg: CHARRANGE,
        seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        chrg: CHARRANGE,
        seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
    },
};
pub const _grouptypingchange = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        fGroupTyping: BOOL,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        fGroupTyping: BOOL,
    },
};
pub const CLIPBOARDFORMAT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        cf: u16,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        cf: u16,
    },
};
pub const GETCONTEXTMENUEX = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        chrg: CHARRANGE,
        dwFlags: u32,
        pt: POINT,
        pvReserved: ?*c_void,
    },
    .X86 => extern struct {
        chrg: CHARRANGE,
        dwFlags: u32,
        pt: POINT,
        pvReserved: ?*c_void,
    },
};
pub const ENDROPFILES = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        hDrop: ?HANDLE,
        cp: i32,
        fProtected: BOOL,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        hDrop: ?HANDLE,
        cp: i32,
        fProtected: BOOL,
    },
};
pub const ENPROTECTED = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        chrg: CHARRANGE,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        chrg: CHARRANGE,
    },
};
pub const ENSAVECLIPBOARD = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        cObjectCount: i32,
        cch: i32,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        cObjectCount: i32,
        cch: i32,
    },
};
pub const ENOLEOPFAILED = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        iob: i32,
        lOper: i32,
        hr: HRESULT,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        iob: i32,
        lOper: i32,
        hr: HRESULT,
    },
};
pub const OBJECTPOSITIONS = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        cObjectCount: i32,
        pcpPositions: ?*i32,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        cObjectCount: i32,
        pcpPositions: ?*i32,
    },
};
pub const ENLINK = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        chrg: CHARRANGE,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        chrg: CHARRANGE,
    },
};
pub const ENLOWFIRTF = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        szControl: ?PSTR,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        szControl: ?PSTR,
    },
};
pub const ENCORRECTTEXT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        nmhdr: NMHDR,
        chrg: CHARRANGE,
        seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
    },
    .X86 => extern struct {
        nmhdr: NMHDR,
        chrg: CHARRANGE,
        seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
    },
};
pub const PUNCTUATION = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        iSize: u32,
        szPunctuation: ?PSTR,
    },
    .X86 => extern struct {
        iSize: u32,
        szPunctuation: ?PSTR,
    },
};
pub const REPASTESPECIAL = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        dwAspect: DVASPECT,
        dwParam: usize,
    },
    .X86 => extern struct {
        dwAspect: DVASPECT,
        dwParam: usize,
    },
};
pub const GETTEXTEX = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        cb: u32,
        flags: GETTEXTEX_FLAGS,
        codepage: u32,
        lpDefaultChar: ?[*:0]const u8,
        lpUsedDefChar: ?*i32,
    },
    .X86 => extern struct {
        cb: u32,
        flags: GETTEXTEX_FLAGS,
        codepage: u32,
        lpDefaultChar: ?[*:0]const u8,
        lpUsedDefChar: ?*i32,
    },
};
pub const HYPHENATEINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        cbSize: i16,
        dxHyphenateZone: i16,
        pfnHyphenate: isize,
    },
    .X86 => extern struct {
        cbSize: i16,
        dxHyphenateZone: i16,
        pfnHyphenate: isize,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (229)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreatePropertySheetPageA(
    constPropSheetPagePointer: ?*PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) ?HPROPSHEETPAGE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreatePropertySheetPageW(
    constPropSheetPagePointer: ?*PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) ?HPROPSHEETPAGE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DestroyPropertySheetPage(
    param0: ?HPROPSHEETPAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn PropertySheetA(
    param0: ?*PROPSHEETHEADERA_V2,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn PropertySheetW(
    param0: ?*PROPSHEETHEADERW_V2,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitCommonControls(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitCommonControlsEx(
    picce: ?*const INITCOMMONCONTROLSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Create(
    cx: i32,
    cy: i32,
    flags: IMAGELIST_CREATION_FLAGS,
    cInitial: i32,
    cGrow: i32,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Destroy(
    himl: ?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetImageCount(
    himl: ?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetImageCount(
    himl: ?HIMAGELIST,
    uNewCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Add(
    himl: ?HIMAGELIST,
    hbmImage: ?HBITMAP,
    hbmMask: ?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_ReplaceIcon(
    himl: ?HIMAGELIST,
    i: i32,
    hicon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetBkColor(
    himl: ?HIMAGELIST,
    clrBk: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetBkColor(
    himl: ?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetOverlayImage(
    himl: ?HIMAGELIST,
    iImage: i32,
    iOverlay: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Draw(
    himl: ?HIMAGELIST,
    i: i32,
    hdcDst: ?HDC,
    x: i32,
    y: i32,
    fStyle: IMAGE_LIST_DRAW_STYLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Replace(
    himl: ?HIMAGELIST,
    i: i32,
    hbmImage: ?HBITMAP,
    hbmMask: ?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_AddMasked(
    himl: ?HIMAGELIST,
    hbmImage: ?HBITMAP,
    crMask: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DrawEx(
    himl: ?HIMAGELIST,
    i: i32,
    hdcDst: ?HDC,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: IMAGE_LIST_DRAW_STYLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DrawIndirect(
    pimldp: ?*IMAGELISTDRAWPARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Remove(
    himl: ?HIMAGELIST,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetIcon(
    himl: ?HIMAGELIST,
    i: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_LoadImageA(
    hi: ?HINSTANCE,
    lpbmp: ?[*:0]const u8,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: IMAGE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_LoadImageW(
    hi: ?HINSTANCE,
    lpbmp: ?[*:0]const u16,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: IMAGE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Copy(
    himlDst: ?HIMAGELIST,
    iDst: i32,
    himlSrc: ?HIMAGELIST,
    iSrc: i32,
    uFlags: IMAGE_LIST_COPY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_BeginDrag(
    himlTrack: ?HIMAGELIST,
    iTrack: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_EndDrag(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragEnter(
    hwndLock: ?HWND,
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragLeave(
    hwndLock: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragMove(
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetDragCursorImage(
    himlDrag: ?HIMAGELIST,
    iDrag: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragShowNolock(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetDragImage(
    ppt: ?*POINT,
    pptHotspot: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Read(
    pstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Write(
    himl: ?HIMAGELIST,
    pstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_ReadEx(
    dwFlags: u32,
    pstm: ?*IStream,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_WriteEx(
    himl: ?HIMAGELIST,
    dwFlags: u32,
    pstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetIconSize(
    himl: ?HIMAGELIST,
    cx: ?*i32,
    cy: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetIconSize(
    himl: ?HIMAGELIST,
    cx: i32,
    cy: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetImageInfo(
    himl: ?HIMAGELIST,
    i: i32,
    pImageInfo: ?*IMAGEINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Merge(
    himl1: ?HIMAGELIST,
    i1: i32,
    himl2: ?HIMAGELIST,
    i2: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Duplicate(
    himl: ?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) ?HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn HIMAGELIST_QueryInterface(
    himl: ?HIMAGELIST,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateToolbarEx(
    hwnd: ?HWND,
    ws: u32,
    wID: u32,
    nBitmaps: i32,
    hBMInst: ?HINSTANCE,
    wBMID: usize,
    lpButtons: ?*TBBUTTON,
    iNumButtons: i32,
    dxButton: i32,
    dyButton: i32,
    dxBitmap: i32,
    dyBitmap: i32,
    uStructSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateMappedBitmap(
    hInstance: ?HINSTANCE,
    idBitmap: isize,
    wFlags: u32,
    lpColorMap: ?*COLORMAP,
    iNumMaps: i32,
) callconv(@import("std").os.windows.WINAPI) ?HBITMAP;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawStatusTextA(
    hDC: ?HDC,
    lprc: ?*RECT,
    pszText: ?[*:0]const u8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawStatusTextW(
    hDC: ?HDC,
    lprc: ?*RECT,
    pszText: ?[*:0]const u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateStatusWindowA(
    style: i32,
    lpszText: ?[*:0]const u8,
    hwndParent: ?HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateStatusWindowW(
    style: i32,
    lpszText: ?[*:0]const u16,
    hwndParent: ?HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn MenuHelp(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    hMainMenu: ?HMENU,
    hInst: ?HINSTANCE,
    hwndStatus: ?HWND,
    lpwIDs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ShowHideMenuCtl(
    hWnd: ?HWND,
    uFlags: usize,
    lpInfo: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn GetEffectiveClientRect(
    hWnd: ?HWND,
    lprc: ?*RECT,
    lpInfo: ?*const i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn MakeDragList(
    hLB: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawInsert(
    handParent: ?HWND,
    hLB: ?HWND,
    nItem: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LBItemFromPt(
    hLB: ?HWND,
    pt: POINT,
    bAutoScroll: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateUpDownControl(
    dwStyle: u32,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    hParent: ?HWND,
    nID: i32,
    hInst: ?HINSTANCE,
    hBuddy: ?HWND,
    nUpper: i32,
    nLower: i32,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn TaskDialogIndirect(
    pTaskConfig: ?*const TASKDIALOGCONFIG,
    pnButton: ?*i32,
    pnRadioButton: ?*i32,
    pfVerificationFlagChecked: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn TaskDialog(
    hwndOwner: ?HWND,
    hInstance: ?HINSTANCE,
    pszWindowTitle: ?[*:0]const u16,
    pszMainInstruction: ?[*:0]const u16,
    pszContent: ?[*:0]const u16,
    dwCommonButtons: TASKDIALOG_COMMON_BUTTON_FLAGS,
    pszIcon: ?[*:0]const u16,
    pnButton: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitMUILanguage(
    uiLang: u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn GetMUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Create(
    cbItem: i32,
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) ?*_DSA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Destroy(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DestroyCallback(
    hdsa: ?*_DSA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DeleteItem(
    hdsa: ?*_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DeleteAllItems(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_EnumCallback(
    hdsa: ?*_DSA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_InsertItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetItemPtr(
    hdsa: ?*_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_SetItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Clone(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) ?*_DSA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetSize(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Sort(
    pdsa: ?*_DSA,
    pfnCompare: ?PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Create(
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_CreateEx(
    cpGrow: i32,
    hheap: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Clone(
    hdpa: ?*const _DPA,
    hdpaNew: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Destroy(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DestroyCallback(
    hdpa: ?*_DPA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DeletePtr(
    hdpa: ?*_DPA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DeleteAllPtrs(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_EnumCallback(
    hdpa: ?*_DPA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Grow(
    pdpa: ?*_DPA,
    cp: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_InsertPtr(
    hdpa: ?*_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_SetPtr(
    hdpa: ?*_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetPtr(
    hdpa: ?*_DPA,
    i: isize,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetPtrIndex(
    hdpa: ?*_DPA,
    p: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetSize(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Sort(
    hdpa: ?*_DPA,
    pfnCompare: ?PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_LoadStream(
    phdpa: ?*?*_DPA,
    pfn: ?PFNDPASTREAM,
    pstream: ?*IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_SaveStream(
    hdpa: ?*_DPA,
    pfn: ?PFNDPASTREAM,
    pstream: ?*IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Merge(
    hdpaDest: ?*_DPA,
    hdpaSrc: ?*_DPA,
    dwFlags: u32,
    pfnCompare: ?PFNDACOMPARE,
    pfnMerge: ?PFNDPAMERGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Search(
    hdpa: ?*_DPA,
    pFind: ?*c_void,
    iStart: i32,
    pfnCompare: ?PFNDACOMPARE,
    lParam: LPARAM,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn Str_SetPtrW(
    ppsz: ?*?PWSTR,
    psz: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_EnableScrollBar(
    param0: ?HWND,
    param1: i32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_ShowScrollBar(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollRange(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: ?*i32,
    param3: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollInfo(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: ?*SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollPos(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollProp(
    param0: ?HWND,
    propIndex: WSB_PROP,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollPos(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    pos: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollInfo(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    psi: ?*SCROLLINFO,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollRange(
    param0: ?HWND,
    code: SCROLLBAR_CONSTANTS,
    min: i32,
    max: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollProp(
    param0: ?HWND,
    index: WSB_PROP,
    newValue: isize,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitializeFlatSB(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn UninitializeFlatSB(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LoadIconMetric(
    hinst: ?HINSTANCE,
    pszName: ?[*:0]const u16,
    lims: _LI_METRIC,
    phico: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LoadIconWithScaleDown(
    hinst: ?HINSTANCE,
    pszName: ?[*:0]const u16,
    cx: i32,
    cy: i32,
    phico: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawShadowText(
    hdc: ?HDC,
    pszText: [*:0]const u16,
    cch: u32,
    prc: ?*RECT,
    dwFlags: u32,
    crText: u32,
    crShadow: u32,
    ixOffset: i32,
    iyOffset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_CoCreateInstance(
    rclsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeAnimationProperty(
    hTheme: isize,
    iStoryboardId: i32,
    iTargetId: i32,
    eProperty: TA_PROPERTY,
    // TODO: what to do with BytesParamIndex 5?
    pvProperty: ?*c_void,
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeAnimationTransform(
    hTheme: isize,
    iStoryboardId: i32,
    iTargetId: i32,
    dwTransformIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    pTransform: ?*TA_TRANSFORM,
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeTimingFunction(
    hTheme: isize,
    iTimingFunctionId: i32,
    // TODO: what to do with BytesParamIndex 3?
    pTimingFunction: ?*TA_TIMINGFUNCTION,
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn OpenThemeData(
    hwnd: ?HWND,
    pszClassList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn OpenThemeDataEx(
    hwnd: ?HWND,
    pszClassList: ?[*:0]const u16,
    dwFlags: OPEN_THEME_DATA_FLAGS,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn CloseThemeData(
    hTheme: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeBackground(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pClipRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeBackgroundEx(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pOptions: ?*const DTBGOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeText(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    dwTextFlags2: u32,
    pRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBackgroundContentRect(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pBoundingRect: ?*RECT,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBackgroundExtent(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pContentRect: ?*RECT,
    pExtentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeBackgroundRegion(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pRegion: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemePartSize(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    prc: ?*RECT,
    eSize: THEMESIZE,
    psz: ?*SIZE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTextExtent(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchCharCount: i32,
    dwTextFlags: u32,
    pBoundingRect: ?*RECT,
    pExtentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTextMetrics(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    ptm: ?*TEXTMETRICW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn HitTestThemeBackground(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    dwOptions: u32,
    pRect: ?*RECT,
    hrgn: ?HRGN,
    ptTest: POINT,
    pwHitTestCode: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeEdge(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pDestRect: ?*RECT,
    uEdge: u32,
    uFlags: u32,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeIcon(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    himl: ?HIMAGELIST,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsThemePartDefined(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn IsThemeBackgroundPartiallyTransparent(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeColor(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pColor: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeMetric(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeString(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszBuff: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeBool(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    pfVal: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeInt(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeEnumValue(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemePosition(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pPoint: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeFont(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pFont: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeRect(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeMargins(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    prc: ?*RECT,
    pMargins: ?*MARGINS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeIntList(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pIntList: ?*INTLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemePropertyOrigin(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pOrigin: ?*PROPERTYORIGIN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn SetWindowTheme(
    hwnd: ?HWND,
    pszSubAppName: ?[*:0]const u16,
    pszSubIdList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeFilename(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszThemeFileName: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysColor(
    hTheme: isize,
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysColorBrush(
    hTheme: isize,
    iColorId: THEME_PROPERTY_SYMBOL_ID,
) callconv(@import("std").os.windows.WINAPI) ?HBRUSH;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysBool(
    hTheme: isize,
    iBoolId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysSize(
    hTheme: isize,
    iSizeId: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysFont(
    hTheme: isize,
    iFontId: THEME_PROPERTY_SYMBOL_ID,
    plf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysString(
    hTheme: isize,
    iStringId: THEME_PROPERTY_SYMBOL_ID,
    pszStringBuff: [*:0]u16,
    cchMaxStringChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysInt(
    hTheme: isize,
    iIntId: i32,
    piValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsThemeActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsAppThemed(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetWindowTheme(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EnableThemeDialogTexture(
    hwnd: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn IsThemeDialogTextureEnabled(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeAppProperties(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn SetThemeAppProperties(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetCurrentThemeName(
    pszThemeFileName: [*:0]u16,
    cchMaxNameChars: i32,
    pszColorBuff: ?[*:0]u16,
    cchMaxColorChars: i32,
    pszSizeBuff: ?[*:0]u16,
    cchMaxSizeChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeDocumentationProperty(
    pszThemeName: ?[*:0]const u16,
    pszPropertyName: ?[*:0]const u16,
    pszValueBuff: [*:0]u16,
    cchMaxValChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeParentBackground(
    hwnd: ?HWND,
    hdc: ?HDC,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EnableTheming(
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeParentBackgroundEx(
    hwnd: ?HWND,
    hdc: ?HDC,
    dwFlags: DRAW_THEME_PARENT_BACKGROUND_FLAGS,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn SetWindowThemeAttribute(
    hwnd: ?HWND,
    eAttribute: WINDOWTHEMEATTRIBUTETYPE,
    // TODO: what to do with BytesParamIndex 3?
    pvAttribute: ?*c_void,
    cbAttribute: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeTextEx(
    hTheme: isize,
    hdc: ?HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    pRect: ?*RECT,
    pOptions: ?*const DTTOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBitmap(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    dwFlags: GET_THEME_BITMAP_FLAGS,
    phBitmap: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeStream(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    ppvStream: ?*?*c_void,
    pcbStream: ?*u32,
    hInst: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintUnInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BeginBufferedPaint(
    hdcTarget: ?HDC,
    prcTarget: ?*const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    phdc: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn EndBufferedPaint(
    hBufferedPaint: isize,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintTargetRect(
    hBufferedPaint: isize,
    prc: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintTargetDC(
    hBufferedPaint: isize,
) callconv(@import("std").os.windows.WINAPI) ?HDC;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintDC(
    hBufferedPaint: isize,
) callconv(@import("std").os.windows.WINAPI) ?HDC;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetBufferedPaintBits(
    hBufferedPaint: isize,
    ppbBuffer: ?*?*RGBQUAD,
    pcxRow: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintClear(
    hBufferedPaint: isize,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BufferedPaintSetAlpha(
    hBufferedPaint: isize,
    prc: ?*const RECT,
    alpha: u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintStopAllAnimations(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BeginBufferedAnimation(
    hwnd: ?HWND,
    hdcTarget: ?HDC,
    prcTarget: ?*const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    pAnimationParams: ?*BP_ANIMATIONPARAMS,
    phdcFrom: ?*?HDC,
    phdcTo: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EndBufferedAnimation(
    hbpAnimation: isize,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BufferedPaintRenderAnimation(
    hwnd: ?HWND,
    hdcTarget: ?HDC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsCompositionActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTransitionDuration(
    hTheme: isize,
    iPartId: i32,
    iStateIdFrom: i32,
    iStateIdTo: i32,
    iPropId: i32,
    pdwDuration: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn CheckDlgButton(
    hDlg: ?HWND,
    nIDButton: i32,
    uCheck: DLG_BUTTON_CHECK_STATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn CheckRadioButton(
    hDlg: ?HWND,
    nIDFirstButton: i32,
    nIDLastButton: i32,
    nIDCheckButton: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn IsDlgButtonChecked(
    hDlg: ?HWND,
    nIDButton: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn IsCharLowerW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn InitializeTouchInjection(
    maxCount: u32,
    dwMode: TOUCH_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn InjectTouchInput(
    count: u32,
    contacts: [*]const POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn CreateSyntheticPointerDevice(
    pointerType: POINTER_INPUT_TYPE,
    maxCount: u32,
    mode: POINTER_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) ?HSYNTHETICPOINTERDEVICE;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn InjectSyntheticPointerInput(
    device: ?HSYNTHETICPOINTERDEVICE,
    pointerInfo: [*]const POINTER_TYPE_INFO,
    count: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn DestroySyntheticPointerDevice(
    device: ?HSYNTHETICPOINTERDEVICE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn RegisterTouchHitTestingWindow(
    hwnd: ?HWND,
    value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn EvaluateProximityToRect(
    controlBoundingBox: ?*const RECT,
    pHitTestingInput: ?*const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn EvaluateProximityToPolygon(
    numVertices: u32,
    controlPolygon: [*]const POINT,
    pHitTestingInput: ?*const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn PackTouchHitTestingProximityEvaluation(
    pHitTestingInput: ?*const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetWindowFeedbackSetting(
    hwnd: ?HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    pSize: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    config: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn SetWindowFeedbackSetting(
    hwnd: ?HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    size: u32,
    // TODO: what to do with BytesParamIndex 3?
    configuration: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollWindow(
    hWnd: ?HWND,
    XAmount: i32,
    YAmount: i32,
    lpRect: ?*const RECT,
    lpClipRect: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollDC(
    hDC: ?HDC,
    dx: i32,
    dy: i32,
    lprcScroll: ?*const RECT,
    lprcClip: ?*const RECT,
    hrgnUpdate: ?HRGN,
    lprcUpdate: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollWindowEx(
    hWnd: ?HWND,
    dx: i32,
    dy: i32,
    prcScroll: ?*const RECT,
    prcClip: ?*const RECT,
    hrgnUpdate: ?HRGN,
    prcUpdate: ?*RECT,
    flags: SHOW_WINDOW_CMD,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollPos(
    hWnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
    nPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollPos(
    hWnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollRange(
    hWnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
    nMinPos: i32,
    nMaxPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollRange(
    hWnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpMinPos: ?*i32,
    lpMaxPos: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ShowScrollBar(
    hWnd: ?HWND,
    wBar: SCROLLBAR_CONSTANTS,
    bShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn EnableScrollBar(
    hWnd: ?HWND,
    wSBflags: SCROLLBAR_CONSTANTS,
    wArrows: ENABLE_SCROLL_BAR_ARROWS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListA(
    hDlg: ?HWND,
    lpPathSpec: ?PSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListW(
    hDlg: ?HWND,
    lpPathSpec: ?PWSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectExA(
    hwndDlg: ?HWND,
    lpString: [*:0]u8,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectExW(
    hwndDlg: ?HWND,
    lpString: [*:0]u16,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListComboBoxA(
    hDlg: ?HWND,
    lpPathSpec: ?PSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListComboBoxW(
    hDlg: ?HWND,
    lpPathSpec: ?PWSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectComboBoxExA(
    hwndDlg: ?HWND,
    lpString: [*:0]u8,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectComboBoxExW(
    hwndDlg: ?HWND,
    lpString: [*:0]u16,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollInfo(
    hwnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpsi: ?*SCROLLINFO,
    redraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollInfo(
    hwnd: ?HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpsi: ?*SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollBarInfo(
    hwnd: ?HWND,
    idObject: OBJECT_IDENTIFIER,
    psbi: ?*SCROLLBARINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetComboBoxInfo(
    hwndCombo: ?HWND,
    pcbi: ?*COMBOBOXINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetListBoxInfo(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDevices(
    deviceCount: ?*u32,
    pointerDevices: ?[*]POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDevice(
    device: ?HANDLE,
    pointerDevice: ?*POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceProperties(
    device: ?HANDLE,
    propertyCount: ?*u32,
    pointerProperties: ?[*]POINTER_DEVICE_PROPERTY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn RegisterPointerDeviceNotifications(
    window: ?HWND,
    notifyRange: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceRects(
    device: ?HANDLE,
    pointerDeviceRect: ?*RECT,
    displayRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceCursors(
    device: ?HANDLE,
    cursorCount: ?*u32,
    deviceCursors: ?[*]POINTER_DEVICE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetRawPointerDeviceData(
    pointerId: u32,
    historyCount: u32,
    propertiesCount: u32,
    pProperties: [*]POINTER_DEVICE_PROPERTY,
    pValues: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetCurrentInputMessageSource(
    inputMessageSource: ?*INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetCIMSSM(
    inputMessageSource: ?*INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (54)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const TEXTRANGE = thismodule.TEXTRANGEA;
        pub const FINDTEXT = thismodule.FINDTEXTA;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXA;
        pub const LPFNPSPCALLBACK = thismodule.LPFNPSPCALLBACKA;
        pub const PROPSHEETPAGE = thismodule.PROPSHEETPAGEA;
        pub const HD_TEXTFILTER = thismodule.HD_TEXTFILTERA;
        pub const HDITEM = thismodule.HDITEMA;
        pub const NMHEADER = thismodule.NMHEADERA;
        pub const NMHDDISPINFO = thismodule.NMHDDISPINFOA;
        pub const TBSAVEPARAMS = thismodule.TBSAVEPARAMSA;
        pub const TBBUTTONINFO = thismodule.TBBUTTONINFOA;
        pub const NMTBGETINFOTIP = thismodule.NMTBGETINFOTIPA;
        pub const NMTBDISPINFO = thismodule.NMTBDISPINFOA;
        pub const NMTOOLBAR = thismodule.NMTOOLBARA;
        pub const REBARBANDINFO = thismodule.REBARBANDINFOA;
        pub const TTTOOLINFO = thismodule.TTTOOLINFOA;
        pub const TTHITTESTINFO = thismodule.TTHITTESTINFOA;
        pub const NMTTDISPINFO = thismodule.NMTTDISPINFOA;
        pub const LVITEM = thismodule.LVITEMA;
        pub const LVFINDINFO = thismodule.LVFINDINFOA;
        pub const LVCOLUMN = thismodule.LVCOLUMNA;
        pub const LVBKIMAGE = thismodule.LVBKIMAGEA;
        pub const NMLVFINDITEM = thismodule.NMLVFINDITEMA;
        pub const NMLVDISPINFO = thismodule.NMLVDISPINFOA;
        pub const NMLVGETINFOTIP = thismodule.NMLVGETINFOTIPA;
        pub const TVITEM = thismodule.TVITEMA;
        pub const TVITEMEX = thismodule.TVITEMEXA;
        pub const TVINSERTSTRUCT = thismodule.TVINSERTSTRUCTA;
        pub const NMTREEVIEW = thismodule.NMTREEVIEWA;
        pub const NMTVDISPINFO = thismodule.NMTVDISPINFOA;
        pub const NMTVDISPINFOEX = thismodule.NMTVDISPINFOEXA;
        pub const NMTVGETINFOTIP = thismodule.NMTVGETINFOTIPA;
        pub const COMBOBOXEXITEM = thismodule.COMBOBOXEXITEMA;
        pub const NMCOMBOBOXEX = thismodule.NMCOMBOBOXEXA;
        pub const NMCBEDRAGBEGIN = thismodule.NMCBEDRAGBEGINA;
        pub const NMCBEENDEDIT = thismodule.NMCBEENDEDITA;
        pub const TCITEMHEADER = thismodule.TCITEMHEADERA;
        pub const TCITEM = thismodule.TCITEMA;
        pub const NMDATETIMESTRING = thismodule.NMDATETIMESTRINGA;
        pub const NMDATETIMEWMKEYDOWN = thismodule.NMDATETIMEWMKEYDOWNA;
        pub const NMDATETIMEFORMAT = thismodule.NMDATETIMEFORMATA;
        pub const NMDATETIMEFORMATQUERY = thismodule.NMDATETIMEFORMATQUERYA;
        pub const CHARFORMAT = thismodule.CHARFORMATA;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2A;
        pub const EDITWORDBREAKPROC = thismodule.EDITWORDBREAKPROCA;
        pub const CreatePropertySheetPage = thismodule.CreatePropertySheetPageA;
        pub const PropertySheet = thismodule.PropertySheetA;
        pub const ImageList_LoadImage = thismodule.ImageList_LoadImageA;
        pub const DrawStatusText = thismodule.DrawStatusTextA;
        pub const CreateStatusWindow = thismodule.CreateStatusWindowA;
        pub const DlgDirList = thismodule.DlgDirListA;
        pub const DlgDirSelectEx = thismodule.DlgDirSelectExA;
        pub const DlgDirListComboBox = thismodule.DlgDirListComboBoxA;
        pub const DlgDirSelectComboBoxEx = thismodule.DlgDirSelectComboBoxExA;
    },
    .wide => struct {
        pub const TEXTRANGE = thismodule.TEXTRANGEW;
        pub const FINDTEXT = thismodule.FINDTEXTW;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXW;
        pub const LPFNPSPCALLBACK = thismodule.LPFNPSPCALLBACKW;
        pub const PROPSHEETPAGE = thismodule.PROPSHEETPAGEW;
        pub const HD_TEXTFILTER = thismodule.HD_TEXTFILTERW;
        pub const HDITEM = thismodule.HDITEMW;
        pub const NMHEADER = thismodule.NMHEADERW;
        pub const NMHDDISPINFO = thismodule.NMHDDISPINFOW;
        pub const TBSAVEPARAMS = thismodule.TBSAVEPARAMSW;
        pub const TBBUTTONINFO = thismodule.TBBUTTONINFOW;
        pub const NMTBGETINFOTIP = thismodule.NMTBGETINFOTIPW;
        pub const NMTBDISPINFO = thismodule.NMTBDISPINFOW;
        pub const NMTOOLBAR = thismodule.NMTOOLBARW;
        pub const REBARBANDINFO = thismodule.REBARBANDINFOW;
        pub const TTTOOLINFO = thismodule.TTTOOLINFOW;
        pub const TTHITTESTINFO = thismodule.TTHITTESTINFOW;
        pub const NMTTDISPINFO = thismodule.NMTTDISPINFOW;
        pub const LVITEM = thismodule.LVITEMW;
        pub const LVFINDINFO = thismodule.LVFINDINFOW;
        pub const LVCOLUMN = thismodule.LVCOLUMNW;
        pub const LVBKIMAGE = thismodule.LVBKIMAGEW;
        pub const NMLVFINDITEM = thismodule.NMLVFINDITEMW;
        pub const NMLVDISPINFO = thismodule.NMLVDISPINFOW;
        pub const NMLVGETINFOTIP = thismodule.NMLVGETINFOTIPW;
        pub const TVITEM = thismodule.TVITEMW;
        pub const TVITEMEX = thismodule.TVITEMEXW;
        pub const TVINSERTSTRUCT = thismodule.TVINSERTSTRUCTW;
        pub const NMTREEVIEW = thismodule.NMTREEVIEWW;
        pub const NMTVDISPINFO = thismodule.NMTVDISPINFOW;
        pub const NMTVDISPINFOEX = thismodule.NMTVDISPINFOEXW;
        pub const NMTVGETINFOTIP = thismodule.NMTVGETINFOTIPW;
        pub const COMBOBOXEXITEM = thismodule.COMBOBOXEXITEMW;
        pub const NMCOMBOBOXEX = thismodule.NMCOMBOBOXEXW;
        pub const NMCBEDRAGBEGIN = thismodule.NMCBEDRAGBEGINW;
        pub const NMCBEENDEDIT = thismodule.NMCBEENDEDITW;
        pub const TCITEMHEADER = thismodule.TCITEMHEADERW;
        pub const TCITEM = thismodule.TCITEMW;
        pub const NMDATETIMESTRING = thismodule.NMDATETIMESTRINGW;
        pub const NMDATETIMEWMKEYDOWN = thismodule.NMDATETIMEWMKEYDOWNW;
        pub const NMDATETIMEFORMAT = thismodule.NMDATETIMEFORMATW;
        pub const NMDATETIMEFORMATQUERY = thismodule.NMDATETIMEFORMATQUERYW;
        pub const CHARFORMAT = thismodule.CHARFORMATW;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2W;
        pub const EDITWORDBREAKPROC = thismodule.EDITWORDBREAKPROCW;
        pub const CreatePropertySheetPage = thismodule.CreatePropertySheetPageW;
        pub const PropertySheet = thismodule.PropertySheetW;
        pub const ImageList_LoadImage = thismodule.ImageList_LoadImageW;
        pub const DrawStatusText = thismodule.DrawStatusTextW;
        pub const CreateStatusWindow = thismodule.CreateStatusWindowW;
        pub const DlgDirList = thismodule.DlgDirListW;
        pub const DlgDirSelectEx = thismodule.DlgDirSelectExW;
        pub const DlgDirListComboBox = thismodule.DlgDirListComboBoxW;
        pub const DlgDirSelectComboBoxEx = thismodule.DlgDirSelectComboBoxExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const TEXTRANGE = *opaque{};
        pub const FINDTEXT = *opaque{};
        pub const FINDTEXTEX = *opaque{};
        pub const LPFNPSPCALLBACK = *opaque{};
        pub const PROPSHEETPAGE = *opaque{};
        pub const HD_TEXTFILTER = *opaque{};
        pub const HDITEM = *opaque{};
        pub const NMHEADER = *opaque{};
        pub const NMHDDISPINFO = *opaque{};
        pub const TBSAVEPARAMS = *opaque{};
        pub const TBBUTTONINFO = *opaque{};
        pub const NMTBGETINFOTIP = *opaque{};
        pub const NMTBDISPINFO = *opaque{};
        pub const NMTOOLBAR = *opaque{};
        pub const REBARBANDINFO = *opaque{};
        pub const TTTOOLINFO = *opaque{};
        pub const TTHITTESTINFO = *opaque{};
        pub const NMTTDISPINFO = *opaque{};
        pub const LVITEM = *opaque{};
        pub const LVFINDINFO = *opaque{};
        pub const LVCOLUMN = *opaque{};
        pub const LVBKIMAGE = *opaque{};
        pub const NMLVFINDITEM = *opaque{};
        pub const NMLVDISPINFO = *opaque{};
        pub const NMLVGETINFOTIP = *opaque{};
        pub const TVITEM = *opaque{};
        pub const TVITEMEX = *opaque{};
        pub const TVINSERTSTRUCT = *opaque{};
        pub const NMTREEVIEW = *opaque{};
        pub const NMTVDISPINFO = *opaque{};
        pub const NMTVDISPINFOEX = *opaque{};
        pub const NMTVGETINFOTIP = *opaque{};
        pub const COMBOBOXEXITEM = *opaque{};
        pub const NMCOMBOBOXEX = *opaque{};
        pub const NMCBEDRAGBEGIN = *opaque{};
        pub const NMCBEENDEDIT = *opaque{};
        pub const TCITEMHEADER = *opaque{};
        pub const TCITEM = *opaque{};
        pub const NMDATETIMESTRING = *opaque{};
        pub const NMDATETIMEWMKEYDOWN = *opaque{};
        pub const NMDATETIMEFORMAT = *opaque{};
        pub const NMDATETIMEFORMATQUERY = *opaque{};
        pub const CHARFORMAT = *opaque{};
        pub const CHARFORMAT2 = *opaque{};
        pub const EDITWORDBREAKPROC = *opaque{};
        pub const CreatePropertySheetPage = *opaque{};
        pub const PropertySheet = *opaque{};
        pub const ImageList_LoadImage = *opaque{};
        pub const DrawStatusText = *opaque{};
        pub const CreateStatusWindow = *opaque{};
        pub const DlgDirList = *opaque{};
        pub const DlgDirSelectEx = *opaque{};
        pub const DlgDirListComboBox = *opaque{};
        pub const DlgDirSelectComboBoxEx = *opaque{};
    } else struct {
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
        pub const LPFNPSPCALLBACK = @compileError("'LPFNPSPCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const PROPSHEETPAGE = @compileError("'PROPSHEETPAGE' requires that UNICODE be set to true or false in the root module");
        pub const HD_TEXTFILTER = @compileError("'HD_TEXTFILTER' requires that UNICODE be set to true or false in the root module");
        pub const HDITEM = @compileError("'HDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMHEADER = @compileError("'NMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const NMHDDISPINFO = @compileError("'NMHDDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const TBSAVEPARAMS = @compileError("'TBSAVEPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const TBBUTTONINFO = @compileError("'TBBUTTONINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTBGETINFOTIP = @compileError("'NMTBGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const NMTBDISPINFO = @compileError("'NMTBDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTOOLBAR = @compileError("'NMTOOLBAR' requires that UNICODE be set to true or false in the root module");
        pub const REBARBANDINFO = @compileError("'REBARBANDINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTTOOLINFO = @compileError("'TTTOOLINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTHITTESTINFO = @compileError("'TTHITTESTINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTTDISPINFO = @compileError("'NMTTDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVITEM = @compileError("'LVITEM' requires that UNICODE be set to true or false in the root module");
        pub const LVFINDINFO = @compileError("'LVFINDINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVCOLUMN = @compileError("'LVCOLUMN' requires that UNICODE be set to true or false in the root module");
        pub const LVBKIMAGE = @compileError("'LVBKIMAGE' requires that UNICODE be set to true or false in the root module");
        pub const NMLVFINDITEM = @compileError("'NMLVFINDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMLVDISPINFO = @compileError("'NMLVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMLVGETINFOTIP = @compileError("'NMLVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const TVITEM = @compileError("'TVITEM' requires that UNICODE be set to true or false in the root module");
        pub const TVITEMEX = @compileError("'TVITEMEX' requires that UNICODE be set to true or false in the root module");
        pub const TVINSERTSTRUCT = @compileError("'TVINSERTSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const NMTREEVIEW = @compileError("'NMTREEVIEW' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFO = @compileError("'NMTVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFOEX = @compileError("'NMTVDISPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NMTVGETINFOTIP = @compileError("'NMTVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const COMBOBOXEXITEM = @compileError("'COMBOBOXEXITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMCOMBOBOXEX = @compileError("'NMCOMBOBOXEX' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEDRAGBEGIN = @compileError("'NMCBEDRAGBEGIN' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEENDEDIT = @compileError("'NMCBEENDEDIT' requires that UNICODE be set to true or false in the root module");
        pub const TCITEMHEADER = @compileError("'TCITEMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const TCITEM = @compileError("'TCITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMESTRING = @compileError("'NMDATETIMESTRING' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEWMKEYDOWN = @compileError("'NMDATETIMEWMKEYDOWN' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMAT = @compileError("'NMDATETIMEFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMATQUERY = @compileError("'NMDATETIMEFORMATQUERY' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const EDITWORDBREAKPROC = @compileError("'EDITWORDBREAKPROC' requires that UNICODE be set to true or false in the root module");
        pub const CreatePropertySheetPage = @compileError("'CreatePropertySheetPage' requires that UNICODE be set to true or false in the root module");
        pub const PropertySheet = @compileError("'PropertySheet' requires that UNICODE be set to true or false in the root module");
        pub const ImageList_LoadImage = @compileError("'ImageList_LoadImage' requires that UNICODE be set to true or false in the root module");
        pub const DrawStatusText = @compileError("'DrawStatusText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStatusWindow = @compileError("'CreateStatusWindow' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirList = @compileError("'DlgDirList' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectEx = @compileError("'DlgDirSelectEx' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirListComboBox = @compileError("'DlgDirListComboBox' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectComboBoxEx = @compileError("'DlgDirSelectComboBoxEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (60)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLENDFUNCTION = @import("../graphics/gdi.zig").BLENDFUNCTION;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../system/system_services.zig").CHAR;
const DLGPROC = @import("../ui/windows_and_messaging.zig").DLGPROC;
const DLGTEMPLATE = @import("../ui/windows_and_messaging.zig").DLGTEMPLATE;
const DVASPECT = @import("../system/com.zig").DVASPECT;
const DVTARGETDEVICE = @import("../system/com.zig").DVTARGETDEVICE;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HBRUSH = @import("../graphics/gdi.zig").HBRUSH;
const HCURSOR = @import("../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../graphics/gdi.zig").HDC;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HIMC = @import("../globalization.zig").HIMC;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HPEN = @import("../graphics/gdi.zig").HPEN;
const HRESULT = @import("../foundation.zig").HRESULT;
const HRGN = @import("../graphics/gdi.zig").HRGN;
const HWND = @import("../foundation.zig").HWND;
const ID2D1RenderTarget = @import("../graphics/direct2d.zig").ID2D1RenderTarget;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDispatch = @import("../system/ole_automation.zig").IDispatch;
const IDropTarget = @import("../system/com.zig").IDropTarget;
const IOleClientSite = @import("../system/com.zig").IOleClientSite;
const IOleInPlaceFrame = @import("../system/com.zig").IOleInPlaceFrame;
const IOleInPlaceUIWindow = @import("../system/com.zig").IOleInPlaceUIWindow;
const IOleObject = @import("../system/com.zig").IOleObject;
const IRawElementProviderSimple = @import("../ui/accessibility.zig").IRawElementProviderSimple;
const IRawElementProviderWindowlessSite = @import("../ui/accessibility.zig").IRawElementProviderWindowlessSite;
const IStorage = @import("../storage/structured_storage.zig").IStorage;
const IStream = @import("../storage/structured_storage.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LOGFONTW = @import("../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const OIFI = @import("../system/com.zig").OIFI;
const POINT = @import("../foundation.zig").POINT;
const POINTER_INPUT_TYPE = @import("../ui/windows_and_messaging.zig").POINTER_INPUT_TYPE;
const POINTER_PEN_INFO = @import("../ui/pointer_input.zig").POINTER_PEN_INFO;
const POINTER_TOUCH_INFO = @import("../ui/pointer_input.zig").POINTER_TOUCH_INFO;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RECTL = @import("../foundation.zig").RECTL;
const RGBQUAD = @import("../graphics/gdi.zig").RGBQUAD;
const SHOW_WINDOW_CMD = @import("../ui/windows_and_messaging.zig").SHOW_WINDOW_CMD;
const SIZE = @import("../foundation.zig").SIZE;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TEXTMETRICW = @import("../graphics/gdi.zig").TEXTMETRICW;
const TTTOOLINFO_FLAGS = @import("../system/system_services.zig").TTTOOLINFO_FLAGS;
const UiaRect = @import("../ui/accessibility.zig").UiaRect;
const VARIANT = @import("../system/ole_automation.zig").VARIANT;
const WINDOWPOS = @import("../ui/windows_and_messaging.zig").WINDOWPOS;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNPSPCALLBACKA")) { _ = LPFNPSPCALLBACKA; }
    if (@hasDecl(@This(), "LPFNPSPCALLBACKW")) { _ = LPFNPSPCALLBACKW; }
    if (@hasDecl(@This(), "PFNPROPSHEETCALLBACK")) { _ = PFNPROPSHEETCALLBACK; }
    if (@hasDecl(@This(), "LPFNSVADDPROPSHEETPAGE")) { _ = LPFNSVADDPROPSHEETPAGE; }
    if (@hasDecl(@This(), "LPFNADDPROPSHEETPAGES")) { _ = LPFNADDPROPSHEETPAGES; }
    if (@hasDecl(@This(), "PFNLVCOMPARE")) { _ = PFNLVCOMPARE; }
    if (@hasDecl(@This(), "PFNLVGROUPCOMPARE")) { _ = PFNLVGROUPCOMPARE; }
    if (@hasDecl(@This(), "PFNTVCOMPARE")) { _ = PFNTVCOMPARE; }
    if (@hasDecl(@This(), "PFTASKDIALOGCALLBACK")) { _ = PFTASKDIALOGCALLBACK; }
    if (@hasDecl(@This(), "PFNDAENUMCALLBACK")) { _ = PFNDAENUMCALLBACK; }
    if (@hasDecl(@This(), "PFNDAENUMCALLBACKCONST")) { _ = PFNDAENUMCALLBACKCONST; }
    if (@hasDecl(@This(), "PFNDACOMPARE")) { _ = PFNDACOMPARE; }
    if (@hasDecl(@This(), "PFNDACOMPARECONST")) { _ = PFNDACOMPARECONST; }
    if (@hasDecl(@This(), "PFNDPASTREAM")) { _ = PFNDPASTREAM; }
    if (@hasDecl(@This(), "PFNDPAMERGE")) { _ = PFNDPAMERGE; }
    if (@hasDecl(@This(), "PFNDPAMERGECONST")) { _ = PFNDPAMERGECONST; }
    if (@hasDecl(@This(), "AutoCorrectProc")) { _ = AutoCorrectProc; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCEX")) { _ = EDITWORDBREAKPROCEX; }
    if (@hasDecl(@This(), "EDITSTREAMCALLBACK")) { _ = EDITSTREAMCALLBACK; }
    if (@hasDecl(@This(), "PCreateTextServices")) { _ = PCreateTextServices; }
    if (@hasDecl(@This(), "PShutdownTextServices")) { _ = PShutdownTextServices; }
    if (@hasDecl(@This(), "DTT_CALLBACK_PROC")) { _ = DTT_CALLBACK_PROC; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCA")) { _ = EDITWORDBREAKPROCA; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCW")) { _ = EDITWORDBREAKPROCW; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (79)
//--------------------------------------------------------------------------------
pub const _FACDXGI = @as(u32, 2170);
pub const DXGI_CPU_ACCESS_NONE = @as(u32, 0);
pub const DXGI_CPU_ACCESS_DYNAMIC = @as(u32, 1);
pub const DXGI_CPU_ACCESS_READ_WRITE = @as(u32, 2);
pub const DXGI_CPU_ACCESS_SCRATCH = @as(u32, 3);
pub const DXGI_CPU_ACCESS_FIELD = @as(u32, 15);
pub const DXGI_FORMAT_DEFINED = @as(u32, 1);
pub const DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN = @as(u32, 4294967295);
pub const DXGI_CENTER_MULTISAMPLE_QUALITY_PATTERN = @as(u32, 4294967294);
pub const DXGI_USAGE_SHADER_INPUT = @as(u32, 16);
pub const DXGI_USAGE_RENDER_TARGET_OUTPUT = @as(u32, 32);
pub const DXGI_USAGE_BACK_BUFFER = @as(u32, 64);
pub const DXGI_USAGE_SHARED = @as(u32, 128);
pub const DXGI_USAGE_READ_ONLY = @as(u32, 256);
pub const DXGI_USAGE_DISCARD_ON_PRESENT = @as(u32, 512);
pub const DXGI_USAGE_UNORDERED_ACCESS = @as(u32, 1024);
pub const DXGI_MAP_READ = @as(u32, 1);
pub const DXGI_MAP_WRITE = @as(u32, 2);
pub const DXGI_MAP_DISCARD = @as(u32, 4);
pub const DXGI_ENUM_MODES_INTERLACED = @as(u32, 1);
pub const DXGI_ENUM_MODES_SCALING = @as(u32, 2);
pub const DXGI_MAX_SWAP_CHAIN_BUFFERS = @as(u32, 16);
pub const DXGI_PRESENT_TEST = @as(u32, 1);
pub const DXGI_PRESENT_DO_NOT_SEQUENCE = @as(u32, 2);
pub const DXGI_PRESENT_RESTART = @as(u32, 4);
pub const DXGI_PRESENT_DO_NOT_WAIT = @as(u32, 8);
pub const DXGI_PRESENT_STEREO_PREFER_RIGHT = @as(u32, 16);
pub const DXGI_PRESENT_STEREO_TEMPORARY_MONO = @as(u32, 32);
pub const DXGI_PRESENT_RESTRICT_TO_OUTPUT = @as(u32, 64);
pub const DXGI_PRESENT_USE_DURATION = @as(u32, 256);
pub const DXGI_PRESENT_ALLOW_TEARING = @as(u32, 512);
pub const DXGI_MWA_NO_WINDOW_CHANGES = @as(u32, 1);
pub const DXGI_MWA_NO_ALT_ENTER = @as(u32, 2);
pub const DXGI_MWA_NO_PRINT_SCREEN = @as(u32, 4);
pub const DXGI_MWA_VALID = @as(u32, 7);
pub const DXGI_ENUM_MODES_STEREO = @as(u32, 4);
pub const DXGI_ENUM_MODES_DISABLED_STEREO = @as(u32, 8);
pub const DXGI_SHARED_RESOURCE_READ = @as(u32, 2147483648);
pub const DXGI_SHARED_RESOURCE_WRITE = @as(u32, 1);
pub const DXGI_DEBUG_BINARY_VERSION = @as(u32, 1);
pub const DXGI_DEBUG_ALL = Guid.initString("e48ae283-da80-490b-87e6-43e9a9cfda08");
pub const DXGI_DEBUG_DX = Guid.initString("35cdd7fc-13b2-421d-a5d7-7e4451287d64");
pub const DXGI_DEBUG_DXGI = Guid.initString("25cddaa4-b1c6-47e1-ac3e-98875b5a2e2a");
pub const DXGI_DEBUG_APP = Guid.initString("06cd6e01-4219-4ebd-8709-27ed23360c62");
pub const DXGI_INFO_QUEUE_MESSAGE_ID_STRING_FROM_APPLICATION = @as(u32, 0);
pub const DXGI_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT = @as(u32, 1024);
pub const DXGI_CREATE_FACTORY_DEBUG = @as(u32, 1);
pub const DXGI_ERROR_INVALID_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270527));
pub const DXGI_ERROR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270526));
pub const DXGI_ERROR_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270525));
pub const DXGI_ERROR_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270524));
pub const DXGI_ERROR_DEVICE_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270523));
pub const DXGI_ERROR_DEVICE_HUNG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270522));
pub const DXGI_ERROR_DEVICE_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270521));
pub const DXGI_ERROR_WAS_STILL_DRAWING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270518));
pub const DXGI_ERROR_FRAME_STATISTICS_DISJOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270517));
pub const DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270516));
pub const DXGI_ERROR_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270496));
pub const DXGI_ERROR_NONEXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270495));
pub const DXGI_ERROR_NOT_CURRENTLY_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270494));
pub const DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270493));
pub const DXGI_ERROR_REMOTE_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270492));
pub const DXGI_ERROR_ACCESS_LOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270490));
pub const DXGI_ERROR_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270489));
pub const DXGI_ERROR_SESSION_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270488));
pub const DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270487));
pub const DXGI_ERROR_CANNOT_PROTECT_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270486));
pub const DXGI_ERROR_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270485));
pub const DXGI_ERROR_NAME_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270484));
pub const DXGI_ERROR_SDK_COMPONENT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270483));
pub const DXGI_ERROR_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270482));
pub const DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270480));
pub const DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270479));
pub const DXGI_ERROR_NON_COMPOSITED_UI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270478));
pub const DXGI_ERROR_MODE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270491));
pub const DXGI_ERROR_CACHE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270477));
pub const DXGI_ERROR_CACHE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270476));
pub const DXGI_ERROR_CACHE_HASH_COLLISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270475));
pub const DXGI_ERROR_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270474));

//--------------------------------------------------------------------------------
// Section: Types (119)
//--------------------------------------------------------------------------------
pub const DXGI_RGBA = extern struct {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
};

pub const DXGI_RESOURCE_PRIORITY = enum(u32) {
    MINIMUM = 671088640,
    LOW = 1342177280,
    NORMAL = 2013265920,
    HIGH = 2684354560,
    MAXIMUM = 3355443200,
};
pub const DXGI_RESOURCE_PRIORITY_MINIMUM = DXGI_RESOURCE_PRIORITY.MINIMUM;
pub const DXGI_RESOURCE_PRIORITY_LOW = DXGI_RESOURCE_PRIORITY.LOW;
pub const DXGI_RESOURCE_PRIORITY_NORMAL = DXGI_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_RESOURCE_PRIORITY_HIGH = DXGI_RESOURCE_PRIORITY.HIGH;
pub const DXGI_RESOURCE_PRIORITY_MAXIMUM = DXGI_RESOURCE_PRIORITY.MAXIMUM;

pub const DXGI_RATIONAL = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXGI_SAMPLE_DESC = extern struct {
    Count: u32,
    Quality: u32,
};

pub const DXGI_COLOR_SPACE_TYPE = enum(i32) {
    RGB_FULL_G22_NONE_P709 = 0,
    RGB_FULL_G10_NONE_P709 = 1,
    RGB_STUDIO_G22_NONE_P709 = 2,
    RGB_STUDIO_G22_NONE_P2020 = 3,
    RESERVED = 4,
    YCBCR_FULL_G22_NONE_P709_X601 = 5,
    YCBCR_STUDIO_G22_LEFT_P601 = 6,
    YCBCR_FULL_G22_LEFT_P601 = 7,
    YCBCR_STUDIO_G22_LEFT_P709 = 8,
    YCBCR_FULL_G22_LEFT_P709 = 9,
    YCBCR_STUDIO_G22_LEFT_P2020 = 10,
    YCBCR_FULL_G22_LEFT_P2020 = 11,
    RGB_FULL_G2084_NONE_P2020 = 12,
    YCBCR_STUDIO_G2084_LEFT_P2020 = 13,
    RGB_STUDIO_G2084_NONE_P2020 = 14,
    YCBCR_STUDIO_G22_TOPLEFT_P2020 = 15,
    YCBCR_STUDIO_G2084_TOPLEFT_P2020 = 16,
    RGB_FULL_G22_NONE_P2020 = 17,
    YCBCR_STUDIO_GHLG_TOPLEFT_P2020 = 18,
    YCBCR_FULL_GHLG_TOPLEFT_P2020 = 19,
    RGB_STUDIO_G24_NONE_P709 = 20,
    RGB_STUDIO_G24_NONE_P2020 = 21,
    YCBCR_STUDIO_G24_LEFT_P709 = 22,
    YCBCR_STUDIO_G24_LEFT_P2020 = 23,
    YCBCR_STUDIO_G24_TOPLEFT_P2020 = 24,
    CUSTOM = -1,
};
pub const DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 = DXGI_COLOR_SPACE_TYPE.RGB_FULL_G22_NONE_P709;
pub const DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 = DXGI_COLOR_SPACE_TYPE.RGB_FULL_G10_NONE_P709;
pub const DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 = DXGI_COLOR_SPACE_TYPE.RGB_STUDIO_G22_NONE_P709;
pub const DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 = DXGI_COLOR_SPACE_TYPE.RGB_STUDIO_G22_NONE_P2020;
pub const DXGI_COLOR_SPACE_RESERVED = DXGI_COLOR_SPACE_TYPE.RESERVED;
pub const DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 = DXGI_COLOR_SPACE_TYPE.YCBCR_FULL_G22_NONE_P709_X601;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G22_LEFT_P601;
pub const DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 = DXGI_COLOR_SPACE_TYPE.YCBCR_FULL_G22_LEFT_P601;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G22_LEFT_P709;
pub const DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 = DXGI_COLOR_SPACE_TYPE.YCBCR_FULL_G22_LEFT_P709;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G22_LEFT_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_FULL_G22_LEFT_P2020;
pub const DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 = DXGI_COLOR_SPACE_TYPE.RGB_FULL_G2084_NONE_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G2084_LEFT_P2020;
pub const DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 = DXGI_COLOR_SPACE_TYPE.RGB_STUDIO_G2084_NONE_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G22_TOPLEFT_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G2084_TOPLEFT_P2020;
pub const DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 = DXGI_COLOR_SPACE_TYPE.RGB_FULL_G22_NONE_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_GHLG_TOPLEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_GHLG_TOPLEFT_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_FULL_GHLG_TOPLEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_FULL_GHLG_TOPLEFT_P2020;
pub const DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P709 = DXGI_COLOR_SPACE_TYPE.RGB_STUDIO_G24_NONE_P709;
pub const DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P2020 = DXGI_COLOR_SPACE_TYPE.RGB_STUDIO_G24_NONE_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P709 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G24_LEFT_P709;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G24_LEFT_P2020;
pub const DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_TOPLEFT_P2020 = DXGI_COLOR_SPACE_TYPE.YCBCR_STUDIO_G24_TOPLEFT_P2020;
pub const DXGI_COLOR_SPACE_CUSTOM = DXGI_COLOR_SPACE_TYPE.CUSTOM;

pub const DXGI_FORMAT = enum(u32) {
    UNKNOWN = 0,
    R32G32B32A32_TYPELESS = 1,
    R32G32B32A32_FLOAT = 2,
    R32G32B32A32_UINT = 3,
    R32G32B32A32_SINT = 4,
    R32G32B32_TYPELESS = 5,
    R32G32B32_FLOAT = 6,
    R32G32B32_UINT = 7,
    R32G32B32_SINT = 8,
    R16G16B16A16_TYPELESS = 9,
    R16G16B16A16_FLOAT = 10,
    R16G16B16A16_UNORM = 11,
    R16G16B16A16_UINT = 12,
    R16G16B16A16_SNORM = 13,
    R16G16B16A16_SINT = 14,
    R32G32_TYPELESS = 15,
    R32G32_FLOAT = 16,
    R32G32_UINT = 17,
    R32G32_SINT = 18,
    R32G8X24_TYPELESS = 19,
    D32_FLOAT_S8X24_UINT = 20,
    R32_FLOAT_X8X24_TYPELESS = 21,
    X32_TYPELESS_G8X24_UINT = 22,
    R10G10B10A2_TYPELESS = 23,
    R10G10B10A2_UNORM = 24,
    R10G10B10A2_UINT = 25,
    R11G11B10_FLOAT = 26,
    R8G8B8A8_TYPELESS = 27,
    R8G8B8A8_UNORM = 28,
    R8G8B8A8_UNORM_SRGB = 29,
    R8G8B8A8_UINT = 30,
    R8G8B8A8_SNORM = 31,
    R8G8B8A8_SINT = 32,
    R16G16_TYPELESS = 33,
    R16G16_FLOAT = 34,
    R16G16_UNORM = 35,
    R16G16_UINT = 36,
    R16G16_SNORM = 37,
    R16G16_SINT = 38,
    R32_TYPELESS = 39,
    D32_FLOAT = 40,
    R32_FLOAT = 41,
    R32_UINT = 42,
    R32_SINT = 43,
    R24G8_TYPELESS = 44,
    D24_UNORM_S8_UINT = 45,
    R24_UNORM_X8_TYPELESS = 46,
    X24_TYPELESS_G8_UINT = 47,
    R8G8_TYPELESS = 48,
    R8G8_UNORM = 49,
    R8G8_UINT = 50,
    R8G8_SNORM = 51,
    R8G8_SINT = 52,
    R16_TYPELESS = 53,
    R16_FLOAT = 54,
    D16_UNORM = 55,
    R16_UNORM = 56,
    R16_UINT = 57,
    R16_SNORM = 58,
    R16_SINT = 59,
    R8_TYPELESS = 60,
    R8_UNORM = 61,
    R8_UINT = 62,
    R8_SNORM = 63,
    R8_SINT = 64,
    A8_UNORM = 65,
    R1_UNORM = 66,
    R9G9B9E5_SHAREDEXP = 67,
    R8G8_B8G8_UNORM = 68,
    G8R8_G8B8_UNORM = 69,
    BC1_TYPELESS = 70,
    BC1_UNORM = 71,
    BC1_UNORM_SRGB = 72,
    BC2_TYPELESS = 73,
    BC2_UNORM = 74,
    BC2_UNORM_SRGB = 75,
    BC3_TYPELESS = 76,
    BC3_UNORM = 77,
    BC3_UNORM_SRGB = 78,
    BC4_TYPELESS = 79,
    BC4_UNORM = 80,
    BC4_SNORM = 81,
    BC5_TYPELESS = 82,
    BC5_UNORM = 83,
    BC5_SNORM = 84,
    B5G6R5_UNORM = 85,
    B5G5R5A1_UNORM = 86,
    B8G8R8A8_UNORM = 87,
    B8G8R8X8_UNORM = 88,
    R10G10B10_XR_BIAS_A2_UNORM = 89,
    B8G8R8A8_TYPELESS = 90,
    B8G8R8A8_UNORM_SRGB = 91,
    B8G8R8X8_TYPELESS = 92,
    B8G8R8X8_UNORM_SRGB = 93,
    BC6H_TYPELESS = 94,
    BC6H_UF16 = 95,
    BC6H_SF16 = 96,
    BC7_TYPELESS = 97,
    BC7_UNORM = 98,
    BC7_UNORM_SRGB = 99,
    AYUV = 100,
    Y410 = 101,
    Y416 = 102,
    NV12 = 103,
    P010 = 104,
    P016 = 105,
    @"420_OPAQUE" = 106,
    YUY2 = 107,
    Y210 = 108,
    Y216 = 109,
    NV11 = 110,
    AI44 = 111,
    IA44 = 112,
    P8 = 113,
    A8P8 = 114,
    B4G4R4A4_UNORM = 115,
    P208 = 130,
    V208 = 131,
    V408 = 132,
    SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 189,
    SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 190,
    FORCE_UINT = 4294967295,
};
pub const DXGI_FORMAT_UNKNOWN = DXGI_FORMAT.UNKNOWN;
pub const DXGI_FORMAT_R32G32B32A32_TYPELESS = DXGI_FORMAT.R32G32B32A32_TYPELESS;
pub const DXGI_FORMAT_R32G32B32A32_FLOAT = DXGI_FORMAT.R32G32B32A32_FLOAT;
pub const DXGI_FORMAT_R32G32B32A32_UINT = DXGI_FORMAT.R32G32B32A32_UINT;
pub const DXGI_FORMAT_R32G32B32A32_SINT = DXGI_FORMAT.R32G32B32A32_SINT;
pub const DXGI_FORMAT_R32G32B32_TYPELESS = DXGI_FORMAT.R32G32B32_TYPELESS;
pub const DXGI_FORMAT_R32G32B32_FLOAT = DXGI_FORMAT.R32G32B32_FLOAT;
pub const DXGI_FORMAT_R32G32B32_UINT = DXGI_FORMAT.R32G32B32_UINT;
pub const DXGI_FORMAT_R32G32B32_SINT = DXGI_FORMAT.R32G32B32_SINT;
pub const DXGI_FORMAT_R16G16B16A16_TYPELESS = DXGI_FORMAT.R16G16B16A16_TYPELESS;
pub const DXGI_FORMAT_R16G16B16A16_FLOAT = DXGI_FORMAT.R16G16B16A16_FLOAT;
pub const DXGI_FORMAT_R16G16B16A16_UNORM = DXGI_FORMAT.R16G16B16A16_UNORM;
pub const DXGI_FORMAT_R16G16B16A16_UINT = DXGI_FORMAT.R16G16B16A16_UINT;
pub const DXGI_FORMAT_R16G16B16A16_SNORM = DXGI_FORMAT.R16G16B16A16_SNORM;
pub const DXGI_FORMAT_R16G16B16A16_SINT = DXGI_FORMAT.R16G16B16A16_SINT;
pub const DXGI_FORMAT_R32G32_TYPELESS = DXGI_FORMAT.R32G32_TYPELESS;
pub const DXGI_FORMAT_R32G32_FLOAT = DXGI_FORMAT.R32G32_FLOAT;
pub const DXGI_FORMAT_R32G32_UINT = DXGI_FORMAT.R32G32_UINT;
pub const DXGI_FORMAT_R32G32_SINT = DXGI_FORMAT.R32G32_SINT;
pub const DXGI_FORMAT_R32G8X24_TYPELESS = DXGI_FORMAT.R32G8X24_TYPELESS;
pub const DXGI_FORMAT_D32_FLOAT_S8X24_UINT = DXGI_FORMAT.D32_FLOAT_S8X24_UINT;
pub const DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = DXGI_FORMAT.R32_FLOAT_X8X24_TYPELESS;
pub const DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = DXGI_FORMAT.X32_TYPELESS_G8X24_UINT;
pub const DXGI_FORMAT_R10G10B10A2_TYPELESS = DXGI_FORMAT.R10G10B10A2_TYPELESS;
pub const DXGI_FORMAT_R10G10B10A2_UNORM = DXGI_FORMAT.R10G10B10A2_UNORM;
pub const DXGI_FORMAT_R10G10B10A2_UINT = DXGI_FORMAT.R10G10B10A2_UINT;
pub const DXGI_FORMAT_R11G11B10_FLOAT = DXGI_FORMAT.R11G11B10_FLOAT;
pub const DXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS;
pub const DXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM;
pub const DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB;
pub const DXGI_FORMAT_R8G8B8A8_UINT = DXGI_FORMAT.R8G8B8A8_UINT;
pub const DXGI_FORMAT_R8G8B8A8_SNORM = DXGI_FORMAT.R8G8B8A8_SNORM;
pub const DXGI_FORMAT_R8G8B8A8_SINT = DXGI_FORMAT.R8G8B8A8_SINT;
pub const DXGI_FORMAT_R16G16_TYPELESS = DXGI_FORMAT.R16G16_TYPELESS;
pub const DXGI_FORMAT_R16G16_FLOAT = DXGI_FORMAT.R16G16_FLOAT;
pub const DXGI_FORMAT_R16G16_UNORM = DXGI_FORMAT.R16G16_UNORM;
pub const DXGI_FORMAT_R16G16_UINT = DXGI_FORMAT.R16G16_UINT;
pub const DXGI_FORMAT_R16G16_SNORM = DXGI_FORMAT.R16G16_SNORM;
pub const DXGI_FORMAT_R16G16_SINT = DXGI_FORMAT.R16G16_SINT;
pub const DXGI_FORMAT_R32_TYPELESS = DXGI_FORMAT.R32_TYPELESS;
pub const DXGI_FORMAT_D32_FLOAT = DXGI_FORMAT.D32_FLOAT;
pub const DXGI_FORMAT_R32_FLOAT = DXGI_FORMAT.R32_FLOAT;
pub const DXGI_FORMAT_R32_UINT = DXGI_FORMAT.R32_UINT;
pub const DXGI_FORMAT_R32_SINT = DXGI_FORMAT.R32_SINT;
pub const DXGI_FORMAT_R24G8_TYPELESS = DXGI_FORMAT.R24G8_TYPELESS;
pub const DXGI_FORMAT_D24_UNORM_S8_UINT = DXGI_FORMAT.D24_UNORM_S8_UINT;
pub const DXGI_FORMAT_R24_UNORM_X8_TYPELESS = DXGI_FORMAT.R24_UNORM_X8_TYPELESS;
pub const DXGI_FORMAT_X24_TYPELESS_G8_UINT = DXGI_FORMAT.X24_TYPELESS_G8_UINT;
pub const DXGI_FORMAT_R8G8_TYPELESS = DXGI_FORMAT.R8G8_TYPELESS;
pub const DXGI_FORMAT_R8G8_UNORM = DXGI_FORMAT.R8G8_UNORM;
pub const DXGI_FORMAT_R8G8_UINT = DXGI_FORMAT.R8G8_UINT;
pub const DXGI_FORMAT_R8G8_SNORM = DXGI_FORMAT.R8G8_SNORM;
pub const DXGI_FORMAT_R8G8_SINT = DXGI_FORMAT.R8G8_SINT;
pub const DXGI_FORMAT_R16_TYPELESS = DXGI_FORMAT.R16_TYPELESS;
pub const DXGI_FORMAT_R16_FLOAT = DXGI_FORMAT.R16_FLOAT;
pub const DXGI_FORMAT_D16_UNORM = DXGI_FORMAT.D16_UNORM;
pub const DXGI_FORMAT_R16_UNORM = DXGI_FORMAT.R16_UNORM;
pub const DXGI_FORMAT_R16_UINT = DXGI_FORMAT.R16_UINT;
pub const DXGI_FORMAT_R16_SNORM = DXGI_FORMAT.R16_SNORM;
pub const DXGI_FORMAT_R16_SINT = DXGI_FORMAT.R16_SINT;
pub const DXGI_FORMAT_R8_TYPELESS = DXGI_FORMAT.R8_TYPELESS;
pub const DXGI_FORMAT_R8_UNORM = DXGI_FORMAT.R8_UNORM;
pub const DXGI_FORMAT_R8_UINT = DXGI_FORMAT.R8_UINT;
pub const DXGI_FORMAT_R8_SNORM = DXGI_FORMAT.R8_SNORM;
pub const DXGI_FORMAT_R8_SINT = DXGI_FORMAT.R8_SINT;
pub const DXGI_FORMAT_A8_UNORM = DXGI_FORMAT.A8_UNORM;
pub const DXGI_FORMAT_R1_UNORM = DXGI_FORMAT.R1_UNORM;
pub const DXGI_FORMAT_R9G9B9E5_SHAREDEXP = DXGI_FORMAT.R9G9B9E5_SHAREDEXP;
pub const DXGI_FORMAT_R8G8_B8G8_UNORM = DXGI_FORMAT.R8G8_B8G8_UNORM;
pub const DXGI_FORMAT_G8R8_G8B8_UNORM = DXGI_FORMAT.G8R8_G8B8_UNORM;
pub const DXGI_FORMAT_BC1_TYPELESS = DXGI_FORMAT.BC1_TYPELESS;
pub const DXGI_FORMAT_BC1_UNORM = DXGI_FORMAT.BC1_UNORM;
pub const DXGI_FORMAT_BC1_UNORM_SRGB = DXGI_FORMAT.BC1_UNORM_SRGB;
pub const DXGI_FORMAT_BC2_TYPELESS = DXGI_FORMAT.BC2_TYPELESS;
pub const DXGI_FORMAT_BC2_UNORM = DXGI_FORMAT.BC2_UNORM;
pub const DXGI_FORMAT_BC2_UNORM_SRGB = DXGI_FORMAT.BC2_UNORM_SRGB;
pub const DXGI_FORMAT_BC3_TYPELESS = DXGI_FORMAT.BC3_TYPELESS;
pub const DXGI_FORMAT_BC3_UNORM = DXGI_FORMAT.BC3_UNORM;
pub const DXGI_FORMAT_BC3_UNORM_SRGB = DXGI_FORMAT.BC3_UNORM_SRGB;
pub const DXGI_FORMAT_BC4_TYPELESS = DXGI_FORMAT.BC4_TYPELESS;
pub const DXGI_FORMAT_BC4_UNORM = DXGI_FORMAT.BC4_UNORM;
pub const DXGI_FORMAT_BC4_SNORM = DXGI_FORMAT.BC4_SNORM;
pub const DXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS;
pub const DXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM;
pub const DXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM;
pub const DXGI_FORMAT_B5G6R5_UNORM = DXGI_FORMAT.B5G6R5_UNORM;
pub const DXGI_FORMAT_B5G5R5A1_UNORM = DXGI_FORMAT.B5G5R5A1_UNORM;
pub const DXGI_FORMAT_B8G8R8A8_UNORM = DXGI_FORMAT.B8G8R8A8_UNORM;
pub const DXGI_FORMAT_B8G8R8X8_UNORM = DXGI_FORMAT.B8G8R8X8_UNORM;
pub const DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = DXGI_FORMAT.R10G10B10_XR_BIAS_A2_UNORM;
pub const DXGI_FORMAT_B8G8R8A8_TYPELESS = DXGI_FORMAT.B8G8R8A8_TYPELESS;
pub const DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = DXGI_FORMAT.B8G8R8A8_UNORM_SRGB;
pub const DXGI_FORMAT_B8G8R8X8_TYPELESS = DXGI_FORMAT.B8G8R8X8_TYPELESS;
pub const DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = DXGI_FORMAT.B8G8R8X8_UNORM_SRGB;
pub const DXGI_FORMAT_BC6H_TYPELESS = DXGI_FORMAT.BC6H_TYPELESS;
pub const DXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16;
pub const DXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16;
pub const DXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS;
pub const DXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM;
pub const DXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB;
pub const DXGI_FORMAT_AYUV = DXGI_FORMAT.AYUV;
pub const DXGI_FORMAT_Y410 = DXGI_FORMAT.Y410;
pub const DXGI_FORMAT_Y416 = DXGI_FORMAT.Y416;
pub const DXGI_FORMAT_NV12 = DXGI_FORMAT.NV12;
pub const DXGI_FORMAT_P010 = DXGI_FORMAT.P010;
pub const DXGI_FORMAT_P016 = DXGI_FORMAT.P016;
pub const DXGI_FORMAT_420_OPAQUE = DXGI_FORMAT.@"420_OPAQUE";
pub const DXGI_FORMAT_YUY2 = DXGI_FORMAT.YUY2;
pub const DXGI_FORMAT_Y210 = DXGI_FORMAT.Y210;
pub const DXGI_FORMAT_Y216 = DXGI_FORMAT.Y216;
pub const DXGI_FORMAT_NV11 = DXGI_FORMAT.NV11;
pub const DXGI_FORMAT_AI44 = DXGI_FORMAT.AI44;
pub const DXGI_FORMAT_IA44 = DXGI_FORMAT.IA44;
pub const DXGI_FORMAT_P8 = DXGI_FORMAT.P8;
pub const DXGI_FORMAT_A8P8 = DXGI_FORMAT.A8P8;
pub const DXGI_FORMAT_B4G4R4A4_UNORM = DXGI_FORMAT.B4G4R4A4_UNORM;
pub const DXGI_FORMAT_P208 = DXGI_FORMAT.P208;
pub const DXGI_FORMAT_V208 = DXGI_FORMAT.V208;
pub const DXGI_FORMAT_V408 = DXGI_FORMAT.V408;
pub const DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = DXGI_FORMAT.SAMPLER_FEEDBACK_MIN_MIP_OPAQUE;
pub const DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = DXGI_FORMAT.SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE;
pub const DXGI_FORMAT_FORCE_UINT = DXGI_FORMAT.FORCE_UINT;

pub const DXGI_RGB = extern struct {
    Red: f32,
    Green: f32,
    Blue: f32,
};

pub const DXGI_GAMMA_CONTROL = extern struct {
    Scale: DXGI_RGB,
    Offset: DXGI_RGB,
    GammaCurve: [1025]DXGI_RGB,
};

pub const DXGI_GAMMA_CONTROL_CAPABILITIES = extern struct {
    ScaleAndOffsetSupported: BOOL,
    MaxConvertedValue: f32,
    MinConvertedValue: f32,
    NumGammaControlPoints: u32,
    ControlPointPositions: [1025]f32,
};

pub const DXGI_MODE_SCANLINE_ORDER = enum(i32) {
    UNSPECIFIED = 0,
    PROGRESSIVE = 1,
    UPPER_FIELD_FIRST = 2,
    LOWER_FIELD_FIRST = 3,
};
pub const DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = DXGI_MODE_SCANLINE_ORDER.UNSPECIFIED;
pub const DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = DXGI_MODE_SCANLINE_ORDER.PROGRESSIVE;
pub const DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = DXGI_MODE_SCANLINE_ORDER.UPPER_FIELD_FIRST;
pub const DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = DXGI_MODE_SCANLINE_ORDER.LOWER_FIELD_FIRST;

pub const DXGI_MODE_SCALING = enum(i32) {
    UNSPECIFIED = 0,
    CENTERED = 1,
    STRETCHED = 2,
};
pub const DXGI_MODE_SCALING_UNSPECIFIED = DXGI_MODE_SCALING.UNSPECIFIED;
pub const DXGI_MODE_SCALING_CENTERED = DXGI_MODE_SCALING.CENTERED;
pub const DXGI_MODE_SCALING_STRETCHED = DXGI_MODE_SCALING.STRETCHED;

pub const DXGI_MODE_ROTATION = enum(i32) {
    UNSPECIFIED = 0,
    IDENTITY = 1,
    ROTATE90 = 2,
    ROTATE180 = 3,
    ROTATE270 = 4,
};
pub const DXGI_MODE_ROTATION_UNSPECIFIED = DXGI_MODE_ROTATION.UNSPECIFIED;
pub const DXGI_MODE_ROTATION_IDENTITY = DXGI_MODE_ROTATION.IDENTITY;
pub const DXGI_MODE_ROTATION_ROTATE90 = DXGI_MODE_ROTATION.ROTATE90;
pub const DXGI_MODE_ROTATION_ROTATE180 = DXGI_MODE_ROTATION.ROTATE180;
pub const DXGI_MODE_ROTATION_ROTATE270 = DXGI_MODE_ROTATION.ROTATE270;

pub const DXGI_MODE_DESC = extern struct {
    Width: u32,
    Height: u32,
    RefreshRate: DXGI_RATIONAL,
    Format: DXGI_FORMAT,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
};

pub const DXGI_JPEG_DC_HUFFMAN_TABLE = extern struct {
    CodeCounts: [12]u8,
    CodeValues: [12]u8,
};

pub const DXGI_JPEG_AC_HUFFMAN_TABLE = extern struct {
    CodeCounts: [16]u8,
    CodeValues: [162]u8,
};

pub const DXGI_JPEG_QUANTIZATION_TABLE = extern struct {
    Elements: [64]u8,
};

pub const DXGI_FRAME_STATISTICS = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
};

pub const DXGI_MAPPED_RECT = extern struct {
    Pitch: i32,
    pBits: ?*u8,
};

pub const DXGI_ADAPTER_DESC = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
};

pub const DXGI_OUTPUT_DESC = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
};

pub const DXGI_SHARED_RESOURCE = extern struct {
    Handle: ?HANDLE,
};

pub const DXGI_RESIDENCY = enum(i32) {
    FULLY_RESIDENT = 1,
    RESIDENT_IN_SHARED_MEMORY = 2,
    EVICTED_TO_DISK = 3,
};
pub const DXGI_RESIDENCY_FULLY_RESIDENT = DXGI_RESIDENCY.FULLY_RESIDENT;
pub const DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = DXGI_RESIDENCY.RESIDENT_IN_SHARED_MEMORY;
pub const DXGI_RESIDENCY_EVICTED_TO_DISK = DXGI_RESIDENCY.EVICTED_TO_DISK;

pub const DXGI_SURFACE_DESC = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    SampleDesc: DXGI_SAMPLE_DESC,
};

pub const DXGI_SWAP_EFFECT = enum(i32) {
    DISCARD = 0,
    SEQUENTIAL = 1,
    FLIP_SEQUENTIAL = 3,
    FLIP_DISCARD = 4,
};
pub const DXGI_SWAP_EFFECT_DISCARD = DXGI_SWAP_EFFECT.DISCARD;
pub const DXGI_SWAP_EFFECT_SEQUENTIAL = DXGI_SWAP_EFFECT.SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = DXGI_SWAP_EFFECT.FLIP_SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_DISCARD = DXGI_SWAP_EFFECT.FLIP_DISCARD;

pub const DXGI_SWAP_CHAIN_FLAG = enum(i32) {
    NONPREROTATED = 1,
    ALLOW_MODE_SWITCH = 2,
    GDI_COMPATIBLE = 4,
    RESTRICTED_CONTENT = 8,
    RESTRICT_SHARED_RESOURCE_DRIVER = 16,
    DISPLAY_ONLY = 32,
    FRAME_LATENCY_WAITABLE_OBJECT = 64,
    FOREGROUND_LAYER = 128,
    FULLSCREEN_VIDEO = 256,
    YUV_VIDEO = 512,
    HW_PROTECTED = 1024,
    ALLOW_TEARING = 2048,
    RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = 4096,
};
pub const DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = DXGI_SWAP_CHAIN_FLAG.NONPREROTATED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = DXGI_SWAP_CHAIN_FLAG.ALLOW_MODE_SWITCH;
pub const DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE = DXGI_SWAP_CHAIN_FLAG.GDI_COMPATIBLE;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_CONTENT;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = DXGI_SWAP_CHAIN_FLAG.RESTRICT_SHARED_RESOURCE_DRIVER;
pub const DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY = DXGI_SWAP_CHAIN_FLAG.DISPLAY_ONLY;
pub const DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = DXGI_SWAP_CHAIN_FLAG.FRAME_LATENCY_WAITABLE_OBJECT;
pub const DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER = DXGI_SWAP_CHAIN_FLAG.FOREGROUND_LAYER;
pub const DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO = DXGI_SWAP_CHAIN_FLAG.FULLSCREEN_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = DXGI_SWAP_CHAIN_FLAG.YUV_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED = DXGI_SWAP_CHAIN_FLAG.HW_PROTECTED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = DXGI_SWAP_CHAIN_FLAG.ALLOW_TEARING;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS;

pub const DXGI_SWAP_CHAIN_DESC = extern struct {
    BufferDesc: DXGI_MODE_DESC,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    OutputWindow: ?HWND,
    Windowed: BOOL,
    SwapEffect: DXGI_SWAP_EFFECT,
    Flags: u32,
};

const IID_IDXGIObject_Value = @import("../zig.zig").Guid.initString("aec22fb8-76f3-4639-9be0-28eb43a67a2e");
pub const IID_IDXGIObject = &IID_IDXGIObject_Value;
pub const IDXGIObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPrivateData: fn(
            self: *const IDXGIObject,
            Name: ?*const Guid,
            DataSize: u32,
            // TODO: what to do with BytesParamIndex 1?
            pData: ?*const c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrivateDataInterface: fn(
            self: *const IDXGIObject,
            Name: ?*const Guid,
            pUnknown: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateData: fn(
            self: *const IDXGIObject,
            Name: ?*const Guid,
            pDataSize: ?*u32,
            // TODO: what to do with BytesParamIndex 1?
            pData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IDXGIObject,
            riid: ?*const Guid,
            ppParent: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_SetPrivateData(self: *const T, Name: ?*const Guid, DataSize: u32, pData: ?*const c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).SetPrivateData(@ptrCast(*const IDXGIObject, self), Name, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_SetPrivateDataInterface(self: *const T, Name: ?*const Guid, pUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).SetPrivateDataInterface(@ptrCast(*const IDXGIObject, self), Name, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_GetPrivateData(self: *const T, Name: ?*const Guid, pDataSize: ?*u32, pData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).GetPrivateData(@ptrCast(*const IDXGIObject, self), Name, pDataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIObject_GetParent(self: *const T, riid: ?*const Guid, ppParent: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIObject.VTable, self.vtable).GetParent(@ptrCast(*const IDXGIObject, self), riid, ppParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDeviceSubObject_Value = @import("../zig.zig").Guid.initString("3d3e0379-f9de-4d58-bb6c-18d62992f1a6");
pub const IID_IDXGIDeviceSubObject = &IID_IDXGIDeviceSubObject_Value;
pub const IDXGIDeviceSubObject = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDevice: fn(
            self: *const IDXGIDeviceSubObject,
            riid: ?*const Guid,
            ppDevice: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDeviceSubObject_GetDevice(self: *const T, riid: ?*const Guid, ppDevice: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDeviceSubObject.VTable, self.vtable).GetDevice(@ptrCast(*const IDXGIDeviceSubObject, self), riid, ppDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIResource_Value = @import("../zig.zig").Guid.initString("035f3ab4-482e-4e50-b41f-8a7f8bd8960b");
pub const IID_IDXGIResource = &IID_IDXGIResource_Value;
pub const IDXGIResource = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetSharedHandle: fn(
            self: *const IDXGIResource,
            pSharedHandle: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsage: fn(
            self: *const IDXGIResource,
            pUsage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEvictionPriority: fn(
            self: *const IDXGIResource,
            EvictionPriority: DXGI_RESOURCE_PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvictionPriority: fn(
            self: *const IDXGIResource,
            pEvictionPriority: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetSharedHandle(self: *const T, pSharedHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetSharedHandle(@ptrCast(*const IDXGIResource, self), pSharedHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetUsage(self: *const T, pUsage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetUsage(@ptrCast(*const IDXGIResource, self), pUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_SetEvictionPriority(self: *const T, EvictionPriority: DXGI_RESOURCE_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).SetEvictionPriority(@ptrCast(*const IDXGIResource, self), EvictionPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource_GetEvictionPriority(self: *const T, pEvictionPriority: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource.VTable, self.vtable).GetEvictionPriority(@ptrCast(*const IDXGIResource, self), pEvictionPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIKeyedMutex_Value = @import("../zig.zig").Guid.initString("9d8e1289-d7b3-465f-8126-250e349af85d");
pub const IID_IDXGIKeyedMutex = &IID_IDXGIKeyedMutex_Value;
pub const IDXGIKeyedMutex = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        AcquireSync: fn(
            self: *const IDXGIKeyedMutex,
            Key: u64,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSync: fn(
            self: *const IDXGIKeyedMutex,
            Key: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIKeyedMutex_AcquireSync(self: *const T, Key: u64, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIKeyedMutex.VTable, self.vtable).AcquireSync(@ptrCast(*const IDXGIKeyedMutex, self), Key, dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIKeyedMutex_ReleaseSync(self: *const T, Key: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIKeyedMutex.VTable, self.vtable).ReleaseSync(@ptrCast(*const IDXGIKeyedMutex, self), Key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISurface_Value = @import("../zig.zig").Guid.initString("cafcb56c-6ac3-4889-bf47-9e23bbd260ec");
pub const IID_IDXGISurface = &IID_IDXGISurface_Value;
pub const IDXGISurface = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetDesc: fn(
            self: *const IDXGISurface,
            pDesc: ?*DXGI_SURFACE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Map: fn(
            self: *const IDXGISurface,
            pLockedRect: ?*DXGI_MAPPED_RECT,
            MapFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmap: fn(
            self: *const IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_GetDesc(self: *const T, pDesc: ?*DXGI_SURFACE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGISurface, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_Map(self: *const T, pLockedRect: ?*DXGI_MAPPED_RECT, MapFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).Map(@ptrCast(*const IDXGISurface, self), pLockedRect, MapFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface_Unmap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface.VTable, self.vtable).Unmap(@ptrCast(*const IDXGISurface, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGISurface1_Value = @import("../zig.zig").Guid.initString("4ae63092-6327-4c1b-80ae-bfe12ea32b86");
pub const IID_IDXGISurface1 = &IID_IDXGISurface1_Value;
pub const IDXGISurface1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface.VTable,
        GetDC: fn(
            self: *const IDXGISurface1,
            Discard: BOOL,
            phdc: ?*?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDC: fn(
            self: *const IDXGISurface1,
            pDirtyRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISurface.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface1_GetDC(self: *const T, Discard: BOOL, phdc: ?*?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface1.VTable, self.vtable).GetDC(@ptrCast(*const IDXGISurface1, self), Discard, phdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface1_ReleaseDC(self: *const T, pDirtyRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface1.VTable, self.vtable).ReleaseDC(@ptrCast(*const IDXGISurface1, self), pDirtyRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIAdapter_Value = @import("../zig.zig").Guid.initString("2411e7e1-12ac-4ccf-bd14-9798e8534dc0");
pub const IID_IDXGIAdapter = &IID_IDXGIAdapter_Value;
pub const IDXGIAdapter = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumOutputs: fn(
            self: *const IDXGIAdapter,
            Output: u32,
            ppOutput: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDesc: fn(
            self: *const IDXGIAdapter,
            pDesc: ?*DXGI_ADAPTER_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckInterfaceSupport: fn(
            self: *const IDXGIAdapter,
            InterfaceName: ?*const Guid,
            pUMDVersion: ?*LARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_EnumOutputs(self: *const T, Output: u32, ppOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).EnumOutputs(@ptrCast(*const IDXGIAdapter, self), Output, ppOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_GetDesc(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIAdapter, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter_CheckInterfaceSupport(self: *const T, InterfaceName: ?*const Guid, pUMDVersion: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter.VTable, self.vtable).CheckInterfaceSupport(@ptrCast(*const IDXGIAdapter, self), InterfaceName, pUMDVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIOutput_Value = @import("../zig.zig").Guid.initString("ae02eedb-c735-4690-8d52-5a8dc20213aa");
pub const IID_IDXGIOutput = &IID_IDXGIOutput_Value;
pub const IDXGIOutput = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: fn(
            self: *const IDXGIOutput,
            pDesc: ?*DXGI_OUTPUT_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayModeList: fn(
            self: *const IDXGIOutput,
            EnumFormat: DXGI_FORMAT,
            Flags: u32,
            pNumModes: ?*u32,
            pDesc: ?[*]DXGI_MODE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestMatchingMode: fn(
            self: *const IDXGIOutput,
            pModeToMatch: ?*const DXGI_MODE_DESC,
            pClosestMatch: ?*DXGI_MODE_DESC,
            pConcernedDevice: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForVBlank: fn(
            self: *const IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TakeOwnership: fn(
            self: *const IDXGIOutput,
            pDevice: ?*IUnknown,
            Exclusive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseOwnership: fn(
            self: *const IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetGammaControlCapabilities: fn(
            self: *const IDXGIOutput,
            pGammaCaps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGammaControl: fn(
            self: *const IDXGIOutput,
            pArray: ?*const DXGI_GAMMA_CONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGammaControl: fn(
            self: *const IDXGIOutput,
            pArray: ?*DXGI_GAMMA_CONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplaySurface: fn(
            self: *const IDXGIOutput,
            pScanoutSurface: ?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplaySurfaceData: fn(
            self: *const IDXGIOutput,
            pDestination: ?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameStatistics: fn(
            self: *const IDXGIOutput,
            pStats: ?*DXGI_FRAME_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDesc(self: *const T, pDesc: ?*DXGI_OUTPUT_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIOutput, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDisplayModeList(self: *const T, EnumFormat: DXGI_FORMAT, Flags: u32, pNumModes: ?*u32, pDesc: ?[*]DXGI_MODE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDisplayModeList(@ptrCast(*const IDXGIOutput, self), EnumFormat, Flags, pNumModes, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_FindClosestMatchingMode(self: *const T, pModeToMatch: ?*const DXGI_MODE_DESC, pClosestMatch: ?*DXGI_MODE_DESC, pConcernedDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).FindClosestMatchingMode(@ptrCast(*const IDXGIOutput, self), pModeToMatch, pClosestMatch, pConcernedDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_WaitForVBlank(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).WaitForVBlank(@ptrCast(*const IDXGIOutput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_TakeOwnership(self: *const T, pDevice: ?*IUnknown, Exclusive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).TakeOwnership(@ptrCast(*const IDXGIOutput, self), pDevice, Exclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_ReleaseOwnership(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).ReleaseOwnership(@ptrCast(*const IDXGIOutput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetGammaControlCapabilities(self: *const T, pGammaCaps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetGammaControlCapabilities(@ptrCast(*const IDXGIOutput, self), pGammaCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_SetGammaControl(self: *const T, pArray: ?*const DXGI_GAMMA_CONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).SetGammaControl(@ptrCast(*const IDXGIOutput, self), pArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetGammaControl(self: *const T, pArray: ?*DXGI_GAMMA_CONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetGammaControl(@ptrCast(*const IDXGIOutput, self), pArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_SetDisplaySurface(self: *const T, pScanoutSurface: ?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).SetDisplaySurface(@ptrCast(*const IDXGIOutput, self), pScanoutSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetDisplaySurfaceData(self: *const T, pDestination: ?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetDisplaySurfaceData(@ptrCast(*const IDXGIOutput, self), pDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput_GetFrameStatistics(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput.VTable, self.vtable).GetFrameStatistics(@ptrCast(*const IDXGIOutput, self), pStats);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISwapChain_Value = @import("../zig.zig").Guid.initString("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a");
pub const IID_IDXGISwapChain = &IID_IDXGISwapChain_Value;
pub const IDXGISwapChain = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        Present: fn(
            self: *const IDXGISwapChain,
            SyncInterval: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const IDXGISwapChain,
            Buffer: u32,
            riid: ?*const Guid,
            ppSurface: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullscreenState: fn(
            self: *const IDXGISwapChain,
            Fullscreen: BOOL,
            pTarget: ?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullscreenState: fn(
            self: *const IDXGISwapChain,
            pFullscreen: ?*BOOL,
            ppTarget: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDesc: fn(
            self: *const IDXGISwapChain,
            pDesc: ?*DXGI_SWAP_CHAIN_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBuffers: fn(
            self: *const IDXGISwapChain,
            BufferCount: u32,
            Width: u32,
            Height: u32,
            NewFormat: DXGI_FORMAT,
            SwapChainFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeTarget: fn(
            self: *const IDXGISwapChain,
            pNewTargetParameters: ?*const DXGI_MODE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingOutput: fn(
            self: *const IDXGISwapChain,
            ppOutput: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameStatistics: fn(
            self: *const IDXGISwapChain,
            pStats: ?*DXGI_FRAME_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastPresentCount: fn(
            self: *const IDXGISwapChain,
            pLastPresentCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_Present(self: *const T, SyncInterval: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).Present(@ptrCast(*const IDXGISwapChain, self), SyncInterval, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetBuffer(self: *const T, Buffer: u32, riid: ?*const Guid, ppSurface: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetBuffer(@ptrCast(*const IDXGISwapChain, self), Buffer, riid, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_SetFullscreenState(self: *const T, Fullscreen: BOOL, pTarget: ?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).SetFullscreenState(@ptrCast(*const IDXGISwapChain, self), Fullscreen, pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetFullscreenState(self: *const T, pFullscreen: ?*BOOL, ppTarget: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetFullscreenState(@ptrCast(*const IDXGISwapChain, self), pFullscreen, ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetDesc(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGISwapChain, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_ResizeBuffers(self: *const T, BufferCount: u32, Width: u32, Height: u32, NewFormat: DXGI_FORMAT, SwapChainFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).ResizeBuffers(@ptrCast(*const IDXGISwapChain, self), BufferCount, Width, Height, NewFormat, SwapChainFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_ResizeTarget(self: *const T, pNewTargetParameters: ?*const DXGI_MODE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).ResizeTarget(@ptrCast(*const IDXGISwapChain, self), pNewTargetParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetContainingOutput(self: *const T, ppOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetContainingOutput(@ptrCast(*const IDXGISwapChain, self), ppOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetFrameStatistics(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetFrameStatistics(@ptrCast(*const IDXGISwapChain, self), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain_GetLastPresentCount(self: *const T, pLastPresentCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain.VTable, self.vtable).GetLastPresentCount(@ptrCast(*const IDXGISwapChain, self), pLastPresentCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory_Value = @import("../zig.zig").Guid.initString("7b7166ec-21c7-44ae-b21a-c9ae321ae369");
pub const IID_IDXGIFactory = &IID_IDXGIFactory_Value;
pub const IDXGIFactory = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumAdapters: fn(
            self: *const IDXGIFactory,
            Adapter: u32,
            ppAdapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeWindowAssociation: fn(
            self: *const IDXGIFactory,
            WindowHandle: ?HWND,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowAssociation: fn(
            self: *const IDXGIFactory,
            pWindowHandle: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSwapChain: fn(
            self: *const IDXGIFactory,
            pDevice: ?*IUnknown,
            pDesc: ?*DXGI_SWAP_CHAIN_DESC,
            ppSwapChain: ?*?*IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSoftwareAdapter: fn(
            self: *const IDXGIFactory,
            Module: ?HINSTANCE,
            ppAdapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_EnumAdapters(self: *const T, Adapter: u32, ppAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).EnumAdapters(@ptrCast(*const IDXGIFactory, self), Adapter, ppAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_MakeWindowAssociation(self: *const T, WindowHandle: ?HWND, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).MakeWindowAssociation(@ptrCast(*const IDXGIFactory, self), WindowHandle, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_GetWindowAssociation(self: *const T, pWindowHandle: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).GetWindowAssociation(@ptrCast(*const IDXGIFactory, self), pWindowHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_CreateSwapChain(self: *const T, pDevice: ?*IUnknown, pDesc: ?*DXGI_SWAP_CHAIN_DESC, ppSwapChain: ?*?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).CreateSwapChain(@ptrCast(*const IDXGIFactory, self), pDevice, pDesc, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory_CreateSoftwareAdapter(self: *const T, Module: ?HINSTANCE, ppAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory.VTable, self.vtable).CreateSoftwareAdapter(@ptrCast(*const IDXGIFactory, self), Module, ppAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDevice_Value = @import("../zig.zig").Guid.initString("54ec77fa-1377-44e6-8c32-88fd5f44c84c");
pub const IID_IDXGIDevice = &IID_IDXGIDevice_Value;
pub const IDXGIDevice = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetAdapter: fn(
            self: *const IDXGIDevice,
            pAdapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSurface: fn(
            self: *const IDXGIDevice,
            pDesc: ?*const DXGI_SURFACE_DESC,
            NumSurfaces: u32,
            Usage: u32,
            pSharedResource: ?*const DXGI_SHARED_RESOURCE,
            ppSurface: ?*?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryResourceResidency: fn(
            self: *const IDXGIDevice,
            ppResources: [*]?*IUnknown,
            pResidencyStatus: [*]DXGI_RESIDENCY,
            NumResources: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGPUThreadPriority: fn(
            self: *const IDXGIDevice,
            Priority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGPUThreadPriority: fn(
            self: *const IDXGIDevice,
            pPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_GetAdapter(self: *const T, pAdapter: ?*?*IDXGIAdapter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).GetAdapter(@ptrCast(*const IDXGIDevice, self), pAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_CreateSurface(self: *const T, pDesc: ?*const DXGI_SURFACE_DESC, NumSurfaces: u32, Usage: u32, pSharedResource: ?*const DXGI_SHARED_RESOURCE, ppSurface: ?*?*IDXGISurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).CreateSurface(@ptrCast(*const IDXGIDevice, self), pDesc, NumSurfaces, Usage, pSharedResource, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_QueryResourceResidency(self: *const T, ppResources: [*]?*IUnknown, pResidencyStatus: [*]DXGI_RESIDENCY, NumResources: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).QueryResourceResidency(@ptrCast(*const IDXGIDevice, self), ppResources, pResidencyStatus, NumResources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_SetGPUThreadPriority(self: *const T, Priority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).SetGPUThreadPriority(@ptrCast(*const IDXGIDevice, self), Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice_GetGPUThreadPriority(self: *const T, pPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice.VTable, self.vtable).GetGPUThreadPriority(@ptrCast(*const IDXGIDevice, self), pPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
    }) DXGI_ADAPTER_FLAG {
        return @intToEnum(DXGI_ADAPTER_FLAG,
              (if (o.NONE == 1) @enumToInt(DXGI_ADAPTER_FLAG.NONE) else 0)
            | (if (o.REMOTE == 1) @enumToInt(DXGI_ADAPTER_FLAG.REMOTE) else 0)
            | (if (o.SOFTWARE == 1) @enumToInt(DXGI_ADAPTER_FLAG.SOFTWARE) else 0)
        );
    }
};
pub const DXGI_ADAPTER_FLAG_NONE = DXGI_ADAPTER_FLAG.NONE;
pub const DXGI_ADAPTER_FLAG_REMOTE = DXGI_ADAPTER_FLAG.REMOTE;
pub const DXGI_ADAPTER_FLAG_SOFTWARE = DXGI_ADAPTER_FLAG.SOFTWARE;

pub const DXGI_ADAPTER_DESC1 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
};

pub const DXGI_DISPLAY_COLOR_SPACE = extern struct {
    PrimaryCoordinates: [16]f32,
    WhitePoints: [32]f32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIFactory1_Value = @import("../zig.zig").Guid.initString("770aae78-f26f-4dba-a829-253c83d1b387");
pub const IID_IDXGIFactory1 = &IID_IDXGIFactory1_Value;
pub const IDXGIFactory1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory.VTable,
        EnumAdapters1: fn(
            self: *const IDXGIFactory1,
            Adapter: u32,
            ppAdapter: ?*?*IDXGIAdapter1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrent: fn(
            self: *const IDXGIFactory1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory1_EnumAdapters1(self: *const T, Adapter: u32, ppAdapter: ?*?*IDXGIAdapter1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory1.VTable, self.vtable).EnumAdapters1(@ptrCast(*const IDXGIFactory1, self), Adapter, ppAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory1_IsCurrent(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIFactory1.VTable, self.vtable).IsCurrent(@ptrCast(*const IDXGIFactory1, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIAdapter1_Value = @import("../zig.zig").Guid.initString("29038f61-3839-4626-91fd-086879011a05");
pub const IID_IDXGIAdapter1 = &IID_IDXGIAdapter1_Value;
pub const IDXGIAdapter1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter.VTable,
        GetDesc1: fn(
            self: *const IDXGIAdapter1,
            pDesc: ?*DXGI_ADAPTER_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter1_GetDesc1(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter1.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGIAdapter1, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIDevice1_Value = @import("../zig.zig").Guid.initString("77db970f-6276-48ba-ba28-070143b4392c");
pub const IID_IDXGIDevice1 = &IID_IDXGIDevice1_Value;
pub const IDXGIDevice1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice.VTable,
        SetMaximumFrameLatency: fn(
            self: *const IDXGIDevice1,
            MaxLatency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumFrameLatency: fn(
            self: *const IDXGIDevice1,
            pMaxLatency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice1_SetMaximumFrameLatency(self: *const T, MaxLatency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice1.VTable, self.vtable).SetMaximumFrameLatency(@ptrCast(*const IDXGIDevice1, self), MaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice1_GetMaximumFrameLatency(self: *const T, pMaxLatency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice1.VTable, self.vtable).GetMaximumFrameLatency(@ptrCast(*const IDXGIDevice1, self), pMaxLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDisplayControl_Value = @import("../zig.zig").Guid.initString("ea9dbf1a-c88e-4486-854a-98aa0138f30c");
pub const IID_IDXGIDisplayControl = &IID_IDXGIDisplayControl_Value;
pub const IDXGIDisplayControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStereoEnabled: fn(
            self: *const IDXGIDisplayControl,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetStereoEnabled: fn(
            self: *const IDXGIDisplayControl,
            enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDisplayControl_IsStereoEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIDisplayControl.VTable, self.vtable).IsStereoEnabled(@ptrCast(*const IDXGIDisplayControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDisplayControl_SetStereoEnabled(self: *const T, enabled: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDisplayControl.VTable, self.vtable).SetStereoEnabled(@ptrCast(*const IDXGIDisplayControl, self), enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_MOVE_RECT = extern struct {
    SourcePoint: POINT,
    DestinationRect: RECT,
};

pub const DXGI_OUTDUPL_DESC = extern struct {
    ModeDesc: DXGI_MODE_DESC,
    Rotation: DXGI_MODE_ROTATION,
    DesktopImageInSystemMemory: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_POSITION = extern struct {
    Position: POINT,
    Visible: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE = enum(i32) {
    MONOCHROME = 1,
    COLOR = 2,
    MASKED_COLOR = 4,
};
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MONOCHROME;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.COLOR;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MASKED_COLOR;

pub const DXGI_OUTDUPL_POINTER_SHAPE_INFO = extern struct {
    Type: u32,
    Width: u32,
    Height: u32,
    Pitch: u32,
    HotSpot: POINT,
};

pub const DXGI_OUTDUPL_FRAME_INFO = extern struct {
    LastPresentTime: LARGE_INTEGER,
    LastMouseUpdateTime: LARGE_INTEGER,
    AccumulatedFrames: u32,
    RectsCoalesced: BOOL,
    ProtectedContentMaskedOut: BOOL,
    PointerPosition: DXGI_OUTDUPL_POINTER_POSITION,
    TotalMetadataBufferSize: u32,
    PointerShapeBufferSize: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutputDuplication_Value = @import("../zig.zig").Guid.initString("191cfac3-a341-470d-b26e-a864f428319c");
pub const IID_IDXGIOutputDuplication = &IID_IDXGIOutputDuplication_Value;
pub const IDXGIOutputDuplication = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: fn(
            self: *const IDXGIOutputDuplication,
            pDesc: ?*DXGI_OUTDUPL_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        AcquireNextFrame: fn(
            self: *const IDXGIOutputDuplication,
            TimeoutInMilliseconds: u32,
            pFrameInfo: ?*DXGI_OUTDUPL_FRAME_INFO,
            ppDesktopResource: ?*?*IDXGIResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameDirtyRects: fn(
            self: *const IDXGIOutputDuplication,
            DirtyRectsBufferSize: u32,
            // TODO: what to do with BytesParamIndex 0?
            pDirtyRectsBuffer: ?*RECT,
            pDirtyRectsBufferSizeRequired: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameMoveRects: fn(
            self: *const IDXGIOutputDuplication,
            MoveRectsBufferSize: u32,
            // TODO: what to do with BytesParamIndex 0?
            pMoveRectBuffer: ?*DXGI_OUTDUPL_MOVE_RECT,
            pMoveRectsBufferSizeRequired: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFramePointerShape: fn(
            self: *const IDXGIOutputDuplication,
            PointerShapeBufferSize: u32,
            // TODO: what to do with BytesParamIndex 0?
            pPointerShapeBuffer: ?*c_void,
            pPointerShapeBufferSizeRequired: ?*u32,
            pPointerShapeInfo: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapDesktopSurface: fn(
            self: *const IDXGIOutputDuplication,
            pLockedRect: ?*DXGI_MAPPED_RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnMapDesktopSurface: fn(
            self: *const IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFrame: fn(
            self: *const IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetDesc(self: *const T, pDesc: ?*DXGI_OUTDUPL_DESC) callconv(.Inline) void {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetDesc(@ptrCast(*const IDXGIOutputDuplication, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_AcquireNextFrame(self: *const T, TimeoutInMilliseconds: u32, pFrameInfo: ?*DXGI_OUTDUPL_FRAME_INFO, ppDesktopResource: ?*?*IDXGIResource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).AcquireNextFrame(@ptrCast(*const IDXGIOutputDuplication, self), TimeoutInMilliseconds, pFrameInfo, ppDesktopResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFrameDirtyRects(self: *const T, DirtyRectsBufferSize: u32, pDirtyRectsBuffer: ?*RECT, pDirtyRectsBufferSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFrameDirtyRects(@ptrCast(*const IDXGIOutputDuplication, self), DirtyRectsBufferSize, pDirtyRectsBuffer, pDirtyRectsBufferSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFrameMoveRects(self: *const T, MoveRectsBufferSize: u32, pMoveRectBuffer: ?*DXGI_OUTDUPL_MOVE_RECT, pMoveRectsBufferSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFrameMoveRects(@ptrCast(*const IDXGIOutputDuplication, self), MoveRectsBufferSize, pMoveRectBuffer, pMoveRectsBufferSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_GetFramePointerShape(self: *const T, PointerShapeBufferSize: u32, pPointerShapeBuffer: ?*c_void, pPointerShapeBufferSizeRequired: ?*u32, pPointerShapeInfo: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).GetFramePointerShape(@ptrCast(*const IDXGIOutputDuplication, self), PointerShapeBufferSize, pPointerShapeBuffer, pPointerShapeBufferSizeRequired, pPointerShapeInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_MapDesktopSurface(self: *const T, pLockedRect: ?*DXGI_MAPPED_RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).MapDesktopSurface(@ptrCast(*const IDXGIOutputDuplication, self), pLockedRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_UnMapDesktopSurface(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).UnMapDesktopSurface(@ptrCast(*const IDXGIOutputDuplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutputDuplication_ReleaseFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutputDuplication.VTable, self.vtable).ReleaseFrame(@ptrCast(*const IDXGIOutputDuplication, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ALPHA_MODE = enum(u32) {
    UNSPECIFIED = 0,
    PREMULTIPLIED = 1,
    STRAIGHT = 2,
    IGNORE = 3,
    FORCE_DWORD = 4294967295,
};
pub const DXGI_ALPHA_MODE_UNSPECIFIED = DXGI_ALPHA_MODE.UNSPECIFIED;
pub const DXGI_ALPHA_MODE_PREMULTIPLIED = DXGI_ALPHA_MODE.PREMULTIPLIED;
pub const DXGI_ALPHA_MODE_STRAIGHT = DXGI_ALPHA_MODE.STRAIGHT;
pub const DXGI_ALPHA_MODE_IGNORE = DXGI_ALPHA_MODE.IGNORE;
pub const DXGI_ALPHA_MODE_FORCE_DWORD = DXGI_ALPHA_MODE.FORCE_DWORD;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISurface2_Value = @import("../zig.zig").Guid.initString("aba496dd-b617-4cb8-a866-bc44d7eb1fa2");
pub const IID_IDXGISurface2 = &IID_IDXGISurface2_Value;
pub const IDXGISurface2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface1.VTable,
        GetResource: fn(
            self: *const IDXGISurface2,
            riid: ?*const Guid,
            ppParentResource: ?*?*c_void,
            pSubresourceIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISurface1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISurface2_GetResource(self: *const T, riid: ?*const Guid, ppParentResource: ?*?*c_void, pSubresourceIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISurface2.VTable, self.vtable).GetResource(@ptrCast(*const IDXGISurface2, self), riid, ppParentResource, pSubresourceIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIResource1_Value = @import("../zig.zig").Guid.initString("30961379-4609-4a41-998e-54fe567ee0c1");
pub const IID_IDXGIResource1 = &IID_IDXGIResource1_Value;
pub const IDXGIResource1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIResource.VTable,
        CreateSubresourceSurface: fn(
            self: *const IDXGIResource1,
            index: u32,
            ppSurface: ?*?*IDXGISurface2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSharedHandle: fn(
            self: *const IDXGIResource1,
            pAttributes: ?*const SECURITY_ATTRIBUTES,
            dwAccess: u32,
            lpName: ?[*:0]const u16,
            pHandle: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIResource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource1_CreateSubresourceSurface(self: *const T, index: u32, ppSurface: ?*?*IDXGISurface2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource1.VTable, self.vtable).CreateSubresourceSurface(@ptrCast(*const IDXGIResource1, self), index, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIResource1_CreateSharedHandle(self: *const T, pAttributes: ?*const SECURITY_ATTRIBUTES, dwAccess: u32, lpName: ?[*:0]const u16, pHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIResource1.VTable, self.vtable).CreateSharedHandle(@ptrCast(*const IDXGIResource1, self), pAttributes, dwAccess, lpName, pHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_PRIORITY = enum(i32) {
    LOW = 1,
    NORMAL = 2,
    HIGH = 3,
};
pub const DXGI_OFFER_RESOURCE_PRIORITY_LOW = DXGI_OFFER_RESOURCE_PRIORITY.LOW;
pub const DXGI_OFFER_RESOURCE_PRIORITY_NORMAL = DXGI_OFFER_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_OFFER_RESOURCE_PRIORITY_HIGH = DXGI_OFFER_RESOURCE_PRIORITY.HIGH;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDevice2_Value = @import("../zig.zig").Guid.initString("05008617-fbfd-4051-a790-144884b4f6a9");
pub const IID_IDXGIDevice2 = &IID_IDXGIDevice2_Value;
pub const IDXGIDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice1.VTable,
        OfferResources: fn(
            self: *const IDXGIDevice2,
            NumResources: u32,
            ppResources: [*]?*IDXGIResource,
            Priority: DXGI_OFFER_RESOURCE_PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReclaimResources: fn(
            self: *const IDXGIDevice2,
            NumResources: u32,
            ppResources: [*]?*IDXGIResource,
            pDiscarded: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnqueueSetEvent: fn(
            self: *const IDXGIDevice2,
            hEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_OfferResources(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).OfferResources(@ptrCast(*const IDXGIDevice2, self), NumResources, ppResources, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_ReclaimResources(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, pDiscarded: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).ReclaimResources(@ptrCast(*const IDXGIDevice2, self), NumResources, ppResources, pDiscarded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice2_EnqueueSetEvent(self: *const T, hEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice2.VTable, self.vtable).EnqueueSetEvent(@ptrCast(*const IDXGIDevice2, self), hEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MODE_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    RefreshRate: DXGI_RATIONAL,
    Format: DXGI_FORMAT,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Stereo: BOOL,
};

pub const DXGI_SCALING = enum(i32) {
    STRETCH = 0,
    NONE = 1,
    ASPECT_RATIO_STRETCH = 2,
};
pub const DXGI_SCALING_STRETCH = DXGI_SCALING.STRETCH;
pub const DXGI_SCALING_NONE = DXGI_SCALING.NONE;
pub const DXGI_SCALING_ASPECT_RATIO_STRETCH = DXGI_SCALING.ASPECT_RATIO_STRETCH;

pub const DXGI_SWAP_CHAIN_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    Stereo: BOOL,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    Scaling: DXGI_SCALING,
    SwapEffect: DXGI_SWAP_EFFECT,
    AlphaMode: DXGI_ALPHA_MODE,
    Flags: u32,
};

pub const DXGI_SWAP_CHAIN_FULLSCREEN_DESC = extern struct {
    RefreshRate: DXGI_RATIONAL,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Windowed: BOOL,
};

pub const DXGI_PRESENT_PARAMETERS = extern struct {
    DirtyRectsCount: u32,
    pDirtyRects: ?*RECT,
    pScrollRect: ?*RECT,
    pScrollOffset: ?*POINT,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISwapChain1_Value = @import("../zig.zig").Guid.initString("790a45f7-0d42-4876-983a-0a55cfe6f4aa");
pub const IID_IDXGISwapChain1 = &IID_IDXGISwapChain1_Value;
pub const IDXGISwapChain1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain.VTable,
        GetDesc1: fn(
            self: *const IDXGISwapChain1,
            pDesc: ?*DXGI_SWAP_CHAIN_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullscreenDesc: fn(
            self: *const IDXGISwapChain1,
            pDesc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHwnd: fn(
            self: *const IDXGISwapChain1,
            pHwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCoreWindow: fn(
            self: *const IDXGISwapChain1,
            refiid: ?*const Guid,
            ppUnk: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Present1: fn(
            self: *const IDXGISwapChain1,
            SyncInterval: u32,
            PresentFlags: u32,
            pPresentParameters: ?*const DXGI_PRESENT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTemporaryMonoSupported: fn(
            self: *const IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetRestrictToOutput: fn(
            self: *const IDXGISwapChain1,
            ppRestrictToOutput: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: fn(
            self: *const IDXGISwapChain1,
            pColor: ?*const DXGI_RGBA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IDXGISwapChain1,
            pColor: ?*DXGI_RGBA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: fn(
            self: *const IDXGISwapChain1,
            Rotation: DXGI_MODE_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRotation: fn(
            self: *const IDXGISwapChain1,
            pRotation: ?*DXGI_MODE_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetDesc1(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGISwapChain1, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetFullscreenDesc(self: *const T, pDesc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetFullscreenDesc(@ptrCast(*const IDXGISwapChain1, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetHwnd(self: *const T, pHwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetHwnd(@ptrCast(*const IDXGISwapChain1, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetCoreWindow(self: *const T, refiid: ?*const Guid, ppUnk: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetCoreWindow(@ptrCast(*const IDXGISwapChain1, self), refiid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_Present1(self: *const T, SyncInterval: u32, PresentFlags: u32, pPresentParameters: ?*const DXGI_PRESENT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).Present1(@ptrCast(*const IDXGISwapChain1, self), SyncInterval, PresentFlags, pPresentParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_IsTemporaryMonoSupported(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).IsTemporaryMonoSupported(@ptrCast(*const IDXGISwapChain1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetRestrictToOutput(self: *const T, ppRestrictToOutput: ?*?*IDXGIOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetRestrictToOutput(@ptrCast(*const IDXGISwapChain1, self), ppRestrictToOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_SetBackgroundColor(self: *const T, pColor: ?*const DXGI_RGBA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IDXGISwapChain1, self), pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetBackgroundColor(self: *const T, pColor: ?*DXGI_RGBA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IDXGISwapChain1, self), pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_SetRotation(self: *const T, Rotation: DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).SetRotation(@ptrCast(*const IDXGISwapChain1, self), Rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain1_GetRotation(self: *const T, pRotation: ?*DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain1.VTable, self.vtable).GetRotation(@ptrCast(*const IDXGISwapChain1, self), pRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIFactory2_Value = @import("../zig.zig").Guid.initString("50c83a1c-e072-4c48-87b0-3630fa36a6d0");
pub const IID_IDXGIFactory2 = &IID_IDXGIFactory2_Value;
pub const IDXGIFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory1.VTable,
        IsWindowedStereoEnabled: fn(
            self: *const IDXGIFactory2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        CreateSwapChainForHwnd: fn(
            self: *const IDXGIFactory2,
            pDevice: ?*IUnknown,
            hWnd: ?HWND,
            pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
            pFullscreenDesc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
            pRestrictToOutput: ?*IDXGIOutput,
            ppSwapChain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSwapChainForCoreWindow: fn(
            self: *const IDXGIFactory2,
            pDevice: ?*IUnknown,
            pWindow: ?*IUnknown,
            pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
            pRestrictToOutput: ?*IDXGIOutput,
            ppSwapChain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSharedResourceAdapterLuid: fn(
            self: *const IDXGIFactory2,
            hResource: ?HANDLE,
            pLuid: ?*LUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterStereoStatusWindow: fn(
            self: *const IDXGIFactory2,
            WindowHandle: ?HWND,
            wMsg: u32,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterStereoStatusEvent: fn(
            self: *const IDXGIFactory2,
            hEvent: ?HANDLE,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterStereoStatus: fn(
            self: *const IDXGIFactory2,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        RegisterOcclusionStatusWindow: fn(
            self: *const IDXGIFactory2,
            WindowHandle: ?HWND,
            wMsg: u32,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterOcclusionStatusEvent: fn(
            self: *const IDXGIFactory2,
            hEvent: ?HANDLE,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterOcclusionStatus: fn(
            self: *const IDXGIFactory2,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CreateSwapChainForComposition: fn(
            self: *const IDXGIFactory2,
            pDevice: ?*IUnknown,
            pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
            pRestrictToOutput: ?*IDXGIOutput,
            ppSwapChain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_IsWindowedStereoEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).IsWindowedStereoEnabled(@ptrCast(*const IDXGIFactory2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForHwnd(self: *const T, pDevice: ?*IUnknown, hWnd: ?HWND, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pFullscreenDesc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForHwnd(@ptrCast(*const IDXGIFactory2, self), pDevice, hWnd, pDesc, pFullscreenDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForCoreWindow(self: *const T, pDevice: ?*IUnknown, pWindow: ?*IUnknown, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForCoreWindow(@ptrCast(*const IDXGIFactory2, self), pDevice, pWindow, pDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_GetSharedResourceAdapterLuid(self: *const T, hResource: ?HANDLE, pLuid: ?*LUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).GetSharedResourceAdapterLuid(@ptrCast(*const IDXGIFactory2, self), hResource, pLuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterStereoStatusWindow(self: *const T, WindowHandle: ?HWND, wMsg: u32, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterStereoStatusWindow(@ptrCast(*const IDXGIFactory2, self), WindowHandle, wMsg, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterStereoStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterStereoStatusEvent(@ptrCast(*const IDXGIFactory2, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_UnregisterStereoStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).UnregisterStereoStatus(@ptrCast(*const IDXGIFactory2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterOcclusionStatusWindow(self: *const T, WindowHandle: ?HWND, wMsg: u32, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterOcclusionStatusWindow(@ptrCast(*const IDXGIFactory2, self), WindowHandle, wMsg, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_RegisterOcclusionStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).RegisterOcclusionStatusEvent(@ptrCast(*const IDXGIFactory2, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_UnregisterOcclusionStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).UnregisterOcclusionStatus(@ptrCast(*const IDXGIFactory2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory2_CreateSwapChainForComposition(self: *const T, pDevice: ?*IUnknown, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory2.VTable, self.vtable).CreateSwapChainForComposition(@ptrCast(*const IDXGIFactory2, self), pDevice, pDesc, pRestrictToOutput, ppSwapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GRAPHICS_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    PRIMITIVE_BOUNDARY = 1,
    TRIANGLE_BOUNDARY = 2,
    PIXEL_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PRIMITIVE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.TRIANGLE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PIXEL_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_COMPUTE_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    DISPATCH_BOUNDARY = 1,
    THREAD_GROUP_BOUNDARY = 2,
    THREAD_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DISPATCH_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_GROUP_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_ADAPTER_DESC2 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIAdapter2_Value = @import("../zig.zig").Guid.initString("0aa1ae0a-fa0e-4b84-8644-e05ff8e5acb5");
pub const IID_IDXGIAdapter2 = &IID_IDXGIAdapter2_Value;
pub const IDXGIAdapter2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter1.VTable,
        GetDesc2: fn(
            self: *const IDXGIAdapter2,
            pDesc: ?*DXGI_ADAPTER_DESC2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter2_GetDesc2(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter2.VTable, self.vtable).GetDesc2(@ptrCast(*const IDXGIAdapter2, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutput1_Value = @import("../zig.zig").Guid.initString("00cddea8-939b-4b83-a340-a685226666cc");
pub const IID_IDXGIOutput1 = &IID_IDXGIOutput1_Value;
pub const IDXGIOutput1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput.VTable,
        GetDisplayModeList1: fn(
            self: *const IDXGIOutput1,
            EnumFormat: DXGI_FORMAT,
            Flags: u32,
            pNumModes: ?*u32,
            pDesc: ?[*]DXGI_MODE_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestMatchingMode1: fn(
            self: *const IDXGIOutput1,
            pModeToMatch: ?*const DXGI_MODE_DESC1,
            pClosestMatch: ?*DXGI_MODE_DESC1,
            pConcernedDevice: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplaySurfaceData1: fn(
            self: *const IDXGIOutput1,
            pDestination: ?*IDXGIResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DuplicateOutput: fn(
            self: *const IDXGIOutput1,
            pDevice: ?*IUnknown,
            ppOutputDuplication: ?*?*IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_GetDisplayModeList1(self: *const T, EnumFormat: DXGI_FORMAT, Flags: u32, pNumModes: ?*u32, pDesc: ?[*]DXGI_MODE_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).GetDisplayModeList1(@ptrCast(*const IDXGIOutput1, self), EnumFormat, Flags, pNumModes, pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_FindClosestMatchingMode1(self: *const T, pModeToMatch: ?*const DXGI_MODE_DESC1, pClosestMatch: ?*DXGI_MODE_DESC1, pConcernedDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).FindClosestMatchingMode1(@ptrCast(*const IDXGIOutput1, self), pModeToMatch, pClosestMatch, pConcernedDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_GetDisplaySurfaceData1(self: *const T, pDestination: ?*IDXGIResource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).GetDisplaySurfaceData1(@ptrCast(*const IDXGIOutput1, self), pDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput1_DuplicateOutput(self: *const T, pDevice: ?*IUnknown, ppOutputDuplication: ?*?*IDXGIOutputDuplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput1.VTable, self.vtable).DuplicateOutput(@ptrCast(*const IDXGIOutput1, self), pDevice, ppOutputDuplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDevice3_Value = @import("../zig.zig").Guid.initString("6007896c-3244-4afd-bf18-a6d3beda5023");
pub const IID_IDXGIDevice3 = &IID_IDXGIDevice3_Value;
pub const IDXGIDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice2.VTable,
        Trim: fn(
            self: *const IDXGIDevice3,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice3_Trim(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDevice3.VTable, self.vtable).Trim(@ptrCast(*const IDXGIDevice3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MATRIX_3X2_F = extern struct {
    _11: f32,
    _12: f32,
    _21: f32,
    _22: f32,
    _31: f32,
    _32: f32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChain2_Value = @import("../zig.zig").Guid.initString("a8be2ac4-199f-4946-b331-79599fb98de7");
pub const IID_IDXGISwapChain2 = &IID_IDXGISwapChain2_Value;
pub const IDXGISwapChain2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain1.VTable,
        SetSourceSize: fn(
            self: *const IDXGISwapChain2,
            Width: u32,
            Height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceSize: fn(
            self: *const IDXGISwapChain2,
            pWidth: ?*u32,
            pHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaximumFrameLatency: fn(
            self: *const IDXGISwapChain2,
            MaxLatency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumFrameLatency: fn(
            self: *const IDXGISwapChain2,
            pMaxLatency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameLatencyWaitableObject: fn(
            self: *const IDXGISwapChain2,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        SetMatrixTransform: fn(
            self: *const IDXGISwapChain2,
            pMatrix: ?*const DXGI_MATRIX_3X2_F,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMatrixTransform: fn(
            self: *const IDXGISwapChain2,
            pMatrix: ?*DXGI_MATRIX_3X2_F,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetSourceSize(self: *const T, Width: u32, Height: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetSourceSize(@ptrCast(*const IDXGISwapChain2, self), Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetSourceSize(self: *const T, pWidth: ?*u32, pHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetSourceSize(@ptrCast(*const IDXGISwapChain2, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetMaximumFrameLatency(self: *const T, MaxLatency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetMaximumFrameLatency(@ptrCast(*const IDXGISwapChain2, self), MaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetMaximumFrameLatency(self: *const T, pMaxLatency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetMaximumFrameLatency(@ptrCast(*const IDXGISwapChain2, self), pMaxLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetFrameLatencyWaitableObject(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetFrameLatencyWaitableObject(@ptrCast(*const IDXGISwapChain2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_SetMatrixTransform(self: *const T, pMatrix: ?*const DXGI_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).SetMatrixTransform(@ptrCast(*const IDXGISwapChain2, self), pMatrix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain2_GetMatrixTransform(self: *const T, pMatrix: ?*DXGI_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain2.VTable, self.vtable).GetMatrixTransform(@ptrCast(*const IDXGISwapChain2, self), pMatrix);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput2_Value = @import("../zig.zig").Guid.initString("595e39d1-2724-4663-99b1-da969de28364");
pub const IID_IDXGIOutput2 = &IID_IDXGIOutput2_Value;
pub const IDXGIOutput2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput1.VTable,
        SupportsOverlays: fn(
            self: *const IDXGIOutput2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput2_SupportsOverlays(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIOutput2.VTable, self.vtable).SupportsOverlays(@ptrCast(*const IDXGIOutput2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactory3_Value = @import("../zig.zig").Guid.initString("25483823-cd46-4c7d-86ca-47aa95b837bd");
pub const IID_IDXGIFactory3 = &IID_IDXGIFactory3_Value;
pub const IDXGIFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory2.VTable,
        GetCreationFlags: fn(
            self: *const IDXGIFactory3,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory3_GetCreationFlags(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIFactory3.VTable, self.vtable).GetCreationFlags(@ptrCast(*const IDXGIFactory3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DECODE_SWAP_CHAIN_DESC = extern struct {
    Flags: u32,
};

pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS = enum(i32) {
    NOMINAL_RANGE = 1,
    BT709 = 2,
    xvYCC = 4,
};
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_NOMINAL_RANGE = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.NOMINAL_RANGE;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_BT709 = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.BT709;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_xvYCC = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.xvYCC;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDecodeSwapChain_Value = @import("../zig.zig").Guid.initString("2633066b-4514-4c7a-8fd8-12ea98059d18");
pub const IID_IDXGIDecodeSwapChain = &IID_IDXGIDecodeSwapChain_Value;
pub const IDXGIDecodeSwapChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PresentBuffer: fn(
            self: *const IDXGIDecodeSwapChain,
            BufferToPresent: u32,
            SyncInterval: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceRect: fn(
            self: *const IDXGIDecodeSwapChain,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTargetRect: fn(
            self: *const IDXGIDecodeSwapChain,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestSize: fn(
            self: *const IDXGIDecodeSwapChain,
            Width: u32,
            Height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceRect: fn(
            self: *const IDXGIDecodeSwapChain,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetRect: fn(
            self: *const IDXGIDecodeSwapChain,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestSize: fn(
            self: *const IDXGIDecodeSwapChain,
            pWidth: ?*u32,
            pHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorSpace: fn(
            self: *const IDXGIDecodeSwapChain,
            ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorSpace: fn(
            self: *const IDXGIDecodeSwapChain,
        ) callconv(@import("std").os.windows.WINAPI) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_PresentBuffer(self: *const T, BufferToPresent: u32, SyncInterval: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).PresentBuffer(@ptrCast(*const IDXGIDecodeSwapChain, self), BufferToPresent, SyncInterval, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetSourceRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetSourceRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetTargetRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetTargetRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetDestSize(self: *const T, Width: u32, Height: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetDestSize(@ptrCast(*const IDXGIDecodeSwapChain, self), Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetSourceRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetSourceRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetTargetRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetTargetRect(@ptrCast(*const IDXGIDecodeSwapChain, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetDestSize(self: *const T, pWidth: ?*u32, pHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetDestSize(@ptrCast(*const IDXGIDecodeSwapChain, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_SetColorSpace(self: *const T, ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).SetColorSpace(@ptrCast(*const IDXGIDecodeSwapChain, self), ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDecodeSwapChain_GetColorSpace(self: *const T) callconv(.Inline) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
            return @ptrCast(*const IDXGIDecodeSwapChain.VTable, self.vtable).GetColorSpace(@ptrCast(*const IDXGIDecodeSwapChain, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactoryMedia_Value = @import("../zig.zig").Guid.initString("41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12");
pub const IID_IDXGIFactoryMedia = &IID_IDXGIFactoryMedia_Value;
pub const IDXGIFactoryMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSwapChainForCompositionSurfaceHandle: fn(
            self: *const IDXGIFactoryMedia,
            pDevice: ?*IUnknown,
            hSurface: ?HANDLE,
            pDesc: ?*const DXGI_SWAP_CHAIN_DESC1,
            pRestrictToOutput: ?*IDXGIOutput,
            ppSwapChain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDecodeSwapChainForCompositionSurfaceHandle: fn(
            self: *const IDXGIFactoryMedia,
            pDevice: ?*IUnknown,
            hSurface: ?HANDLE,
            pDesc: ?*DXGI_DECODE_SWAP_CHAIN_DESC,
            pYuvDecodeBuffers: ?*IDXGIResource,
            pRestrictToOutput: ?*IDXGIOutput,
            ppSwapChain: ?*?*IDXGIDecodeSwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactoryMedia_CreateSwapChainForCompositionSurfaceHandle(self: *const T, pDevice: ?*IUnknown, hSurface: ?HANDLE, pDesc: ?*const DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGISwapChain1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactoryMedia.VTable, self.vtable).CreateSwapChainForCompositionSurfaceHandle(@ptrCast(*const IDXGIFactoryMedia, self), pDevice, hSurface, pDesc, pRestrictToOutput, ppSwapChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactoryMedia_CreateDecodeSwapChainForCompositionSurfaceHandle(self: *const T, pDevice: ?*IUnknown, hSurface: ?HANDLE, pDesc: ?*DXGI_DECODE_SWAP_CHAIN_DESC, pYuvDecodeBuffers: ?*IDXGIResource, pRestrictToOutput: ?*IDXGIOutput, ppSwapChain: ?*?*IDXGIDecodeSwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactoryMedia.VTable, self.vtable).CreateDecodeSwapChainForCompositionSurfaceHandle(@ptrCast(*const IDXGIFactoryMedia, self), pDevice, hSurface, pDesc, pYuvDecodeBuffers, pRestrictToOutput, ppSwapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FRAME_PRESENTATION_MODE = enum(i32) {
    COMPOSED = 0,
    OVERLAY = 1,
    NONE = 2,
    COMPOSITION_FAILURE = 3,
};
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSED = DXGI_FRAME_PRESENTATION_MODE.COMPOSED;
pub const DXGI_FRAME_PRESENTATION_MODE_OVERLAY = DXGI_FRAME_PRESENTATION_MODE.OVERLAY;
pub const DXGI_FRAME_PRESENTATION_MODE_NONE = DXGI_FRAME_PRESENTATION_MODE.NONE;
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSITION_FAILURE = DXGI_FRAME_PRESENTATION_MODE.COMPOSITION_FAILURE;

pub const DXGI_FRAME_STATISTICS_MEDIA = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
    CompositionMode: DXGI_FRAME_PRESENTATION_MODE,
    ApprovedPresentDuration: u32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChainMedia_Value = @import("../zig.zig").Guid.initString("dd95b90b-f05f-4f6a-bd65-25bfb264bd84");
pub const IID_IDXGISwapChainMedia = &IID_IDXGISwapChainMedia_Value;
pub const IDXGISwapChainMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameStatisticsMedia: fn(
            self: *const IDXGISwapChainMedia,
            pStats: ?*DXGI_FRAME_STATISTICS_MEDIA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPresentDuration: fn(
            self: *const IDXGISwapChainMedia,
            Duration: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckPresentDurationSupport: fn(
            self: *const IDXGISwapChainMedia,
            DesiredPresentDuration: u32,
            pClosestSmallerPresentDuration: ?*u32,
            pClosestLargerPresentDuration: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_GetFrameStatisticsMedia(self: *const T, pStats: ?*DXGI_FRAME_STATISTICS_MEDIA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).GetFrameStatisticsMedia(@ptrCast(*const IDXGISwapChainMedia, self), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_SetPresentDuration(self: *const T, Duration: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).SetPresentDuration(@ptrCast(*const IDXGISwapChainMedia, self), Duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChainMedia_CheckPresentDurationSupport(self: *const T, DesiredPresentDuration: u32, pClosestSmallerPresentDuration: ?*u32, pClosestLargerPresentDuration: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChainMedia.VTable, self.vtable).CheckPresentDurationSupport(@ptrCast(*const IDXGISwapChainMedia, self), DesiredPresentDuration, pClosestSmallerPresentDuration, pClosestLargerPresentDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_SUPPORT_FLAG = enum(i32) {
    DIRECT = 1,
    SCALING = 2,
};
pub const DXGI_OVERLAY_SUPPORT_FLAG_DIRECT = DXGI_OVERLAY_SUPPORT_FLAG.DIRECT;
pub const DXGI_OVERLAY_SUPPORT_FLAG_SCALING = DXGI_OVERLAY_SUPPORT_FLAG.SCALING;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput3_Value = @import("../zig.zig").Guid.initString("8a6bb301-7e7e-41f4-a8e0-5b32f7f99b18");
pub const IID_IDXGIOutput3 = &IID_IDXGIOutput3_Value;
pub const IDXGIOutput3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput2.VTable,
        CheckOverlaySupport: fn(
            self: *const IDXGIOutput3,
            EnumFormat: DXGI_FORMAT,
            pConcernedDevice: ?*IUnknown,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput3_CheckOverlaySupport(self: *const T, EnumFormat: DXGI_FORMAT, pConcernedDevice: ?*IUnknown, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput3.VTable, self.vtable).CheckOverlaySupport(@ptrCast(*const IDXGIOutput3, self), EnumFormat, pConcernedDevice, pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    PRESENT = 1,
    OVERLAY_PRESENT = 2,
};
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.PRESENT;
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.OVERLAY_PRESENT;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGISwapChain3_Value = @import("../zig.zig").Guid.initString("94d99bdb-f1f8-4ab0-b236-7da0170edab1");
pub const IID_IDXGISwapChain3 = &IID_IDXGISwapChain3_Value;
pub const IDXGISwapChain3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain2.VTable,
        GetCurrentBackBufferIndex: fn(
            self: *const IDXGISwapChain3,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CheckColorSpaceSupport: fn(
            self: *const IDXGISwapChain3,
            ColorSpace: DXGI_COLOR_SPACE_TYPE,
            pColorSpaceSupport: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorSpace1: fn(
            self: *const IDXGISwapChain3,
            ColorSpace: DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBuffers1: fn(
            self: *const IDXGISwapChain3,
            BufferCount: u32,
            Width: u32,
            Height: u32,
            Format: DXGI_FORMAT,
            SwapChainFlags: u32,
            pCreationNodeMask: [*]const u32,
            ppPresentQueue: [*]?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_GetCurrentBackBufferIndex(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).GetCurrentBackBufferIndex(@ptrCast(*const IDXGISwapChain3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_CheckColorSpaceSupport(self: *const T, ColorSpace: DXGI_COLOR_SPACE_TYPE, pColorSpaceSupport: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).CheckColorSpaceSupport(@ptrCast(*const IDXGISwapChain3, self), ColorSpace, pColorSpaceSupport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_SetColorSpace1(self: *const T, ColorSpace: DXGI_COLOR_SPACE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).SetColorSpace1(@ptrCast(*const IDXGISwapChain3, self), ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain3_ResizeBuffers1(self: *const T, BufferCount: u32, Width: u32, Height: u32, Format: DXGI_FORMAT, SwapChainFlags: u32, pCreationNodeMask: [*]const u32, ppPresentQueue: [*]?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain3.VTable, self.vtable).ResizeBuffers1(@ptrCast(*const IDXGISwapChain3, self), BufferCount, Width, Height, Format, SwapChainFlags, pCreationNodeMask, ppPresentQueue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    T = 1,
};
pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG.T;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput4_Value = @import("../zig.zig").Guid.initString("dc7dca35-2196-414d-9f53-617884032a60");
pub const IID_IDXGIOutput4 = &IID_IDXGIOutput4_Value;
pub const IDXGIOutput4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput3.VTable,
        CheckOverlayColorSpaceSupport: fn(
            self: *const IDXGIOutput4,
            Format: DXGI_FORMAT,
            ColorSpace: DXGI_COLOR_SPACE_TYPE,
            pConcernedDevice: ?*IUnknown,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput4_CheckOverlayColorSpaceSupport(self: *const T, Format: DXGI_FORMAT, ColorSpace: DXGI_COLOR_SPACE_TYPE, pConcernedDevice: ?*IUnknown, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput4.VTable, self.vtable).CheckOverlayColorSpaceSupport(@ptrCast(*const IDXGIOutput4, self), Format, ColorSpace, pConcernedDevice, pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory4_Value = @import("../zig.zig").Guid.initString("1bc6ea02-ef36-464f-bf0c-21ca39e5168a");
pub const IID_IDXGIFactory4 = &IID_IDXGIFactory4_Value;
pub const IDXGIFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory3.VTable,
        EnumAdapterByLuid: fn(
            self: *const IDXGIFactory4,
            AdapterLuid: LUID,
            riid: ?*const Guid,
            ppvAdapter: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumWarpAdapter: fn(
            self: *const IDXGIFactory4,
            riid: ?*const Guid,
            ppvAdapter: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory4_EnumAdapterByLuid(self: *const T, AdapterLuid: LUID, riid: ?*const Guid, ppvAdapter: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory4.VTable, self.vtable).EnumAdapterByLuid(@ptrCast(*const IDXGIFactory4, self), AdapterLuid, riid, ppvAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory4_EnumWarpAdapter(self: *const T, riid: ?*const Guid, ppvAdapter: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory4.VTable, self.vtable).EnumWarpAdapter(@ptrCast(*const IDXGIFactory4, self), riid, ppvAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MEMORY_SEGMENT_GROUP = enum(i32) {
    LOCAL = 0,
    NON_LOCAL = 1,
};
pub const DXGI_MEMORY_SEGMENT_GROUP_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.LOCAL;
pub const DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.NON_LOCAL;

pub const DXGI_QUERY_VIDEO_MEMORY_INFO = extern struct {
    Budget: u64,
    CurrentUsage: u64,
    AvailableForReservation: u64,
    CurrentReservation: u64,
};

const IID_IDXGIAdapter3_Value = @import("../zig.zig").Guid.initString("645967a4-1392-4310-a798-8053ce3e93fd");
pub const IID_IDXGIAdapter3 = &IID_IDXGIAdapter3_Value;
pub const IDXGIAdapter3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter2.VTable,
        RegisterHardwareContentProtectionTeardownStatusEvent: fn(
            self: *const IDXGIAdapter3,
            hEvent: ?HANDLE,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterHardwareContentProtectionTeardownStatus: fn(
            self: *const IDXGIAdapter3,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        QueryVideoMemoryInfo: fn(
            self: *const IDXGIAdapter3,
            NodeIndex: u32,
            MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
            pVideoMemoryInfo: ?*DXGI_QUERY_VIDEO_MEMORY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoMemoryReservation: fn(
            self: *const IDXGIAdapter3,
            NodeIndex: u32,
            MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP,
            Reservation: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterVideoMemoryBudgetChangeNotificationEvent: fn(
            self: *const IDXGIAdapter3,
            hEvent: ?HANDLE,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterVideoMemoryBudgetChangeNotification: fn(
            self: *const IDXGIAdapter3,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).RegisterHardwareContentProtectionTeardownStatusEvent(@ptrCast(*const IDXGIAdapter3, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).UnregisterHardwareContentProtectionTeardownStatus(@ptrCast(*const IDXGIAdapter3, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_QueryVideoMemoryInfo(self: *const T, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, pVideoMemoryInfo: ?*DXGI_QUERY_VIDEO_MEMORY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).QueryVideoMemoryInfo(@ptrCast(*const IDXGIAdapter3, self), NodeIndex, MemorySegmentGroup, pVideoMemoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_SetVideoMemoryReservation(self: *const T, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, Reservation: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).SetVideoMemoryReservation(@ptrCast(*const IDXGIAdapter3, self), NodeIndex, MemorySegmentGroup, Reservation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).RegisterVideoMemoryBudgetChangeNotificationEvent(@ptrCast(*const IDXGIAdapter3, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification(self: *const T, dwCookie: u32) callconv(.Inline) void {
            return @ptrCast(*const IDXGIAdapter3.VTable, self.vtable).UnregisterVideoMemoryBudgetChangeNotification(@ptrCast(*const IDXGIAdapter3, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_FLAG = enum(i32) {
    Y = 1,
};
pub const DXGI_OUTDUPL_COMPOSITED_UI_CAPTURE_ONLY = DXGI_OUTDUPL_FLAG.Y;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput5_Value = @import("../zig.zig").Guid.initString("80a07424-ab52-42eb-833c-0c42fd282d98");
pub const IID_IDXGIOutput5 = &IID_IDXGIOutput5_Value;
pub const IDXGIOutput5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput4.VTable,
        DuplicateOutput1: fn(
            self: *const IDXGIOutput5,
            pDevice: ?*IUnknown,
            Flags: u32,
            SupportedFormatsCount: u32,
            pSupportedFormats: [*]const DXGI_FORMAT,
            ppOutputDuplication: ?*?*IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput5_DuplicateOutput1(self: *const T, pDevice: ?*IUnknown, Flags: u32, SupportedFormatsCount: u32, pSupportedFormats: [*]const DXGI_FORMAT, ppOutputDuplication: ?*?*IDXGIOutputDuplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput5.VTable, self.vtable).DuplicateOutput1(@ptrCast(*const IDXGIOutput5, self), pDevice, Flags, SupportedFormatsCount, pSupportedFormats, ppOutputDuplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_HDR_METADATA_TYPE = enum(i32) {
    NONE = 0,
    HDR10 = 1,
    HDR10PLUS = 2,
};
pub const DXGI_HDR_METADATA_TYPE_NONE = DXGI_HDR_METADATA_TYPE.NONE;
pub const DXGI_HDR_METADATA_TYPE_HDR10 = DXGI_HDR_METADATA_TYPE.HDR10;
pub const DXGI_HDR_METADATA_TYPE_HDR10PLUS = DXGI_HDR_METADATA_TYPE.HDR10PLUS;

pub const DXGI_HDR_METADATA_HDR10 = extern struct {
    RedPrimary: [2]u16,
    GreenPrimary: [2]u16,
    BluePrimary: [2]u16,
    WhitePoint: [2]u16,
    MaxMasteringLuminance: u32,
    MinMasteringLuminance: u32,
    MaxContentLightLevel: u16,
    MaxFrameAverageLightLevel: u16,
};

pub const DXGI_HDR_METADATA_HDR10PLUS = extern struct {
    Data: [72]u8,
};

const IID_IDXGISwapChain4_Value = @import("../zig.zig").Guid.initString("3d585d5a-bd4a-489e-b1f4-3dbcb6452ffb");
pub const IID_IDXGISwapChain4 = &IID_IDXGISwapChain4_Value;
pub const IDXGISwapChain4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain3.VTable,
        SetHDRMetaData: fn(
            self: *const IDXGISwapChain4,
            Type: DXGI_HDR_METADATA_TYPE,
            Size: u32,
            pMetaData: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGISwapChain3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGISwapChain4_SetHDRMetaData(self: *const T, Type: DXGI_HDR_METADATA_TYPE, Size: u32, pMetaData: ?[*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGISwapChain4.VTable, self.vtable).SetHDRMetaData(@ptrCast(*const IDXGISwapChain4, self), Type, Size, pMetaData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_FLAGS = enum(i32) {
    T = 1,
};
pub const DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT = DXGI_OFFER_RESOURCE_FLAGS.T;

pub const DXGI_RECLAIM_RESOURCE_RESULTS = enum(i32) {
    OK = 0,
    DISCARDED = 1,
    NOT_COMMITTED = 2,
};
pub const DXGI_RECLAIM_RESOURCE_RESULT_OK = DXGI_RECLAIM_RESOURCE_RESULTS.OK;
pub const DXGI_RECLAIM_RESOURCE_RESULT_DISCARDED = DXGI_RECLAIM_RESOURCE_RESULTS.DISCARDED;
pub const DXGI_RECLAIM_RESOURCE_RESULT_NOT_COMMITTED = DXGI_RECLAIM_RESOURCE_RESULTS.NOT_COMMITTED;

const IID_IDXGIDevice4_Value = @import("../zig.zig").Guid.initString("95b4f95f-d8da-4ca4-9ee6-3b76d5968a10");
pub const IID_IDXGIDevice4 = &IID_IDXGIDevice4_Value;
pub const IDXGIDevice4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice3.VTable,
        OfferResources1: fn(
            self: *const IDXGIDevice4,
            NumResources: u32,
            ppResources: [*]?*IDXGIResource,
            Priority: DXGI_OFFER_RESOURCE_PRIORITY,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReclaimResources1: fn(
            self: *const IDXGIDevice4,
            NumResources: u32,
            ppResources: [*]?*IDXGIResource,
            pResults: ?*DXGI_RECLAIM_RESOURCE_RESULTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDevice3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice4_OfferResources1(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice4.VTable, self.vtable).OfferResources1(@ptrCast(*const IDXGIDevice4, self), NumResources, ppResources, Priority, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDevice4_ReclaimResources1(self: *const T, NumResources: u32, ppResources: [*]?*IDXGIResource, pResults: ?*DXGI_RECLAIM_RESOURCE_RESULTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDevice4.VTable, self.vtable).ReclaimResources1(@ptrCast(*const IDXGIDevice4, self), NumResources, ppResources, pResults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FEATURE = enum(i32) {
    G = 0,
};
pub const DXGI_FEATURE_PRESENT_ALLOW_TEARING = DXGI_FEATURE.G;

const IID_IDXGIFactory5_Value = @import("../zig.zig").Guid.initString("7632e1f5-ee65-4dca-87fd-84cd75f8838d");
pub const IID_IDXGIFactory5 = &IID_IDXGIFactory5_Value;
pub const IDXGIFactory5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory4.VTable,
        CheckFeatureSupport: fn(
            self: *const IDXGIFactory5,
            Feature: DXGI_FEATURE,
            // TODO: what to do with BytesParamIndex 2?
            pFeatureSupportData: ?*c_void,
            FeatureSupportDataSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory5_CheckFeatureSupport(self: *const T, Feature: DXGI_FEATURE, pFeatureSupportData: ?*c_void, FeatureSupportDataSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory5.VTable, self.vtable).CheckFeatureSupport(@ptrCast(*const IDXGIFactory5, self), Feature, pFeatureSupportData, FeatureSupportDataSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG3 = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    ACG_COMPATIBLE = 4,
    SUPPORT_MONITORED_FENCES = 8,
    SUPPORT_NON_MONITORED_FENCES = 16,
    KEYED_MUTEX_CONFORMANCE = 32,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
        ACG_COMPATIBLE: u1 = 0,
        SUPPORT_MONITORED_FENCES: u1 = 0,
        SUPPORT_NON_MONITORED_FENCES: u1 = 0,
        KEYED_MUTEX_CONFORMANCE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) DXGI_ADAPTER_FLAG3 {
        return @intToEnum(DXGI_ADAPTER_FLAG3,
              (if (o.NONE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.NONE) else 0)
            | (if (o.REMOTE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.REMOTE) else 0)
            | (if (o.SOFTWARE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SOFTWARE) else 0)
            | (if (o.ACG_COMPATIBLE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE) else 0)
            | (if (o.SUPPORT_MONITORED_FENCES == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES) else 0)
            | (if (o.SUPPORT_NON_MONITORED_FENCES == 1) @enumToInt(DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES) else 0)
            | (if (o.KEYED_MUTEX_CONFORMANCE == 1) @enumToInt(DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE) else 0)
            | (if (o.FORCE_DWORD == 1) @enumToInt(DXGI_ADAPTER_FLAG3.FORCE_DWORD) else 0)
        );
    }
};
pub const DXGI_ADAPTER_FLAG3_NONE = DXGI_ADAPTER_FLAG3.NONE;
pub const DXGI_ADAPTER_FLAG3_REMOTE = DXGI_ADAPTER_FLAG3.REMOTE;
pub const DXGI_ADAPTER_FLAG3_SOFTWARE = DXGI_ADAPTER_FLAG3.SOFTWARE;
pub const DXGI_ADAPTER_FLAG3_ACG_COMPATIBLE = DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_NON_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_KEYED_MUTEX_CONFORMANCE = DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE;
pub const DXGI_ADAPTER_FLAG3_FORCE_DWORD = DXGI_ADAPTER_FLAG3.FORCE_DWORD;

pub const DXGI_ADAPTER_DESC3 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: DXGI_ADAPTER_FLAG3,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

const IID_IDXGIAdapter4_Value = @import("../zig.zig").Guid.initString("3c8d99d1-4fbf-4181-a82c-af66bf7bd24e");
pub const IID_IDXGIAdapter4 = &IID_IDXGIAdapter4_Value;
pub const IDXGIAdapter4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter3.VTable,
        GetDesc3: fn(
            self: *const IDXGIAdapter4,
            pDesc: ?*DXGI_ADAPTER_DESC3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIAdapter3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIAdapter4_GetDesc3(self: *const T, pDesc: ?*DXGI_ADAPTER_DESC3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIAdapter4.VTable, self.vtable).GetDesc3(@ptrCast(*const IDXGIAdapter4, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTPUT_DESC1 = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
    BitsPerColor: u32,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    RedPrimary: [2]f32,
    GreenPrimary: [2]f32,
    BluePrimary: [2]f32,
    WhitePoint: [2]f32,
    MinLuminance: f32,
    MaxLuminance: f32,
    MaxFullFrameLuminance: f32,
};

pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS = enum(u32) {
    FULLSCREEN = 1,
    WINDOWED = 2,
    CURSOR_STRETCHED = 4,
    _,
    pub fn initFlags(o: struct {
        FULLSCREEN: u1 = 0,
        WINDOWED: u1 = 0,
        CURSOR_STRETCHED: u1 = 0,
    }) DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS {
        return @intToEnum(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS,
              (if (o.FULLSCREEN == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN) else 0)
            | (if (o.WINDOWED == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED) else 0)
            | (if (o.CURSOR_STRETCHED == 1) @enumToInt(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED) else 0)
        );
    }
};
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_FULLSCREEN = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_WINDOWED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_CURSOR_STRETCHED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput6_Value = @import("../zig.zig").Guid.initString("068346e8-aaec-4b84-add7-137f513f77a1");
pub const IID_IDXGIOutput6 = &IID_IDXGIOutput6_Value;
pub const IDXGIOutput6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput5.VTable,
        GetDesc1: fn(
            self: *const IDXGIOutput6,
            pDesc: ?*DXGI_OUTPUT_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckHardwareCompositionSupport: fn(
            self: *const IDXGIOutput6,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIOutput5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput6_GetDesc1(self: *const T, pDesc: ?*DXGI_OUTPUT_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput6.VTable, self.vtable).GetDesc1(@ptrCast(*const IDXGIOutput6, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIOutput6_CheckHardwareCompositionSupport(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIOutput6.VTable, self.vtable).CheckHardwareCompositionSupport(@ptrCast(*const IDXGIOutput6, self), pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GPU_PREFERENCE = enum(i32) {
    UNSPECIFIED = 0,
    MINIMUM_POWER = 1,
    HIGH_PERFORMANCE = 2,
};
pub const DXGI_GPU_PREFERENCE_UNSPECIFIED = DXGI_GPU_PREFERENCE.UNSPECIFIED;
pub const DXGI_GPU_PREFERENCE_MINIMUM_POWER = DXGI_GPU_PREFERENCE.MINIMUM_POWER;
pub const DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE = DXGI_GPU_PREFERENCE.HIGH_PERFORMANCE;

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IDXGIFactory6_Value = @import("../zig.zig").Guid.initString("c1b6694f-ff09-44a9-b03c-77900a0a1d17");
pub const IID_IDXGIFactory6 = &IID_IDXGIFactory6_Value;
pub const IDXGIFactory6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory5.VTable,
        EnumAdapterByGpuPreference: fn(
            self: *const IDXGIFactory6,
            Adapter: u32,
            GpuPreference: DXGI_GPU_PREFERENCE,
            riid: ?*const Guid,
            ppvAdapter: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory6_EnumAdapterByGpuPreference(self: *const T, Adapter: u32, GpuPreference: DXGI_GPU_PREFERENCE, riid: ?*const Guid, ppvAdapter: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory6.VTable, self.vtable).EnumAdapterByGpuPreference(@ptrCast(*const IDXGIFactory6, self), Adapter, GpuPreference, riid, ppvAdapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IDXGIFactory7_Value = @import("../zig.zig").Guid.initString("a4966eed-76db-44da-84c1-ee9a7afb20a8");
pub const IID_IDXGIFactory7 = &IID_IDXGIFactory7_Value;
pub const IDXGIFactory7 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory6.VTable,
        RegisterAdaptersChangedEvent: fn(
            self: *const IDXGIFactory7,
            hEvent: ?HANDLE,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAdaptersChangedEvent: fn(
            self: *const IDXGIFactory7,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIFactory6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory7_RegisterAdaptersChangedEvent(self: *const T, hEvent: ?HANDLE, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory7.VTable, self.vtable).RegisterAdaptersChangedEvent(@ptrCast(*const IDXGIFactory7, self), hEvent, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIFactory7_UnregisterAdaptersChangedEvent(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIFactory7.VTable, self.vtable).UnregisterAdaptersChangedEvent(@ptrCast(*const IDXGIFactory7, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DEBUG_RLO_FLAGS = enum(u32) {
    SUMMARY = 1,
    DETAIL = 2,
    IGNORE_INTERNAL = 4,
    ALL = 7,
    _,
    pub fn initFlags(o: struct {
        SUMMARY: u1 = 0,
        DETAIL: u1 = 0,
        IGNORE_INTERNAL: u1 = 0,
        ALL: u1 = 0,
    }) DXGI_DEBUG_RLO_FLAGS {
        return @intToEnum(DXGI_DEBUG_RLO_FLAGS,
              (if (o.SUMMARY == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.SUMMARY) else 0)
            | (if (o.DETAIL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.DETAIL) else 0)
            | (if (o.IGNORE_INTERNAL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL) else 0)
            | (if (o.ALL == 1) @enumToInt(DXGI_DEBUG_RLO_FLAGS.ALL) else 0)
        );
    }
};
pub const DXGI_DEBUG_RLO_SUMMARY = DXGI_DEBUG_RLO_FLAGS.SUMMARY;
pub const DXGI_DEBUG_RLO_DETAIL = DXGI_DEBUG_RLO_FLAGS.DETAIL;
pub const DXGI_DEBUG_RLO_IGNORE_INTERNAL = DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL;
pub const DXGI_DEBUG_RLO_ALL = DXGI_DEBUG_RLO_FLAGS.ALL;

pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY = enum(i32) {
    UNKNOWN = 0,
    MISCELLANEOUS = 1,
    INITIALIZATION = 2,
    CLEANUP = 3,
    COMPILATION = 4,
    STATE_CREATION = 5,
    STATE_SETTING = 6,
    STATE_GETTING = 7,
    RESOURCE_MANIPULATION = 8,
    EXECUTION = 9,
    SHADER = 10,
};
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_UNKNOWN = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.UNKNOWN;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_MISCELLANEOUS = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.MISCELLANEOUS;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_INITIALIZATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.INITIALIZATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_CLEANUP = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.CLEANUP;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_COMPILATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.COMPILATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_CREATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_CREATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_SETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_SETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_GETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_GETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.RESOURCE_MANIPULATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_EXECUTION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.EXECUTION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_SHADER = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.SHADER;

pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY = enum(i32) {
    CORRUPTION = 0,
    ERROR = 1,
    WARNING = 2,
    INFO = 3,
    MESSAGE = 4,
};
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_CORRUPTION = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.CORRUPTION;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_ERROR = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.ERROR;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_WARNING = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.WARNING;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_INFO = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.INFO;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_MESSAGE = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.MESSAGE;

pub const DXGI_INFO_QUEUE_MESSAGE = extern struct {
    Producer: Guid,
    Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    ID: i32,
    pDescription: ?*const u8,
    DescriptionByteLength: usize,
};

pub const DXGI_INFO_QUEUE_FILTER_DESC = extern struct {
    NumCategories: u32,
    pCategoryList: ?*DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    NumSeverities: u32,
    pSeverityList: ?*DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    NumIDs: u32,
    pIDList: ?*i32,
};

pub const DXGI_INFO_QUEUE_FILTER = extern struct {
    AllowList: DXGI_INFO_QUEUE_FILTER_DESC,
    DenyList: DXGI_INFO_QUEUE_FILTER_DESC,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIInfoQueue_Value = @import("../zig.zig").Guid.initString("d67441c7-672a-476f-9e82-cd55b44949ce");
pub const IID_IDXGIInfoQueue = &IID_IDXGIInfoQueue_Value;
pub const IDXGIInfoQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMessageCountLimit: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            MessageCountLimit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearStoredMessages: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetMessage: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            MessageIndex: u64,
            // TODO: what to do with BytesParamIndex 3?
            pMessage: ?*DXGI_INFO_QUEUE_MESSAGE,
            pMessageByteLength: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumStoredMessagesAllowedByRetrievalFilters: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumStoredMessages: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesDiscardedByMessageCountLimit: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetMessageCountLimit: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesAllowedByStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesDeniedByStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        AddStorageFilterEntries: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            // TODO: what to do with BytesParamIndex 2?
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            pFilterByteLength: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PushEmptyStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushDenyAllStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushCopyOfStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopStorageFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetStorageFilterStackSize: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddRetrievalFilterEntries: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            // TODO: what to do with BytesParamIndex 2?
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
            pFilterByteLength: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PushEmptyRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushDenyAllRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushCopyOfRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            pFilter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopRetrievalFilter: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetRetrievalFilterStackSize: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddMessage: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            ID: i32,
            pDescription: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplicationMessage: fn(
            self: *const IDXGIInfoQueue,
            Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            pDescription: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnCategory: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            bEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnSeverity: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            bEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnID: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            ID: i32,
            bEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakOnCategory: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetBreakOnSeverity: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetBreakOnID: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            ID: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetMuteDebugOutput: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
            bMute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetMuteDebugOutput: fn(
            self: *const IDXGIInfoQueue,
            Producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetMessageCountLimit(self: *const T, Producer: Guid, MessageCountLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer, MessageCountLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearStoredMessages(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearStoredMessages(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMessage(self: *const T, Producer: Guid, MessageIndex: u64, pMessage: ?*DXGI_INFO_QUEUE_MESSAGE, pMessageByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMessage(@ptrCast(*const IDXGIInfoQueue, self), Producer, MessageIndex, pMessage, pMessageByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumStoredMessagesAllowedByRetrievalFilters(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumStoredMessagesAllowedByRetrievalFilters(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumStoredMessages(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumStoredMessages(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesDiscardedByMessageCountLimit(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesDiscardedByMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMessageCountLimit(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMessageCountLimit(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesAllowedByStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesAllowedByStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetNumMessagesDeniedByStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) u64 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetNumMessagesDeniedByStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddStorageFilterEntries(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddStorageFilterEntries(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetStorageFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushEmptyStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushEmptyStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushDenyAllStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushDenyAllStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushCopyOfStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushCopyOfStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushStorageFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PopStorageFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PopStorageFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetStorageFilterStackSize(self: *const T, Producer: Guid) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetStorageFilterStackSize(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddRetrievalFilterEntries(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddRetrievalFilterEntries(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetRetrievalFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER, pFilterByteLength: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter, pFilterByteLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_ClearRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).ClearRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushEmptyRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushEmptyRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushDenyAllRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushDenyAllRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushCopyOfRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushCopyOfRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PushRetrievalFilter(self: *const T, Producer: Guid, pFilter: ?*DXGI_INFO_QUEUE_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PushRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer, pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_PopRetrievalFilter(self: *const T, Producer: Guid) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).PopRetrievalFilter(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetRetrievalFilterStackSize(self: *const T, Producer: Guid) callconv(.Inline) u32 {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetRetrievalFilterStackSize(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddMessage(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, ID: i32, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddMessage(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category, Severity, ID, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_AddApplicationMessage(self: *const T, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, pDescription: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).AddApplicationMessage(@ptrCast(*const IDXGIInfoQueue, self), Severity, pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnCategory(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnCategory(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnSeverity(self: *const T, Producer: Guid, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnSeverity(@ptrCast(*const IDXGIInfoQueue, self), Producer, Severity, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetBreakOnID(self: *const T, Producer: Guid, ID: i32, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetBreakOnID(@ptrCast(*const IDXGIInfoQueue, self), Producer, ID, bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnCategory(self: *const T, Producer: Guid, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnCategory(@ptrCast(*const IDXGIInfoQueue, self), Producer, Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnSeverity(self: *const T, Producer: Guid, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnSeverity(@ptrCast(*const IDXGIInfoQueue, self), Producer, Severity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetBreakOnID(self: *const T, Producer: Guid, ID: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetBreakOnID(@ptrCast(*const IDXGIInfoQueue, self), Producer, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_SetMuteDebugOutput(self: *const T, Producer: Guid, bMute: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).SetMuteDebugOutput(@ptrCast(*const IDXGIInfoQueue, self), Producer, bMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIInfoQueue_GetMuteDebugOutput(self: *const T, Producer: Guid) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIInfoQueue.VTable, self.vtable).GetMuteDebugOutput(@ptrCast(*const IDXGIInfoQueue, self), Producer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDebug_Value = @import("../zig.zig").Guid.initString("119e7452-de9e-40fe-8806-88f90c12b441");
pub const IID_IDXGIDebug = &IID_IDXGIDebug_Value;
pub const IDXGIDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportLiveObjects: fn(
            self: *const IDXGIDebug,
            apiid: Guid,
            flags: DXGI_DEBUG_RLO_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug_ReportLiveObjects(self: *const T, apiid: Guid, flags: DXGI_DEBUG_RLO_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXGIDebug.VTable, self.vtable).ReportLiveObjects(@ptrCast(*const IDXGIDebug, self), apiid, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDebug1_Value = @import("../zig.zig").Guid.initString("c5a05f0c-16f2-4adf-9f4d-a8c4d58ac550");
pub const IID_IDXGIDebug1 = &IID_IDXGIDebug1_Value;
pub const IDXGIDebug1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDebug.VTable,
        EnableLeakTrackingForThread: fn(
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DisableLeakTrackingForThread: fn(
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) void,
        IsLeakTrackingEnabledForThread: fn(
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDXGIDebug.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_EnableLeakTrackingForThread(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).EnableLeakTrackingForThread(@ptrCast(*const IDXGIDebug1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_DisableLeakTrackingForThread(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).DisableLeakTrackingForThread(@ptrCast(*const IDXGIDebug1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXGIDebug1_IsLeakTrackingEnabledForThread(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDXGIDebug1.VTable, self.vtable).IsLeakTrackingEnabledForThread(@ptrCast(*const IDXGIDebug1, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "dxgi" fn CreateDXGIFactory(
    riid: ?*const Guid,
    ppFactory: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "dxgi" fn CreateDXGIFactory1(
    riid: ?*const Guid,
    ppFactory: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn CreateDXGIFactory2(
    Flags: u32,
    riid: ?*const Guid,
    ppFactory: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn DXGIGetDebugInterface1(
    Flags: u32,
    riid: ?*const Guid,
    pDebug: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "dxgi" fn DXGIDeclareAdapterRemovalSupport(
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (16)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../system/system_services.zig").LARGE_INTEGER;
const LUID = @import("../system/system_services.zig").LUID;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

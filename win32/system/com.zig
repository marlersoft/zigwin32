//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (819)
//--------------------------------------------------------------------------------
pub const CTL_E_ILLEGALFUNCTIONCALL = @as(i32, -2146828283);
pub const CONNECT_E_FIRST = @as(i32, -2147220992);
pub const SELFREG_E_FIRST = @as(i32, -2147220992);
pub const PERPROP_E_FIRST = @as(i32, -2147220992);
pub const OLECMDERR_E_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221248));
pub const OLECMDERR_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221247));
pub const OLECMDERR_E_NOHELP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221246));
pub const OLECMDERR_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221245));
pub const OLECMDERR_E_UNKNOWNGROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221244));
pub const CONNECT_E_NOCONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const CONNECT_E_ADVISELIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const CONNECT_E_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const CONNECT_E_OVERRIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const SELFREG_E_TYPELIB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const SELFREG_E_CLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const PERPROP_E_NOPAGEAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const CLSID_CFontPropPage = Guid.initString("0be35200-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_CColorPropPage = Guid.initString("0be35201-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_CPicturePropPage = Guid.initString("0be35202-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_PersistPropset = Guid.initString("fb8f0821-0164-101b-84ed-08002b2ec713");
pub const CLSID_ConvertVBX = Guid.initString("fb8f0822-0164-101b-84ed-08002b2ec713");
pub const CLSID_StdFont = Guid.initString("0be35203-8f91-11ce-9de3-00aa004bb851");
pub const CLSID_StdPicture = Guid.initString("0be35204-8f91-11ce-9de3-00aa004bb851");
pub const GUID_HIMETRIC = Guid.initString("66504300-be0f-101a-8bbb-00aa00300cab");
pub const GUID_COLOR = Guid.initString("66504301-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XPOSPIXEL = Guid.initString("66504302-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YPOSPIXEL = Guid.initString("66504303-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XSIZEPIXEL = Guid.initString("66504304-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YSIZEPIXEL = Guid.initString("66504305-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XPOS = Guid.initString("66504306-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YPOS = Guid.initString("66504307-be0f-101a-8bbb-00aa00300cab");
pub const GUID_XSIZE = Guid.initString("66504308-be0f-101a-8bbb-00aa00300cab");
pub const GUID_YSIZE = Guid.initString("66504309-be0f-101a-8bbb-00aa00300cab");
pub const GUID_TRISTATE = Guid.initString("6650430a-be0f-101a-8bbb-00aa00300cab");
pub const GUID_OPTIONVALUEEXCLUSIVE = Guid.initString("6650430b-be0f-101a-8bbb-00aa00300cab");
pub const GUID_CHECKVALUEEXCLUSIVE = Guid.initString("6650430c-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTNAME = Guid.initString("6650430d-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTSIZE = Guid.initString("6650430e-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTBOLD = Guid.initString("6650430f-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTITALIC = Guid.initString("66504310-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTUNDERSCORE = Guid.initString("66504311-be0f-101a-8bbb-00aa00300cab");
pub const GUID_FONTSTRIKETHROUGH = Guid.initString("66504312-be0f-101a-8bbb-00aa00300cab");
pub const GUID_HANDLE = Guid.initString("66504313-be0f-101a-8bbb-00aa00300cab");
pub const PICTYPE_UNINITIALIZED = @as(i32, -1);
pub const PICTYPE_NONE = @as(u32, 0);
pub const PICTYPE_BITMAP = @as(u32, 1);
pub const PICTYPE_METAFILE = @as(u32, 2);
pub const PICTYPE_ICON = @as(u32, 3);
pub const PICTYPE_ENHMETAFILE = @as(u32, 4);
pub const CONNECT_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const CONNECT_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const CONNECT_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const SELFREG_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const SELFREG_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const SELFREG_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const PERPROP_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const PERPROP_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const PERPROP_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262671));
pub const OLEIVERB_PROPERTIES = @as(i32, -7);
pub const VT_STREAMED_PROPSET = @as(u32, 73);
pub const VT_STORED_PROPSET = @as(u32, 74);
pub const VT_BLOB_PROPSET = @as(u32, 75);
pub const VT_VERBOSE_ENUM = @as(u32, 76);
pub const OCM__BASE = @as(u32, 8192);
pub const LP_DEFAULT = @as(u32, 0);
pub const LP_MONOCHROME = @as(u32, 1);
pub const LP_VGACOLOR = @as(u32, 2);
pub const LP_COLOR = @as(u32, 4);
pub const DISPID_AUTOSIZE = @as(i32, -500);
pub const DISPID_BACKCOLOR = @as(i32, -501);
pub const DISPID_BACKSTYLE = @as(i32, -502);
pub const DISPID_BORDERCOLOR = @as(i32, -503);
pub const DISPID_BORDERSTYLE = @as(i32, -504);
pub const DISPID_BORDERWIDTH = @as(i32, -505);
pub const DISPID_DRAWMODE = @as(i32, -507);
pub const DISPID_DRAWSTYLE = @as(i32, -508);
pub const DISPID_DRAWWIDTH = @as(i32, -509);
pub const DISPID_FILLCOLOR = @as(i32, -510);
pub const DISPID_FILLSTYLE = @as(i32, -511);
pub const DISPID_FONT = @as(i32, -512);
pub const DISPID_FORECOLOR = @as(i32, -513);
pub const DISPID_ENABLED = @as(i32, -514);
pub const DISPID_HWND = @as(i32, -515);
pub const DISPID_TABSTOP = @as(i32, -516);
pub const DISPID_TEXT = @as(i32, -517);
pub const DISPID_CAPTION = @as(i32, -518);
pub const DISPID_BORDERVISIBLE = @as(i32, -519);
pub const DISPID_APPEARANCE = @as(i32, -520);
pub const DISPID_MOUSEPOINTER = @as(i32, -521);
pub const DISPID_MOUSEICON = @as(i32, -522);
pub const DISPID_PICTURE = @as(i32, -523);
pub const DISPID_VALID = @as(i32, -524);
pub const DISPID_READYSTATE = @as(i32, -525);
pub const DISPID_LISTINDEX = @as(i32, -526);
pub const DISPID_SELECTED = @as(i32, -527);
pub const DISPID_LIST = @as(i32, -528);
pub const DISPID_COLUMN = @as(i32, -529);
pub const DISPID_LISTCOUNT = @as(i32, -531);
pub const DISPID_MULTISELECT = @as(i32, -532);
pub const DISPID_MAXLENGTH = @as(i32, -533);
pub const DISPID_PASSWORDCHAR = @as(i32, -534);
pub const DISPID_SCROLLBARS = @as(i32, -535);
pub const DISPID_WORDWRAP = @as(i32, -536);
pub const DISPID_MULTILINE = @as(i32, -537);
pub const DISPID_NUMBEROFROWS = @as(i32, -538);
pub const DISPID_NUMBEROFCOLUMNS = @as(i32, -539);
pub const DISPID_DISPLAYSTYLE = @as(i32, -540);
pub const DISPID_GROUPNAME = @as(i32, -541);
pub const DISPID_IMEMODE = @as(i32, -542);
pub const DISPID_ACCELERATOR = @as(i32, -543);
pub const DISPID_ENTERKEYBEHAVIOR = @as(i32, -544);
pub const DISPID_TABKEYBEHAVIOR = @as(i32, -545);
pub const DISPID_SELTEXT = @as(i32, -546);
pub const DISPID_SELSTART = @as(i32, -547);
pub const DISPID_SELLENGTH = @as(i32, -548);
pub const DISPID_REFRESH = @as(i32, -550);
pub const DISPID_DOCLICK = @as(i32, -551);
pub const DISPID_ABOUTBOX = @as(i32, -552);
pub const DISPID_ADDITEM = @as(i32, -553);
pub const DISPID_CLEAR = @as(i32, -554);
pub const DISPID_REMOVEITEM = @as(i32, -555);
pub const DISPID_CLICK = @as(i32, -600);
pub const DISPID_DBLCLICK = @as(i32, -601);
pub const DISPID_KEYDOWN = @as(i32, -602);
pub const DISPID_KEYPRESS = @as(i32, -603);
pub const DISPID_KEYUP = @as(i32, -604);
pub const DISPID_MOUSEDOWN = @as(i32, -605);
pub const DISPID_MOUSEMOVE = @as(i32, -606);
pub const DISPID_MOUSEUP = @as(i32, -607);
pub const DISPID_ERROREVENT = @as(i32, -608);
pub const DISPID_READYSTATECHANGE = @as(i32, -609);
pub const DISPID_CLICK_VALUE = @as(i32, -610);
pub const DISPID_RIGHTTOLEFT = @as(i32, -611);
pub const DISPID_TOPTOBOTTOM = @as(i32, -612);
pub const DISPID_AMBIENT_BACKCOLOR = @as(i32, -701);
pub const DISPID_AMBIENT_DISPLAYNAME = @as(i32, -702);
pub const DISPID_AMBIENT_FONT = @as(i32, -703);
pub const DISPID_AMBIENT_FORECOLOR = @as(i32, -704);
pub const DISPID_AMBIENT_LOCALEID = @as(i32, -705);
pub const DISPID_AMBIENT_MESSAGEREFLECT = @as(i32, -706);
pub const DISPID_AMBIENT_SCALEUNITS = @as(i32, -707);
pub const DISPID_AMBIENT_TEXTALIGN = @as(i32, -708);
pub const DISPID_AMBIENT_USERMODE = @as(i32, -709);
pub const DISPID_AMBIENT_UIDEAD = @as(i32, -710);
pub const DISPID_AMBIENT_SHOWGRABHANDLES = @as(i32, -711);
pub const DISPID_AMBIENT_SHOWHATCHING = @as(i32, -712);
pub const DISPID_AMBIENT_DISPLAYASDEFAULT = @as(i32, -713);
pub const DISPID_AMBIENT_SUPPORTSMNEMONICS = @as(i32, -714);
pub const DISPID_AMBIENT_AUTOCLIP = @as(i32, -715);
pub const DISPID_AMBIENT_APPEARANCE = @as(i32, -716);
pub const DISPID_AMBIENT_CODEPAGE = @as(i32, -725);
pub const DISPID_AMBIENT_PALETTE = @as(i32, -726);
pub const DISPID_AMBIENT_CHARSET = @as(i32, -727);
pub const DISPID_AMBIENT_TRANSFERPRIORITY = @as(i32, -728);
pub const DISPID_AMBIENT_RIGHTTOLEFT = @as(i32, -732);
pub const DISPID_AMBIENT_TOPTOBOTTOM = @as(i32, -733);
pub const DISPID_Name = @as(i32, -800);
pub const DISPID_Delete = @as(i32, -801);
pub const DISPID_Object = @as(i32, -802);
pub const DISPID_Parent = @as(i32, -803);
pub const DISPID_FONT_NAME = @as(u32, 0);
pub const DISPID_FONT_SIZE = @as(u32, 2);
pub const DISPID_FONT_BOLD = @as(u32, 3);
pub const DISPID_FONT_ITALIC = @as(u32, 4);
pub const DISPID_FONT_UNDER = @as(u32, 5);
pub const DISPID_FONT_STRIKE = @as(u32, 6);
pub const DISPID_FONT_WEIGHT = @as(u32, 7);
pub const DISPID_FONT_CHARSET = @as(u32, 8);
pub const DISPID_FONT_CHANGED = @as(u32, 9);
pub const DISPID_PICT_HANDLE = @as(u32, 0);
pub const DISPID_PICT_HPAL = @as(u32, 2);
pub const DISPID_PICT_TYPE = @as(u32, 3);
pub const DISPID_PICT_WIDTH = @as(u32, 4);
pub const DISPID_PICT_HEIGHT = @as(u32, 5);
pub const DISPID_PICT_RENDER = @as(u32, 6);
pub const GC_WCH_SIBLING = @as(i32, 1);
pub const TIFLAGS_EXTENDDISPATCHONLY = @as(u32, 1);
pub const OLECMD_TASKDLGID_ONBEFOREUNLOAD = @as(u32, 1);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_HWND = @as(u32, 0);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_X = @as(u32, 1);
pub const OLECMDARGINDEX_SHOWPAGEACTIONMENU_Y = @as(u32, 2);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_PUBLISHER = @as(u32, 0);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_DISPLAYNAME = @as(u32, 1);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_CLSID = @as(u32, 2);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_INSTALLSCOPE = @as(u32, 3);
pub const OLECMDARGINDEX_ACTIVEXINSTALL_SOURCEURL = @as(u32, 4);
pub const INSTALL_SCOPE_INVALID = @as(u32, 0);
pub const INSTALL_SCOPE_MACHINE = @as(u32, 1);
pub const INSTALL_SCOPE_USER = @as(u32, 2);
pub const MK_ALT = @as(u32, 32);
pub const DROPEFFECT_NONE = @as(u32, 0);
pub const DROPEFFECT_COPY = @as(u32, 1);
pub const DROPEFFECT_MOVE = @as(u32, 2);
pub const DROPEFFECT_LINK = @as(u32, 4);
pub const DROPEFFECT_SCROLL = @as(u32, 2147483648);
pub const DD_DEFSCROLLINSET = @as(u32, 11);
pub const DD_DEFSCROLLDELAY = @as(u32, 50);
pub const DD_DEFSCROLLINTERVAL = @as(u32, 50);
pub const DD_DEFDRAGDELAY = @as(u32, 200);
pub const DD_DEFDRAGMINDIST = @as(u32, 2);
pub const OT_LINK = @as(i32, 1);
pub const OT_EMBEDDED = @as(i32, 2);
pub const OT_STATIC = @as(i32, 3);
pub const OLEVERB_PRIMARY = @as(u32, 0);
pub const OF_SET = @as(u32, 1);
pub const OF_GET = @as(u32, 2);
pub const OF_HANDLER = @as(u32, 4);
pub const WIN32 = @as(u32, 100);
pub const OLEIVERB_PRIMARY = @as(i32, 0);
pub const OLEIVERB_SHOW = @as(i32, -1);
pub const OLEIVERB_OPEN = @as(i32, -2);
pub const OLEIVERB_HIDE = @as(i32, -3);
pub const OLEIVERB_UIACTIVATE = @as(i32, -4);
pub const OLEIVERB_INPLACEACTIVATE = @as(i32, -5);
pub const OLEIVERB_DISCARDUNDOSTATE = @as(i32, -6);
pub const EMBDHLP_INPROC_HANDLER = @as(i32, 0);
pub const EMBDHLP_INPROC_SERVER = @as(i32, 1);
pub const EMBDHLP_CREATENOW = @as(i32, 0);
pub const EMBDHLP_DELAYCREATE = @as(i32, 65536);
pub const OLECREATE_LEAVERUNNING = @as(u32, 1);
pub const IDC_OLEUIHELP = @as(u32, 99);
pub const IDC_IO_CREATENEW = @as(u32, 2100);
pub const IDC_IO_CREATEFROMFILE = @as(u32, 2101);
pub const IDC_IO_LINKFILE = @as(u32, 2102);
pub const IDC_IO_OBJECTTYPELIST = @as(u32, 2103);
pub const IDC_IO_DISPLAYASICON = @as(u32, 2104);
pub const IDC_IO_CHANGEICON = @as(u32, 2105);
pub const IDC_IO_FILE = @as(u32, 2106);
pub const IDC_IO_FILEDISPLAY = @as(u32, 2107);
pub const IDC_IO_RESULTIMAGE = @as(u32, 2108);
pub const IDC_IO_RESULTTEXT = @as(u32, 2109);
pub const IDC_IO_ICONDISPLAY = @as(u32, 2110);
pub const IDC_IO_OBJECTTYPETEXT = @as(u32, 2111);
pub const IDC_IO_FILETEXT = @as(u32, 2112);
pub const IDC_IO_FILETYPE = @as(u32, 2113);
pub const IDC_IO_INSERTCONTROL = @as(u32, 2114);
pub const IDC_IO_ADDCONTROL = @as(u32, 2115);
pub const IDC_IO_CONTROLTYPELIST = @as(u32, 2116);
pub const IDC_PS_PASTE = @as(u32, 500);
pub const IDC_PS_PASTELINK = @as(u32, 501);
pub const IDC_PS_SOURCETEXT = @as(u32, 502);
pub const IDC_PS_PASTELIST = @as(u32, 503);
pub const IDC_PS_PASTELINKLIST = @as(u32, 504);
pub const IDC_PS_DISPLAYLIST = @as(u32, 505);
pub const IDC_PS_DISPLAYASICON = @as(u32, 506);
pub const IDC_PS_ICONDISPLAY = @as(u32, 507);
pub const IDC_PS_CHANGEICON = @as(u32, 508);
pub const IDC_PS_RESULTIMAGE = @as(u32, 509);
pub const IDC_PS_RESULTTEXT = @as(u32, 510);
pub const IDC_CI_GROUP = @as(u32, 120);
pub const IDC_CI_CURRENT = @as(u32, 121);
pub const IDC_CI_CURRENTICON = @as(u32, 122);
pub const IDC_CI_DEFAULT = @as(u32, 123);
pub const IDC_CI_DEFAULTICON = @as(u32, 124);
pub const IDC_CI_FROMFILE = @as(u32, 125);
pub const IDC_CI_FROMFILEEDIT = @as(u32, 126);
pub const IDC_CI_ICONLIST = @as(u32, 127);
pub const IDC_CI_LABEL = @as(u32, 128);
pub const IDC_CI_LABELEDIT = @as(u32, 129);
pub const IDC_CI_BROWSE = @as(u32, 130);
pub const IDC_CI_ICONDISPLAY = @as(u32, 131);
pub const IDC_CV_OBJECTTYPE = @as(u32, 150);
pub const IDC_CV_DISPLAYASICON = @as(u32, 152);
pub const IDC_CV_CHANGEICON = @as(u32, 153);
pub const IDC_CV_ACTIVATELIST = @as(u32, 154);
pub const IDC_CV_CONVERTTO = @as(u32, 155);
pub const IDC_CV_ACTIVATEAS = @as(u32, 156);
pub const IDC_CV_RESULTTEXT = @as(u32, 157);
pub const IDC_CV_CONVERTLIST = @as(u32, 158);
pub const IDC_CV_ICONDISPLAY = @as(u32, 165);
pub const IDC_EL_CHANGESOURCE = @as(u32, 201);
pub const IDC_EL_AUTOMATIC = @as(u32, 202);
pub const IDC_EL_CANCELLINK = @as(u32, 209);
pub const IDC_EL_UPDATENOW = @as(u32, 210);
pub const IDC_EL_OPENSOURCE = @as(u32, 211);
pub const IDC_EL_MANUAL = @as(u32, 212);
pub const IDC_EL_LINKSOURCE = @as(u32, 216);
pub const IDC_EL_LINKTYPE = @as(u32, 217);
pub const IDC_EL_LINKSLISTBOX = @as(u32, 206);
pub const IDC_EL_COL1 = @as(u32, 220);
pub const IDC_EL_COL2 = @as(u32, 221);
pub const IDC_EL_COL3 = @as(u32, 222);
pub const IDC_BZ_RETRY = @as(u32, 600);
pub const IDC_BZ_ICON = @as(u32, 601);
pub const IDC_BZ_MESSAGE1 = @as(u32, 602);
pub const IDC_BZ_SWITCHTO = @as(u32, 604);
pub const IDC_UL_METER = @as(u32, 1029);
pub const IDC_UL_STOP = @as(u32, 1030);
pub const IDC_UL_PERCENT = @as(u32, 1031);
pub const IDC_UL_PROGRESS = @as(u32, 1032);
pub const IDC_PU_LINKS = @as(u32, 900);
pub const IDC_PU_TEXT = @as(u32, 901);
pub const IDC_PU_CONVERT = @as(u32, 902);
pub const IDC_PU_ICON = @as(u32, 908);
pub const IDC_GP_OBJECTNAME = @as(u32, 1009);
pub const IDC_GP_OBJECTTYPE = @as(u32, 1010);
pub const IDC_GP_OBJECTSIZE = @as(u32, 1011);
pub const IDC_GP_CONVERT = @as(u32, 1013);
pub const IDC_GP_OBJECTICON = @as(u32, 1014);
pub const IDC_GP_OBJECTLOCATION = @as(u32, 1022);
pub const IDC_VP_PERCENT = @as(u32, 1000);
pub const IDC_VP_CHANGEICON = @as(u32, 1001);
pub const IDC_VP_EDITABLE = @as(u32, 1002);
pub const IDC_VP_ASICON = @as(u32, 1003);
pub const IDC_VP_RELATIVE = @as(u32, 1005);
pub const IDC_VP_SPIN = @as(u32, 1006);
pub const IDC_VP_SCALETXT = @as(u32, 1034);
pub const IDC_VP_ICONDISPLAY = @as(u32, 1021);
pub const IDC_VP_RESULTIMAGE = @as(u32, 1033);
pub const IDC_LP_OPENSOURCE = @as(u32, 1006);
pub const IDC_LP_UPDATENOW = @as(u32, 1007);
pub const IDC_LP_BREAKLINK = @as(u32, 1008);
pub const IDC_LP_LINKSOURCE = @as(u32, 1012);
pub const IDC_LP_CHANGESOURCE = @as(u32, 1015);
pub const IDC_LP_AUTOMATIC = @as(u32, 1016);
pub const IDC_LP_MANUAL = @as(u32, 1017);
pub const IDC_LP_DATE = @as(u32, 1018);
pub const IDC_LP_TIME = @as(u32, 1019);
pub const IDD_INSERTOBJECT = @as(u32, 1000);
pub const IDD_CHANGEICON = @as(u32, 1001);
pub const IDD_CONVERT = @as(u32, 1002);
pub const IDD_PASTESPECIAL = @as(u32, 1003);
pub const IDD_EDITLINKS = @as(u32, 1004);
pub const IDD_BUSY = @as(u32, 1006);
pub const IDD_UPDATELINKS = @as(u32, 1007);
pub const IDD_CHANGESOURCE = @as(u32, 1009);
pub const IDD_INSERTFILEBROWSE = @as(u32, 1010);
pub const IDD_CHANGEICONBROWSE = @as(u32, 1011);
pub const IDD_CONVERTONLY = @as(u32, 1012);
pub const IDD_CHANGESOURCE4 = @as(u32, 1013);
pub const IDD_GNRLPROPS = @as(u32, 1100);
pub const IDD_VIEWPROPS = @as(u32, 1101);
pub const IDD_LINKPROPS = @as(u32, 1102);
pub const IDD_CONVERT4 = @as(u32, 1103);
pub const IDD_CONVERTONLY4 = @as(u32, 1104);
pub const IDD_EDITLINKS4 = @as(u32, 1105);
pub const IDD_GNRLPROPS4 = @as(u32, 1106);
pub const IDD_LINKPROPS4 = @as(u32, 1107);
pub const IDD_PASTESPECIAL4 = @as(u32, 1108);
pub const IDD_CANNOTUPDATELINK = @as(u32, 1008);
pub const IDD_LINKSOURCEUNAVAILABLE = @as(u32, 1020);
pub const IDD_SERVERNOTFOUND = @as(u32, 1023);
pub const IDD_OUTOFMEMORY = @as(u32, 1024);
pub const IDD_SERVERNOTREGW = @as(u32, 1021);
pub const IDD_LINKTYPECHANGEDW = @as(u32, 1022);
pub const IDD_SERVERNOTREGA = @as(u32, 1025);
pub const IDD_LINKTYPECHANGEDA = @as(u32, 1026);
pub const ID_BROWSE_CHANGEICON = @as(u32, 1);
pub const ID_BROWSE_INSERTFILE = @as(u32, 2);
pub const ID_BROWSE_ADDCONTROL = @as(u32, 3);
pub const ID_BROWSE_CHANGESOURCE = @as(u32, 4);
pub const OLEUI_FALSE = @as(u32, 0);
pub const OLEUI_SUCCESS = @as(u32, 1);
pub const OLEUI_OK = @as(u32, 1);
pub const OLEUI_CANCEL = @as(u32, 2);
pub const OLEUI_ERR_STANDARDMIN = @as(u32, 100);
pub const OLEUI_ERR_OLEMEMALLOC = @as(u32, 100);
pub const OLEUI_ERR_STRUCTURENULL = @as(u32, 101);
pub const OLEUI_ERR_STRUCTUREINVALID = @as(u32, 102);
pub const OLEUI_ERR_CBSTRUCTINCORRECT = @as(u32, 103);
pub const OLEUI_ERR_HWNDOWNERINVALID = @as(u32, 104);
pub const OLEUI_ERR_LPSZCAPTIONINVALID = @as(u32, 105);
pub const OLEUI_ERR_LPFNHOOKINVALID = @as(u32, 106);
pub const OLEUI_ERR_HINSTANCEINVALID = @as(u32, 107);
pub const OLEUI_ERR_LPSZTEMPLATEINVALID = @as(u32, 108);
pub const OLEUI_ERR_HRESOURCEINVALID = @as(u32, 109);
pub const OLEUI_ERR_FINDTEMPLATEFAILURE = @as(u32, 110);
pub const OLEUI_ERR_LOADTEMPLATEFAILURE = @as(u32, 111);
pub const OLEUI_ERR_DIALOGFAILURE = @as(u32, 112);
pub const OLEUI_ERR_LOCALMEMALLOC = @as(u32, 113);
pub const OLEUI_ERR_GLOBALMEMALLOC = @as(u32, 114);
pub const OLEUI_ERR_LOADSTRING = @as(u32, 115);
pub const OLEUI_ERR_STANDARDMAX = @as(u32, 116);
pub const IOF_SHOWHELP = @as(i32, 1);
pub const IOF_SELECTCREATENEW = @as(i32, 2);
pub const IOF_SELECTCREATEFROMFILE = @as(i32, 4);
pub const IOF_CHECKLINK = @as(i32, 8);
pub const IOF_CHECKDISPLAYASICON = @as(i32, 16);
pub const IOF_CREATENEWOBJECT = @as(i32, 32);
pub const IOF_CREATEFILEOBJECT = @as(i32, 64);
pub const IOF_CREATELINKOBJECT = @as(i32, 128);
pub const IOF_DISABLELINK = @as(i32, 256);
pub const IOF_VERIFYSERVERSEXIST = @as(i32, 512);
pub const IOF_DISABLEDISPLAYASICON = @as(i32, 1024);
pub const IOF_HIDECHANGEICON = @as(i32, 2048);
pub const IOF_SHOWINSERTCONTROL = @as(i32, 4096);
pub const IOF_SELECTCREATECONTROL = @as(i32, 8192);
pub const OLEUI_IOERR_LPSZFILEINVALID = @as(u32, 116);
pub const OLEUI_IOERR_LPSZLABELINVALID = @as(u32, 117);
pub const OLEUI_IOERR_HICONINVALID = @as(u32, 118);
pub const OLEUI_IOERR_LPFORMATETCINVALID = @as(u32, 119);
pub const OLEUI_IOERR_PPVOBJINVALID = @as(u32, 120);
pub const OLEUI_IOERR_LPIOLECLIENTSITEINVALID = @as(u32, 121);
pub const OLEUI_IOERR_LPISTORAGEINVALID = @as(u32, 122);
pub const OLEUI_IOERR_SCODEHASERROR = @as(u32, 123);
pub const OLEUI_IOERR_LPCLSIDEXCLUDEINVALID = @as(u32, 124);
pub const OLEUI_IOERR_CCHFILEINVALID = @as(u32, 125);
pub const PS_MAXLINKTYPES = @as(u32, 8);
pub const PSF_SHOWHELP = @as(i32, 1);
pub const PSF_SELECTPASTE = @as(i32, 2);
pub const PSF_SELECTPASTELINK = @as(i32, 4);
pub const PSF_CHECKDISPLAYASICON = @as(i32, 8);
pub const PSF_DISABLEDISPLAYASICON = @as(i32, 16);
pub const PSF_HIDECHANGEICON = @as(i32, 32);
pub const PSF_STAYONCLIPBOARDCHANGE = @as(i32, 64);
pub const PSF_NOREFRESHDATAOBJECT = @as(i32, 128);
pub const OLEUI_IOERR_SRCDATAOBJECTINVALID = @as(u32, 116);
pub const OLEUI_IOERR_ARRPASTEENTRIESINVALID = @as(u32, 117);
pub const OLEUI_IOERR_ARRLINKTYPESINVALID = @as(u32, 118);
pub const OLEUI_PSERR_CLIPBOARDCHANGED = @as(u32, 119);
pub const OLEUI_PSERR_GETCLIPBOARDFAILED = @as(u32, 120);
pub const OLEUI_ELERR_LINKCNTRNULL = @as(u32, 116);
pub const OLEUI_ELERR_LINKCNTRINVALID = @as(u32, 117);
pub const ELF_SHOWHELP = @as(i32, 1);
pub const ELF_DISABLEUPDATENOW = @as(i32, 2);
pub const ELF_DISABLEOPENSOURCE = @as(i32, 4);
pub const ELF_DISABLECHANGESOURCE = @as(i32, 8);
pub const ELF_DISABLECANCELLINK = @as(i32, 16);
pub const CIF_SHOWHELP = @as(i32, 1);
pub const CIF_SELECTCURRENT = @as(i32, 2);
pub const CIF_SELECTDEFAULT = @as(i32, 4);
pub const CIF_SELECTFROMFILE = @as(i32, 8);
pub const CIF_USEICONEXE = @as(i32, 16);
pub const OLEUI_CIERR_MUSTHAVECLSID = @as(u32, 116);
pub const OLEUI_CIERR_MUSTHAVECURRENTMETAFILE = @as(u32, 117);
pub const OLEUI_CIERR_SZICONEXEINVALID = @as(u32, 118);
pub const CF_SHOWHELPBUTTON = @as(i32, 1);
pub const CF_SETCONVERTDEFAULT = @as(i32, 2);
pub const CF_SETACTIVATEDEFAULT = @as(i32, 4);
pub const CF_SELECTCONVERTTO = @as(i32, 8);
pub const CF_SELECTACTIVATEAS = @as(i32, 16);
pub const CF_DISABLEDISPLAYASICON = @as(i32, 32);
pub const CF_DISABLEACTIVATEAS = @as(i32, 64);
pub const CF_HIDECHANGEICON = @as(i32, 128);
pub const CF_CONVERTONLY = @as(i32, 256);
pub const OLEUI_CTERR_CLASSIDINVALID = @as(u32, 117);
pub const OLEUI_CTERR_DVASPECTINVALID = @as(u32, 118);
pub const OLEUI_CTERR_CBFORMATINVALID = @as(u32, 119);
pub const OLEUI_CTERR_HMETAPICTINVALID = @as(u32, 120);
pub const OLEUI_CTERR_STRINGINVALID = @as(u32, 121);
pub const BZ_DISABLECANCELBUTTON = @as(i32, 1);
pub const BZ_DISABLESWITCHTOBUTTON = @as(i32, 2);
pub const BZ_DISABLERETRYBUTTON = @as(i32, 4);
pub const BZ_NOTRESPONDINGDIALOG = @as(i32, 8);
pub const OLEUI_BZERR_HTASKINVALID = @as(u32, 116);
pub const OLEUI_BZ_SWITCHTOSELECTED = @as(u32, 117);
pub const OLEUI_BZ_RETRYSELECTED = @as(u32, 118);
pub const OLEUI_BZ_CALLUNBLOCKED = @as(u32, 119);
pub const CSF_SHOWHELP = @as(i32, 1);
pub const CSF_VALIDSOURCE = @as(i32, 2);
pub const CSF_ONLYGETSOURCE = @as(i32, 4);
pub const CSF_EXPLORER = @as(i32, 8);
pub const OLEUI_CSERR_LINKCNTRNULL = @as(u32, 116);
pub const OLEUI_CSERR_LINKCNTRINVALID = @as(u32, 117);
pub const OLEUI_CSERR_FROMNOTNULL = @as(u32, 118);
pub const OLEUI_CSERR_TONOTNULL = @as(u32, 119);
pub const OLEUI_CSERR_SOURCENULL = @as(u32, 120);
pub const OLEUI_CSERR_SOURCEINVALID = @as(u32, 121);
pub const OLEUI_CSERR_SOURCEPARSERROR = @as(u32, 122);
pub const OLEUI_CSERR_SOURCEPARSEERROR = @as(u32, 122);
pub const VPF_SELECTRELATIVE = @as(i32, 1);
pub const VPF_DISABLERELATIVE = @as(i32, 2);
pub const VPF_DISABLESCALE = @as(i32, 4);
pub const OPF_OBJECTISLINK = @as(i32, 1);
pub const OPF_NOFILLDEFAULT = @as(i32, 2);
pub const OPF_SHOWHELP = @as(i32, 4);
pub const OPF_DISABLECONVERT = @as(i32, 8);
pub const OLEUI_OPERR_SUBPROPNULL = @as(u32, 116);
pub const OLEUI_OPERR_SUBPROPINVALID = @as(u32, 117);
pub const OLEUI_OPERR_PROPSHEETNULL = @as(u32, 118);
pub const OLEUI_OPERR_PROPSHEETINVALID = @as(u32, 119);
pub const OLEUI_OPERR_SUPPROP = @as(u32, 120);
pub const OLEUI_OPERR_PROPSINVALID = @as(u32, 121);
pub const OLEUI_OPERR_PAGESINCORRECT = @as(u32, 122);
pub const OLEUI_OPERR_INVALIDPAGES = @as(u32, 123);
pub const OLEUI_OPERR_NOTSUPPORTED = @as(u32, 124);
pub const OLEUI_OPERR_DLGPROCNOTNULL = @as(u32, 125);
pub const OLEUI_OPERR_LPARAMNOTZERO = @as(u32, 126);
pub const OLEUI_GPERR_STRINGINVALID = @as(u32, 127);
pub const OLEUI_GPERR_CLASSIDINVALID = @as(u32, 128);
pub const OLEUI_GPERR_LPCLSIDEXCLUDEINVALID = @as(u32, 129);
pub const OLEUI_GPERR_CBFORMATINVALID = @as(u32, 130);
pub const OLEUI_VPERR_METAPICTINVALID = @as(u32, 131);
pub const OLEUI_VPERR_DVASPECTINVALID = @as(u32, 132);
pub const OLEUI_LPERR_LINKCNTRNULL = @as(u32, 133);
pub const OLEUI_LPERR_LINKCNTRINVALID = @as(u32, 134);
pub const OLEUI_OPERR_PROPERTYSHEET = @as(u32, 135);
pub const OLEUI_OPERR_OBJINFOINVALID = @as(u32, 136);
pub const OLEUI_OPERR_LINKINFOINVALID = @as(u32, 137);
pub const OLEUI_QUERY_GETCLASSID = @as(u32, 65280);
pub const OLEUI_QUERY_LINKBROKEN = @as(u32, 65281);
pub const MKSYS_URLMONIKER = @as(u32, 6);
pub const URL_MK_LEGACY = @as(u32, 0);
pub const URL_MK_UNIFORM = @as(u32, 1);
pub const URL_MK_NO_CANONICALIZE = @as(u32, 2);
pub const FIEF_FLAG_FORCE_JITUI = @as(u32, 1);
pub const FIEF_FLAG_PEEK = @as(u32, 2);
pub const FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK = @as(u32, 4);
pub const FIEF_FLAG_RESERVED_0 = @as(u32, 8);
pub const FMFD_DEFAULT = @as(u32, 0);
pub const FMFD_URLASFILENAME = @as(u32, 1);
pub const FMFD_ENABLEMIMESNIFFING = @as(u32, 2);
pub const FMFD_IGNOREMIMETEXTPLAIN = @as(u32, 4);
pub const FMFD_SERVERMIME = @as(u32, 8);
pub const FMFD_RESPECTTEXTPLAIN = @as(u32, 16);
pub const FMFD_RETURNUPDATEDIMGMIMES = @as(u32, 32);
pub const FMFD_RESERVED_1 = @as(u32, 64);
pub const UAS_EXACTLEGACY = @as(u32, 4096);
pub const URLMON_OPTION_USERAGENT = @as(u32, 268435457);
pub const URLMON_OPTION_USERAGENT_REFRESH = @as(u32, 268435458);
pub const URLMON_OPTION_URL_ENCODING = @as(u32, 268435460);
pub const URLMON_OPTION_USE_BINDSTRINGCREDS = @as(u32, 268435464);
pub const URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS = @as(u32, 268435472);
pub const CF_NULL = @as(u32, 0);
pub const MK_S_ASYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262632));
pub const E_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483638));
pub const INET_E_INVALID_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697214));
pub const INET_E_NO_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697213));
pub const INET_E_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697212));
pub const INET_E_RESOURCE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697211));
pub const INET_E_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697210));
pub const INET_E_DATA_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697209));
pub const INET_E_DOWNLOAD_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697208));
pub const INET_E_AUTHENTICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697207));
pub const INET_E_NO_VALID_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697206));
pub const INET_E_CONNECTION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697205));
pub const INET_E_INVALID_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697204));
pub const INET_E_UNKNOWN_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697203));
pub const INET_E_SECURITY_PROBLEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697202));
pub const INET_E_CANNOT_LOAD_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697201));
pub const INET_E_CANNOT_INSTANTIATE_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697200));
pub const INET_E_INVALID_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697191));
pub const INET_E_REDIRECT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697196));
pub const INET_E_REDIRECT_TO_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697195));
pub const INET_E_CANNOT_LOCK_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697194));
pub const INET_E_USE_EXTEND_BINDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697193));
pub const INET_E_TERMINATED_BIND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697192));
pub const INET_E_RESERVED_1 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697190));
pub const INET_E_BLOCKED_REDIRECT_XSECURITYID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697189));
pub const INET_E_DOMINJECTIONVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697188));
pub const INET_E_VTAB_SWITCH_FORCE_ENGINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697187));
pub const INET_E_HSTS_CERTIFICATE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697186));
pub const INET_E_RESERVED_2 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697185));
pub const INET_E_RESERVED_3 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697184));
pub const INET_E_RESERVED_4 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697183));
pub const INET_E_RESERVED_5 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697182));
pub const INET_E_ERROR_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697214));
pub const INET_E_CODE_DOWNLOAD_DECLINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146696960));
pub const INET_E_RESULT_DISPATCHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146696704));
pub const INET_E_CANNOT_REPLACE_SFP_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146696448));
pub const INET_E_CODE_INSTALL_SUPPRESSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146696192));
pub const INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695936));
pub const INET_E_DOWNLOAD_BLOCKED_BY_INPRIVATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695935));
pub const INET_E_CODE_INSTALL_BLOCKED_IMMERSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695934));
pub const INET_E_FORBIDFRAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695933));
pub const INET_E_CODE_INSTALL_BLOCKED_ARM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695932));
pub const INET_E_BLOCKED_PLUGGABLE_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695931));
pub const INET_E_BLOCKED_ENHANCEDPROTECTEDMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695930));
pub const INET_E_CODE_INSTALL_BLOCKED_BITNESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695929));
pub const INET_E_DOWNLOAD_BLOCKED_BY_CSP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146695928));
pub const Uri_DISPLAY_NO_FRAGMENT = @as(u32, 1);
pub const Uri_PUNYCODE_IDN_HOST = @as(u32, 2);
pub const Uri_DISPLAY_IDN_HOST = @as(u32, 4);
pub const Uri_DISPLAY_NO_PUNYCODE = @as(u32, 8);
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 = @as(u32, 1);
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_CP = @as(u32, 2);
pub const Uri_ENCODING_HOST_IS_IDN = @as(u32, 4);
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 = @as(u32, 8);
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP = @as(u32, 16);
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8 = @as(u32, 32);
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP = @as(u32, 64);
pub const UriBuilder_USE_ORIGINAL_FLAGS = @as(u32, 1);
pub const WININETINFO_OPTION_LOCK_HANDLE = @as(u32, 65534);
pub const URLOSTRM_USECACHEDCOPY_ONLY = @as(u32, 1);
pub const URLOSTRM_USECACHEDCOPY = @as(u32, 2);
pub const URLOSTRM_GETNEWESTVERSION = @as(u32, 3);
pub const SET_FEATURE_ON_THREAD = @as(u32, 1);
pub const SET_FEATURE_ON_PROCESS = @as(u32, 2);
pub const SET_FEATURE_IN_REGISTRY = @as(u32, 4);
pub const SET_FEATURE_ON_THREAD_LOCALMACHINE = @as(u32, 8);
pub const SET_FEATURE_ON_THREAD_INTRANET = @as(u32, 16);
pub const SET_FEATURE_ON_THREAD_TRUSTED = @as(u32, 32);
pub const SET_FEATURE_ON_THREAD_INTERNET = @as(u32, 64);
pub const SET_FEATURE_ON_THREAD_RESTRICTED = @as(u32, 128);
pub const GET_FEATURE_FROM_THREAD = @as(u32, 1);
pub const GET_FEATURE_FROM_PROCESS = @as(u32, 2);
pub const GET_FEATURE_FROM_REGISTRY = @as(u32, 4);
pub const GET_FEATURE_FROM_THREAD_LOCALMACHINE = @as(u32, 8);
pub const GET_FEATURE_FROM_THREAD_INTRANET = @as(u32, 16);
pub const GET_FEATURE_FROM_THREAD_TRUSTED = @as(u32, 32);
pub const GET_FEATURE_FROM_THREAD_INTERNET = @as(u32, 64);
pub const GET_FEATURE_FROM_THREAD_RESTRICTED = @as(u32, 128);
pub const INET_E_USE_DEFAULT_PROTOCOLHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697199));
pub const INET_E_USE_DEFAULT_SETTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697198));
pub const INET_E_QUERYOPTION_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697197));
pub const INET_E_REDIRECTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697196));
pub const PROTOCOLFLAG_NO_PICS_CHECK = @as(u32, 1);
pub const MUTZ_NOSAVEDFILECHECK = @as(u32, 1);
pub const MUTZ_ISFILE = @as(u32, 2);
pub const MUTZ_ACCEPT_WILDCARD_SCHEME = @as(u32, 128);
pub const MUTZ_ENFORCERESTRICTED = @as(u32, 256);
pub const MUTZ_RESERVED = @as(u32, 512);
pub const MUTZ_REQUIRESAVEDFILECHECK = @as(u32, 1024);
pub const MUTZ_DONT_UNESCAPE = @as(u32, 2048);
pub const MUTZ_DONT_USE_CACHE = @as(u32, 4096);
pub const MUTZ_FORCE_INTRANET_FLAGS = @as(u32, 8192);
pub const MUTZ_IGNORE_ZONE_MAPPINGS = @as(u32, 16384);
pub const MAX_SIZE_SECURITY_ID = @as(u32, 512);
pub const URLACTION_MIN = @as(u32, 4096);
pub const URLACTION_DOWNLOAD_MIN = @as(u32, 4096);
pub const URLACTION_DOWNLOAD_SIGNED_ACTIVEX = @as(u32, 4097);
pub const URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX = @as(u32, 4100);
pub const URLACTION_DOWNLOAD_CURR_MAX = @as(u32, 4100);
pub const URLACTION_DOWNLOAD_MAX = @as(u32, 4607);
pub const URLACTION_ACTIVEX_MIN = @as(u32, 4608);
pub const URLACTION_ACTIVEX_RUN = @as(u32, 4608);
pub const URLPOLICY_ACTIVEX_CHECK_LIST = @as(u32, 65536);
pub const URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY = @as(u32, 4609);
pub const URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY = @as(u32, 4610);
pub const URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY = @as(u32, 4611);
pub const URLACTION_SCRIPT_OVERRIDE_SAFETY = @as(u32, 5121);
pub const URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY = @as(u32, 4612);
pub const URLACTION_ACTIVEX_TREATASUNTRUSTED = @as(u32, 4613);
pub const URLACTION_ACTIVEX_NO_WEBOC_SCRIPT = @as(u32, 4614);
pub const URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION = @as(u32, 4615);
pub const URLACTION_ACTIVEX_OVERRIDE_OPTIN = @as(u32, 4616);
pub const URLACTION_ACTIVEX_SCRIPTLET_RUN = @as(u32, 4617);
pub const URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION = @as(u32, 4618);
pub const URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST = @as(u32, 4619);
pub const URLACTION_ACTIVEX_ALLOW_TDC = @as(u32, 4620);
pub const URLACTION_ACTIVEX_CURR_MAX = @as(u32, 4620);
pub const URLACTION_ACTIVEX_MAX = @as(u32, 5119);
pub const URLACTION_SCRIPT_MIN = @as(u32, 5120);
pub const URLACTION_SCRIPT_RUN = @as(u32, 5120);
pub const URLACTION_SCRIPT_JAVA_USE = @as(u32, 5122);
pub const URLACTION_SCRIPT_SAFE_ACTIVEX = @as(u32, 5125);
pub const URLACTION_CROSS_DOMAIN_DATA = @as(u32, 5126);
pub const URLACTION_SCRIPT_PASTE = @as(u32, 5127);
pub const URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE = @as(u32, 5128);
pub const URLACTION_SCRIPT_XSSFILTER = @as(u32, 5129);
pub const URLACTION_SCRIPT_NAVIGATE = @as(u32, 5130);
pub const URLACTION_PLUGGABLE_PROTOCOL_XHR = @as(u32, 5131);
pub const URLACTION_ALLOW_VBSCRIPT_IE = @as(u32, 5132);
pub const URLACTION_SCRIPT_CURR_MAX = @as(u32, 5132);
pub const URLACTION_SCRIPT_MAX = @as(u32, 5631);
pub const URLACTION_HTML_MIN = @as(u32, 5632);
pub const URLACTION_HTML_SUBMIT_FORMS = @as(u32, 5633);
pub const URLACTION_HTML_SUBMIT_FORMS_FROM = @as(u32, 5634);
pub const URLACTION_HTML_SUBMIT_FORMS_TO = @as(u32, 5635);
pub const URLACTION_HTML_FONT_DOWNLOAD = @as(u32, 5636);
pub const URLACTION_HTML_JAVA_RUN = @as(u32, 5637);
pub const URLACTION_HTML_USERDATA_SAVE = @as(u32, 5638);
pub const URLACTION_HTML_SUBFRAME_NAVIGATE = @as(u32, 5639);
pub const URLACTION_HTML_META_REFRESH = @as(u32, 5640);
pub const URLACTION_HTML_MIXED_CONTENT = @as(u32, 5641);
pub const URLACTION_HTML_INCLUDE_FILE_PATH = @as(u32, 5642);
pub const URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML = @as(u32, 5643);
pub const URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE = @as(u32, 5644);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS = @as(u32, 5645);
pub const URLACTION_HTML_ALLOW_WINDOW_CLOSE = @as(u32, 5646);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER = @as(u32, 5647);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK = @as(u32, 5648);
pub const URLACTION_HTML_ALLOW_INDEXEDDB = @as(u32, 5649);
pub const URLACTION_HTML_MAX = @as(u32, 6143);
pub const URLACTION_SHELL_MIN = @as(u32, 6144);
pub const URLACTION_SHELL_INSTALL_DTITEMS = @as(u32, 6144);
pub const URLACTION_SHELL_MOVE_OR_COPY = @as(u32, 6146);
pub const URLACTION_SHELL_FILE_DOWNLOAD = @as(u32, 6147);
pub const URLACTION_SHELL_VERB = @as(u32, 6148);
pub const URLACTION_SHELL_WEBVIEW_VERB = @as(u32, 6149);
pub const URLACTION_SHELL_SHELLEXECUTE = @as(u32, 6150);
pub const URLACTION_SHELL_EXECUTE_HIGHRISK = @as(u32, 6150);
pub const URLACTION_SHELL_EXECUTE_MODRISK = @as(u32, 6151);
pub const URLACTION_SHELL_EXECUTE_LOWRISK = @as(u32, 6152);
pub const URLACTION_SHELL_POPUPMGR = @as(u32, 6153);
pub const URLACTION_SHELL_RTF_OBJECTS_LOAD = @as(u32, 6154);
pub const URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY = @as(u32, 6155);
pub const URLACTION_SHELL_EXTENSIONSECURITY = @as(u32, 6156);
pub const URLACTION_SHELL_SECURE_DRAGSOURCE = @as(u32, 6157);
pub const URLACTION_SHELL_REMOTEQUERY = @as(u32, 6158);
pub const URLACTION_SHELL_PREVIEW = @as(u32, 6159);
pub const URLACTION_SHELL_SHARE = @as(u32, 6160);
pub const URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE = @as(u32, 6161);
pub const URLACTION_SHELL_TOCTOU_RISK = @as(u32, 6162);
pub const URLACTION_SHELL_CURR_MAX = @as(u32, 6162);
pub const URLACTION_SHELL_MAX = @as(u32, 6655);
pub const URLACTION_NETWORK_MIN = @as(u32, 6656);
pub const URLACTION_CREDENTIALS_USE = @as(u32, 6656);
pub const URLPOLICY_CREDENTIALS_SILENT_LOGON_OK = @as(u32, 0);
pub const URLPOLICY_CREDENTIALS_MUST_PROMPT_USER = @as(u32, 65536);
pub const URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT = @as(u32, 131072);
pub const URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY = @as(u32, 196608);
pub const URLACTION_AUTHENTICATE_CLIENT = @as(u32, 6657);
pub const URLPOLICY_AUTHENTICATE_CLEARTEXT_OK = @as(u32, 0);
pub const URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE = @as(u32, 65536);
pub const URLPOLICY_AUTHENTICATE_MUTUAL_ONLY = @as(u32, 196608);
pub const URLACTION_COOKIES = @as(u32, 6658);
pub const URLACTION_COOKIES_SESSION = @as(u32, 6659);
pub const URLACTION_CLIENT_CERT_PROMPT = @as(u32, 6660);
pub const URLACTION_COOKIES_THIRD_PARTY = @as(u32, 6661);
pub const URLACTION_COOKIES_SESSION_THIRD_PARTY = @as(u32, 6662);
pub const URLACTION_COOKIES_ENABLED = @as(u32, 6672);
pub const URLACTION_NETWORK_CURR_MAX = @as(u32, 6672);
pub const URLACTION_NETWORK_MAX = @as(u32, 7167);
pub const URLACTION_JAVA_MIN = @as(u32, 7168);
pub const URLACTION_JAVA_PERMISSIONS = @as(u32, 7168);
pub const URLPOLICY_JAVA_PROHIBIT = @as(u32, 0);
pub const URLPOLICY_JAVA_HIGH = @as(u32, 65536);
pub const URLPOLICY_JAVA_MEDIUM = @as(u32, 131072);
pub const URLPOLICY_JAVA_LOW = @as(u32, 196608);
pub const URLPOLICY_JAVA_CUSTOM = @as(u32, 8388608);
pub const URLACTION_JAVA_CURR_MAX = @as(u32, 7168);
pub const URLACTION_JAVA_MAX = @as(u32, 7423);
pub const URLACTION_INFODELIVERY_MIN = @as(u32, 7424);
pub const URLACTION_INFODELIVERY_NO_ADDING_CHANNELS = @as(u32, 7424);
pub const URLACTION_INFODELIVERY_NO_EDITING_CHANNELS = @as(u32, 7425);
pub const URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS = @as(u32, 7426);
pub const URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS = @as(u32, 7427);
pub const URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS = @as(u32, 7428);
pub const URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS = @as(u32, 7429);
pub const URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING = @as(u32, 7430);
pub const URLACTION_INFODELIVERY_CURR_MAX = @as(u32, 7430);
pub const URLACTION_INFODELIVERY_MAX = @as(u32, 7679);
pub const URLACTION_CHANNEL_SOFTDIST_MIN = @as(u32, 7680);
pub const URLACTION_CHANNEL_SOFTDIST_PERMISSIONS = @as(u32, 7685);
pub const URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT = @as(u32, 65536);
pub const URLPOLICY_CHANNEL_SOFTDIST_PRECACHE = @as(u32, 131072);
pub const URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL = @as(u32, 196608);
pub const URLACTION_CHANNEL_SOFTDIST_MAX = @as(u32, 7935);
pub const URLACTION_DOTNET_USERCONTROLS = @as(u32, 8197);
pub const URLACTION_BEHAVIOR_MIN = @as(u32, 8192);
pub const URLACTION_BEHAVIOR_RUN = @as(u32, 8192);
pub const URLPOLICY_BEHAVIOR_CHECK_LIST = @as(u32, 65536);
pub const URLACTION_FEATURE_MIN = @as(u32, 8448);
pub const URLACTION_FEATURE_MIME_SNIFFING = @as(u32, 8448);
pub const URLACTION_FEATURE_ZONE_ELEVATION = @as(u32, 8449);
pub const URLACTION_FEATURE_WINDOW_RESTRICTIONS = @as(u32, 8450);
pub const URLACTION_FEATURE_SCRIPT_STATUS_BAR = @as(u32, 8451);
pub const URLACTION_FEATURE_FORCE_ADDR_AND_STATUS = @as(u32, 8452);
pub const URLACTION_FEATURE_BLOCK_INPUT_PROMPTS = @as(u32, 8453);
pub const URLACTION_FEATURE_DATA_BINDING = @as(u32, 8454);
pub const URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE = @as(u32, 8455);
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN = @as(u32, 8704);
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI = @as(u32, 8704);
pub const URLACTION_AUTOMATIC_ACTIVEX_UI = @as(u32, 8705);
pub const URLACTION_ALLOW_RESTRICTEDPROTOCOLS = @as(u32, 8960);
pub const URLACTION_ALLOW_APEVALUATION = @as(u32, 8961);
pub const URLACTION_ALLOW_XHR_EVALUATION = @as(u32, 8962);
pub const URLACTION_WINDOWS_BROWSER_APPLICATIONS = @as(u32, 9216);
pub const URLACTION_XPS_DOCUMENTS = @as(u32, 9217);
pub const URLACTION_LOOSE_XAML = @as(u32, 9218);
pub const URLACTION_LOWRIGHTS = @as(u32, 9472);
pub const URLACTION_WINFX_SETUP = @as(u32, 9728);
pub const URLACTION_INPRIVATE_BLOCKING = @as(u32, 9984);
pub const URLACTION_ALLOW_AUDIO_VIDEO = @as(u32, 9985);
pub const URLACTION_ALLOW_ACTIVEX_FILTERING = @as(u32, 9986);
pub const URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING = @as(u32, 9987);
pub const URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS = @as(u32, 9988);
pub const URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT = @as(u32, 9989);
pub const URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION = @as(u32, 9990);
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW = @as(u32, 9992);
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS = @as(u32, 9993);
pub const URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST = @as(u32, 9994);
pub const URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS = @as(u32, 9995);
pub const URLACTION_ALLOW_ANTIMALWARE_SCANNING_OF_ACTIVEX = @as(u32, 9996);
pub const URLACTION_ALLOW_CSS_EXPRESSIONS = @as(u32, 9997);
pub const URLPOLICY_ALLOW = @as(u32, 0);
pub const URLPOLICY_QUERY = @as(u32, 1);
pub const URLPOLICY_DISALLOW = @as(u32, 3);
pub const URLPOLICY_NOTIFY_ON_ALLOW = @as(u32, 16);
pub const URLPOLICY_NOTIFY_ON_DISALLOW = @as(u32, 32);
pub const URLPOLICY_LOG_ON_ALLOW = @as(u32, 64);
pub const URLPOLICY_LOG_ON_DISALLOW = @as(u32, 128);
pub const URLPOLICY_MASK_PERMISSIONS = @as(u32, 15);
pub const URLPOLICY_DONTCHECKDLGBOX = @as(u32, 256);
pub const URLZONE_ESC_FLAG = @as(u32, 256);
pub const SECURITY_IE_STATE_GREEN = @as(u32, 0);
pub const SECURITY_IE_STATE_RED = @as(u32, 1);
pub const SOFTDIST_FLAG_USAGE_EMAIL = @as(u32, 1);
pub const SOFTDIST_FLAG_USAGE_PRECACHE = @as(u32, 2);
pub const SOFTDIST_FLAG_USAGE_AUTOINSTALL = @as(u32, 4);
pub const SOFTDIST_FLAG_DELETE_SUBSCRIPTION = @as(u32, 8);
pub const SOFTDIST_ADSTATE_NONE = @as(u32, 0);
pub const SOFTDIST_ADSTATE_AVAILABLE = @as(u32, 1);
pub const SOFTDIST_ADSTATE_DOWNLOADED = @as(u32, 2);
pub const SOFTDIST_ADSTATE_INSTALLED = @as(u32, 3);
pub const CONFIRMSAFETYACTION_LOADOBJECT = @as(u32, 1);
pub const COM_RIGHTS_EXECUTE = @as(u32, 1);
pub const COM_RIGHTS_EXECUTE_LOCAL = @as(u32, 2);
pub const COM_RIGHTS_EXECUTE_REMOTE = @as(u32, 4);
pub const COM_RIGHTS_ACTIVATE_LOCAL = @as(u32, 8);
pub const COM_RIGHTS_ACTIVATE_REMOTE = @as(u32, 16);
pub const COM_RIGHTS_RESERVED1 = @as(u32, 32);
pub const COM_RIGHTS_RESERVED2 = @as(u32, 64);
pub const CWMO_MAX_HANDLES = @as(u32, 56);
pub const ROTREGFLAGS_ALLOWANYCLIENT = @as(u32, 1);
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP = @as(u32, 1);
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND = @as(u32, 2);
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY = @as(u32, 4);
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN = @as(u32, 8);
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION = @as(u32, 16);
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY = @as(u32, 32);
pub const APPIDREGFLAGS_RESERVED1 = @as(u32, 64);
pub const APPIDREGFLAGS_RESERVED2 = @as(u32, 128);
pub const APPIDREGFLAGS_RESERVED3 = @as(u32, 256);
pub const APPIDREGFLAGS_RESERVED4 = @as(u32, 512);
pub const APPIDREGFLAGS_RESERVED5 = @as(u32, 1024);
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU = @as(u32, 2048);
pub const APPIDREGFLAGS_RESERVED7 = @as(u32, 4096);
pub const APPIDREGFLAGS_RESERVED8 = @as(u32, 8192);
pub const APPIDREGFLAGS_RESERVED9 = @as(u32, 16384);
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES = @as(u32, 1);
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL = @as(u32, 2);
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES = @as(u32, 4);
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL = @as(u32, 8);
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE = @as(u32, 16);
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL = @as(u32, 32);
pub const MAXLSN = @as(u64, 9223372036854775807);
pub const DMUS_ERRBASE = @as(u32, 4096);

//--------------------------------------------------------------------------------
// Section: Types (480)
//--------------------------------------------------------------------------------
pub const UPDFCACHE_FLAGS = enum(u32) {
    ALL = 2147483647,
    ALLBUTNODATACACHE = 2147483646,
    NORMALCACHE = 8,
    IFBLANK = 16,
    ONLYIFBLANK = 2147483648,
    NODATACACHE = 1,
    ONSAVECACHE = 2,
    ONSTOPCACHE = 4,
    IFBLANKORONSAVECACHE = 18,
    _,
    pub fn initFlags(o: struct {
        ALL: u1 = 0,
        ALLBUTNODATACACHE: u1 = 0,
        NORMALCACHE: u1 = 0,
        IFBLANK: u1 = 0,
        ONLYIFBLANK: u1 = 0,
        NODATACACHE: u1 = 0,
        ONSAVECACHE: u1 = 0,
        ONSTOPCACHE: u1 = 0,
        IFBLANKORONSAVECACHE: u1 = 0,
    }) UPDFCACHE_FLAGS {
        return @intToEnum(UPDFCACHE_FLAGS,
              (if (o.ALL == 1) @enumToInt(UPDFCACHE_FLAGS.ALL) else 0)
            | (if (o.ALLBUTNODATACACHE == 1) @enumToInt(UPDFCACHE_FLAGS.ALLBUTNODATACACHE) else 0)
            | (if (o.NORMALCACHE == 1) @enumToInt(UPDFCACHE_FLAGS.NORMALCACHE) else 0)
            | (if (o.IFBLANK == 1) @enumToInt(UPDFCACHE_FLAGS.IFBLANK) else 0)
            | (if (o.ONLYIFBLANK == 1) @enumToInt(UPDFCACHE_FLAGS.ONLYIFBLANK) else 0)
            | (if (o.NODATACACHE == 1) @enumToInt(UPDFCACHE_FLAGS.NODATACACHE) else 0)
            | (if (o.ONSAVECACHE == 1) @enumToInt(UPDFCACHE_FLAGS.ONSAVECACHE) else 0)
            | (if (o.ONSTOPCACHE == 1) @enumToInt(UPDFCACHE_FLAGS.ONSTOPCACHE) else 0)
            | (if (o.IFBLANKORONSAVECACHE == 1) @enumToInt(UPDFCACHE_FLAGS.IFBLANKORONSAVECACHE) else 0)
        );
    }
};
pub const UPDFCACHE_ALL = UPDFCACHE_FLAGS.ALL;
pub const UPDFCACHE_ALLBUTNODATACACHE = UPDFCACHE_FLAGS.ALLBUTNODATACACHE;
pub const UPDFCACHE_NORMALCACHE = UPDFCACHE_FLAGS.NORMALCACHE;
pub const UPDFCACHE_IFBLANK = UPDFCACHE_FLAGS.IFBLANK;
pub const UPDFCACHE_ONLYIFBLANK = UPDFCACHE_FLAGS.ONLYIFBLANK;
pub const UPDFCACHE_NODATACACHE = UPDFCACHE_FLAGS.NODATACACHE;
pub const UPDFCACHE_ONSAVECACHE = UPDFCACHE_FLAGS.ONSAVECACHE;
pub const UPDFCACHE_ONSTOPCACHE = UPDFCACHE_FLAGS.ONSTOPCACHE;
pub const UPDFCACHE_IFBLANKORONSAVECACHE = UPDFCACHE_FLAGS.IFBLANKORONSAVECACHE;

pub const URI_CREATE_FLAGS = enum(u32) {
    ALLOW_RELATIVE = 1,
    ALLOW_IMPLICIT_WILDCARD_SCHEME = 2,
    ALLOW_IMPLICIT_FILE_SCHEME = 4,
    NOFRAG = 8,
    NO_CANONICALIZE = 16,
    CANONICALIZE = 256,
    FILE_USE_DOS_PATH = 32,
    DECODE_EXTRA_INFO = 64,
    NO_DECODE_EXTRA_INFO = 128,
    CRACK_UNKNOWN_SCHEMES = 512,
    NO_CRACK_UNKNOWN_SCHEMES = 1024,
    PRE_PROCESS_HTML_URI = 2048,
    NO_PRE_PROCESS_HTML_URI = 4096,
    IE_SETTINGS = 8192,
    NO_IE_SETTINGS = 16384,
    NO_ENCODE_FORBIDDEN_CHARACTERS = 32768,
    NORMALIZE_INTL_CHARACTERS = 65536,
    CANONICALIZE_ABSOLUTE = 131072,
    _,
    pub fn initFlags(o: struct {
        ALLOW_RELATIVE: u1 = 0,
        ALLOW_IMPLICIT_WILDCARD_SCHEME: u1 = 0,
        ALLOW_IMPLICIT_FILE_SCHEME: u1 = 0,
        NOFRAG: u1 = 0,
        NO_CANONICALIZE: u1 = 0,
        CANONICALIZE: u1 = 0,
        FILE_USE_DOS_PATH: u1 = 0,
        DECODE_EXTRA_INFO: u1 = 0,
        NO_DECODE_EXTRA_INFO: u1 = 0,
        CRACK_UNKNOWN_SCHEMES: u1 = 0,
        NO_CRACK_UNKNOWN_SCHEMES: u1 = 0,
        PRE_PROCESS_HTML_URI: u1 = 0,
        NO_PRE_PROCESS_HTML_URI: u1 = 0,
        IE_SETTINGS: u1 = 0,
        NO_IE_SETTINGS: u1 = 0,
        NO_ENCODE_FORBIDDEN_CHARACTERS: u1 = 0,
        NORMALIZE_INTL_CHARACTERS: u1 = 0,
        CANONICALIZE_ABSOLUTE: u1 = 0,
    }) URI_CREATE_FLAGS {
        return @intToEnum(URI_CREATE_FLAGS,
              (if (o.ALLOW_RELATIVE == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_RELATIVE) else 0)
            | (if (o.ALLOW_IMPLICIT_WILDCARD_SCHEME == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME) else 0)
            | (if (o.ALLOW_IMPLICIT_FILE_SCHEME == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME) else 0)
            | (if (o.NOFRAG == 1) @enumToInt(URI_CREATE_FLAGS.NOFRAG) else 0)
            | (if (o.NO_CANONICALIZE == 1) @enumToInt(URI_CREATE_FLAGS.NO_CANONICALIZE) else 0)
            | (if (o.CANONICALIZE == 1) @enumToInt(URI_CREATE_FLAGS.CANONICALIZE) else 0)
            | (if (o.FILE_USE_DOS_PATH == 1) @enumToInt(URI_CREATE_FLAGS.FILE_USE_DOS_PATH) else 0)
            | (if (o.DECODE_EXTRA_INFO == 1) @enumToInt(URI_CREATE_FLAGS.DECODE_EXTRA_INFO) else 0)
            | (if (o.NO_DECODE_EXTRA_INFO == 1) @enumToInt(URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO) else 0)
            | (if (o.CRACK_UNKNOWN_SCHEMES == 1) @enumToInt(URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES) else 0)
            | (if (o.NO_CRACK_UNKNOWN_SCHEMES == 1) @enumToInt(URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES) else 0)
            | (if (o.PRE_PROCESS_HTML_URI == 1) @enumToInt(URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI) else 0)
            | (if (o.NO_PRE_PROCESS_HTML_URI == 1) @enumToInt(URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI) else 0)
            | (if (o.IE_SETTINGS == 1) @enumToInt(URI_CREATE_FLAGS.IE_SETTINGS) else 0)
            | (if (o.NO_IE_SETTINGS == 1) @enumToInt(URI_CREATE_FLAGS.NO_IE_SETTINGS) else 0)
            | (if (o.NO_ENCODE_FORBIDDEN_CHARACTERS == 1) @enumToInt(URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS) else 0)
            | (if (o.NORMALIZE_INTL_CHARACTERS == 1) @enumToInt(URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS) else 0)
            | (if (o.CANONICALIZE_ABSOLUTE == 1) @enumToInt(URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE) else 0)
        );
    }
};
pub const Uri_CREATE_ALLOW_RELATIVE = URI_CREATE_FLAGS.ALLOW_RELATIVE;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME;
pub const Uri_CREATE_NOFRAG = URI_CREATE_FLAGS.NOFRAG;
pub const Uri_CREATE_NO_CANONICALIZE = URI_CREATE_FLAGS.NO_CANONICALIZE;
pub const Uri_CREATE_CANONICALIZE = URI_CREATE_FLAGS.CANONICALIZE;
pub const Uri_CREATE_FILE_USE_DOS_PATH = URI_CREATE_FLAGS.FILE_USE_DOS_PATH;
pub const Uri_CREATE_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.DECODE_EXTRA_INFO;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_IE_SETTINGS = URI_CREATE_FLAGS.IE_SETTINGS;
pub const Uri_CREATE_NO_IE_SETTINGS = URI_CREATE_FLAGS.NO_IE_SETTINGS;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE;

pub const RPC_C_AUTHN_LEVEL = enum(u32) {
    DEFAULT = 0,
    NONE = 1,
    CONNECT = 2,
    CALL = 3,
    PKT = 4,
    PKT_INTEGRITY = 5,
    PKT_PRIVACY = 6,
};
pub const RPC_C_AUTHN_LEVEL_DEFAULT = RPC_C_AUTHN_LEVEL.DEFAULT;
pub const RPC_C_AUTHN_LEVEL_NONE = RPC_C_AUTHN_LEVEL.NONE;
pub const RPC_C_AUTHN_LEVEL_CONNECT = RPC_C_AUTHN_LEVEL.CONNECT;
pub const RPC_C_AUTHN_LEVEL_CALL = RPC_C_AUTHN_LEVEL.CALL;
pub const RPC_C_AUTHN_LEVEL_PKT = RPC_C_AUTHN_LEVEL.PKT;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = RPC_C_AUTHN_LEVEL.PKT_INTEGRITY;
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY = RPC_C_AUTHN_LEVEL.PKT_PRIVACY;

pub const RPC_C_IMP_LEVEL = enum(u32) {
    DEFAULT = 0,
    ANONYMOUS = 1,
    IDENTIFY = 2,
    IMPERSONATE = 3,
    DELEGATE = 4,
};
pub const RPC_C_IMP_LEVEL_DEFAULT = RPC_C_IMP_LEVEL.DEFAULT;
pub const RPC_C_IMP_LEVEL_ANONYMOUS = RPC_C_IMP_LEVEL.ANONYMOUS;
pub const RPC_C_IMP_LEVEL_IDENTIFY = RPC_C_IMP_LEVEL.IDENTIFY;
pub const RPC_C_IMP_LEVEL_IMPERSONATE = RPC_C_IMP_LEVEL.IMPERSONATE;
pub const RPC_C_IMP_LEVEL_DELEGATE = RPC_C_IMP_LEVEL.DELEGATE;

pub const ENUM_CONTROLS_WHICH_FLAGS = enum(u32) {
    W_WCH_SIBLING = 1,
    _WCH_CONTAINER = 2,
    _WCH_CONTAINED = 3,
    _WCH_ALL = 4,
    _WCH_FREVERSEDIR = 134217728,
    _WCH_FONLYAFTER = 268435456,
    _WCH_FONLYBEFORE = 536870912,
    _WCH_FSELECTED = 1073741824,
};
pub const GCW_WCH_SIBLING = ENUM_CONTROLS_WHICH_FLAGS.W_WCH_SIBLING;
pub const GC_WCH_CONTAINER = ENUM_CONTROLS_WHICH_FLAGS._WCH_CONTAINER;
pub const GC_WCH_CONTAINED = ENUM_CONTROLS_WHICH_FLAGS._WCH_CONTAINED;
pub const GC_WCH_ALL = ENUM_CONTROLS_WHICH_FLAGS._WCH_ALL;
pub const GC_WCH_FREVERSEDIR = ENUM_CONTROLS_WHICH_FLAGS._WCH_FREVERSEDIR;
pub const GC_WCH_FONLYAFTER = ENUM_CONTROLS_WHICH_FLAGS._WCH_FONLYAFTER;
pub const GC_WCH_FONLYBEFORE = ENUM_CONTROLS_WHICH_FLAGS._WCH_FONLYBEFORE;
pub const GC_WCH_FSELECTED = ENUM_CONTROLS_WHICH_FLAGS._WCH_FSELECTED;

pub const MULTICLASSINFO_FLAGS = enum(u32) {
    TYPEINFO = 1,
    NUMRESERVEDDISPIDS = 2,
    IIDPRIMARY = 4,
    IIDSOURCE = 8,
};
pub const MULTICLASSINFO_GETTYPEINFO = MULTICLASSINFO_FLAGS.TYPEINFO;
pub const MULTICLASSINFO_GETNUMRESERVEDDISPIDS = MULTICLASSINFO_FLAGS.NUMRESERVEDDISPIDS;
pub const MULTICLASSINFO_GETIIDPRIMARY = MULTICLASSINFO_FLAGS.IIDPRIMARY;
pub const MULTICLASSINFO_GETIIDSOURCE = MULTICLASSINFO_FLAGS.IIDSOURCE;

pub const IEnumContextProps = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IContext = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const CO_MTA_USAGE_COOKIE = isize;

pub const CO_DEVICE_CATALOG_COOKIE = isize;

pub const DVASPECT = enum(i32) {
    CONTENT = 1,
    THUMBNAIL = 2,
    ICON = 4,
    DOCPRINT = 8,
};
pub const DVASPECT_CONTENT = DVASPECT.CONTENT;
pub const DVASPECT_THUMBNAIL = DVASPECT.THUMBNAIL;
pub const DVASPECT_ICON = DVASPECT.ICON;
pub const DVASPECT_DOCPRINT = DVASPECT.DOCPRINT;

pub const CSPLATFORM = extern struct {
    dwPlatformId: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
    dwProcessorArch: u32,
};

pub const QUERYCONTEXT = extern struct {
    dwContext: u32,
    Platform: CSPLATFORM,
    Locale: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
};

pub const TYSPEC = enum(i32) {
    CLSID = 0,
    FILEEXT = 1,
    MIMETYPE = 2,
    FILENAME = 3,
    PROGID = 4,
    PACKAGENAME = 5,
    OBJECTID = 6,
};
pub const TYSPEC_CLSID = TYSPEC.CLSID;
pub const TYSPEC_FILEEXT = TYSPEC.FILEEXT;
pub const TYSPEC_MIMETYPE = TYSPEC.MIMETYPE;
pub const TYSPEC_FILENAME = TYSPEC.FILENAME;
pub const TYSPEC_PROGID = TYSPEC.PROGID;
pub const TYSPEC_PACKAGENAME = TYSPEC.PACKAGENAME;
pub const TYSPEC_OBJECTID = TYSPEC.OBJECTID;

pub const REGCLS = enum(i32) {
    SINGLEUSE = 0,
    MULTIPLEUSE = 1,
    MULTI_SEPARATE = 2,
    SUSPENDED = 4,
    SURROGATE = 8,
    AGILE = 16,
};
pub const REGCLS_SINGLEUSE = REGCLS.SINGLEUSE;
pub const REGCLS_MULTIPLEUSE = REGCLS.MULTIPLEUSE;
pub const REGCLS_MULTI_SEPARATE = REGCLS.MULTI_SEPARATE;
pub const REGCLS_SUSPENDED = REGCLS.SUSPENDED;
pub const REGCLS_SURROGATE = REGCLS.SURROGATE;
pub const REGCLS_AGILE = REGCLS.AGILE;

pub const COINITBASE = enum(i32) {
    D = 0,
};
pub const COINITBASE_MULTITHREADED = COINITBASE.D;

pub const COAUTHIDENTITY = extern struct {
    User: ?*u16,
    UserLength: u32,
    Domain: ?*u16,
    DomainLength: u32,
    Password: ?*u16,
    PasswordLength: u32,
    Flags: u32,
};

pub const COAUTHINFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pwszServerPrincName: ?PWSTR,
    dwAuthnLevel: u32,
    dwImpersonationLevel: u32,
    pAuthIdentityData: ?*COAUTHIDENTITY,
    dwCapabilities: u32,
};

pub const MEMCTX = enum(i32) {
    TASK = 1,
    SHARED = 2,
    MACSYSTEM = 3,
    UNKNOWN = -1,
    SAME = -2,
};
pub const MEMCTX_TASK = MEMCTX.TASK;
pub const MEMCTX_SHARED = MEMCTX.SHARED;
pub const MEMCTX_MACSYSTEM = MEMCTX.MACSYSTEM;
pub const MEMCTX_UNKNOWN = MEMCTX.UNKNOWN;
pub const MEMCTX_SAME = MEMCTX.SAME;

pub const CLSCTX = enum(u32) {
    INPROC_SERVER = 1,
    INPROC_HANDLER = 2,
    LOCAL_SERVER = 4,
    INPROC_SERVER16 = 8,
    REMOTE_SERVER = 16,
    INPROC_HANDLER16 = 32,
    RESERVED1 = 64,
    RESERVED2 = 128,
    RESERVED3 = 256,
    RESERVED4 = 512,
    NO_CODE_DOWNLOAD = 1024,
    RESERVED5 = 2048,
    NO_CUSTOM_MARSHAL = 4096,
    ENABLE_CODE_DOWNLOAD = 8192,
    NO_FAILURE_LOG = 16384,
    DISABLE_AAA = 32768,
    ENABLE_AAA = 65536,
    FROM_DEFAULT_CONTEXT = 131072,
    ACTIVATE_X86_SERVER = 262144,
    // ACTIVATE_32_BIT_SERVER = 262144, this enum value conflicts with ACTIVATE_X86_SERVER
    ACTIVATE_64_BIT_SERVER = 524288,
    ENABLE_CLOAKING = 1048576,
    APPCONTAINER = 4194304,
    ACTIVATE_AAA_AS_IU = 8388608,
    RESERVED6 = 16777216,
    ACTIVATE_ARM32_SERVER = 33554432,
    PS_DLL = 2147483648,
    ALL = 23,
    SERVER = 21,
    _,
    pub fn initFlags(o: struct {
        INPROC_SERVER: u1 = 0,
        INPROC_HANDLER: u1 = 0,
        LOCAL_SERVER: u1 = 0,
        INPROC_SERVER16: u1 = 0,
        REMOTE_SERVER: u1 = 0,
        INPROC_HANDLER16: u1 = 0,
        RESERVED1: u1 = 0,
        RESERVED2: u1 = 0,
        RESERVED3: u1 = 0,
        RESERVED4: u1 = 0,
        NO_CODE_DOWNLOAD: u1 = 0,
        RESERVED5: u1 = 0,
        NO_CUSTOM_MARSHAL: u1 = 0,
        ENABLE_CODE_DOWNLOAD: u1 = 0,
        NO_FAILURE_LOG: u1 = 0,
        DISABLE_AAA: u1 = 0,
        ENABLE_AAA: u1 = 0,
        FROM_DEFAULT_CONTEXT: u1 = 0,
        ACTIVATE_X86_SERVER: u1 = 0,
        ACTIVATE_64_BIT_SERVER: u1 = 0,
        ENABLE_CLOAKING: u1 = 0,
        APPCONTAINER: u1 = 0,
        ACTIVATE_AAA_AS_IU: u1 = 0,
        RESERVED6: u1 = 0,
        ACTIVATE_ARM32_SERVER: u1 = 0,
        PS_DLL: u1 = 0,
        ALL: u1 = 0,
        SERVER: u1 = 0,
    }) CLSCTX {
        return @intToEnum(CLSCTX,
              (if (o.INPROC_SERVER == 1) @enumToInt(CLSCTX.INPROC_SERVER) else 0)
            | (if (o.INPROC_HANDLER == 1) @enumToInt(CLSCTX.INPROC_HANDLER) else 0)
            | (if (o.LOCAL_SERVER == 1) @enumToInt(CLSCTX.LOCAL_SERVER) else 0)
            | (if (o.INPROC_SERVER16 == 1) @enumToInt(CLSCTX.INPROC_SERVER16) else 0)
            | (if (o.REMOTE_SERVER == 1) @enumToInt(CLSCTX.REMOTE_SERVER) else 0)
            | (if (o.INPROC_HANDLER16 == 1) @enumToInt(CLSCTX.INPROC_HANDLER16) else 0)
            | (if (o.RESERVED1 == 1) @enumToInt(CLSCTX.RESERVED1) else 0)
            | (if (o.RESERVED2 == 1) @enumToInt(CLSCTX.RESERVED2) else 0)
            | (if (o.RESERVED3 == 1) @enumToInt(CLSCTX.RESERVED3) else 0)
            | (if (o.RESERVED4 == 1) @enumToInt(CLSCTX.RESERVED4) else 0)
            | (if (o.NO_CODE_DOWNLOAD == 1) @enumToInt(CLSCTX.NO_CODE_DOWNLOAD) else 0)
            | (if (o.RESERVED5 == 1) @enumToInt(CLSCTX.RESERVED5) else 0)
            | (if (o.NO_CUSTOM_MARSHAL == 1) @enumToInt(CLSCTX.NO_CUSTOM_MARSHAL) else 0)
            | (if (o.ENABLE_CODE_DOWNLOAD == 1) @enumToInt(CLSCTX.ENABLE_CODE_DOWNLOAD) else 0)
            | (if (o.NO_FAILURE_LOG == 1) @enumToInt(CLSCTX.NO_FAILURE_LOG) else 0)
            | (if (o.DISABLE_AAA == 1) @enumToInt(CLSCTX.DISABLE_AAA) else 0)
            | (if (o.ENABLE_AAA == 1) @enumToInt(CLSCTX.ENABLE_AAA) else 0)
            | (if (o.FROM_DEFAULT_CONTEXT == 1) @enumToInt(CLSCTX.FROM_DEFAULT_CONTEXT) else 0)
            | (if (o.ACTIVATE_X86_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_X86_SERVER) else 0)
            | (if (o.ACTIVATE_64_BIT_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_64_BIT_SERVER) else 0)
            | (if (o.ENABLE_CLOAKING == 1) @enumToInt(CLSCTX.ENABLE_CLOAKING) else 0)
            | (if (o.APPCONTAINER == 1) @enumToInt(CLSCTX.APPCONTAINER) else 0)
            | (if (o.ACTIVATE_AAA_AS_IU == 1) @enumToInt(CLSCTX.ACTIVATE_AAA_AS_IU) else 0)
            | (if (o.RESERVED6 == 1) @enumToInt(CLSCTX.RESERVED6) else 0)
            | (if (o.ACTIVATE_ARM32_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_ARM32_SERVER) else 0)
            | (if (o.PS_DLL == 1) @enumToInt(CLSCTX.PS_DLL) else 0)
            | (if (o.ALL == 1) @enumToInt(CLSCTX.ALL) else 0)
            | (if (o.SERVER == 1) @enumToInt(CLSCTX.SERVER) else 0)
        );
    }
};
pub const CLSCTX_INPROC_SERVER = CLSCTX.INPROC_SERVER;
pub const CLSCTX_INPROC_HANDLER = CLSCTX.INPROC_HANDLER;
pub const CLSCTX_LOCAL_SERVER = CLSCTX.LOCAL_SERVER;
pub const CLSCTX_INPROC_SERVER16 = CLSCTX.INPROC_SERVER16;
pub const CLSCTX_REMOTE_SERVER = CLSCTX.REMOTE_SERVER;
pub const CLSCTX_INPROC_HANDLER16 = CLSCTX.INPROC_HANDLER16;
pub const CLSCTX_RESERVED1 = CLSCTX.RESERVED1;
pub const CLSCTX_RESERVED2 = CLSCTX.RESERVED2;
pub const CLSCTX_RESERVED3 = CLSCTX.RESERVED3;
pub const CLSCTX_RESERVED4 = CLSCTX.RESERVED4;
pub const CLSCTX_NO_CODE_DOWNLOAD = CLSCTX.NO_CODE_DOWNLOAD;
pub const CLSCTX_RESERVED5 = CLSCTX.RESERVED5;
pub const CLSCTX_NO_CUSTOM_MARSHAL = CLSCTX.NO_CUSTOM_MARSHAL;
pub const CLSCTX_ENABLE_CODE_DOWNLOAD = CLSCTX.ENABLE_CODE_DOWNLOAD;
pub const CLSCTX_NO_FAILURE_LOG = CLSCTX.NO_FAILURE_LOG;
pub const CLSCTX_DISABLE_AAA = CLSCTX.DISABLE_AAA;
pub const CLSCTX_ENABLE_AAA = CLSCTX.ENABLE_AAA;
pub const CLSCTX_FROM_DEFAULT_CONTEXT = CLSCTX.FROM_DEFAULT_CONTEXT;
pub const CLSCTX_ACTIVATE_X86_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_64_BIT_SERVER = CLSCTX.ACTIVATE_64_BIT_SERVER;
pub const CLSCTX_ENABLE_CLOAKING = CLSCTX.ENABLE_CLOAKING;
pub const CLSCTX_APPCONTAINER = CLSCTX.APPCONTAINER;
pub const CLSCTX_ACTIVATE_AAA_AS_IU = CLSCTX.ACTIVATE_AAA_AS_IU;
pub const CLSCTX_RESERVED6 = CLSCTX.RESERVED6;
pub const CLSCTX_ACTIVATE_ARM32_SERVER = CLSCTX.ACTIVATE_ARM32_SERVER;
pub const CLSCTX_PS_DLL = CLSCTX.PS_DLL;
pub const CLSCTX_ALL = CLSCTX.ALL;
pub const CLSCTX_SERVER = CLSCTX.SERVER;

pub const MSHLFLAGS = enum(i32) {
    NORMAL = 0,
    TABLESTRONG = 1,
    TABLEWEAK = 2,
    NOPING = 4,
    RESERVED1 = 8,
    RESERVED2 = 16,
    RESERVED3 = 32,
    RESERVED4 = 64,
};
pub const MSHLFLAGS_NORMAL = MSHLFLAGS.NORMAL;
pub const MSHLFLAGS_TABLESTRONG = MSHLFLAGS.TABLESTRONG;
pub const MSHLFLAGS_TABLEWEAK = MSHLFLAGS.TABLEWEAK;
pub const MSHLFLAGS_NOPING = MSHLFLAGS.NOPING;
pub const MSHLFLAGS_RESERVED1 = MSHLFLAGS.RESERVED1;
pub const MSHLFLAGS_RESERVED2 = MSHLFLAGS.RESERVED2;
pub const MSHLFLAGS_RESERVED3 = MSHLFLAGS.RESERVED3;
pub const MSHLFLAGS_RESERVED4 = MSHLFLAGS.RESERVED4;

pub const MSHCTX = enum(i32) {
    LOCAL = 0,
    NOSHAREDMEM = 1,
    DIFFERENTMACHINE = 2,
    INPROC = 3,
    CROSSCTX = 4,
    RESERVED1 = 5,
};
pub const MSHCTX_LOCAL = MSHCTX.LOCAL;
pub const MSHCTX_NOSHAREDMEM = MSHCTX.NOSHAREDMEM;
pub const MSHCTX_DIFFERENTMACHINE = MSHCTX.DIFFERENTMACHINE;
pub const MSHCTX_INPROC = MSHCTX.INPROC;
pub const MSHCTX_CROSSCTX = MSHCTX.CROSSCTX;
pub const MSHCTX_RESERVED1 = MSHCTX.RESERVED1;

pub const BYTE_BLOB = extern struct {
    clSize: u32,
    abData: [1]u8,
};

pub const WORD_BLOB = extern struct {
    clSize: u32,
    asData: [1]u16,
};

pub const DWORD_BLOB = extern struct {
    clSize: u32,
    alData: [1]u32,
};

pub const FLAGGED_BYTE_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    abData: [1]u8,
};

pub const FLAGGED_WORD_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    asData: [1]u16,
};

pub const BYTE_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u8,
};

pub const SHORT_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u16,
};

pub const LONG_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u32,
};

pub const HYPER_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*i64,
};

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: ?*u8,
};

const IID_IUnknown_Value = @import("../zig.zig").Guid.initString("00000000-0000-0000-c000-000000000046");
pub const IID_IUnknown = &IID_IUnknown_Value;
pub const IUnknown = extern struct {
    pub const VTable = extern struct {
        QueryInterface: fn(
            self: *const IUnknown,
            riid: ?*const Guid,
            ppvObject: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: fn(
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: fn(
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_QueryInterface(self: *const T, riid: ?*const Guid, ppvObject: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUnknown.VTable, self.vtable).QueryInterface(@ptrCast(*const IUnknown, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IUnknown.VTable, self.vtable).AddRef(@ptrCast(*const IUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IUnknown.VTable, self.vtable).Release(@ptrCast(*const IUnknown, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIUnknown_Value = @import("../zig.zig").Guid.initString("000e0000-0000-0000-c000-000000000046");
pub const IID_AsyncIUnknown = &IID_AsyncIUnknown_Value;
pub const AsyncIUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryInterface: fn(
            self: *const AsyncIUnknown,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryInterface: fn(
            self: *const AsyncIUnknown,
            ppvObject: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_AddRef: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_AddRef: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Begin_Release: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Release: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_QueryInterface(self: *const T, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_QueryInterface(@ptrCast(*const AsyncIUnknown, self), riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_QueryInterface(self: *const T, ppvObject: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_QueryInterface(@ptrCast(*const AsyncIUnknown, self), ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_AddRef(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_AddRef(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_AddRef(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_Release(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_Release(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_Release(@ptrCast(*const AsyncIUnknown, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory_Value = @import("../zig.zig").Guid.initString("00000001-0000-0000-c000-000000000046");
pub const IID_IClassFactory = &IID_IClassFactory_Value;
pub const IClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IClassFactory,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppvObject: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockServer: fn(
            self: *const IClassFactory,
            fLock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObject: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IClassFactory, self), pUnkOuter, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory_LockServer(self: *const T, fLock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory.VTable, self.vtable).LockServer(@ptrCast(*const IClassFactory, self), fLock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COSERVERINFO = extern struct {
    dwReserved1: u32,
    pwszName: ?PWSTR,
    pAuthInfo: ?*COAUTHINFO,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMarshal_Value = @import("../zig.zig").Guid.initString("00000003-0000-0000-c000-000000000046");
pub const IID_IMarshal = &IID_IMarshal_Value;
pub const IMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUnmarshalClass: fn(
            self: *const IMarshal,
            riid: ?*const Guid,
            pv: ?*c_void,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            mshlflags: u32,
            pCid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarshalSizeMax: fn(
            self: *const IMarshal,
            riid: ?*const Guid,
            pv: ?*c_void,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            mshlflags: u32,
            pSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MarshalInterface: fn(
            self: *const IMarshal,
            pStm: ?*IStream,
            riid: ?*const Guid,
            pv: ?*c_void,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            mshlflags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmarshalInterface: fn(
            self: *const IMarshal,
            pStm: ?*IStream,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: fn(
            self: *const IMarshal,
            pStm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectObject: fn(
            self: *const IMarshal,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_GetUnmarshalClass(self: *const T, riid: ?*const Guid, pv: ?*c_void, dwDestContext: u32, pvDestContext: ?*c_void, mshlflags: u32, pCid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).GetUnmarshalClass(@ptrCast(*const IMarshal, self), riid, pv, dwDestContext, pvDestContext, mshlflags, pCid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_GetMarshalSizeMax(self: *const T, riid: ?*const Guid, pv: ?*c_void, dwDestContext: u32, pvDestContext: ?*c_void, mshlflags: u32, pSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).GetMarshalSizeMax(@ptrCast(*const IMarshal, self), riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_MarshalInterface(self: *const T, pStm: ?*IStream, riid: ?*const Guid, pv: ?*c_void, dwDestContext: u32, pvDestContext: ?*c_void, mshlflags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).MarshalInterface(@ptrCast(*const IMarshal, self), pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_UnmarshalInterface(self: *const T, pStm: ?*IStream, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).UnmarshalInterface(@ptrCast(*const IMarshal, self), pStm, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_ReleaseMarshalData(self: *const T, pStm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).ReleaseMarshalData(@ptrCast(*const IMarshal, self), pStm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshal_DisconnectObject(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshal.VTable, self.vtable).DisconnectObject(@ptrCast(*const IMarshal, self), dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INoMarshal_Value = @import("../zig.zig").Guid.initString("ecc8691b-c1db-4dc0-855e-65f6c551af49");
pub const IID_INoMarshal = &IID_INoMarshal_Value;
pub const INoMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAgileObject_Value = @import("../zig.zig").Guid.initString("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90");
pub const IID_IAgileObject = &IID_IAgileObject_Value;
pub const IAgileObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActivationFilter_Value = @import("../zig.zig").Guid.initString("00000017-0000-0000-c000-000000000046");
pub const IID_IActivationFilter = &IID_IActivationFilter_Value;
pub const IActivationFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActivation: fn(
            self: *const IActivationFilter,
            dwActivationType: u32,
            rclsid: ?*const Guid,
            pReplacementClsId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivationFilter_HandleActivation(self: *const T, dwActivationType: u32, rclsid: ?*const Guid, pReplacementClsId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivationFilter.VTable, self.vtable).HandleActivation(@ptrCast(*const IActivationFilter, self), dwActivationType, rclsid, pReplacementClsId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarshal2_Value = @import("../zig.zig").Guid.initString("000001cf-0000-0000-c000-000000000046");
pub const IID_IMarshal2 = &IID_IMarshal2_Value;
pub const IMarshal2 = extern struct {
    pub const VTable = extern struct {
        base: IMarshal.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarshal.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMalloc_Value = @import("../zig.zig").Guid.initString("00000002-0000-0000-c000-000000000046");
pub const IID_IMalloc = &IID_IMalloc_Value;
pub const IMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: fn(
            self: *const IMalloc,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        Realloc: fn(
            self: *const IMalloc,
            pv: ?*c_void,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        Free: fn(
            self: *const IMalloc,
            pv: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetSize: fn(
            self: *const IMalloc,
            pv: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        DidAlloc: fn(
            self: *const IMalloc,
            pv: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        HeapMinimize: fn(
            self: *const IMalloc,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Alloc(self: *const T, cb: usize) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Alloc(@ptrCast(*const IMalloc, self), cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Realloc(self: *const T, pv: ?*c_void, cb: usize) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Realloc(@ptrCast(*const IMalloc, self), pv, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Free(self: *const T, pv: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Free(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_GetSize(self: *const T, pv: ?*c_void) callconv(.Inline) usize {
            return @ptrCast(*const IMalloc.VTable, self.vtable).GetSize(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_DidAlloc(self: *const T, pv: ?*c_void) callconv(.Inline) i32 {
            return @ptrCast(*const IMalloc.VTable, self.vtable).DidAlloc(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_HeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).HeapMinimize(@ptrCast(*const IMalloc, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStdMarshalInfo_Value = @import("../zig.zig").Guid.initString("00000018-0000-0000-c000-000000000046");
pub const IID_IStdMarshalInfo = &IID_IStdMarshalInfo_Value;
pub const IStdMarshalInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassForHandler: fn(
            self: *const IStdMarshalInfo,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            pClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStdMarshalInfo_GetClassForHandler(self: *const T, dwDestContext: u32, pvDestContext: ?*c_void, pClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStdMarshalInfo.VTable, self.vtable).GetClassForHandler(@ptrCast(*const IStdMarshalInfo, self), dwDestContext, pvDestContext, pClsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EXTCONN = enum(i32) {
    STRONG = 1,
    WEAK = 2,
    CALLABLE = 4,
};
pub const EXTCONN_STRONG = EXTCONN.STRONG;
pub const EXTCONN_WEAK = EXTCONN.WEAK;
pub const EXTCONN_CALLABLE = EXTCONN.CALLABLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IExternalConnection_Value = @import("../zig.zig").Guid.initString("00000019-0000-0000-c000-000000000046");
pub const IID_IExternalConnection = &IID_IExternalConnection_Value;
pub const IExternalConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddConnection: fn(
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseConnection: fn(
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
            fLastReleaseCloses: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExternalConnection_AddConnection(self: *const T, extconn: u32, reserved: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IExternalConnection.VTable, self.vtable).AddConnection(@ptrCast(*const IExternalConnection, self), extconn, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExternalConnection_ReleaseConnection(self: *const T, extconn: u32, reserved: u32, fLastReleaseCloses: BOOL) callconv(.Inline) u32 {
            return @ptrCast(*const IExternalConnection.VTable, self.vtable).ReleaseConnection(@ptrCast(*const IExternalConnection, self), extconn, reserved, fLastReleaseCloses);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MULTI_QI = extern struct {
    pIID: ?*const Guid,
    pItf: ?*IUnknown,
    hr: HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMultiQI_Value = @import("../zig.zig").Guid.initString("00000020-0000-0000-c000-000000000046");
pub const IID_IMultiQI = &IID_IMultiQI_Value;
pub const IMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryMultipleInterfaces: fn(
            self: *const IMultiQI,
            cMQIs: u32,
            pMQIs: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiQI_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiQI.VTable, self.vtable).QueryMultipleInterfaces(@ptrCast(*const IMultiQI, self), cMQIs, pMQIs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIMultiQI_Value = @import("../zig.zig").Guid.initString("000e0020-0000-0000-c000-000000000046");
pub const IID_AsyncIMultiQI = &IID_AsyncIMultiQI_Value;
pub const AsyncIMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryMultipleInterfaces: fn(
            self: *const AsyncIMultiQI,
            cMQIs: u32,
            pMQIs: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryMultipleInterfaces: fn(
            self: *const AsyncIMultiQI,
            pMQIs: ?*MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIMultiQI_Begin_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIMultiQI.VTable, self.vtable).Begin_QueryMultipleInterfaces(@ptrCast(*const AsyncIMultiQI, self), cMQIs, pMQIs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIMultiQI_Finish_QueryMultipleInterfaces(self: *const T, pMQIs: ?*MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIMultiQI.VTable, self.vtable).Finish_QueryMultipleInterfaces(@ptrCast(*const AsyncIMultiQI, self), pMQIs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInternalUnknown_Value = @import("../zig.zig").Guid.initString("00000021-0000-0000-c000-000000000046");
pub const IID_IInternalUnknown = &IID_IInternalUnknown_Value;
pub const IInternalUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInternalInterface: fn(
            self: *const IInternalUnknown,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternalUnknown_QueryInternalInterface(self: *const T, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternalUnknown.VTable, self.vtable).QueryInternalInterface(@ptrCast(*const IInternalUnknown, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumUnknown_Value = @import("../zig.zig").Guid.initString("00000100-0000-0000-c000-000000000046");
pub const IID_IEnumUnknown = &IID_IEnumUnknown_Value;
pub const IEnumUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumUnknown,
            celt: u32,
            rgelt: [*]?*IUnknown,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumUnknown,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumUnknown,
            ppenum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Next(self: *const T, celt: u32, rgelt: [*]?*IUnknown, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Next(@ptrCast(*const IEnumUnknown, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Skip(@ptrCast(*const IEnumUnknown, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Reset(@ptrCast(*const IEnumUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Clone(self: *const T, ppenum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Clone(@ptrCast(*const IEnumUnknown, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumString_Value = @import("../zig.zig").Guid.initString("00000101-0000-0000-c000-000000000046");
pub const IID_IEnumString = &IID_IEnumString_Value;
pub const IEnumString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumString,
            celt: u32,
            rgelt: [*]?PWSTR,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumString,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumString,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Next(self: *const T, celt: u32, rgelt: [*]?PWSTR, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Next(@ptrCast(*const IEnumString, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Skip(@ptrCast(*const IEnumString, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Reset(@ptrCast(*const IEnumString, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Clone(self: *const T, ppenum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Clone(@ptrCast(*const IEnumString, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOLEMESSAGE = extern struct {
    reserved1: ?*c_void,
    dataRepresentation: u32,
    Buffer: ?*c_void,
    cbBuffer: u32,
    iMethod: u32,
    reserved2: [5]?*c_void,
    rpcFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcChannelBuffer_Value = @import("../zig.zig").Guid.initString("d5f56b60-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcChannelBuffer = &IID_IRpcChannelBuffer_Value;
pub const IRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendReceive: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
            pStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtx: fn(
            self: *const IRpcChannelBuffer,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_GetBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).GetBuffer(@ptrCast(*const IRpcChannelBuffer, self), pMessage, riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_SendReceive(self: *const T, pMessage: ?*RPCOLEMESSAGE, pStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).SendReceive(@ptrCast(*const IRpcChannelBuffer, self), pMessage, pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_FreeBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).FreeBuffer(@ptrCast(*const IRpcChannelBuffer, self), pMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_GetDestCtx(self: *const T, pdwDestContext: ?*u32, ppvDestContext: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).GetDestCtx(@ptrCast(*const IRpcChannelBuffer, self), pdwDestContext, ppvDestContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).IsConnected(@ptrCast(*const IRpcChannelBuffer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer2_Value = @import("../zig.zig").Guid.initString("594f31d0-7f19-11d0-b194-00a0c90dc8bf");
pub const IID_IRpcChannelBuffer2 = &IID_IRpcChannelBuffer2_Value;
pub const IRpcChannelBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer.VTable,
        GetProtocolVersion: fn(
            self: *const IRpcChannelBuffer2,
            pdwVersion: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer2_GetProtocolVersion(self: *const T, pdwVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer2.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IRpcChannelBuffer2, self), pdwVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAsyncRpcChannelBuffer_Value = @import("../zig.zig").Guid.initString("a5029fb6-3c34-11d1-9c99-00c04fb998aa");
pub const IID_IAsyncRpcChannelBuffer = &IID_IAsyncRpcChannelBuffer_Value;
pub const IAsyncRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pSync: ?*ISynchronize,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pSync: ?*ISynchronize, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).Send(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pSync, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).Receive(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).GetDestCtxEx(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pdwDestContext, ppvDestContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer3_Value = @import("../zig.zig").Guid.initString("25b15600-0115-11d0-bf0d-00aa00b8dfd2");
pub const IID_IRpcChannelBuffer3 = &IID_IRpcChannelBuffer3_Value;
pub const IRpcChannelBuffer3 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            ulSize: u32,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
            pInterface: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAsync: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pAsyncMgr: ?*IAsyncManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Send(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, ulSize: u32, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Receive(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, ulSize, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Cancel(self: *const T, pMsg: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Cancel(@ptrCast(*const IRpcChannelBuffer3, self), pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetCallContext(self: *const T, pMsg: ?*RPCOLEMESSAGE, riid: ?*const Guid, pInterface: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetCallContext(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, riid, pInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetDestCtxEx(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pdwDestContext, ppvDestContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetState(self: *const T, pMsg: ?*RPCOLEMESSAGE, pState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetState(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_RegisterAsync(self: *const T, pMsg: ?*RPCOLEMESSAGE, pAsyncMgr: ?*IAsyncManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).RegisterAsync(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pAsyncMgr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcSyntaxNegotiate_Value = @import("../zig.zig").Guid.initString("58a08519-24c8-4935-b482-3fd823333a4f");
pub const IID_IRpcSyntaxNegotiate = &IID_IRpcSyntaxNegotiate_Value;
pub const IRpcSyntaxNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateSyntax: fn(
            self: *const IRpcSyntaxNegotiate,
            pMsg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcSyntaxNegotiate_NegotiateSyntax(self: *const T, pMsg: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcSyntaxNegotiate.VTable, self.vtable).NegotiateSyntax(@ptrCast(*const IRpcSyntaxNegotiate, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcProxyBuffer_Value = @import("../zig.zig").Guid.initString("d5f56a34-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcProxyBuffer = &IID_IRpcProxyBuffer_Value;
pub const IRpcProxyBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IRpcProxyBuffer,
            pRpcChannelBuffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IRpcProxyBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcProxyBuffer_Connect(self: *const T, pRpcChannelBuffer: ?*IRpcChannelBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcProxyBuffer.VTable, self.vtable).Connect(@ptrCast(*const IRpcProxyBuffer, self), pRpcChannelBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcProxyBuffer_Disconnect(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IRpcProxyBuffer.VTable, self.vtable).Disconnect(@ptrCast(*const IRpcProxyBuffer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcStubBuffer_Value = @import("../zig.zig").Guid.initString("d5f56afc-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcStubBuffer = &IID_IRpcStubBuffer_Value;
pub const IRpcStubBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IRpcStubBuffer,
            pUnkServer: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Invoke: fn(
            self: *const IRpcStubBuffer,
            _prpcmsg: ?*RPCOLEMESSAGE,
            _pRpcChannelBuffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIIDSupported: fn(
            self: *const IRpcStubBuffer,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) ?*IRpcStubBuffer,
        CountRefs: fn(
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        DebugServerQueryInterface: fn(
            self: *const IRpcStubBuffer,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugServerRelease: fn(
            self: *const IRpcStubBuffer,
            pv: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Connect(self: *const T, pUnkServer: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Connect(@ptrCast(*const IRpcStubBuffer, self), pUnkServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Disconnect(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Disconnect(@ptrCast(*const IRpcStubBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Invoke(self: *const T, _prpcmsg: ?*RPCOLEMESSAGE, _pRpcChannelBuffer: ?*IRpcChannelBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Invoke(@ptrCast(*const IRpcStubBuffer, self), _prpcmsg, _pRpcChannelBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_IsIIDSupported(self: *const T, riid: ?*const Guid) callconv(.Inline) ?*IRpcStubBuffer {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).IsIIDSupported(@ptrCast(*const IRpcStubBuffer, self), riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_CountRefs(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).CountRefs(@ptrCast(*const IRpcStubBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_DebugServerQueryInterface(self: *const T, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).DebugServerQueryInterface(@ptrCast(*const IRpcStubBuffer, self), ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_DebugServerRelease(self: *const T, pv: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).DebugServerRelease(@ptrCast(*const IRpcStubBuffer, self), pv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPSFactoryBuffer_Value = @import("../zig.zig").Guid.initString("d5f569d0-593b-101a-b569-08002b2dbf7a");
pub const IID_IPSFactoryBuffer = &IID_IPSFactoryBuffer_Value;
pub const IPSFactoryBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxy: fn(
            self: *const IPSFactoryBuffer,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppProxy: ?*?*IRpcProxyBuffer,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStub: fn(
            self: *const IPSFactoryBuffer,
            riid: ?*const Guid,
            pUnkServer: ?*IUnknown,
            ppStub: ?*?*IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSFactoryBuffer_CreateProxy(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppProxy: ?*?*IRpcProxyBuffer, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPSFactoryBuffer.VTable, self.vtable).CreateProxy(@ptrCast(*const IPSFactoryBuffer, self), pUnkOuter, riid, ppProxy, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSFactoryBuffer_CreateStub(self: *const T, riid: ?*const Guid, pUnkServer: ?*IUnknown, ppStub: ?*?*IRpcStubBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPSFactoryBuffer.VTable, self.vtable).CreateStub(@ptrCast(*const IPSFactoryBuffer, self), riid, pUnkServer, ppStub);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SChannelHookCallInfo = extern struct {
    iid: Guid,
    cbSize: u32,
    uCausality: Guid,
    dwServerPid: u32,
    iMethod: u32,
    pObject: ?*c_void,
};

const IID_IChannelHook_Value = @import("../zig.zig").Guid.initString("1008c4a0-7613-11cf-9af1-0020af6e72f4");
pub const IID_IChannelHook = &IID_IChannelHook_Value;
pub const IChannelHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClientGetSize: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientFillBuffer: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
            pDataBuffer: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientNotify: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            cbDataSize: u32,
            pDataBuffer: ?*c_void,
            lDataRep: u32,
            hrFault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerNotify: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            cbDataSize: u32,
            pDataBuffer: ?*c_void,
            lDataRep: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerGetSize: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            hrFault: HRESULT,
            pDataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerFillBuffer: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
            pDataBuffer: ?*c_void,
            hrFault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientGetSize(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientFillBuffer(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize, pDataBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*c_void, lDataRep: u32, hrFault: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientNotify(@ptrCast(*const IChannelHook, self), uExtent, riid, cbDataSize, pDataBuffer, lDataRep, hrFault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*c_void, lDataRep: u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerNotify(@ptrCast(*const IChannelHook, self), uExtent, riid, cbDataSize, pDataBuffer, lDataRep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, hrFault: HRESULT, pDataSize: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerGetSize(@ptrCast(*const IChannelHook, self), uExtent, riid, hrFault, pDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*c_void, hrFault: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerFillBuffer(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize, pDataBuffer, hrFault);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pPrincipalName: ?PWSTR,
    hr: HRESULT,
};

pub const EOLE_AUTHENTICATION_CAPABILITIES = enum(i32) {
    NONE = 0,
    MUTUAL_AUTH = 1,
    STATIC_CLOAKING = 32,
    DYNAMIC_CLOAKING = 64,
    ANY_AUTHORITY = 128,
    MAKE_FULLSIC = 256,
    DEFAULT = 2048,
    SECURE_REFS = 2,
    ACCESS_CONTROL = 4,
    APPID = 8,
    DYNAMIC = 16,
    REQUIRE_FULLSIC = 512,
    AUTO_IMPERSONATE = 1024,
    DISABLE_AAA = 4096,
    NO_CUSTOM_MARSHAL = 8192,
    RESERVED1 = 16384,
};
pub const EOAC_NONE = EOLE_AUTHENTICATION_CAPABILITIES.NONE;
pub const EOAC_MUTUAL_AUTH = EOLE_AUTHENTICATION_CAPABILITIES.MUTUAL_AUTH;
pub const EOAC_STATIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.STATIC_CLOAKING;
pub const EOAC_DYNAMIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC_CLOAKING;
pub const EOAC_ANY_AUTHORITY = EOLE_AUTHENTICATION_CAPABILITIES.ANY_AUTHORITY;
pub const EOAC_MAKE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.MAKE_FULLSIC;
pub const EOAC_DEFAULT = EOLE_AUTHENTICATION_CAPABILITIES.DEFAULT;
pub const EOAC_SECURE_REFS = EOLE_AUTHENTICATION_CAPABILITIES.SECURE_REFS;
pub const EOAC_ACCESS_CONTROL = EOLE_AUTHENTICATION_CAPABILITIES.ACCESS_CONTROL;
pub const EOAC_APPID = EOLE_AUTHENTICATION_CAPABILITIES.APPID;
pub const EOAC_DYNAMIC = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC;
pub const EOAC_REQUIRE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.REQUIRE_FULLSIC;
pub const EOAC_AUTO_IMPERSONATE = EOLE_AUTHENTICATION_CAPABILITIES.AUTO_IMPERSONATE;
pub const EOAC_DISABLE_AAA = EOLE_AUTHENTICATION_CAPABILITIES.DISABLE_AAA;
pub const EOAC_NO_CUSTOM_MARSHAL = EOLE_AUTHENTICATION_CAPABILITIES.NO_CUSTOM_MARSHAL;
pub const EOAC_RESERVED1 = EOLE_AUTHENTICATION_CAPABILITIES.RESERVED1;

pub const SOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pAuthInfo: ?*c_void,
};

pub const SOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: u32,
    aAuthInfo: ?*SOLE_AUTHENTICATION_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClientSecurity_Value = @import("../zig.zig").Guid.initString("0000013d-0000-0000-c000-000000000046");
pub const IID_IClientSecurity = &IID_IClientSecurity_Value;
pub const IClientSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            pAuthnSvc: ?*u32,
            pAuthzSvc: ?*u32,
            pServerPrincName: ?*?*u16,
            pAuthnLevel: ?*RPC_C_AUTHN_LEVEL,
            pImpLevel: ?*RPC_C_IMP_LEVEL,
            pAuthInfo: ?*?*c_void,
            pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlanket: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            dwAuthnSvc: u32,
            dwAuthzSvc: u32,
            pServerPrincName: ?PWSTR,
            dwAuthnLevel: RPC_C_AUTHN_LEVEL,
            dwImpLevel: RPC_C_IMP_LEVEL,
            pAuthInfo: ?*c_void,
            dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProxy: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            ppCopy: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_QueryBlanket(self: *const T, pProxy: ?*IUnknown, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*RPC_C_AUTHN_LEVEL, pImpLevel: ?*RPC_C_IMP_LEVEL, pAuthInfo: ?*?*c_void, pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).QueryBlanket(@ptrCast(*const IClientSecurity, self), pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pAuthInfo, pCapabilites);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_SetBlanket(self: *const T, pProxy: ?*IUnknown, dwAuthnSvc: u32, dwAuthzSvc: u32, pServerPrincName: ?PWSTR, dwAuthnLevel: RPC_C_AUTHN_LEVEL, dwImpLevel: RPC_C_IMP_LEVEL, pAuthInfo: ?*c_void, dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).SetBlanket(@ptrCast(*const IClientSecurity, self), pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_CopyProxy(self: *const T, pProxy: ?*IUnknown, ppCopy: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).CopyProxy(@ptrCast(*const IClientSecurity, self), pProxy, ppCopy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IServerSecurity_Value = @import("../zig.zig").Guid.initString("0000013e-0000-0000-c000-000000000046");
pub const IID_IServerSecurity = &IID_IServerSecurity_Value;
pub const IServerSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: fn(
            self: *const IServerSecurity,
            pAuthnSvc: ?*u32,
            pAuthzSvc: ?*u32,
            pServerPrincName: ?*?*u16,
            pAuthnLevel: ?*u32,
            pImpLevel: ?*u32,
            pPrivs: ?*?*c_void,
            pCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImpersonateClient: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToSelf: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsImpersonating: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_QueryBlanket(self: *const T, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*u32, pImpLevel: ?*u32, pPrivs: ?*?*c_void, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).QueryBlanket(@ptrCast(*const IServerSecurity, self), pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_ImpersonateClient(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).ImpersonateClient(@ptrCast(*const IServerSecurity, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_RevertToSelf(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).RevertToSelf(@ptrCast(*const IServerSecurity, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_IsImpersonating(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).IsImpersonating(@ptrCast(*const IServerSecurity, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOPT_PROPERTIES = enum(i32) {
    RPCTIMEOUT = 1,
    SERVER_LOCALITY = 2,
    RESERVED1 = 4,
    RESERVED2 = 5,
    RESERVED3 = 8,
    RESERVED4 = 16,
};
pub const COMBND_RPCTIMEOUT = RPCOPT_PROPERTIES.RPCTIMEOUT;
pub const COMBND_SERVER_LOCALITY = RPCOPT_PROPERTIES.SERVER_LOCALITY;
pub const COMBND_RESERVED1 = RPCOPT_PROPERTIES.RESERVED1;
pub const COMBND_RESERVED2 = RPCOPT_PROPERTIES.RESERVED2;
pub const COMBND_RESERVED3 = RPCOPT_PROPERTIES.RESERVED3;
pub const COMBND_RESERVED4 = RPCOPT_PROPERTIES.RESERVED4;

pub const RPCOPT_SERVER_LOCALITY_VALUES = enum(i32) {
    PROCESS_LOCAL = 0,
    MACHINE_LOCAL = 1,
    REMOTE = 2,
};
pub const SERVER_LOCALITY_PROCESS_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.PROCESS_LOCAL;
pub const SERVER_LOCALITY_MACHINE_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.MACHINE_LOCAL;
pub const SERVER_LOCALITY_REMOTE = RPCOPT_SERVER_LOCALITY_VALUES.REMOTE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcOptions_Value = @import("../zig.zig").Guid.initString("00000144-0000-0000-c000-000000000046");
pub const IID_IRpcOptions = &IID_IRpcOptions_Value;
pub const IRpcOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: fn(
            self: *const IRpcOptions,
            pPrx: ?*IUnknown,
            dwProperty: RPCOPT_PROPERTIES,
            dwValue: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IRpcOptions,
            pPrx: ?*IUnknown,
            dwProperty: RPCOPT_PROPERTIES,
            pdwValue: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcOptions_Set(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, dwValue: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcOptions.VTable, self.vtable).Set(@ptrCast(*const IRpcOptions, self), pPrx, dwProperty, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcOptions_Query(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, pdwValue: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcOptions.VTable, self.vtable).Query(@ptrCast(*const IRpcOptions, self), pPrx, dwProperty, pdwValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const GLOBALOPT_PROPERTIES = enum(i32) {
    EXCEPTION_HANDLING = 1,
    APPID = 2,
    RPC_THREADPOOL_SETTING = 3,
    RO_SETTINGS = 4,
    UNMARSHALING_POLICY = 5,
    PROPERTIES_RESERVED1 = 6,
    PROPERTIES_RESERVED2 = 7,
    PROPERTIES_RESERVED3 = 8,
};
pub const COMGLB_EXCEPTION_HANDLING = GLOBALOPT_PROPERTIES.EXCEPTION_HANDLING;
pub const COMGLB_APPID = GLOBALOPT_PROPERTIES.APPID;
pub const COMGLB_RPC_THREADPOOL_SETTING = GLOBALOPT_PROPERTIES.RPC_THREADPOOL_SETTING;
pub const COMGLB_RO_SETTINGS = GLOBALOPT_PROPERTIES.RO_SETTINGS;
pub const COMGLB_UNMARSHALING_POLICY = GLOBALOPT_PROPERTIES.UNMARSHALING_POLICY;
pub const COMGLB_PROPERTIES_RESERVED1 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED1;
pub const COMGLB_PROPERTIES_RESERVED2 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED2;
pub const COMGLB_PROPERTIES_RESERVED3 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED3;

pub const GLOBALOPT_EH_VALUES = enum(i32) {
    HANDLE = 0,
    DONOT_HANDLE_FATAL = 1,
    // DONOT_HANDLE = 1, this enum value conflicts with DONOT_HANDLE_FATAL
    DONOT_HANDLE_ANY = 2,
};
pub const COMGLB_EXCEPTION_HANDLE = GLOBALOPT_EH_VALUES.HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_ANY = GLOBALOPT_EH_VALUES.DONOT_HANDLE_ANY;

pub const GLOBALOPT_RPCTP_VALUES = enum(i32) {
    DEFAULT_POOL = 0,
    PRIVATE_POOL = 1,
};
pub const COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = GLOBALOPT_RPCTP_VALUES.DEFAULT_POOL;
pub const COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = GLOBALOPT_RPCTP_VALUES.PRIVATE_POOL;

pub const GLOBALOPT_RO_FLAGS = enum(i32) {
    STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    FAST_RUNDOWN = 8,
    RESERVED1 = 16,
    RESERVED2 = 32,
    RESERVED3 = 64,
    STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    RESERVED4 = 256,
    RESERVED5 = 512,
    RESERVED6 = 1024,
};
pub const COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_REMOVE_TOUCH_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES;
pub const COMGLB_FAST_RUNDOWN = GLOBALOPT_RO_FLAGS.FAST_RUNDOWN;
pub const COMGLB_RESERVED1 = GLOBALOPT_RO_FLAGS.RESERVED1;
pub const COMGLB_RESERVED2 = GLOBALOPT_RO_FLAGS.RESERVED2;
pub const COMGLB_RESERVED3 = GLOBALOPT_RO_FLAGS.RESERVED3;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES;
pub const COMGLB_RESERVED4 = GLOBALOPT_RO_FLAGS.RESERVED4;
pub const COMGLB_RESERVED5 = GLOBALOPT_RO_FLAGS.RESERVED5;
pub const COMGLB_RESERVED6 = GLOBALOPT_RO_FLAGS.RESERVED6;

pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = enum(i32) {
    NORMAL = 0,
    STRONG = 1,
    HYBRID = 2,
};
pub const COMGLB_UNMARSHALING_POLICY_NORMAL = GLOBALOPT_UNMARSHALING_POLICY_VALUES.NORMAL;
pub const COMGLB_UNMARSHALING_POLICY_STRONG = GLOBALOPT_UNMARSHALING_POLICY_VALUES.STRONG;
pub const COMGLB_UNMARSHALING_POLICY_HYBRID = GLOBALOPT_UNMARSHALING_POLICY_VALUES.HYBRID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IGlobalOptions_Value = @import("../zig.zig").Guid.initString("0000015b-0000-0000-c000-000000000046");
pub const IID_IGlobalOptions = &IID_IGlobalOptions_Value;
pub const IGlobalOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: fn(
            self: *const IGlobalOptions,
            dwProperty: GLOBALOPT_PROPERTIES,
            dwValue: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IGlobalOptions,
            dwProperty: GLOBALOPT_PROPERTIES,
            pdwValue: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalOptions_Set(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, dwValue: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalOptions.VTable, self.vtable).Set(@ptrCast(*const IGlobalOptions, self), dwProperty, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalOptions_Query(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, pdwValue: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalOptions.VTable, self.vtable).Query(@ptrCast(*const IGlobalOptions, self), dwProperty, pdwValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogate_Value = @import("../zig.zig").Guid.initString("00000022-0000-0000-c000-000000000046");
pub const IID_ISurrogate = &IID_ISurrogate_Value;
pub const ISurrogate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadDllServer: fn(
            self: *const ISurrogate,
            Clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeSurrogate: fn(
            self: *const ISurrogate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogate_LoadDllServer(self: *const T, Clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogate.VTable, self.vtable).LoadDllServer(@ptrCast(*const ISurrogate, self), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogate_FreeSurrogate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogate.VTable, self.vtable).FreeSurrogate(@ptrCast(*const ISurrogate, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGlobalInterfaceTable_Value = @import("../zig.zig").Guid.initString("00000146-0000-0000-c000-000000000046");
pub const IID_IGlobalInterfaceTable = &IID_IGlobalInterfaceTable_Value;
pub const IGlobalInterfaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterInterfaceInGlobal: fn(
            self: *const IGlobalInterfaceTable,
            pUnk: ?*IUnknown,
            riid: ?*const Guid,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeInterfaceFromGlobal: fn(
            self: *const IGlobalInterfaceTable,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterfaceFromGlobal: fn(
            self: *const IGlobalInterfaceTable,
            dwCookie: u32,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_RegisterInterfaceInGlobal(self: *const T, pUnk: ?*IUnknown, riid: ?*const Guid, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).RegisterInterfaceInGlobal(@ptrCast(*const IGlobalInterfaceTable, self), pUnk, riid, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_RevokeInterfaceFromGlobal(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).RevokeInterfaceFromGlobal(@ptrCast(*const IGlobalInterfaceTable, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_GetInterfaceFromGlobal(self: *const T, dwCookie: u32, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).GetInterfaceFromGlobal(@ptrCast(*const IGlobalInterfaceTable, self), dwCookie, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronize_Value = @import("../zig.zig").Guid.initString("00000030-0000-0000-c000-000000000046");
pub const IID_ISynchronize = &IID_ISynchronize_Value;
pub const ISynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: fn(
            self: *const ISynchronize,
            dwFlags: u32,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Signal: fn(
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Wait(self: *const T, dwFlags: u32, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Wait(@ptrCast(*const ISynchronize, self), dwFlags, dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Signal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Signal(@ptrCast(*const ISynchronize, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Reset(@ptrCast(*const ISynchronize, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeHandle_Value = @import("../zig.zig").Guid.initString("00000031-0000-0000-c000-000000000046");
pub const IID_ISynchronizeHandle = &IID_ISynchronizeHandle_Value;
pub const ISynchronizeHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandle: fn(
            self: *const ISynchronizeHandle,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeHandle_GetHandle(self: *const T, ph: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeHandle.VTable, self.vtable).GetHandle(@ptrCast(*const ISynchronizeHandle, self), ph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeEvent_Value = @import("../zig.zig").Guid.initString("00000032-0000-0000-c000-000000000046");
pub const IID_ISynchronizeEvent = &IID_ISynchronizeEvent_Value;
pub const ISynchronizeEvent = extern struct {
    pub const VTable = extern struct {
        base: ISynchronizeHandle.VTable,
        SetEventHandle: fn(
            self: *const ISynchronizeEvent,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISynchronizeHandle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeEvent_SetEventHandle(self: *const T, ph: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeEvent.VTable, self.vtable).SetEventHandle(@ptrCast(*const ISynchronizeEvent, self), ph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeContainer_Value = @import("../zig.zig").Guid.initString("00000033-0000-0000-c000-000000000046");
pub const IID_ISynchronizeContainer = &IID_ISynchronizeContainer_Value;
pub const ISynchronizeContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSynchronize: fn(
            self: *const ISynchronizeContainer,
            pSync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitMultiple: fn(
            self: *const ISynchronizeContainer,
            dwFlags: u32,
            dwTimeOut: u32,
            ppSync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeContainer_AddSynchronize(self: *const T, pSync: ?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeContainer.VTable, self.vtable).AddSynchronize(@ptrCast(*const ISynchronizeContainer, self), pSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeContainer_WaitMultiple(self: *const T, dwFlags: u32, dwTimeOut: u32, ppSync: ?*?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeContainer.VTable, self.vtable).WaitMultiple(@ptrCast(*const ISynchronizeContainer, self), dwFlags, dwTimeOut, ppSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISynchronizeMutex_Value = @import("../zig.zig").Guid.initString("00000025-0000-0000-c000-000000000046");
pub const IID_ISynchronizeMutex = &IID_ISynchronizeMutex_Value;
pub const ISynchronizeMutex = extern struct {
    pub const VTable = extern struct {
        base: ISynchronize.VTable,
        ReleaseMutex: fn(
            self: *const ISynchronizeMutex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISynchronize.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeMutex_ReleaseMutex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeMutex.VTable, self.vtable).ReleaseMutex(@ptrCast(*const ISynchronizeMutex, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICancelMethodCalls_Value = @import("../zig.zig").Guid.initString("00000029-0000-0000-c000-000000000046");
pub const IID_ICancelMethodCalls = &IID_ICancelMethodCalls_Value;
pub const ICancelMethodCalls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const ICancelMethodCalls,
            ulSeconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestCancel: fn(
            self: *const ICancelMethodCalls,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICancelMethodCalls_Cancel(self: *const T, ulSeconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICancelMethodCalls.VTable, self.vtable).Cancel(@ptrCast(*const ICancelMethodCalls, self), ulSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICancelMethodCalls_TestCancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICancelMethodCalls.VTable, self.vtable).TestCancel(@ptrCast(*const ICancelMethodCalls, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DCOM_CALL_STATE = enum(i32) {
    NONE = 0,
    CALL_COMPLETE = 1,
    CALL_CANCELED = 2,
};
pub const DCOM_NONE = DCOM_CALL_STATE.NONE;
pub const DCOM_CALL_COMPLETE = DCOM_CALL_STATE.CALL_COMPLETE;
pub const DCOM_CALL_CANCELED = DCOM_CALL_STATE.CALL_CANCELED;

const IID_IAsyncManager_Value = @import("../zig.zig").Guid.initString("0000002a-0000-0000-c000-000000000046");
pub const IID_IAsyncManager = &IID_IAsyncManager_Value;
pub const IAsyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteCall: fn(
            self: *const IAsyncManager,
            Result: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: fn(
            self: *const IAsyncManager,
            riid: ?*const Guid,
            pInterface: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IAsyncManager,
            pulStateFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_CompleteCall(self: *const T, Result: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).CompleteCall(@ptrCast(*const IAsyncManager, self), Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_GetCallContext(self: *const T, riid: ?*const Guid, pInterface: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).GetCallContext(@ptrCast(*const IAsyncManager, self), riid, pInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_GetState(self: *const T, pulStateFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).GetState(@ptrCast(*const IAsyncManager, self), pulStateFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFactory_Value = @import("../zig.zig").Guid.initString("1c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICallFactory = &IID_ICallFactory_Value;
pub const ICallFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCall: fn(
            self: *const ICallFactory,
            riid: ?*const Guid,
            pCtrlUnk: ?*IUnknown,
            riid2: ?*const Guid,
            ppv: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFactory_CreateCall(self: *const T, riid: ?*const Guid, pCtrlUnk: ?*IUnknown, riid2: ?*const Guid, ppv: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFactory.VTable, self.vtable).CreateCall(@ptrCast(*const ICallFactory, self), riid, pCtrlUnk, riid2, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcHelper_Value = @import("../zig.zig").Guid.initString("00000149-0000-0000-c000-000000000046");
pub const IID_IRpcHelper = &IID_IRpcHelper_Value;
pub const IRpcHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDCOMProtocolVersion: fn(
            self: *const IRpcHelper,
            pComVersion: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDFromOBJREF: fn(
            self: *const IRpcHelper,
            pObjRef: ?*c_void,
            piid: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcHelper_GetDCOMProtocolVersion(self: *const T, pComVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcHelper.VTable, self.vtable).GetDCOMProtocolVersion(@ptrCast(*const IRpcHelper, self), pComVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcHelper_GetIIDFromOBJREF(self: *const T, pObjRef: ?*c_void, piid: ?*?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcHelper.VTable, self.vtable).GetIIDFromOBJREF(@ptrCast(*const IRpcHelper, self), pObjRef, piid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReleaseMarshalBuffers_Value = @import("../zig.zig").Guid.initString("eb0cb9e8-7996-11d2-872e-0000f8080859");
pub const IID_IReleaseMarshalBuffers = &IID_IReleaseMarshalBuffers_Value;
pub const IReleaseMarshalBuffers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReleaseMarshalBuffer: fn(
            self: *const IReleaseMarshalBuffers,
            pMsg: ?*RPCOLEMESSAGE,
            dwFlags: u32,
            pChnl: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReleaseMarshalBuffers_ReleaseMarshalBuffer(self: *const T, pMsg: ?*RPCOLEMESSAGE, dwFlags: u32, pChnl: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReleaseMarshalBuffers.VTable, self.vtable).ReleaseMarshalBuffer(@ptrCast(*const IReleaseMarshalBuffers, self), pMsg, dwFlags, pChnl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWaitMultiple_Value = @import("../zig.zig").Guid.initString("0000002b-0000-0000-c000-000000000046");
pub const IID_IWaitMultiple = &IID_IWaitMultiple_Value;
pub const IWaitMultiple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitMultiple: fn(
            self: *const IWaitMultiple,
            timeout: u32,
            pSync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSynchronize: fn(
            self: *const IWaitMultiple,
            pSync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaitMultiple_WaitMultiple(self: *const T, timeout: u32, pSync: ?*?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaitMultiple.VTable, self.vtable).WaitMultiple(@ptrCast(*const IWaitMultiple, self), timeout, pSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaitMultiple_AddSynchronize(self: *const T, pSync: ?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaitMultiple.VTable, self.vtable).AddSynchronize(@ptrCast(*const IWaitMultiple, self), pSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrTrackingControl_Value = @import("../zig.zig").Guid.initString("00000147-0000-0000-c000-000000000046");
pub const IID_IAddrTrackingControl = &IID_IAddrTrackingControl_Value;
pub const IAddrTrackingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableCOMDynamicAddrTracking: fn(
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableCOMDynamicAddrTracking: fn(
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrTrackingControl_EnableCOMDynamicAddrTracking(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrTrackingControl.VTable, self.vtable).EnableCOMDynamicAddrTracking(@ptrCast(*const IAddrTrackingControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrTrackingControl_DisableCOMDynamicAddrTracking(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrTrackingControl.VTable, self.vtable).DisableCOMDynamicAddrTracking(@ptrCast(*const IAddrTrackingControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrExclusionControl_Value = @import("../zig.zig").Guid.initString("00000148-0000-0000-c000-000000000046");
pub const IID_IAddrExclusionControl = &IID_IAddrExclusionControl_Value;
pub const IAddrExclusionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentAddrExclusionList: fn(
            self: *const IAddrExclusionControl,
            riid: ?*const Guid,
            ppEnumerator: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAddrExclusionList: fn(
            self: *const IAddrExclusionControl,
            pEnumerator: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrExclusionControl_GetCurrentAddrExclusionList(self: *const T, riid: ?*const Guid, ppEnumerator: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrExclusionControl.VTable, self.vtable).GetCurrentAddrExclusionList(@ptrCast(*const IAddrExclusionControl, self), riid, ppEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrExclusionControl_UpdateAddrExclusionList(self: *const T, pEnumerator: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrExclusionControl.VTable, self.vtable).UpdateAddrExclusionList(@ptrCast(*const IAddrExclusionControl, self), pEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeByte_Value = @import("../zig.zig").Guid.initString("db2f3aca-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeByte = &IID_IPipeByte_Value;
pub const IPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeByte,
            buf: [*:0]u8,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeByte,
            buf: [*:0]u8,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeByte_Pull(self: *const T, buf: [*:0]u8, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeByte.VTable, self.vtable).Pull(@ptrCast(*const IPipeByte, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeByte_Push(self: *const T, buf: [*:0]u8, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeByte.VTable, self.vtable).Push(@ptrCast(*const IPipeByte, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeByte_Value = @import("../zig.zig").Guid.initString("db2f3acb-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeByte = &IID_AsyncIPipeByte_Value;
pub const AsyncIPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeByte,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeByte,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeByte, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Finish_Pull(self: *const T, buf: [*:0]u8, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeByte, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Begin_Push(self: *const T, buf: [*:0]u8, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeByte, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeByte, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeLong_Value = @import("../zig.zig").Guid.initString("db2f3acc-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeLong = &IID_IPipeLong_Value;
pub const IPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeLong,
            buf: [*]i32,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeLong,
            buf: [*]i32,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeLong_Pull(self: *const T, buf: [*]i32, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeLong.VTable, self.vtable).Pull(@ptrCast(*const IPipeLong, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeLong_Push(self: *const T, buf: [*]i32, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeLong.VTable, self.vtable).Push(@ptrCast(*const IPipeLong, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeLong_Value = @import("../zig.zig").Guid.initString("db2f3acd-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeLong = &IID_AsyncIPipeLong_Value;
pub const AsyncIPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeLong,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeLong,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeLong, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Finish_Pull(self: *const T, buf: [*]i32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeLong, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Begin_Push(self: *const T, buf: [*]i32, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeLong, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeLong, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeDouble_Value = @import("../zig.zig").Guid.initString("db2f3ace-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeDouble = &IID_IPipeDouble_Value;
pub const IPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeDouble,
            buf: [*]f64,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeDouble,
            buf: [*]f64,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeDouble_Pull(self: *const T, buf: [*]f64, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeDouble.VTable, self.vtable).Pull(@ptrCast(*const IPipeDouble, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeDouble_Push(self: *const T, buf: [*]f64, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeDouble.VTable, self.vtable).Push(@ptrCast(*const IPipeDouble, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeDouble_Value = @import("../zig.zig").Guid.initString("db2f3acf-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeDouble = &IID_AsyncIPipeDouble_Value;
pub const AsyncIPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeDouble,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeDouble,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeDouble, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Finish_Pull(self: *const T, buf: [*]f64, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeDouble, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Begin_Push(self: *const T, buf: [*]f64, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeDouble, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeDouble, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APTTYPEQUALIFIER = enum(i32) {
    NONE = 0,
    IMPLICIT_MTA = 1,
    NA_ON_MTA = 2,
    NA_ON_STA = 3,
    NA_ON_IMPLICIT_MTA = 4,
    NA_ON_MAINSTA = 5,
    APPLICATION_STA = 6,
    RESERVED_1 = 7,
};
pub const APTTYPEQUALIFIER_NONE = APTTYPEQUALIFIER.NONE;
pub const APTTYPEQUALIFIER_IMPLICIT_MTA = APTTYPEQUALIFIER.IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MTA = APTTYPEQUALIFIER.NA_ON_MTA;
pub const APTTYPEQUALIFIER_NA_ON_STA = APTTYPEQUALIFIER.NA_ON_STA;
pub const APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = APTTYPEQUALIFIER.NA_ON_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MAINSTA = APTTYPEQUALIFIER.NA_ON_MAINSTA;
pub const APTTYPEQUALIFIER_APPLICATION_STA = APTTYPEQUALIFIER.APPLICATION_STA;
pub const APTTYPEQUALIFIER_RESERVED_1 = APTTYPEQUALIFIER.RESERVED_1;

pub const APTTYPE = enum(i32) {
    CURRENT = -1,
    STA = 0,
    MTA = 1,
    NA = 2,
    MAINSTA = 3,
};
pub const APTTYPE_CURRENT = APTTYPE.CURRENT;
pub const APTTYPE_STA = APTTYPE.STA;
pub const APTTYPE_MTA = APTTYPE.MTA;
pub const APTTYPE_NA = APTTYPE.NA;
pub const APTTYPE_MAINSTA = APTTYPE.MAINSTA;

pub const THDTYPE = enum(i32) {
    BLOCKMESSAGES = 0,
    PROCESSMESSAGES = 1,
};
pub const THDTYPE_BLOCKMESSAGES = THDTYPE.BLOCKMESSAGES;
pub const THDTYPE_PROCESSMESSAGES = THDTYPE.PROCESSMESSAGES;

// TODO: this type is limited to platform 'windows5.0'
const IID_IComThreadingInfo_Value = @import("../zig.zig").Guid.initString("000001ce-0000-0000-c000-000000000046");
pub const IID_IComThreadingInfo = &IID_IComThreadingInfo_Value;
pub const IComThreadingInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentApartmentType: fn(
            self: *const IComThreadingInfo,
            pAptType: ?*APTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadType: fn(
            self: *const IComThreadingInfo,
            pThreadType: ?*THDTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLogicalThreadId: fn(
            self: *const IComThreadingInfo,
            pguidLogicalThreadId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentLogicalThreadId: fn(
            self: *const IComThreadingInfo,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentApartmentType(self: *const T, pAptType: ?*APTTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentApartmentType(@ptrCast(*const IComThreadingInfo, self), pAptType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentThreadType(self: *const T, pThreadType: ?*THDTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentThreadType(@ptrCast(*const IComThreadingInfo, self), pThreadType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentLogicalThreadId(self: *const T, pguidLogicalThreadId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentLogicalThreadId(@ptrCast(*const IComThreadingInfo, self), pguidLogicalThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_SetCurrentLogicalThreadId(self: *const T, rguid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).SetCurrentLogicalThreadId(@ptrCast(*const IComThreadingInfo, self), rguid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessInitControl_Value = @import("../zig.zig").Guid.initString("72380d55-8d2b-43a3-8513-2b6ef31434e9");
pub const IID_IProcessInitControl = &IID_IProcessInitControl_Value;
pub const IProcessInitControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetInitializerTimeout: fn(
            self: *const IProcessInitControl,
            dwSecondsRemaining: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessInitControl_ResetInitializerTimeout(self: *const T, dwSecondsRemaining: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessInitControl.VTable, self.vtable).ResetInitializerTimeout(@ptrCast(*const IProcessInitControl, self), dwSecondsRemaining);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFastRundown_Value = @import("../zig.zig").Guid.initString("00000040-0000-0000-c000-000000000046");
pub const IID_IFastRundown = &IID_IFastRundown_Value;
pub const IFastRundown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = enum(i32) {
    SOURCE_IS_APP_CONTAINER = 0,
    CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
    CONTEXT_ATTRIBUTE_RESERVED_18 = -2147483631,
};
pub const CO_MARSHALING_SOURCE_IS_APP_CONTAINER = CO_MARSHALING_CONTEXT_ATTRIBUTES.SOURCE_IS_APP_CONTAINER;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_1;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_2;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_3;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_4;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_5;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_6;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_7;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_8;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_9;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_10;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_11;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_12;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_13;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_14;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_15;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_16;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_17;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_18;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMarshalingStream_Value = @import("../zig.zig").Guid.initString("d8f2f5e6-6102-4863-9f26-389a4676efde");
pub const IID_IMarshalingStream = &IID_IMarshalingStream_Value;
pub const IMarshalingStream = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        GetMarshalingContextAttribute: fn(
            self: *const IMarshalingStream,
            attribute: CO_MARSHALING_CONTEXT_ATTRIBUTES,
            pAttributeValue: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarshalingStream_GetMarshalingContextAttribute(self: *const T, attribute: CO_MARSHALING_CONTEXT_ATTRIBUTES, pAttributeValue: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarshalingStream.VTable, self.vtable).GetMarshalingContextAttribute(@ptrCast(*const IMarshalingStream, self), attribute, pAttributeValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMallocSpy_Value = @import("../zig.zig").Guid.initString("0000001d-0000-0000-c000-000000000046");
pub const IID_IMallocSpy = &IID_IMallocSpy_Value;
pub const IMallocSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreAlloc: fn(
            self: *const IMallocSpy,
            cbRequest: usize,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostAlloc: fn(
            self: *const IMallocSpy,
            pActual: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        PreFree: fn(
            self: *const IMallocSpy,
            pRequest: ?*c_void,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        PostFree: fn(
            self: *const IMallocSpy,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PreRealloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*c_void,
            cbRequest: usize,
            ppNewRequest: ?*?*c_void,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostRealloc: fn(
            self: *const IMallocSpy,
            pActual: ?*c_void,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        PreGetSize: fn(
            self: *const IMallocSpy,
            pRequest: ?*c_void,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        PostGetSize: fn(
            self: *const IMallocSpy,
            cbActual: usize,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PreDidAlloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*c_void,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        PostDidAlloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*c_void,
            fSpyed: BOOL,
            fActual: i32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        PreHeapMinimize: fn(
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PostHeapMinimize: fn(
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreAlloc(self: *const T, cbRequest: usize) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreAlloc(@ptrCast(*const IMallocSpy, self), cbRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostAlloc(self: *const T, pActual: ?*c_void) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostAlloc(@ptrCast(*const IMallocSpy, self), pActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreFree(self: *const T, pRequest: ?*c_void, fSpyed: BOOL) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreFree(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostFree(self: *const T, fSpyed: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostFree(@ptrCast(*const IMallocSpy, self), fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreRealloc(self: *const T, pRequest: ?*c_void, cbRequest: usize, ppNewRequest: ?*?*c_void, fSpyed: BOOL) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreRealloc(@ptrCast(*const IMallocSpy, self), pRequest, cbRequest, ppNewRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostRealloc(self: *const T, pActual: ?*c_void, fSpyed: BOOL) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostRealloc(@ptrCast(*const IMallocSpy, self), pActual, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreGetSize(self: *const T, pRequest: ?*c_void, fSpyed: BOOL) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreGetSize(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostGetSize(self: *const T, cbActual: usize, fSpyed: BOOL) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostGetSize(@ptrCast(*const IMallocSpy, self), cbActual, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreDidAlloc(self: *const T, pRequest: ?*c_void, fSpyed: BOOL) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreDidAlloc(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostDidAlloc(self: *const T, pRequest: ?*c_void, fSpyed: BOOL, fActual: i32) callconv(.Inline) i32 {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostDidAlloc(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed, fActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreHeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreHeapMinimize(@ptrCast(*const IMallocSpy, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostHeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostHeapMinimize(@ptrCast(*const IMallocSpy, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BIND_OPTS = extern struct {
    cbStruct: u32,
    grfFlags: u32,
    grfMode: u32,
    dwTickCountDeadline: u32,
};

pub const BIND_OPTS2 = extern struct {
    __AnonymousBase_objidl_L8479_C36: BIND_OPTS,
    dwTrackFlags: u32,
    dwClassContext: u32,
    locale: u32,
    pServerInfo: ?*COSERVERINFO,
};

pub const BIND_OPTS3 = extern struct {
    __AnonymousBase_objidl_L8503_C36: BIND_OPTS2,
    hwnd: ?HWND,
};

pub const BIND_FLAGS = enum(i32) {
    MAYBOTHERUSER = 1,
    JUSTTESTEXISTENCE = 2,
};
pub const BIND_MAYBOTHERUSER = BIND_FLAGS.MAYBOTHERUSER;
pub const BIND_JUSTTESTEXISTENCE = BIND_FLAGS.JUSTTESTEXISTENCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBindCtx_Value = @import("../zig.zig").Guid.initString("0000000e-0000-0000-c000-000000000046");
pub const IID_IBindCtx = &IID_IBindCtx_Value;
pub const IBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObjectBound: fn(
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectBound: fn(
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBoundObjects: fn(
            self: *const IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBindOptions: fn(
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindOptions: fn(
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningObjectTable: fn(
            self: *const IBindCtx,
            pprot: ?*?*IRunningObjectTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumObjectParam: fn(
            self: *const IBindCtx,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RegisterObjectBound(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RegisterObjectBound(@ptrCast(*const IBindCtx, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RevokeObjectBound(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RevokeObjectBound(@ptrCast(*const IBindCtx, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_ReleaseBoundObjects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).ReleaseBoundObjects(@ptrCast(*const IBindCtx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_SetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).SetBindOptions(@ptrCast(*const IBindCtx, self), pbindopts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetBindOptions(@ptrCast(*const IBindCtx, self), pbindopts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetRunningObjectTable(self: *const T, pprot: ?*?*IRunningObjectTable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetRunningObjectTable(@ptrCast(*const IBindCtx, self), pprot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RegisterObjectParam(self: *const T, pszKey: ?PWSTR, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RegisterObjectParam(@ptrCast(*const IBindCtx, self), pszKey, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetObjectParam(self: *const T, pszKey: ?PWSTR, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetObjectParam(@ptrCast(*const IBindCtx, self), pszKey, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_EnumObjectParam(self: *const T, ppenum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).EnumObjectParam(@ptrCast(*const IBindCtx, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RevokeObjectParam(self: *const T, pszKey: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RevokeObjectParam(@ptrCast(*const IBindCtx, self), pszKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMoniker_Value = @import("../zig.zig").Guid.initString("00000102-0000-0000-c000-000000000046");
pub const IID_IEnumMoniker = &IID_IEnumMoniker_Value;
pub const IEnumMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMoniker,
            celt: u32,
            rgelt: [*]?*IMoniker,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMoniker,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMoniker,
            ppenum: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Next(self: *const T, celt: u32, rgelt: [*]?*IMoniker, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Next(@ptrCast(*const IEnumMoniker, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Skip(@ptrCast(*const IEnumMoniker, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Reset(@ptrCast(*const IEnumMoniker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Clone(self: *const T, ppenum: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Clone(@ptrCast(*const IEnumMoniker, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableObject_Value = @import("../zig.zig").Guid.initString("00000126-0000-0000-c000-000000000046");
pub const IID_IRunnableObject = &IID_IRunnableObject_Value;
pub const IRunnableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRunningClass: fn(
            self: *const IRunnableObject,
            lpClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IRunnableObject,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IRunnableObject,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        LockRunning: fn(
            self: *const IRunnableObject,
            fLock: BOOL,
            fLastUnlockCloses: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContainedObject: fn(
            self: *const IRunnableObject,
            fContained: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_GetRunningClass(self: *const T, lpClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).GetRunningClass(@ptrCast(*const IRunnableObject, self), lpClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_Run(self: *const T, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).Run(@ptrCast(*const IRunnableObject, self), pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_IsRunning(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).IsRunning(@ptrCast(*const IRunnableObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_LockRunning(self: *const T, fLock: BOOL, fLastUnlockCloses: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).LockRunning(@ptrCast(*const IRunnableObject, self), fLock, fLastUnlockCloses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_SetContainedObject(self: *const T, fContained: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).SetContainedObject(@ptrCast(*const IRunnableObject, self), fContained);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunningObjectTable_Value = @import("../zig.zig").Guid.initString("00000010-0000-0000-c000-000000000046");
pub const IID_IRunningObjectTable = &IID_IRunningObjectTable_Value;
pub const IRunningObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IRunningObjectTable,
            grfFlags: u32,
            punkObject: ?*IUnknown,
            pmkObjectName: ?*IMoniker,
            pdwRegister: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revoke: fn(
            self: *const IRunningObjectTable,
            dwRegister: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
            ppunkObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NoteChangeTime: fn(
            self: *const IRunningObjectTable,
            dwRegister: u32,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRunning: fn(
            self: *const IRunningObjectTable,
            ppenumMoniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_Register(self: *const T, grfFlags: u32, punkObject: ?*IUnknown, pmkObjectName: ?*IMoniker, pdwRegister: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).Register(@ptrCast(*const IRunningObjectTable, self), grfFlags, punkObject, pmkObjectName, pdwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_Revoke(self: *const T, dwRegister: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).Revoke(@ptrCast(*const IRunningObjectTable, self), dwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_IsRunning(self: *const T, pmkObjectName: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).IsRunning(@ptrCast(*const IRunningObjectTable, self), pmkObjectName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_GetObject(self: *const T, pmkObjectName: ?*IMoniker, ppunkObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).GetObject(@ptrCast(*const IRunningObjectTable, self), pmkObjectName, ppunkObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_NoteChangeTime(self: *const T, dwRegister: u32, pfiletime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).NoteChangeTime(@ptrCast(*const IRunningObjectTable, self), dwRegister, pfiletime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_GetTimeOfLastChange(self: *const T, pmkObjectName: ?*IMoniker, pfiletime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).GetTimeOfLastChange(@ptrCast(*const IRunningObjectTable, self), pmkObjectName, pfiletime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_EnumRunning(self: *const T, ppenumMoniker: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).EnumRunning(@ptrCast(*const IRunningObjectTable, self), ppenumMoniker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersist_Value = @import("../zig.zig").Guid.initString("0000010c-0000-0000-c000-000000000046");
pub const IID_IPersist = &IID_IPersist_Value;
pub const IPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: fn(
            self: *const IPersist,
            pClassID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersist_GetClassID(self: *const T, pClassID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersist.VTable, self.vtable).GetClassID(@ptrCast(*const IPersist, self), pClassID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStream_Value = @import("../zig.zig").Guid.initString("00000109-0000-0000-c000-000000000046");
pub const IID_IPersistStream = &IID_IPersistStream_Value;
pub const IPersistStream = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistStream,
            pStm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistStream,
            pStm: ?*IStream,
            fClearDirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistStream,
            pcbSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_Load(self: *const T, pStm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).Load(@ptrCast(*const IPersistStream, self), pStm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).Save(@ptrCast(*const IPersistStream, self), pStm, fClearDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_GetSizeMax(self: *const T, pcbSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistStream, self), pcbSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MKSYS = enum(i32) {
    NONE = 0,
    GENERICCOMPOSITE = 1,
    FILEMONIKER = 2,
    ANTIMONIKER = 3,
    ITEMMONIKER = 4,
    POINTERMONIKER = 5,
    CLASSMONIKER = 7,
    OBJREFMONIKER = 8,
    SESSIONMONIKER = 9,
    LUAMONIKER = 10,
};
pub const MKSYS_NONE = MKSYS.NONE;
pub const MKSYS_GENERICCOMPOSITE = MKSYS.GENERICCOMPOSITE;
pub const MKSYS_FILEMONIKER = MKSYS.FILEMONIKER;
pub const MKSYS_ANTIMONIKER = MKSYS.ANTIMONIKER;
pub const MKSYS_ITEMMONIKER = MKSYS.ITEMMONIKER;
pub const MKSYS_POINTERMONIKER = MKSYS.POINTERMONIKER;
pub const MKSYS_CLASSMONIKER = MKSYS.CLASSMONIKER;
pub const MKSYS_OBJREFMONIKER = MKSYS.OBJREFMONIKER;
pub const MKSYS_SESSIONMONIKER = MKSYS.SESSIONMONIKER;
pub const MKSYS_LUAMONIKER = MKSYS.LUAMONIKER;

pub const MKREDUCE = enum(i32) {
    ONE = 196608,
    TOUSER = 131072,
    THROUGHUSER = 65536,
    ALL = 0,
};
pub const MKRREDUCE_ONE = MKREDUCE.ONE;
pub const MKRREDUCE_TOUSER = MKREDUCE.TOUSER;
pub const MKRREDUCE_THROUGHUSER = MKREDUCE.THROUGHUSER;
pub const MKRREDUCE_ALL = MKREDUCE.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMoniker_Value = @import("../zig.zig").Guid.initString("0000000f-0000-0000-c000-000000000046");
pub const IID_IMoniker = &IID_IMoniker_Value;
pub const IMoniker = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        BindToObject: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            riidResult: ?*const Guid,
            ppvResult: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStorage: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reduce: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            dwReduceHowFar: u32,
            ppmkToLeft: ?*?*IMoniker,
            ppmkReduced: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposeWith: fn(
            self: *const IMoniker,
            pmkRight: ?*IMoniker,
            fOnlyIfNotGeneric: BOOL,
            ppmkComposite: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: fn(
            self: *const IMoniker,
            fForward: BOOL,
            ppenumMoniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IMoniker,
            pmkOtherMoniker: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: fn(
            self: *const IMoniker,
            pdwHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pmkNewlyRunning: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pFileTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Inverse: fn(
            self: *const IMoniker,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommonPrefixWith: fn(
            self: *const IMoniker,
            pmkOther: ?*IMoniker,
            ppmkPrefix: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RelativePathTo: fn(
            self: *const IMoniker,
            pmkOther: ?*IMoniker,
            ppmkRelPath: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            ppszDisplayName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseDisplayName: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pszDisplayName: ?PWSTR,
            pchEaten: ?*u32,
            ppmkOut: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSystemMoniker: fn(
            self: *const IMoniker,
            pdwMksys: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_BindToObject(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riidResult: ?*const Guid, ppvResult: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).BindToObject(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, riidResult, ppvResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_BindToStorage(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riid: ?*const Guid, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).BindToStorage(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Reduce(self: *const T, pbc: ?*IBindCtx, dwReduceHowFar: u32, ppmkToLeft: ?*?*IMoniker, ppmkReduced: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Reduce(@ptrCast(*const IMoniker, self), pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_ComposeWith(self: *const T, pmkRight: ?*IMoniker, fOnlyIfNotGeneric: BOOL, ppmkComposite: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).ComposeWith(@ptrCast(*const IMoniker, self), pmkRight, fOnlyIfNotGeneric, ppmkComposite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Enum(self: *const T, fForward: BOOL, ppenumMoniker: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Enum(@ptrCast(*const IMoniker, self), fForward, ppenumMoniker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsEqual(self: *const T, pmkOtherMoniker: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsEqual(@ptrCast(*const IMoniker, self), pmkOtherMoniker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Hash(self: *const T, pdwHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Hash(@ptrCast(*const IMoniker, self), pdwHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsRunning(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pmkNewlyRunning: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsRunning(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pmkNewlyRunning);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_GetTimeOfLastChange(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pFileTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).GetTimeOfLastChange(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pFileTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Inverse(self: *const T, ppmk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Inverse(@ptrCast(*const IMoniker, self), ppmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_CommonPrefixWith(self: *const T, pmkOther: ?*IMoniker, ppmkPrefix: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).CommonPrefixWith(@ptrCast(*const IMoniker, self), pmkOther, ppmkPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_RelativePathTo(self: *const T, pmkOther: ?*IMoniker, ppmkRelPath: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).RelativePathTo(@ptrCast(*const IMoniker, self), pmkOther, ppmkRelPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_GetDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, ppszDisplayName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).GetDisplayName(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, ppszDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_ParseDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppmkOut: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).ParseDisplayName(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pszDisplayName, pchEaten, ppmkOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsSystemMoniker(self: *const T, pdwMksys: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsSystemMoniker(@ptrCast(*const IMoniker, self), pdwMksys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IROTData_Value = @import("../zig.zig").Guid.initString("f29f6bc0-5021-11ce-aa15-00006901293f");
pub const IID_IROTData = &IID_IROTData_Value;
pub const IROTData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetComparisonData: fn(
            self: *const IROTData,
            pbData: [*:0]u8,
            cbMax: u32,
            pcbData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IROTData_GetComparisonData(self: *const T, pbData: [*:0]u8, cbMax: u32, pcbData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IROTData.VTable, self.vtable).GetComparisonData(@ptrCast(*const IROTData, self), pbData, cbMax, pcbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFile_Value = @import("../zig.zig").Guid.initString("0000010b-0000-0000-c000-000000000046");
pub const IID_IPersistFile = &IID_IPersistFile_Value;
pub const IPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
            dwMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
            fRemember: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: fn(
            self: *const IPersistFile,
            ppszFileName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistFile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_Load(self: *const T, pszFileName: ?[*:0]const u16, dwMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).Load(@ptrCast(*const IPersistFile, self), pszFileName, dwMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_Save(self: *const T, pszFileName: ?[*:0]const u16, fRemember: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).Save(@ptrCast(*const IPersistFile, self), pszFileName, fRemember);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_SaveCompleted(self: *const T, pszFileName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).SaveCompleted(@ptrCast(*const IPersistFile, self), pszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).GetCurFile(@ptrCast(*const IPersistFile, self), ppszFileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStorage_Value = @import("../zig.zig").Guid.initString("0000010a-0000-0000-c000-000000000046");
pub const IID_IPersistStorage = &IID_IPersistStorage_Value;
pub const IPersistStorage = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: fn(
            self: *const IPersistStorage,
            pStg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistStorage,
            pStg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistStorage,
            pStgSave: ?*IStorage,
            fSameAsLoad: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IPersistStorage,
            pStgNew: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: fn(
            self: *const IPersistStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistStorage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_InitNew(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).InitNew(@ptrCast(*const IPersistStorage, self), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Load(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).Load(@ptrCast(*const IPersistStorage, self), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Save(self: *const T, pStgSave: ?*IStorage, fSameAsLoad: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).Save(@ptrCast(*const IPersistStorage, self), pStgSave, fSameAsLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_SaveCompleted(self: *const T, pStgNew: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).SaveCompleted(@ptrCast(*const IPersistStorage, self), pStgNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_HandsOffStorage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStorage.VTable, self.vtable).HandsOffStorage(@ptrCast(*const IPersistStorage, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVTARGETDEVICE = extern struct {
    tdSize: u32,
    tdDriverNameOffset: u16,
    tdDeviceNameOffset: u16,
    tdPortNameOffset: u16,
    tdExtDevmodeOffset: u16,
    tdData: [1]u8,
};

pub const FORMATETC = extern struct {
    cfFormat: u16,
    ptd: ?*DVTARGETDEVICE,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFORMATETC_Value = @import("../zig.zig").Guid.initString("00000103-0000-0000-c000-000000000046");
pub const IID_IEnumFORMATETC = &IID_IEnumFORMATETC_Value;
pub const IEnumFORMATETC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumFORMATETC,
            celt: u32,
            rgelt: [*]FORMATETC,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumFORMATETC,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumFORMATETC,
            ppenum: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Next(self: *const T, celt: u32, rgelt: [*]FORMATETC, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Next(@ptrCast(*const IEnumFORMATETC, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Skip(@ptrCast(*const IEnumFORMATETC, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Reset(@ptrCast(*const IEnumFORMATETC, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Clone(self: *const T, ppenum: ?*?*IEnumFORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Clone(@ptrCast(*const IEnumFORMATETC, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ADVF = enum(i32) {
    _NODATA = 1,
    _PRIMEFIRST = 2,
    _ONLYONCE = 4,
    _DATAONSTOP = 64,
    CACHE_NOHANDLER = 8,
    CACHE_FORCEBUILTIN = 16,
    CACHE_ONSAVE = 32,
};
pub const ADVF_NODATA = ADVF._NODATA;
pub const ADVF_PRIMEFIRST = ADVF._PRIMEFIRST;
pub const ADVF_ONLYONCE = ADVF._ONLYONCE;
pub const ADVF_DATAONSTOP = ADVF._DATAONSTOP;
pub const ADVFCACHE_NOHANDLER = ADVF.CACHE_NOHANDLER;
pub const ADVFCACHE_FORCEBUILTIN = ADVF.CACHE_FORCEBUILTIN;
pub const ADVFCACHE_ONSAVE = ADVF.CACHE_ONSAVE;

pub const STATDATA = extern struct {
    formatetc: FORMATETC,
    advf: u32,
    pAdvSink: ?*IAdviseSink,
    dwConnection: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATDATA_Value = @import("../zig.zig").Guid.initString("00000105-0000-0000-c000-000000000046");
pub const IID_IEnumSTATDATA = &IID_IEnumSTATDATA_Value;
pub const IEnumSTATDATA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSTATDATA,
            celt: u32,
            rgelt: [*]STATDATA,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSTATDATA,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSTATDATA,
            ppenum: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Next(self: *const T, celt: u32, rgelt: [*]STATDATA, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Next(@ptrCast(*const IEnumSTATDATA, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Skip(@ptrCast(*const IEnumSTATDATA, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Reset(@ptrCast(*const IEnumSTATDATA, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Clone(self: *const T, ppenum: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Clone(@ptrCast(*const IEnumSTATDATA, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TYMED = enum(i32) {
    HGLOBAL = 1,
    FILE = 2,
    ISTREAM = 4,
    ISTORAGE = 8,
    GDI = 16,
    MFPICT = 32,
    ENHMF = 64,
    NULL = 0,
};
pub const TYMED_HGLOBAL = TYMED.HGLOBAL;
pub const TYMED_FILE = TYMED.FILE;
pub const TYMED_ISTREAM = TYMED.ISTREAM;
pub const TYMED_ISTORAGE = TYMED.ISTORAGE;
pub const TYMED_GDI = TYMED.GDI;
pub const TYMED_MFPICT = TYMED.MFPICT;
pub const TYMED_ENHMF = TYMED.ENHMF;
pub const TYMED_NULL = TYMED.NULL;

pub const RemSTGMEDIUM = extern struct {
    tymed: u32,
    dwHandleType: u32,
    pData: u32,
    pUnkForRelease: u32,
    cbData: u32,
    data: [1]u8,
};

pub const STGMEDIUM = extern struct {
    tymed: u32,
    Anonymous: extern union {
        hBitmap: ?HBITMAP,
        hMetaFilePict: ?*c_void,
        hEnhMetaFile: ?HENHMETAFILE,
        hGlobal: isize,
        lpszFileName: ?PWSTR,
        pstm: ?*IStream,
        pstg: ?*IStorage,
    },
    pUnkForRelease: ?*IUnknown,
};

pub const GDI_OBJECT = extern struct {
    ObjectType: u32,
    u: extern struct {
        hBitmap: ?*userHBITMAP,
        hPalette: ?*userHPALETTE,
        hGeneric: ?*userHGLOBAL,
    },
};

pub const userSTGMEDIUM = extern struct {
    pub const _STGMEDIUM_UNION = extern struct {
        tymed: u32,
        u: extern struct {
            hMetaFilePict: ?*userHMETAFILEPICT,
            hHEnhMetaFile: ?*userHENHMETAFILE,
            hGdiHandle: ?*GDI_OBJECT,
            hGlobal: ?*userHGLOBAL,
            lpszFileName: ?PWSTR,
            pstm: ?*BYTE_BLOB,
            pstg: ?*BYTE_BLOB,
        },
    };
    pUnkForRelease: ?*IUnknown,
};

pub const userFLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: userSTGMEDIUM,
};

pub const FLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: STGMEDIUM,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink_Value = @import("../zig.zig").Guid.initString("0000010f-0000-0000-c000-000000000046");
pub const IID_IAdviseSink = &IID_IAdviseSink_Value;
pub const IAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataChange: fn(
            self: *const IAdviseSink,
            pFormatetc: ?*FORMATETC,
            pStgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnViewChange: fn(
            self: *const IAdviseSink,
            dwAspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnRename: fn(
            self: *const IAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSave: fn(
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnClose: fn(
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnDataChange(@ptrCast(*const IAdviseSink, self), pFormatetc, pStgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnViewChange(@ptrCast(*const IAdviseSink, self), dwAspect, lindex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnRename(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnRename(@ptrCast(*const IAdviseSink, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnSave(@ptrCast(*const IAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnClose(@ptrCast(*const IAdviseSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink_Value = @import("../zig.zig").Guid.initString("00000150-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink = &IID_AsyncIAdviseSink_Value;
pub const AsyncIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_OnDataChange: fn(
            self: *const AsyncIAdviseSink,
            pFormatetc: ?*FORMATETC,
            pStgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnDataChange: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnViewChange: fn(
            self: *const AsyncIAdviseSink,
            dwAspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnViewChange: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnRename: fn(
            self: *const AsyncIAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnRename: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnSave: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnSave: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnClose: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnClose: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnDataChange(@ptrCast(*const AsyncIAdviseSink, self), pFormatetc, pStgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnDataChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnDataChange(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnViewChange(@ptrCast(*const AsyncIAdviseSink, self), dwAspect, lindex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnViewChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnViewChange(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnRename(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnRename(@ptrCast(*const AsyncIAdviseSink, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnRename(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnRename(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnSave(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnSave(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnClose(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnClose(@ptrCast(*const AsyncIAdviseSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink2_Value = @import("../zig.zig").Guid.initString("00000125-0000-0000-c000-000000000046");
pub const IID_IAdviseSink2 = &IID_IAdviseSink2_Value;
pub const IAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnLinkSrcChange: fn(
            self: *const IAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAdviseSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink2_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink2.VTable, self.vtable).OnLinkSrcChange(@ptrCast(*const IAdviseSink2, self), pmk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink2_Value = @import("../zig.zig").Guid.initString("00000151-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink2 = &IID_AsyncIAdviseSink2_Value;
pub const AsyncIAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: AsyncIAdviseSink.VTable,
        Begin_OnLinkSrcChange: fn(
            self: *const AsyncIAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnLinkSrcChange: fn(
            self: *const AsyncIAdviseSink2,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace AsyncIAdviseSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink2_Begin_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink2.VTable, self.vtable).Begin_OnLinkSrcChange(@ptrCast(*const AsyncIAdviseSink2, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink2_Finish_OnLinkSrcChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink2.VTable, self.vtable).Finish_OnLinkSrcChange(@ptrCast(*const AsyncIAdviseSink2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DATADIR = enum(i32) {
    GET = 1,
    SET = 2,
};
pub const DATADIR_GET = DATADIR.GET;
pub const DATADIR_SET = DATADIR.SET;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataObject_Value = @import("../zig.zig").Guid.initString("0000010e-0000-0000-c000-000000000046");
pub const IID_IDataObject = &IID_IDataObject_Value;
pub const IDataObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IDataObject,
            pformatetcIn: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataHere: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryGetData: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCanonicalFormatEtc: fn(
            self: *const IDataObject,
            pformatectIn: ?*FORMATETC,
            pformatetcOut: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
            fRelease: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFormatEtc: fn(
            self: *const IDataObject,
            dwDirection: u32,
            ppenumFormatEtc: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DAdvise: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            advf: u32,
            pAdvSink: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DUnadvise: fn(
            self: *const IDataObject,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDAdvise: fn(
            self: *const IDataObject,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetData(self: *const T, pformatetcIn: ?*FORMATETC, pmedium: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetData(@ptrCast(*const IDataObject, self), pformatetcIn, pmedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetDataHere(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetDataHere(@ptrCast(*const IDataObject, self), pformatetc, pmedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_QueryGetData(self: *const T, pformatetc: ?*FORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).QueryGetData(@ptrCast(*const IDataObject, self), pformatetc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetCanonicalFormatEtc(self: *const T, pformatectIn: ?*FORMATETC, pformatetcOut: ?*FORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetCanonicalFormatEtc(@ptrCast(*const IDataObject, self), pformatectIn, pformatetcOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_SetData(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM, fRelease: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).SetData(@ptrCast(*const IDataObject, self), pformatetc, pmedium, fRelease);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_EnumFormatEtc(self: *const T, dwDirection: u32, ppenumFormatEtc: ?*?*IEnumFORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).EnumFormatEtc(@ptrCast(*const IDataObject, self), dwDirection, ppenumFormatEtc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_DAdvise(self: *const T, pformatetc: ?*FORMATETC, advf: u32, pAdvSink: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).DAdvise(@ptrCast(*const IDataObject, self), pformatetc, advf, pAdvSink, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_DUnadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).DUnadvise(@ptrCast(*const IDataObject, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_EnumDAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).EnumDAdvise(@ptrCast(*const IDataObject, self), ppenumAdvise);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataAdviseHolder_Value = @import("../zig.zig").Guid.initString("00000110-0000-0000-c000-000000000046");
pub const IID_IDataAdviseHolder = &IID_IDataAdviseHolder_Value;
pub const IDataAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const IDataAdviseHolder,
            pDataObject: ?*IDataObject,
            pFetc: ?*FORMATETC,
            advf: u32,
            pAdvise: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IDataAdviseHolder,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAdvise: fn(
            self: *const IDataAdviseHolder,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnDataChange: fn(
            self: *const IDataAdviseHolder,
            pDataObject: ?*IDataObject,
            dwReserved: u32,
            advf: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_Advise(self: *const T, pDataObject: ?*IDataObject, pFetc: ?*FORMATETC, advf: u32, pAdvise: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).Advise(@ptrCast(*const IDataAdviseHolder, self), pDataObject, pFetc, advf, pAdvise, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_Unadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).Unadvise(@ptrCast(*const IDataAdviseHolder, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).EnumAdvise(@ptrCast(*const IDataAdviseHolder, self), ppenumAdvise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_SendOnDataChange(self: *const T, pDataObject: ?*IDataObject, dwReserved: u32, advf: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).SendOnDataChange(@ptrCast(*const IDataAdviseHolder, self), pDataObject, dwReserved, advf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CALLTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
    ASYNC = 3,
    TOPLEVEL_CALLPENDING = 4,
    ASYNC_CALLPENDING = 5,
};
pub const CALLTYPE_TOPLEVEL = CALLTYPE.TOPLEVEL;
pub const CALLTYPE_NESTED = CALLTYPE.NESTED;
pub const CALLTYPE_ASYNC = CALLTYPE.ASYNC;
pub const CALLTYPE_TOPLEVEL_CALLPENDING = CALLTYPE.TOPLEVEL_CALLPENDING;
pub const CALLTYPE_ASYNC_CALLPENDING = CALLTYPE.ASYNC_CALLPENDING;

pub const SERVERCALL = enum(i32) {
    ISHANDLED = 0,
    REJECTED = 1,
    RETRYLATER = 2,
};
pub const SERVERCALL_ISHANDLED = SERVERCALL.ISHANDLED;
pub const SERVERCALL_REJECTED = SERVERCALL.REJECTED;
pub const SERVERCALL_RETRYLATER = SERVERCALL.RETRYLATER;

pub const PENDINGTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
};
pub const PENDINGTYPE_TOPLEVEL = PENDINGTYPE.TOPLEVEL;
pub const PENDINGTYPE_NESTED = PENDINGTYPE.NESTED;

pub const PENDINGMSG = enum(i32) {
    CANCELCALL = 0,
    WAITNOPROCESS = 1,
    WAITDEFPROCESS = 2,
};
pub const PENDINGMSG_CANCELCALL = PENDINGMSG.CANCELCALL;
pub const PENDINGMSG_WAITNOPROCESS = PENDINGMSG.WAITNOPROCESS;
pub const PENDINGMSG_WAITDEFPROCESS = PENDINGMSG.WAITDEFPROCESS;

pub const INTERFACEINFO = extern struct {
    pUnk: ?*IUnknown,
    iid: Guid,
    wMethod: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMessageFilter_Value = @import("../zig.zig").Guid.initString("00000016-0000-0000-c000-000000000046");
pub const IID_IMessageFilter = &IID_IMessageFilter_Value;
pub const IMessageFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleInComingCall: fn(
            self: *const IMessageFilter,
            dwCallType: u32,
            htaskCaller: ?HTASK,
            dwTickCount: u32,
            lpInterfaceInfo: ?*INTERFACEINFO,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        RetryRejectedCall: fn(
            self: *const IMessageFilter,
            htaskCallee: ?HTASK,
            dwTickCount: u32,
            dwRejectType: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        MessagePending: fn(
            self: *const IMessageFilter,
            htaskCallee: ?HTASK,
            dwTickCount: u32,
            dwPendingType: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_HandleInComingCall(self: *const T, dwCallType: u32, htaskCaller: ?HTASK, dwTickCount: u32, lpInterfaceInfo: ?*INTERFACEINFO) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).HandleInComingCall(@ptrCast(*const IMessageFilter, self), dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_RetryRejectedCall(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwRejectType: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).RetryRejectedCall(@ptrCast(*const IMessageFilter, self), htaskCallee, dwTickCount, dwRejectType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_MessagePending(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwPendingType: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).MessagePending(@ptrCast(*const IMessageFilter, self), htaskCallee, dwTickCount, dwPendingType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassActivator_Value = @import("../zig.zig").Guid.initString("00000140-0000-0000-c000-000000000046");
pub const IID_IClassActivator = &IID_IClassActivator_Value;
pub const IClassActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassObject: fn(
            self: *const IClassActivator,
            rclsid: ?*const Guid,
            dwClassContext: u32,
            locale: u32,
            riid: ?*const Guid,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassActivator_GetClassObject(self: *const T, rclsid: ?*const Guid, dwClassContext: u32, locale: u32, riid: ?*const Guid, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassActivator.VTable, self.vtable).GetClassObject(@ptrCast(*const IClassActivator, self), rclsid, dwClassContext, locale, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressNotify_Value = @import("../zig.zig").Guid.initString("a9d758a0-4617-11cf-95fc-00aa00680db4");
pub const IID_IProgressNotify = &IID_IProgressNotify_Value;
pub const IProgressNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnProgress: fn(
            self: *const IProgressNotify,
            dwProgressCurrent: u32,
            dwProgressMaximum: u32,
            fAccurate: BOOL,
            fOwner: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressNotify_OnProgress(self: *const T, dwProgressCurrent: u32, dwProgressMaximum: u32, fAccurate: BOOL, fOwner: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressNotify.VTable, self.vtable).OnProgress(@ptrCast(*const IProgressNotify, self), dwProgressCurrent, dwProgressMaximum, fAccurate, fOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBlockingLock_Value = @import("../zig.zig").Guid.initString("30f3d47a-6447-11d1-8e3c-00c04fb9386d");
pub const IID_IBlockingLock = &IID_IBlockingLock_Value;
pub const IBlockingLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: fn(
            self: *const IBlockingLock,
            dwTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlock: fn(
            self: *const IBlockingLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockingLock_Lock(self: *const T, dwTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockingLock.VTable, self.vtable).Lock(@ptrCast(*const IBlockingLock, self), dwTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockingLock_Unlock(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockingLock.VTable, self.vtable).Unlock(@ptrCast(*const IBlockingLock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimeAndNoticeControl_Value = @import("../zig.zig").Guid.initString("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4");
pub const IID_ITimeAndNoticeControl = &IID_ITimeAndNoticeControl_Value;
pub const ITimeAndNoticeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuppressChanges: fn(
            self: *const ITimeAndNoticeControl,
            res1: u32,
            res2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimeAndNoticeControl_SuppressChanges(self: *const T, res1: u32, res2: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITimeAndNoticeControl.VTable, self.vtable).SuppressChanges(@ptrCast(*const ITimeAndNoticeControl, self), res1, res2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOplockStorage_Value = @import("../zig.zig").Guid.initString("8d19c834-8879-11d1-83e9-00c04fc2c6d4");
pub const IID_IOplockStorage = &IID_IOplockStorage_Value;
pub const IOplockStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStorageEx: fn(
            self: *const IOplockStorage,
            pwcsName: ?[*:0]const u16,
            grfMode: u32,
            stgfmt: u32,
            grfAttrs: u32,
            riid: ?*const Guid,
            ppstgOpen: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStorageEx: fn(
            self: *const IOplockStorage,
            pwcsName: ?[*:0]const u16,
            grfMode: u32,
            stgfmt: u32,
            grfAttrs: u32,
            riid: ?*const Guid,
            ppstgOpen: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOplockStorage_CreateStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOplockStorage.VTable, self.vtable).CreateStorageEx(@ptrCast(*const IOplockStorage, self), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOplockStorage_OpenStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOplockStorage.VTable, self.vtable).OpenStorageEx(@ptrCast(*const IOplockStorage, self), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlMon_Value = @import("../zig.zig").Guid.initString("00000026-0000-0000-c000-000000000046");
pub const IID_IUrlMon = &IID_IUrlMon_Value;
pub const IUrlMon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsyncGetClassBits: fn(
            self: *const IUrlMon,
            rclsid: ?*const Guid,
            pszTYPE: ?[*:0]const u16,
            pszExt: ?[*:0]const u16,
            dwFileVersionMS: u32,
            dwFileVersionLS: u32,
            pszCodeBase: ?[*:0]const u16,
            pbc: ?*IBindCtx,
            dwClassContext: u32,
            riid: ?*const Guid,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlMon_AsyncGetClassBits(self: *const T, rclsid: ?*const Guid, pszTYPE: ?[*:0]const u16, pszExt: ?[*:0]const u16, dwFileVersionMS: u32, dwFileVersionLS: u32, pszCodeBase: ?[*:0]const u16, pbc: ?*IBindCtx, dwClassContext: u32, riid: ?*const Guid, flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlMon.VTable, self.vtable).AsyncGetClassBits(@ptrCast(*const IUrlMon, self), rclsid, pszTYPE, pszExt, dwFileVersionMS, dwFileVersionLS, pszCodeBase, pbc, dwClassContext, riid, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IForegroundTransfer_Value = @import("../zig.zig").Guid.initString("00000145-0000-0000-c000-000000000046");
pub const IID_IForegroundTransfer = &IID_IForegroundTransfer_Value;
pub const IForegroundTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowForegroundTransfer: fn(
            self: *const IForegroundTransfer,
            lpvReserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IForegroundTransfer_AllowForegroundTransfer(self: *const T, lpvReserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IForegroundTransfer.VTable, self.vtable).AllowForegroundTransfer(@ptrCast(*const IForegroundTransfer, self), lpvReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IThumbnailExtractor_Value = @import("../zig.zig").Guid.initString("969dc708-5c76-11d1-8d86-0000f804b057");
pub const IID_IThumbnailExtractor = &IID_IThumbnailExtractor_Value;
pub const IThumbnailExtractor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ExtractThumbnail: fn(
            self: *const IThumbnailExtractor,
            pStg: ?*IStorage,
            ulLength: u32,
            ulHeight: u32,
            pulOutputLength: ?*u32,
            pulOutputHeight: ?*u32,
            phOutputBitmap: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFileUpdated: fn(
            self: *const IThumbnailExtractor,
            pStg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailExtractor_ExtractThumbnail(self: *const T, pStg: ?*IStorage, ulLength: u32, ulHeight: u32, pulOutputLength: ?*u32, pulOutputHeight: ?*u32, phOutputBitmap: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailExtractor.VTable, self.vtable).ExtractThumbnail(@ptrCast(*const IThumbnailExtractor, self), pStg, ulLength, ulHeight, pulOutputLength, pulOutputHeight, phOutputBitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailExtractor_OnFileUpdated(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailExtractor.VTable, self.vtable).OnFileUpdated(@ptrCast(*const IThumbnailExtractor, self), pStg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDummyHICONIncluder_Value = @import("../zig.zig").Guid.initString("947990de-cc28-11d2-a0f7-00805f858fb1");
pub const IID_IDummyHICONIncluder = &IID_IDummyHICONIncluder_Value;
pub const IDummyHICONIncluder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Dummy: fn(
            self: *const IDummyHICONIncluder,
            h1: ?HICON,
            h2: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDummyHICONIncluder_Dummy(self: *const T, h1: ?HICON, h2: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDummyHICONIncluder.VTable, self.vtable).Dummy(@ptrCast(*const IDummyHICONIncluder, self), h1, h2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ApplicationType = enum(i32) {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const ServerApplication = ApplicationType.ServerApplication;
pub const LibraryApplication = ApplicationType.LibraryApplication;

pub const ShutdownType = enum(i32) {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const IdleShutdown = ShutdownType.IdleShutdown;
pub const ForcedShutdown = ShutdownType.ForcedShutdown;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessLock_Value = @import("../zig.zig").Guid.initString("000001d5-0000-0000-c000-000000000046");
pub const IID_IProcessLock = &IID_IProcessLock_Value;
pub const IProcessLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefOnProcess: fn(
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseRefOnProcess: fn(
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessLock_AddRefOnProcess(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IProcessLock.VTable, self.vtable).AddRefOnProcess(@ptrCast(*const IProcessLock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessLock_ReleaseRefOnProcess(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IProcessLock.VTable, self.vtable).ReleaseRefOnProcess(@ptrCast(*const IProcessLock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogateService_Value = @import("../zig.zig").Guid.initString("000001d4-0000-0000-c000-000000000046");
pub const IID_ISurrogateService = &IID_ISurrogateService_Value;
pub const ISurrogateService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const ISurrogateService,
            rguidProcessID: ?*const Guid,
            pProcessLock: ?*IProcessLock,
            pfApplicationAware: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationLaunch: fn(
            self: *const ISurrogateService,
            rguidApplID: ?*const Guid,
            appType: ApplicationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationFree: fn(
            self: *const ISurrogateService,
            rguidApplID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatalogRefresh: fn(
            self: *const ISurrogateService,
            ulReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessShutdown: fn(
            self: *const ISurrogateService,
            shutdownType: ShutdownType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_Init(self: *const T, rguidProcessID: ?*const Guid, pProcessLock: ?*IProcessLock, pfApplicationAware: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).Init(@ptrCast(*const ISurrogateService, self), rguidProcessID, pProcessLock, pfApplicationAware);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ApplicationLaunch(self: *const T, rguidApplID: ?*const Guid, appType: ApplicationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ApplicationLaunch(@ptrCast(*const ISurrogateService, self), rguidApplID, appType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ApplicationFree(self: *const T, rguidApplID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ApplicationFree(@ptrCast(*const ISurrogateService, self), rguidApplID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_CatalogRefresh(self: *const T, ulReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).CatalogRefresh(@ptrCast(*const ISurrogateService, self), ulReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ProcessShutdown(self: *const T, shutdownType: ShutdownType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ProcessShutdown(@ptrCast(*const ISurrogateService, self), shutdownType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInitializeSpy_Value = @import("../zig.zig").Guid.initString("00000034-0000-0000-c000-000000000046");
pub const IID_IInitializeSpy = &IID_IInitializeSpy_Value;
pub const IInitializeSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreInitialize: fn(
            self: *const IInitializeSpy,
            dwCoInit: u32,
            dwCurThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostInitialize: fn(
            self: *const IInitializeSpy,
            hrCoInit: HRESULT,
            dwCoInit: u32,
            dwNewThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUninitialize: fn(
            self: *const IInitializeSpy,
            dwCurThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUninitialize: fn(
            self: *const IInitializeSpy,
            dwNewThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PreInitialize(self: *const T, dwCoInit: u32, dwCurThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PreInitialize(@ptrCast(*const IInitializeSpy, self), dwCoInit, dwCurThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PostInitialize(self: *const T, hrCoInit: HRESULT, dwCoInit: u32, dwNewThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PostInitialize(@ptrCast(*const IInitializeSpy, self), hrCoInit, dwCoInit, dwNewThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PreUninitialize(self: *const T, dwCurThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PreUninitialize(@ptrCast(*const IInitializeSpy, self), dwCurThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PostUninitialize(self: *const T, dwNewThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PostUninitialize(@ptrCast(*const IInitializeSpy, self), dwNewThreadAptRefs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleAdviseHolder_Value = @import("../zig.zig").Guid.initString("00000111-0000-0000-c000-000000000046");
pub const IID_IOleAdviseHolder = &IID_IOleAdviseHolder_Value;
pub const IOleAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const IOleAdviseHolder,
            pAdvise: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IOleAdviseHolder,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAdvise: fn(
            self: *const IOleAdviseHolder,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnRename: fn(
            self: *const IOleAdviseHolder,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnSave: fn(
            self: *const IOleAdviseHolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnClose: fn(
            self: *const IOleAdviseHolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_Advise(self: *const T, pAdvise: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).Advise(@ptrCast(*const IOleAdviseHolder, self), pAdvise, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_Unadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).Unadvise(@ptrCast(*const IOleAdviseHolder, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).EnumAdvise(@ptrCast(*const IOleAdviseHolder, self), ppenumAdvise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_SendOnRename(self: *const T, pmk: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).SendOnRename(@ptrCast(*const IOleAdviseHolder, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_SendOnSave(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).SendOnSave(@ptrCast(*const IOleAdviseHolder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleAdviseHolder_SendOnClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleAdviseHolder.VTable, self.vtable).SendOnClose(@ptrCast(*const IOleAdviseHolder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCache_Value = @import("../zig.zig").Guid.initString("0000011e-0000-0000-c000-000000000046");
pub const IID_IOleCache = &IID_IOleCache_Value;
pub const IOleCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cache: fn(
            self: *const IOleCache,
            pformatetc: ?*FORMATETC,
            advf: u32,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uncache: fn(
            self: *const IOleCache,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCache: fn(
            self: *const IOleCache,
            ppenumSTATDATA: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitCache: fn(
            self: *const IOleCache,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: fn(
            self: *const IOleCache,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
            fRelease: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache_Cache(self: *const T, pformatetc: ?*FORMATETC, advf: u32, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache.VTable, self.vtable).Cache(@ptrCast(*const IOleCache, self), pformatetc, advf, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache_Uncache(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache.VTable, self.vtable).Uncache(@ptrCast(*const IOleCache, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache_EnumCache(self: *const T, ppenumSTATDATA: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache.VTable, self.vtable).EnumCache(@ptrCast(*const IOleCache, self), ppenumSTATDATA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache_InitCache(self: *const T, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache.VTable, self.vtable).InitCache(@ptrCast(*const IOleCache, self), pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache_SetData(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM, fRelease: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache.VTable, self.vtable).SetData(@ptrCast(*const IOleCache, self), pformatetc, pmedium, fRelease);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DISCARDCACHE = enum(i32) {
    SAVEIFDIRTY = 0,
    NOSAVE = 1,
};
pub const DISCARDCACHE_SAVEIFDIRTY = DISCARDCACHE.SAVEIFDIRTY;
pub const DISCARDCACHE_NOSAVE = DISCARDCACHE.NOSAVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCache2_Value = @import("../zig.zig").Guid.initString("00000128-0000-0000-c000-000000000046");
pub const IID_IOleCache2 = &IID_IOleCache2_Value;
pub const IOleCache2 = extern struct {
    pub const VTable = extern struct {
        base: IOleCache.VTable,
        UpdateCache: fn(
            self: *const IOleCache2,
            pDataObject: ?*IDataObject,
            grfUpdf: UPDFCACHE_FLAGS,
            pReserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardCache: fn(
            self: *const IOleCache2,
            dwDiscardOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleCache.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache2_UpdateCache(self: *const T, pDataObject: ?*IDataObject, grfUpdf: UPDFCACHE_FLAGS, pReserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache2.VTable, self.vtable).UpdateCache(@ptrCast(*const IOleCache2, self), pDataObject, grfUpdf, pReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCache2_DiscardCache(self: *const T, dwDiscardOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCache2.VTable, self.vtable).DiscardCache(@ptrCast(*const IOleCache2, self), dwDiscardOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCacheControl_Value = @import("../zig.zig").Guid.initString("00000129-0000-0000-c000-000000000046");
pub const IID_IOleCacheControl = &IID_IOleCacheControl_Value;
pub const IOleCacheControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRun: fn(
            self: *const IOleCacheControl,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStop: fn(
            self: *const IOleCacheControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCacheControl_OnRun(self: *const T, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCacheControl.VTable, self.vtable).OnRun(@ptrCast(*const IOleCacheControl, self), pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCacheControl_OnStop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCacheControl.VTable, self.vtable).OnStop(@ptrCast(*const IOleCacheControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IParseDisplayName_Value = @import("../zig.zig").Guid.initString("0000011a-0000-0000-c000-000000000046");
pub const IID_IParseDisplayName = &IID_IParseDisplayName_Value;
pub const IParseDisplayName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseDisplayName: fn(
            self: *const IParseDisplayName,
            pbc: ?*IBindCtx,
            pszDisplayName: ?PWSTR,
            pchEaten: ?*u32,
            ppmkOut: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParseDisplayName_ParseDisplayName(self: *const T, pbc: ?*IBindCtx, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppmkOut: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParseDisplayName.VTable, self.vtable).ParseDisplayName(@ptrCast(*const IParseDisplayName, self), pbc, pszDisplayName, pchEaten, ppmkOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleContainer_Value = @import("../zig.zig").Guid.initString("0000011b-0000-0000-c000-000000000046");
pub const IID_IOleContainer = &IID_IOleContainer_Value;
pub const IOleContainer = extern struct {
    pub const VTable = extern struct {
        base: IParseDisplayName.VTable,
        EnumObjects: fn(
            self: *const IOleContainer,
            grfFlags: u32,
            ppenum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockContainer: fn(
            self: *const IOleContainer,
            fLock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IParseDisplayName.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleContainer_EnumObjects(self: *const T, grfFlags: u32, ppenum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleContainer.VTable, self.vtable).EnumObjects(@ptrCast(*const IOleContainer, self), grfFlags, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleContainer_LockContainer(self: *const T, fLock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleContainer.VTable, self.vtable).LockContainer(@ptrCast(*const IOleContainer, self), fLock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleClientSite_Value = @import("../zig.zig").Guid.initString("00000118-0000-0000-c000-000000000046");
pub const IID_IOleClientSite = &IID_IOleClientSite_Value;
pub const IOleClientSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SaveObject: fn(
            self: *const IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMoniker: fn(
            self: *const IOleClientSite,
            dwAssign: u32,
            dwWhichMoniker: u32,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainer: fn(
            self: *const IOleClientSite,
            ppContainer: ?*?*IOleContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowObject: fn(
            self: *const IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnShowWindow: fn(
            self: *const IOleClientSite,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestNewObjectLayout: fn(
            self: *const IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_SaveObject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).SaveObject(@ptrCast(*const IOleClientSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_GetMoniker(self: *const T, dwAssign: u32, dwWhichMoniker: u32, ppmk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).GetMoniker(@ptrCast(*const IOleClientSite, self), dwAssign, dwWhichMoniker, ppmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_GetContainer(self: *const T, ppContainer: ?*?*IOleContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).GetContainer(@ptrCast(*const IOleClientSite, self), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_ShowObject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).ShowObject(@ptrCast(*const IOleClientSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_OnShowWindow(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).OnShowWindow(@ptrCast(*const IOleClientSite, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleClientSite_RequestNewObjectLayout(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleClientSite.VTable, self.vtable).RequestNewObjectLayout(@ptrCast(*const IOleClientSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEGETMONIKER = enum(i32) {
    ONLYIFTHERE = 1,
    FORCEASSIGN = 2,
    UNASSIGN = 3,
    TEMPFORUSER = 4,
};
pub const OLEGETMONIKER_ONLYIFTHERE = OLEGETMONIKER.ONLYIFTHERE;
pub const OLEGETMONIKER_FORCEASSIGN = OLEGETMONIKER.FORCEASSIGN;
pub const OLEGETMONIKER_UNASSIGN = OLEGETMONIKER.UNASSIGN;
pub const OLEGETMONIKER_TEMPFORUSER = OLEGETMONIKER.TEMPFORUSER;

pub const OLEWHICHMK = enum(i32) {
    CONTAINER = 1,
    OBJREL = 2,
    OBJFULL = 3,
};
pub const OLEWHICHMK_CONTAINER = OLEWHICHMK.CONTAINER;
pub const OLEWHICHMK_OBJREL = OLEWHICHMK.OBJREL;
pub const OLEWHICHMK_OBJFULL = OLEWHICHMK.OBJFULL;

pub const USERCLASSTYPE = enum(i32) {
    FULL = 1,
    SHORT = 2,
    APPNAME = 3,
};
pub const USERCLASSTYPE_FULL = USERCLASSTYPE.FULL;
pub const USERCLASSTYPE_SHORT = USERCLASSTYPE.SHORT;
pub const USERCLASSTYPE_APPNAME = USERCLASSTYPE.APPNAME;

pub const OLEMISC = enum(i32) {
    RECOMPOSEONRESIZE = 1,
    ONLYICONIC = 2,
    INSERTNOTREPLACE = 4,
    STATIC = 8,
    CANTLINKINSIDE = 16,
    CANLINKBYOLE1 = 32,
    ISLINKOBJECT = 64,
    INSIDEOUT = 128,
    ACTIVATEWHENVISIBLE = 256,
    RENDERINGISDEVICEINDEPENDENT = 512,
    INVISIBLEATRUNTIME = 1024,
    ALWAYSRUN = 2048,
    ACTSLIKEBUTTON = 4096,
    ACTSLIKELABEL = 8192,
    NOUIACTIVATE = 16384,
    ALIGNABLE = 32768,
    SIMPLEFRAME = 65536,
    SETCLIENTSITEFIRST = 131072,
    IMEMODE = 262144,
    IGNOREACTIVATEWHENVISIBLE = 524288,
    WANTSTOMENUMERGE = 1048576,
    SUPPORTSMULTILEVELUNDO = 2097152,
};
// TODO: enum 'OLEMISC' has known issues with its value aliases

pub const OLECLOSE = enum(i32) {
    SAVEIFDIRTY = 0,
    NOSAVE = 1,
    PROMPTSAVE = 2,
};
pub const OLECLOSE_SAVEIFDIRTY = OLECLOSE.SAVEIFDIRTY;
pub const OLECLOSE_NOSAVE = OLECLOSE.NOSAVE;
pub const OLECLOSE_PROMPTSAVE = OLECLOSE.PROMPTSAVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleObject_Value = @import("../zig.zig").Guid.initString("00000112-0000-0000-c000-000000000046");
pub const IID_IOleObject = &IID_IOleObject_Value;
pub const IOleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClientSite: fn(
            self: *const IOleObject,
            pClientSite: ?*IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientSite: fn(
            self: *const IOleObject,
            ppClientSite: ?*?*IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: fn(
            self: *const IOleObject,
            szContainerApp: ?[*:0]const u16,
            szContainerObj: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IOleObject,
            dwSaveOption: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMoniker: fn(
            self: *const IOleObject,
            dwWhichMoniker: u32,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMoniker: fn(
            self: *const IOleObject,
            dwAssign: u32,
            dwWhichMoniker: u32,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitFromData: fn(
            self: *const IOleObject,
            pDataObject: ?*IDataObject,
            fCreation: BOOL,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IOleObject,
            dwReserved: u32,
            ppDataObject: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoVerb: fn(
            self: *const IOleObject,
            iVerb: i32,
            lpmsg: ?*MSG,
            pActiveSite: ?*IOleClientSite,
            lindex: i32,
            hwndParent: ?HWND,
            lprcPosRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumVerbs: fn(
            self: *const IOleObject,
            ppEnumOleVerb: ?*?*IEnumOLEVERB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUpToDate: fn(
            self: *const IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserClassID: fn(
            self: *const IOleObject,
            pClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserType: fn(
            self: *const IOleObject,
            dwFormOfType: u32,
            pszUserType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtent: fn(
            self: *const IOleObject,
            dwDrawAspect: u32,
            psizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtent: fn(
            self: *const IOleObject,
            dwDrawAspect: u32,
            psizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IOleObject,
            pAdvSink: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IOleObject,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAdvise: fn(
            self: *const IOleObject,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMiscStatus: fn(
            self: *const IOleObject,
            dwAspect: u32,
            pdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorScheme: fn(
            self: *const IOleObject,
            pLogpal: ?*LOGPALETTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_SetClientSite(self: *const T, pClientSite: ?*IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).SetClientSite(@ptrCast(*const IOleObject, self), pClientSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetClientSite(self: *const T, ppClientSite: ?*?*IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetClientSite(@ptrCast(*const IOleObject, self), ppClientSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_SetHostNames(self: *const T, szContainerApp: ?[*:0]const u16, szContainerObj: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).SetHostNames(@ptrCast(*const IOleObject, self), szContainerApp, szContainerObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_Close(self: *const T, dwSaveOption: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).Close(@ptrCast(*const IOleObject, self), dwSaveOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_SetMoniker(self: *const T, dwWhichMoniker: u32, pmk: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).SetMoniker(@ptrCast(*const IOleObject, self), dwWhichMoniker, pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetMoniker(self: *const T, dwAssign: u32, dwWhichMoniker: u32, ppmk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetMoniker(@ptrCast(*const IOleObject, self), dwAssign, dwWhichMoniker, ppmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_InitFromData(self: *const T, pDataObject: ?*IDataObject, fCreation: BOOL, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).InitFromData(@ptrCast(*const IOleObject, self), pDataObject, fCreation, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetClipboardData(self: *const T, dwReserved: u32, ppDataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetClipboardData(@ptrCast(*const IOleObject, self), dwReserved, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_DoVerb(self: *const T, iVerb: i32, lpmsg: ?*MSG, pActiveSite: ?*IOleClientSite, lindex: i32, hwndParent: ?HWND, lprcPosRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).DoVerb(@ptrCast(*const IOleObject, self), iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_EnumVerbs(self: *const T, ppEnumOleVerb: ?*?*IEnumOLEVERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).EnumVerbs(@ptrCast(*const IOleObject, self), ppEnumOleVerb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_Update(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).Update(@ptrCast(*const IOleObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_IsUpToDate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).IsUpToDate(@ptrCast(*const IOleObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetUserClassID(self: *const T, pClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetUserClassID(@ptrCast(*const IOleObject, self), pClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetUserType(self: *const T, dwFormOfType: u32, pszUserType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetUserType(@ptrCast(*const IOleObject, self), dwFormOfType, pszUserType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_SetExtent(self: *const T, dwDrawAspect: u32, psizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).SetExtent(@ptrCast(*const IOleObject, self), dwDrawAspect, psizel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetExtent(self: *const T, dwDrawAspect: u32, psizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetExtent(@ptrCast(*const IOleObject, self), dwDrawAspect, psizel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_Advise(self: *const T, pAdvSink: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).Advise(@ptrCast(*const IOleObject, self), pAdvSink, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_Unadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).Unadvise(@ptrCast(*const IOleObject, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).EnumAdvise(@ptrCast(*const IOleObject, self), ppenumAdvise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_GetMiscStatus(self: *const T, dwAspect: u32, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).GetMiscStatus(@ptrCast(*const IOleObject, self), dwAspect, pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleObject_SetColorScheme(self: *const T, pLogpal: ?*LOGPALETTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleObject.VTable, self.vtable).SetColorScheme(@ptrCast(*const IOleObject, self), pLogpal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLERENDER = enum(i32) {
    NONE = 0,
    DRAW = 1,
    FORMAT = 2,
    ASIS = 3,
};
pub const OLERENDER_NONE = OLERENDER.NONE;
pub const OLERENDER_DRAW = OLERENDER.DRAW;
pub const OLERENDER_FORMAT = OLERENDER.FORMAT;
pub const OLERENDER_ASIS = OLERENDER.ASIS;

pub const OBJECTDESCRIPTOR = extern struct {
    cbSize: u32,
    clsid: Guid,
    dwDrawAspect: u32,
    sizel: SIZE,
    pointl: POINTL,
    dwStatus: u32,
    dwFullUserTypeName: u32,
    dwSrcOfCopy: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleWindow_Value = @import("../zig.zig").Guid.initString("00000114-0000-0000-c000-000000000046");
pub const IID_IOleWindow = &IID_IOleWindow_Value;
pub const IOleWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: fn(
            self: *const IOleWindow,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IOleWindow,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleWindow_GetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleWindow.VTable, self.vtable).GetWindow(@ptrCast(*const IOleWindow, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleWindow_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleWindow.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IOleWindow, self), fEnterMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUPDATE = enum(i32) {
    ALWAYS = 1,
    ONCALL = 3,
};
pub const OLEUPDATE_ALWAYS = OLEUPDATE.ALWAYS;
pub const OLEUPDATE_ONCALL = OLEUPDATE.ONCALL;

pub const OLELINKBIND = enum(i32) {
    F = 1,
};
pub const OLELINKBIND_EVENIFCLASSDIFF = OLELINKBIND.F;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleLink_Value = @import("../zig.zig").Guid.initString("0000011d-0000-0000-c000-000000000046");
pub const IID_IOleLink = &IID_IOleLink_Value;
pub const IOleLink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUpdateOptions: fn(
            self: *const IOleLink,
            dwUpdateOpt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateOptions: fn(
            self: *const IOleLink,
            pdwUpdateOpt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceMoniker: fn(
            self: *const IOleLink,
            pmk: ?*IMoniker,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceMoniker: fn(
            self: *const IOleLink,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceDisplayName: fn(
            self: *const IOleLink,
            pszStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceDisplayName: fn(
            self: *const IOleLink,
            ppszDisplayName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToSource: fn(
            self: *const IOleLink,
            bindflags: u32,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindIfRunning: fn(
            self: *const IOleLink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBoundSource: fn(
            self: *const IOleLink,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnbindSource: fn(
            self: *const IOleLink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IOleLink,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_SetUpdateOptions(self: *const T, dwUpdateOpt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).SetUpdateOptions(@ptrCast(*const IOleLink, self), dwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_GetUpdateOptions(self: *const T, pdwUpdateOpt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).GetUpdateOptions(@ptrCast(*const IOleLink, self), pdwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_SetSourceMoniker(self: *const T, pmk: ?*IMoniker, rclsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).SetSourceMoniker(@ptrCast(*const IOleLink, self), pmk, rclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_GetSourceMoniker(self: *const T, ppmk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).GetSourceMoniker(@ptrCast(*const IOleLink, self), ppmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_SetSourceDisplayName(self: *const T, pszStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).SetSourceDisplayName(@ptrCast(*const IOleLink, self), pszStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_GetSourceDisplayName(self: *const T, ppszDisplayName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).GetSourceDisplayName(@ptrCast(*const IOleLink, self), ppszDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_BindToSource(self: *const T, bindflags: u32, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).BindToSource(@ptrCast(*const IOleLink, self), bindflags, pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_BindIfRunning(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).BindIfRunning(@ptrCast(*const IOleLink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_GetBoundSource(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).GetBoundSource(@ptrCast(*const IOleLink, self), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_UnbindSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).UnbindSource(@ptrCast(*const IOleLink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleLink_Update(self: *const T, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleLink.VTable, self.vtable).Update(@ptrCast(*const IOleLink, self), pbc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDSPEED = enum(i32) {
    INDEFINITE = 1,
    MODERATE = 2,
    IMMEDIATE = 3,
};
pub const BINDSPEED_INDEFINITE = BINDSPEED.INDEFINITE;
pub const BINDSPEED_MODERATE = BINDSPEED.MODERATE;
pub const BINDSPEED_IMMEDIATE = BINDSPEED.IMMEDIATE;

pub const OLECONTF = enum(i32) {
    EMBEDDINGS = 1,
    LINKS = 2,
    OTHERS = 4,
    ONLYUSER = 8,
    ONLYIFRUNNING = 16,
};
pub const OLECONTF_EMBEDDINGS = OLECONTF.EMBEDDINGS;
pub const OLECONTF_LINKS = OLECONTF.LINKS;
pub const OLECONTF_OTHERS = OLECONTF.OTHERS;
pub const OLECONTF_ONLYUSER = OLECONTF.ONLYUSER;
pub const OLECONTF_ONLYIFRUNNING = OLECONTF.ONLYIFRUNNING;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleItemContainer_Value = @import("../zig.zig").Guid.initString("0000011c-0000-0000-c000-000000000046");
pub const IID_IOleItemContainer = &IID_IOleItemContainer_Value;
pub const IOleItemContainer = extern struct {
    pub const VTable = extern struct {
        base: IOleContainer.VTable,
        GetObject: fn(
            self: *const IOleItemContainer,
            pszItem: ?PWSTR,
            dwSpeedNeeded: u32,
            pbc: ?*IBindCtx,
            riid: ?*const Guid,
            ppvObject: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectStorage: fn(
            self: *const IOleItemContainer,
            pszItem: ?PWSTR,
            pbc: ?*IBindCtx,
            riid: ?*const Guid,
            ppvStorage: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IOleItemContainer,
            pszItem: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleItemContainer_GetObject(self: *const T, pszItem: ?PWSTR, dwSpeedNeeded: u32, pbc: ?*IBindCtx, riid: ?*const Guid, ppvObject: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleItemContainer.VTable, self.vtable).GetObject(@ptrCast(*const IOleItemContainer, self), pszItem, dwSpeedNeeded, pbc, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleItemContainer_GetObjectStorage(self: *const T, pszItem: ?PWSTR, pbc: ?*IBindCtx, riid: ?*const Guid, ppvStorage: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleItemContainer.VTable, self.vtable).GetObjectStorage(@ptrCast(*const IOleItemContainer, self), pszItem, pbc, riid, ppvStorage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleItemContainer_IsRunning(self: *const T, pszItem: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleItemContainer.VTable, self.vtable).IsRunning(@ptrCast(*const IOleItemContainer, self), pszItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceUIWindow_Value = @import("../zig.zig").Guid.initString("00000115-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceUIWindow = &IID_IOleInPlaceUIWindow_Value;
pub const IOleInPlaceUIWindow = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        GetBorder: fn(
            self: *const IOleInPlaceUIWindow,
            lprectBorder: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestBorderSpace: fn(
            self: *const IOleInPlaceUIWindow,
            pborderwidths: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderSpace: fn(
            self: *const IOleInPlaceUIWindow,
            pborderwidths: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveObject: fn(
            self: *const IOleInPlaceUIWindow,
            pActiveObject: ?*IOleInPlaceActiveObject,
            pszObjName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceUIWindow_GetBorder(self: *const T, lprectBorder: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceUIWindow.VTable, self.vtable).GetBorder(@ptrCast(*const IOleInPlaceUIWindow, self), lprectBorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceUIWindow_RequestBorderSpace(self: *const T, pborderwidths: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceUIWindow.VTable, self.vtable).RequestBorderSpace(@ptrCast(*const IOleInPlaceUIWindow, self), pborderwidths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceUIWindow_SetBorderSpace(self: *const T, pborderwidths: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceUIWindow.VTable, self.vtable).SetBorderSpace(@ptrCast(*const IOleInPlaceUIWindow, self), pborderwidths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceUIWindow_SetActiveObject(self: *const T, pActiveObject: ?*IOleInPlaceActiveObject, pszObjName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceUIWindow.VTable, self.vtable).SetActiveObject(@ptrCast(*const IOleInPlaceUIWindow, self), pActiveObject, pszObjName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceActiveObject_Value = @import("../zig.zig").Guid.initString("00000117-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceActiveObject = &IID_IOleInPlaceActiveObject_Value;
pub const IOleInPlaceActiveObject = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        TranslateAccelerator: fn(
            self: *const IOleInPlaceActiveObject,
            lpmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFrameWindowActivate: fn(
            self: *const IOleInPlaceActiveObject,
            fActivate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocWindowActivate: fn(
            self: *const IOleInPlaceActiveObject,
            fActivate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBorder: fn(
            self: *const IOleInPlaceActiveObject,
            prcBorder: ?*RECT,
            pUIWindow: ?*IOleInPlaceUIWindow,
            fFrameWindow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IOleInPlaceActiveObject,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceActiveObject_TranslateAccelerator(self: *const T, lpmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceActiveObject.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IOleInPlaceActiveObject, self), lpmsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceActiveObject_OnFrameWindowActivate(self: *const T, fActivate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceActiveObject.VTable, self.vtable).OnFrameWindowActivate(@ptrCast(*const IOleInPlaceActiveObject, self), fActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceActiveObject_OnDocWindowActivate(self: *const T, fActivate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceActiveObject.VTable, self.vtable).OnDocWindowActivate(@ptrCast(*const IOleInPlaceActiveObject, self), fActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceActiveObject_ResizeBorder(self: *const T, prcBorder: ?*RECT, pUIWindow: ?*IOleInPlaceUIWindow, fFrameWindow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceActiveObject.VTable, self.vtable).ResizeBorder(@ptrCast(*const IOleInPlaceActiveObject, self), prcBorder, pUIWindow, fFrameWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceActiveObject_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceActiveObject.VTable, self.vtable).EnableModeless(@ptrCast(*const IOleInPlaceActiveObject, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OIFI = extern struct {
    cb: u32,
    fMDIApp: BOOL,
    hwndFrame: ?HWND,
    haccel: ?HACCEL,
    cAccelEntries: u32,
};

pub const OleMenuGroupWidths = extern struct {
    width: [6]i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceFrame_Value = @import("../zig.zig").Guid.initString("00000116-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceFrame = &IID_IOleInPlaceFrame_Value;
pub const IOleInPlaceFrame = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceUIWindow.VTable,
        InsertMenus: fn(
            self: *const IOleInPlaceFrame,
            hmenuShared: ?HMENU,
            lpMenuWidths: ?*OleMenuGroupWidths,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMenu: fn(
            self: *const IOleInPlaceFrame,
            hmenuShared: ?HMENU,
            holemenu: isize,
            hwndActiveObject: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveMenus: fn(
            self: *const IOleInPlaceFrame,
            hmenuShared: ?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusText: fn(
            self: *const IOleInPlaceFrame,
            pszStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IOleInPlaceFrame,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IOleInPlaceFrame,
            lpmsg: ?*MSG,
            wID: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleInPlaceUIWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_InsertMenus(self: *const T, hmenuShared: ?HMENU, lpMenuWidths: ?*OleMenuGroupWidths) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).InsertMenus(@ptrCast(*const IOleInPlaceFrame, self), hmenuShared, lpMenuWidths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_SetMenu(self: *const T, hmenuShared: ?HMENU, holemenu: isize, hwndActiveObject: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).SetMenu(@ptrCast(*const IOleInPlaceFrame, self), hmenuShared, holemenu, hwndActiveObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_RemoveMenus(self: *const T, hmenuShared: ?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).RemoveMenus(@ptrCast(*const IOleInPlaceFrame, self), hmenuShared);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_SetStatusText(self: *const T, pszStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).SetStatusText(@ptrCast(*const IOleInPlaceFrame, self), pszStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).EnableModeless(@ptrCast(*const IOleInPlaceFrame, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceFrame_TranslateAccelerator(self: *const T, lpmsg: ?*MSG, wID: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceFrame.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IOleInPlaceFrame, self), lpmsg, wID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceObject_Value = @import("../zig.zig").Guid.initString("00000113-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceObject = &IID_IOleInPlaceObject_Value;
pub const IOleInPlaceObject = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        InPlaceDeactivate: fn(
            self: *const IOleInPlaceObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UIDeactivate: fn(
            self: *const IOleInPlaceObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectRects: fn(
            self: *const IOleInPlaceObject,
            lprcPosRect: ?*RECT,
            lprcClipRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReactivateAndUndo: fn(
            self: *const IOleInPlaceObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObject_InPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObject.VTable, self.vtable).InPlaceDeactivate(@ptrCast(*const IOleInPlaceObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObject_UIDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObject.VTable, self.vtable).UIDeactivate(@ptrCast(*const IOleInPlaceObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObject_SetObjectRects(self: *const T, lprcPosRect: ?*RECT, lprcClipRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObject.VTable, self.vtable).SetObjectRects(@ptrCast(*const IOleInPlaceObject, self), lprcPosRect, lprcClipRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObject_ReactivateAndUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObject.VTable, self.vtable).ReactivateAndUndo(@ptrCast(*const IOleInPlaceObject, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSite_Value = @import("../zig.zig").Guid.initString("00000119-0000-0000-c000-000000000046");
pub const IID_IOleInPlaceSite = &IID_IOleInPlaceSite_Value;
pub const IOleInPlaceSite = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        CanInPlaceActivate: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInPlaceActivate: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUIActivate: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowContext: fn(
            self: *const IOleInPlaceSite,
            ppFrame: ?*?*IOleInPlaceFrame,
            ppDoc: ?*?*IOleInPlaceUIWindow,
            lprcPosRect: ?*RECT,
            lprcClipRect: ?*RECT,
            lpFrameInfo: ?*OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Scroll: fn(
            self: *const IOleInPlaceSite,
            scrollExtant: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUIDeactivate: fn(
            self: *const IOleInPlaceSite,
            fUndoable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInPlaceDeactivate: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardUndoState: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeactivateAndUndo: fn(
            self: *const IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPosRectChange: fn(
            self: *const IOleInPlaceSite,
            lprcPosRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_CanInPlaceActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).CanInPlaceActivate(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_OnInPlaceActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).OnInPlaceActivate(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_OnUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).OnUIActivate(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_GetWindowContext(self: *const T, ppFrame: ?*?*IOleInPlaceFrame, ppDoc: ?*?*IOleInPlaceUIWindow, lprcPosRect: ?*RECT, lprcClipRect: ?*RECT, lpFrameInfo: ?*OIFI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).GetWindowContext(@ptrCast(*const IOleInPlaceSite, self), ppFrame, ppDoc, lprcPosRect, lprcClipRect, lpFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_Scroll(self: *const T, scrollExtant: SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).Scroll(@ptrCast(*const IOleInPlaceSite, self), scrollExtant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_OnUIDeactivate(self: *const T, fUndoable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).OnUIDeactivate(@ptrCast(*const IOleInPlaceSite, self), fUndoable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_OnInPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).OnInPlaceDeactivate(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_DiscardUndoState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).DiscardUndoState(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_DeactivateAndUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).DeactivateAndUndo(@ptrCast(*const IOleInPlaceSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSite_OnPosRectChange(self: *const T, lprcPosRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSite.VTable, self.vtable).OnPosRectChange(@ptrCast(*const IOleInPlaceSite, self), lprcPosRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IContinue_Value = @import("../zig.zig").Guid.initString("0000012a-0000-0000-c000-000000000046");
pub const IID_IContinue = &IID_IContinue_Value;
pub const IContinue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FContinue: fn(
            self: *const IContinue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContinue_FContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContinue.VTable, self.vtable).FContinue(@ptrCast(*const IContinue, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObject_Value = @import("../zig.zig").Guid.initString("0000010d-0000-0000-c000-000000000046");
pub const IID_IViewObject = &IID_IViewObject_Value;
pub const IViewObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: fn(
            self: *const IViewObject,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: ?*c_void,
            ptd: ?*DVTARGETDEVICE,
            hdcTargetDev: ?HDC,
            hdcDraw: ?HDC,
            lprcBounds: ?*RECTL,
            lprcWBounds: ?*RECTL,
            pfnContinue: isize,
            dwContinue: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorSet: fn(
            self: *const IViewObject,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: ?*c_void,
            ptd: ?*DVTARGETDEVICE,
            hicTargetDev: ?HDC,
            ppColorSet: ?*?*LOGPALETTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: fn(
            self: *const IViewObject,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: ?*c_void,
            pdwFreeze: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: fn(
            self: *const IViewObject,
            dwFreeze: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdvise: fn(
            self: *const IViewObject,
            aspects: u32,
            advf: u32,
            pAdvSink: ?*IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdvise: fn(
            self: *const IViewObject,
            pAspects: ?*u32,
            pAdvf: ?*u32,
            ppAdvSink: ?*?*IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_Draw(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*c_void, ptd: ?*DVTARGETDEVICE, hdcTargetDev: ?HDC, hdcDraw: ?HDC, lprcBounds: ?*RECTL, lprcWBounds: ?*RECTL, pfnContinue: isize, dwContinue: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).Draw(@ptrCast(*const IViewObject, self), dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_GetColorSet(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*c_void, ptd: ?*DVTARGETDEVICE, hicTargetDev: ?HDC, ppColorSet: ?*?*LOGPALETTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).GetColorSet(@ptrCast(*const IViewObject, self), dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, ppColorSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_Freeze(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: ?*c_void, pdwFreeze: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).Freeze(@ptrCast(*const IViewObject, self), dwDrawAspect, lindex, pvAspect, pdwFreeze);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_Unfreeze(self: *const T, dwFreeze: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).Unfreeze(@ptrCast(*const IViewObject, self), dwFreeze);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_SetAdvise(self: *const T, aspects: u32, advf: u32, pAdvSink: ?*IAdviseSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).SetAdvise(@ptrCast(*const IViewObject, self), aspects, advf, pAdvSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject_GetAdvise(self: *const T, pAspects: ?*u32, pAdvf: ?*u32, ppAdvSink: ?*?*IAdviseSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject.VTable, self.vtable).GetAdvise(@ptrCast(*const IViewObject, self), pAspects, pAdvf, ppAdvSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObject2_Value = @import("../zig.zig").Guid.initString("00000127-0000-0000-c000-000000000046");
pub const IID_IViewObject2 = &IID_IViewObject2_Value;
pub const IViewObject2 = extern struct {
    pub const VTable = extern struct {
        base: IViewObject.VTable,
        GetExtent: fn(
            self: *const IViewObject2,
            dwDrawAspect: u32,
            lindex: i32,
            ptd: ?*DVTARGETDEVICE,
            lpsizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IViewObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObject2_GetExtent(self: *const T, dwDrawAspect: u32, lindex: i32, ptd: ?*DVTARGETDEVICE, lpsizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObject2.VTable, self.vtable).GetExtent(@ptrCast(*const IViewObject2, self), dwDrawAspect, lindex, ptd, lpsizel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropSource_Value = @import("../zig.zig").Guid.initString("00000121-0000-0000-c000-000000000046");
pub const IID_IDropSource = &IID_IDropSource_Value;
pub const IDropSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinueDrag: fn(
            self: *const IDropSource,
            fEscapePressed: BOOL,
            grfKeyState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GiveFeedback: fn(
            self: *const IDropSource,
            dwEffect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropSource_QueryContinueDrag(self: *const T, fEscapePressed: BOOL, grfKeyState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropSource.VTable, self.vtable).QueryContinueDrag(@ptrCast(*const IDropSource, self), fEscapePressed, grfKeyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropSource_GiveFeedback(self: *const T, dwEffect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropSource.VTable, self.vtable).GiveFeedback(@ptrCast(*const IDropSource, self), dwEffect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropTarget_Value = @import("../zig.zig").Guid.initString("00000122-0000-0000-c000-000000000046");
pub const IID_IDropTarget = &IID_IDropTarget_Value;
pub const IDropTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnter: fn(
            self: *const IDropTarget,
            pDataObj: ?*IDataObject,
            grfKeyState: u32,
            pt: POINTL,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragOver: fn(
            self: *const IDropTarget,
            grfKeyState: u32,
            pt: POINTL,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeave: fn(
            self: *const IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Drop: fn(
            self: *const IDropTarget,
            pDataObj: ?*IDataObject,
            grfKeyState: u32,
            pt: POINTL,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTarget_DragEnter(self: *const T, pDataObj: ?*IDataObject, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTarget.VTable, self.vtable).DragEnter(@ptrCast(*const IDropTarget, self), pDataObj, grfKeyState, pt, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTarget_DragOver(self: *const T, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTarget.VTable, self.vtable).DragOver(@ptrCast(*const IDropTarget, self), grfKeyState, pt, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTarget_DragLeave(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTarget.VTable, self.vtable).DragLeave(@ptrCast(*const IDropTarget, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTarget_Drop(self: *const T, pDataObj: ?*IDataObject, grfKeyState: u32, pt: POINTL, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTarget.VTable, self.vtable).Drop(@ptrCast(*const IDropTarget, self), pDataObj, grfKeyState, pt, pdwEffect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDropSourceNotify_Value = @import("../zig.zig").Guid.initString("0000012b-0000-0000-c000-000000000046");
pub const IID_IDropSourceNotify = &IID_IDropSourceNotify_Value;
pub const IDropSourceNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnterTarget: fn(
            self: *const IDropSourceNotify,
            hwndTarget: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeaveTarget: fn(
            self: *const IDropSourceNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropSourceNotify_DragEnterTarget(self: *const T, hwndTarget: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropSourceNotify.VTable, self.vtable).DragEnterTarget(@ptrCast(*const IDropSourceNotify, self), hwndTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropSourceNotify_DragLeaveTarget(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropSourceNotify.VTable, self.vtable).DragLeaveTarget(@ptrCast(*const IDropSourceNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IEnterpriseDropTarget_Value = @import("../zig.zig").Guid.initString("390e3878-fd55-4e18-819d-4682081c0cfd");
pub const IID_IEnterpriseDropTarget = &IID_IEnterpriseDropTarget_Value;
pub const IEnterpriseDropTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDropSourceEnterpriseId: fn(
            self: *const IEnterpriseDropTarget,
            identity: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEvaluatingEdpPolicy: fn(
            self: *const IEnterpriseDropTarget,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnterpriseDropTarget_SetDropSourceEnterpriseId(self: *const T, identity: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnterpriseDropTarget.VTable, self.vtable).SetDropSourceEnterpriseId(@ptrCast(*const IEnterpriseDropTarget, self), identity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnterpriseDropTarget_IsEvaluatingEdpPolicy(self: *const T, value: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnterpriseDropTarget.VTable, self.vtable).IsEvaluatingEdpPolicy(@ptrCast(*const IEnterpriseDropTarget, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEVERB = extern struct {
    lVerb: i32,
    lpszVerbName: ?PWSTR,
    fuFlags: u32,
    grfAttribs: u32,
};

pub const OLEVERBATTRIB = enum(i32) {
    NEVERDIRTIES = 1,
    ONCONTAINERMENU = 2,
};
pub const OLEVERBATTRIB_NEVERDIRTIES = OLEVERBATTRIB.NEVERDIRTIES;
pub const OLEVERBATTRIB_ONCONTAINERMENU = OLEVERBATTRIB.ONCONTAINERMENU;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOLEVERB_Value = @import("../zig.zig").Guid.initString("00000104-0000-0000-c000-000000000046");
pub const IID_IEnumOLEVERB = &IID_IEnumOLEVERB_Value;
pub const IEnumOLEVERB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumOLEVERB,
            celt: u32,
            rgelt: [*]OLEVERB,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumOLEVERB,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumOLEVERB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumOLEVERB,
            ppenum: ?*?*IEnumOLEVERB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOLEVERB_Next(self: *const T, celt: u32, rgelt: [*]OLEVERB, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOLEVERB.VTable, self.vtable).Next(@ptrCast(*const IEnumOLEVERB, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOLEVERB_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOLEVERB.VTable, self.vtable).Skip(@ptrCast(*const IEnumOLEVERB, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOLEVERB_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOLEVERB.VTable, self.vtable).Reset(@ptrCast(*const IEnumOLEVERB, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOLEVERB_Clone(self: *const T, ppenum: ?*?*IEnumOLEVERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOLEVERB.VTable, self.vtable).Clone(@ptrCast(*const IEnumOLEVERB, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IEObjectType = enum(i32) {
    EVENT = 0,
    MUTEX = 1,
    SEMAPHORE = 2,
    SHARED_MEMORY = 3,
    WAITABLE_TIMER = 4,
    FILE = 5,
    NAMED_PIPE = 6,
    REGISTRY = 7,
};
pub const IE_EPM_OBJECT_EVENT = IEObjectType.EVENT;
pub const IE_EPM_OBJECT_MUTEX = IEObjectType.MUTEX;
pub const IE_EPM_OBJECT_SEMAPHORE = IEObjectType.SEMAPHORE;
pub const IE_EPM_OBJECT_SHARED_MEMORY = IEObjectType.SHARED_MEMORY;
pub const IE_EPM_OBJECT_WAITABLE_TIMER = IEObjectType.WAITABLE_TIMER;
pub const IE_EPM_OBJECT_FILE = IEObjectType.FILE;
pub const IE_EPM_OBJECT_NAMED_PIPE = IEObjectType.NAMED_PIPE;
pub const IE_EPM_OBJECT_REGISTRY = IEObjectType.REGISTRY;

const IID_IPersistMoniker_Value = @import("../zig.zig").Guid.initString("79eac9c9-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IPersistMoniker = &IID_IPersistMoniker_Value;
pub const IPersistMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: fn(
            self: *const IPersistMoniker,
            pClassID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirty: fn(
            self: *const IPersistMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistMoniker,
            fFullyAvailable: BOOL,
            pimkName: ?*IMoniker,
            pibc: ?*IBindCtx,
            grfMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistMoniker,
            pimkName: ?*IMoniker,
            pbc: ?*IBindCtx,
            fRemember: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IPersistMoniker,
            pimkName: ?*IMoniker,
            pibc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurMoniker: fn(
            self: *const IPersistMoniker,
            ppimkName: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_GetClassID(self: *const T, pClassID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).GetClassID(@ptrCast(*const IPersistMoniker, self), pClassID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistMoniker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_Load(self: *const T, fFullyAvailable: BOOL, pimkName: ?*IMoniker, pibc: ?*IBindCtx, grfMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).Load(@ptrCast(*const IPersistMoniker, self), fFullyAvailable, pimkName, pibc, grfMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_Save(self: *const T, pimkName: ?*IMoniker, pbc: ?*IBindCtx, fRemember: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).Save(@ptrCast(*const IPersistMoniker, self), pimkName, pbc, fRemember);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_SaveCompleted(self: *const T, pimkName: ?*IMoniker, pibc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).SaveCompleted(@ptrCast(*const IPersistMoniker, self), pimkName, pibc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_GetCurMoniker(self: *const T, ppimkName: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).GetCurMoniker(@ptrCast(*const IPersistMoniker, self), ppimkName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MONIKERPROPERTY = enum(i32) {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 1,
    CLASSIDPROP = 2,
    TRUSTEDDOWNLOADPROP = 3,
    POPUPLEVELPROP = 4,
};
pub const MIMETYPEPROP = MONIKERPROPERTY.MIMETYPEPROP;
pub const USE_SRC_URL = MONIKERPROPERTY.USE_SRC_URL;
pub const CLASSIDPROP = MONIKERPROPERTY.CLASSIDPROP;
pub const TRUSTEDDOWNLOADPROP = MONIKERPROPERTY.TRUSTEDDOWNLOADPROP;
pub const POPUPLEVELPROP = MONIKERPROPERTY.POPUPLEVELPROP;

const IID_IMonikerProp_Value = @import("../zig.zig").Guid.initString("a5ca5f7f-1847-4d87-9c5b-918509f7511d");
pub const IID_IMonikerProp = &IID_IMonikerProp_Value;
pub const IMonikerProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutProperty: fn(
            self: *const IMonikerProp,
            mkp: MONIKERPROPERTY,
            val: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonikerProp_PutProperty(self: *const T, mkp: MONIKERPROPERTY, val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonikerProp.VTable, self.vtable).PutProperty(@ptrCast(*const IMonikerProp, self), mkp, val);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindProtocol_Value = @import("../zig.zig").Guid.initString("79eac9cd-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindProtocol = &IID_IBindProtocol_Value;
pub const IBindProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBinding: fn(
            self: *const IBindProtocol,
            szUrl: ?[*:0]const u16,
            pbc: ?*IBindCtx,
            ppb: ?*?*IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindProtocol_CreateBinding(self: *const T, szUrl: ?[*:0]const u16, pbc: ?*IBindCtx, ppb: ?*?*IBinding) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindProtocol.VTable, self.vtable).CreateBinding(@ptrCast(*const IBindProtocol, self), szUrl, pbc, ppb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBinding_Value = @import("../zig.zig").Guid.initString("79eac9c0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBinding = &IID_IBinding_Value;
pub const IBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPriority: fn(
            self: *const IBinding,
            nPriority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IBinding,
            pnPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindResult: fn(
            self: *const IBinding,
            pclsidProtocol: ?*Guid,
            pdwResult: ?*u32,
            pszResult: ?*?PWSTR,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Abort(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Suspend(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Resume(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_SetPriority(self: *const T, nPriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).SetPriority(@ptrCast(*const IBinding, self), nPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).GetPriority(@ptrCast(*const IBinding, self), pnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_GetBindResult(self: *const T, pclsidProtocol: ?*Guid, pdwResult: ?*u32, pszResult: ?*?PWSTR, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).GetBindResult(@ptrCast(*const IBinding, self), pclsidProtocol, pdwResult, pszResult, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDVERB = enum(i32) {
    GET = 0,
    POST = 1,
    PUT = 2,
    CUSTOM = 3,
    RESERVED1 = 4,
};
pub const BINDVERB_GET = BINDVERB.GET;
pub const BINDVERB_POST = BINDVERB.POST;
pub const BINDVERB_PUT = BINDVERB.PUT;
pub const BINDVERB_CUSTOM = BINDVERB.CUSTOM;
pub const BINDVERB_RESERVED1 = BINDVERB.RESERVED1;

pub const BINDINFOF = enum(i32) {
    STGMEDDATA = 1,
    DEXTRAINFO = 2,
};
pub const BINDINFOF_URLENCODESTGMEDDATA = BINDINFOF.STGMEDDATA;
pub const BINDINFOF_URLENCODEDEXTRAINFO = BINDINFOF.DEXTRAINFO;

pub const BINDF = enum(i32) {
    ASYNCHRONOUS = 1,
    ASYNCSTORAGE = 2,
    NOPROGRESSIVERENDERING = 4,
    OFFLINEOPERATION = 8,
    GETNEWESTVERSION = 16,
    NOWRITECACHE = 32,
    NEEDFILE = 64,
    PULLDATA = 128,
    IGNORESECURITYPROBLEM = 256,
    RESYNCHRONIZE = 512,
    HYPERLINK = 1024,
    NO_UI = 2048,
    SILENTOPERATION = 4096,
    PRAGMA_NO_CACHE = 8192,
    GETCLASSOBJECT = 16384,
    RESERVED_1 = 32768,
    FREE_THREADED = 65536,
    DIRECT_READ = 131072,
    FORMS_SUBMIT = 262144,
    GETFROMCACHE_IF_NET_FAIL = 524288,
    FROMURLMON = 1048576,
    FWD_BACK = 2097152,
    PREFERDEFAULTHANDLER = 4194304,
    ENFORCERESTRICTED = 8388608,
    RESERVED_2 = -2147483648,
    RESERVED_3 = 16777216,
    RESERVED_4 = 33554432,
    RESERVED_5 = 67108864,
    RESERVED_6 = 134217728,
    RESERVED_7 = 1073741824,
    RESERVED_8 = 536870912,
};
pub const BINDF_ASYNCHRONOUS = BINDF.ASYNCHRONOUS;
pub const BINDF_ASYNCSTORAGE = BINDF.ASYNCSTORAGE;
pub const BINDF_NOPROGRESSIVERENDERING = BINDF.NOPROGRESSIVERENDERING;
pub const BINDF_OFFLINEOPERATION = BINDF.OFFLINEOPERATION;
pub const BINDF_GETNEWESTVERSION = BINDF.GETNEWESTVERSION;
pub const BINDF_NOWRITECACHE = BINDF.NOWRITECACHE;
pub const BINDF_NEEDFILE = BINDF.NEEDFILE;
pub const BINDF_PULLDATA = BINDF.PULLDATA;
pub const BINDF_IGNORESECURITYPROBLEM = BINDF.IGNORESECURITYPROBLEM;
pub const BINDF_RESYNCHRONIZE = BINDF.RESYNCHRONIZE;
pub const BINDF_HYPERLINK = BINDF.HYPERLINK;
pub const BINDF_NO_UI = BINDF.NO_UI;
pub const BINDF_SILENTOPERATION = BINDF.SILENTOPERATION;
pub const BINDF_PRAGMA_NO_CACHE = BINDF.PRAGMA_NO_CACHE;
pub const BINDF_GETCLASSOBJECT = BINDF.GETCLASSOBJECT;
pub const BINDF_RESERVED_1 = BINDF.RESERVED_1;
pub const BINDF_FREE_THREADED = BINDF.FREE_THREADED;
pub const BINDF_DIRECT_READ = BINDF.DIRECT_READ;
pub const BINDF_FORMS_SUBMIT = BINDF.FORMS_SUBMIT;
pub const BINDF_GETFROMCACHE_IF_NET_FAIL = BINDF.GETFROMCACHE_IF_NET_FAIL;
pub const BINDF_FROMURLMON = BINDF.FROMURLMON;
pub const BINDF_FWD_BACK = BINDF.FWD_BACK;
pub const BINDF_PREFERDEFAULTHANDLER = BINDF.PREFERDEFAULTHANDLER;
pub const BINDF_ENFORCERESTRICTED = BINDF.ENFORCERESTRICTED;
pub const BINDF_RESERVED_2 = BINDF.RESERVED_2;
pub const BINDF_RESERVED_3 = BINDF.RESERVED_3;
pub const BINDF_RESERVED_4 = BINDF.RESERVED_4;
pub const BINDF_RESERVED_5 = BINDF.RESERVED_5;
pub const BINDF_RESERVED_6 = BINDF.RESERVED_6;
pub const BINDF_RESERVED_7 = BINDF.RESERVED_7;
pub const BINDF_RESERVED_8 = BINDF.RESERVED_8;

pub const URL_ENCODING = enum(i32) {
    NONE = 0,
    ENABLE_UTF8 = 268435456,
    DISABLE_UTF8 = 536870912,
};
pub const URL_ENCODING_NONE = URL_ENCODING.NONE;
pub const URL_ENCODING_ENABLE_UTF8 = URL_ENCODING.ENABLE_UTF8;
pub const URL_ENCODING_DISABLE_UTF8 = URL_ENCODING.DISABLE_UTF8;

pub const BINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    stgmedData: STGMEDIUM,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

pub const REMSECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: u32,
    bInheritHandle: BOOL,
};

pub const RemBINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: REMSECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

pub const RemFORMATETC = extern struct {
    cfFormat: u32,
    ptd: u32,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

pub const BINDINFO_OPTIONS = enum(i32) {
    OPTIONS_WININETFLAG = 65536,
    OPTIONS_ENABLE_UTF8 = 131072,
    OPTIONS_DISABLE_UTF8 = 262144,
    OPTIONS_USE_IE_ENCODING = 524288,
    OPTIONS_BINDTOOBJECT = 1048576,
    OPTIONS_SECURITYOPTOUT = 2097152,
    OPTIONS_IGNOREMIMETEXTPLAIN = 4194304,
    OPTIONS_USEBINDSTRINGCREDS = 8388608,
    OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 16777216,
    OPTIONS_IGNORE_SSLERRORS_ONCE = 33554432,
    WPC_DOWNLOADBLOCKED = 134217728,
    WPC_LOGGING_ENABLED = 268435456,
    OPTIONS_ALLOWCONNECTDATA = 536870912,
    OPTIONS_DISABLEAUTOREDIRECTS = 1073741824,
    OPTIONS_SHDOCVW_NAVIGATE = -2147483648,
};
pub const BINDINFO_OPTIONS_WININETFLAG = BINDINFO_OPTIONS.OPTIONS_WININETFLAG;
pub const BINDINFO_OPTIONS_ENABLE_UTF8 = BINDINFO_OPTIONS.OPTIONS_ENABLE_UTF8;
pub const BINDINFO_OPTIONS_DISABLE_UTF8 = BINDINFO_OPTIONS.OPTIONS_DISABLE_UTF8;
pub const BINDINFO_OPTIONS_USE_IE_ENCODING = BINDINFO_OPTIONS.OPTIONS_USE_IE_ENCODING;
pub const BINDINFO_OPTIONS_BINDTOOBJECT = BINDINFO_OPTIONS.OPTIONS_BINDTOOBJECT;
pub const BINDINFO_OPTIONS_SECURITYOPTOUT = BINDINFO_OPTIONS.OPTIONS_SECURITYOPTOUT;
pub const BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = BINDINFO_OPTIONS.OPTIONS_IGNOREMIMETEXTPLAIN;
pub const BINDINFO_OPTIONS_USEBINDSTRINGCREDS = BINDINFO_OPTIONS.OPTIONS_USEBINDSTRINGCREDS;
pub const BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = BINDINFO_OPTIONS.OPTIONS_IGNOREHTTPHTTPSREDIRECTS;
pub const BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = BINDINFO_OPTIONS.OPTIONS_IGNORE_SSLERRORS_ONCE;
pub const BINDINFO_WPC_DOWNLOADBLOCKED = BINDINFO_OPTIONS.WPC_DOWNLOADBLOCKED;
pub const BINDINFO_WPC_LOGGING_ENABLED = BINDINFO_OPTIONS.WPC_LOGGING_ENABLED;
pub const BINDINFO_OPTIONS_ALLOWCONNECTDATA = BINDINFO_OPTIONS.OPTIONS_ALLOWCONNECTDATA;
pub const BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = BINDINFO_OPTIONS.OPTIONS_DISABLEAUTOREDIRECTS;
pub const BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = BINDINFO_OPTIONS.OPTIONS_SHDOCVW_NAVIGATE;

pub const BSCF = enum(i32) {
    FIRSTDATANOTIFICATION = 1,
    INTERMEDIATEDATANOTIFICATION = 2,
    LASTDATANOTIFICATION = 4,
    DATAFULLYAVAILABLE = 8,
    AVAILABLEDATASIZEUNKNOWN = 16,
    SKIPDRAINDATAFORFILEURLS = 32,
    @"64BITLENGTHDOWNLOAD" = 64,
};
pub const BSCF_FIRSTDATANOTIFICATION = BSCF.FIRSTDATANOTIFICATION;
pub const BSCF_INTERMEDIATEDATANOTIFICATION = BSCF.INTERMEDIATEDATANOTIFICATION;
pub const BSCF_LASTDATANOTIFICATION = BSCF.LASTDATANOTIFICATION;
pub const BSCF_DATAFULLYAVAILABLE = BSCF.DATAFULLYAVAILABLE;
pub const BSCF_AVAILABLEDATASIZEUNKNOWN = BSCF.AVAILABLEDATASIZEUNKNOWN;
pub const BSCF_SKIPDRAINDATAFORFILEURLS = BSCF.SKIPDRAINDATAFORFILEURLS;
pub const BSCF_64BITLENGTHDOWNLOAD = BSCF.@"64BITLENGTHDOWNLOAD";

pub const BINDSTATUS = enum(i32) {
    FINDINGRESOURCE = 1,
    CONNECTING = 2,
    REDIRECTING = 3,
    BEGINDOWNLOADDATA = 4,
    DOWNLOADINGDATA = 5,
    ENDDOWNLOADDATA = 6,
    BEGINDOWNLOADCOMPONENTS = 7,
    INSTALLINGCOMPONENTS = 8,
    ENDDOWNLOADCOMPONENTS = 9,
    USINGCACHEDCOPY = 10,
    SENDINGREQUEST = 11,
    CLASSIDAVAILABLE = 12,
    MIMETYPEAVAILABLE = 13,
    CACHEFILENAMEAVAILABLE = 14,
    BEGINSYNCOPERATION = 15,
    ENDSYNCOPERATION = 16,
    BEGINUPLOADDATA = 17,
    UPLOADINGDATA = 18,
    ENDUPLOADDATA = 19,
    PROTOCOLCLASSID = 20,
    ENCODING = 21,
    VERIFIEDMIMETYPEAVAILABLE = 22,
    CLASSINSTALLLOCATION = 23,
    DECODING = 24,
    LOADINGMIMEHANDLER = 25,
    CONTENTDISPOSITIONATTACH = 26,
    FILTERREPORTMIMETYPE = 27,
    CLSIDCANINSTANTIATE = 28,
    IUNKNOWNAVAILABLE = 29,
    DIRECTBIND = 30,
    RAWMIMETYPE = 31,
    PROXYDETECTING = 32,
    ACCEPTRANGES = 33,
    COOKIE_SENT = 34,
    COMPACT_POLICY_RECEIVED = 35,
    COOKIE_SUPPRESSED = 36,
    COOKIE_STATE_UNKNOWN = 37,
    COOKIE_STATE_ACCEPT = 38,
    COOKIE_STATE_REJECT = 39,
    COOKIE_STATE_PROMPT = 40,
    COOKIE_STATE_LEASH = 41,
    COOKIE_STATE_DOWNGRADE = 42,
    POLICY_HREF = 43,
    P3P_HEADER = 44,
    SESSION_COOKIE_RECEIVED = 45,
    PERSISTENT_COOKIE_RECEIVED = 46,
    SESSION_COOKIES_ALLOWED = 47,
    CACHECONTROL = 48,
    CONTENTDISPOSITIONFILENAME = 49,
    MIMETEXTPLAINMISMATCH = 50,
    PUBLISHERAVAILABLE = 51,
    DISPLAYNAMEAVAILABLE = 52,
    SSLUX_NAVBLOCKED = 53,
    SERVER_MIMETYPEAVAILABLE = 54,
    SNIFFED_CLASSIDAVAILABLE = 55,
    @"64BIT_PROGRESS" = 56,
    // LAST = 56, this enum value conflicts with @"64BIT_PROGRESS"
    RESERVED_0 = 57,
    RESERVED_1 = 58,
    RESERVED_2 = 59,
    RESERVED_3 = 60,
    RESERVED_4 = 61,
    RESERVED_5 = 62,
    RESERVED_6 = 63,
    RESERVED_7 = 64,
    RESERVED_8 = 65,
    RESERVED_9 = 66,
    RESERVED_A = 67,
    RESERVED_B = 68,
    RESERVED_C = 69,
    RESERVED_D = 70,
    RESERVED_E = 71,
    RESERVED_F = 72,
    RESERVED_10 = 73,
    RESERVED_11 = 74,
    RESERVED_12 = 75,
    RESERVED_13 = 76,
    // LAST_PRIVATE = 76, this enum value conflicts with RESERVED_13
};
pub const BINDSTATUS_FINDINGRESOURCE = BINDSTATUS.FINDINGRESOURCE;
pub const BINDSTATUS_CONNECTING = BINDSTATUS.CONNECTING;
pub const BINDSTATUS_REDIRECTING = BINDSTATUS.REDIRECTING;
pub const BINDSTATUS_BEGINDOWNLOADDATA = BINDSTATUS.BEGINDOWNLOADDATA;
pub const BINDSTATUS_DOWNLOADINGDATA = BINDSTATUS.DOWNLOADINGDATA;
pub const BINDSTATUS_ENDDOWNLOADDATA = BINDSTATUS.ENDDOWNLOADDATA;
pub const BINDSTATUS_BEGINDOWNLOADCOMPONENTS = BINDSTATUS.BEGINDOWNLOADCOMPONENTS;
pub const BINDSTATUS_INSTALLINGCOMPONENTS = BINDSTATUS.INSTALLINGCOMPONENTS;
pub const BINDSTATUS_ENDDOWNLOADCOMPONENTS = BINDSTATUS.ENDDOWNLOADCOMPONENTS;
pub const BINDSTATUS_USINGCACHEDCOPY = BINDSTATUS.USINGCACHEDCOPY;
pub const BINDSTATUS_SENDINGREQUEST = BINDSTATUS.SENDINGREQUEST;
pub const BINDSTATUS_CLASSIDAVAILABLE = BINDSTATUS.CLASSIDAVAILABLE;
pub const BINDSTATUS_MIMETYPEAVAILABLE = BINDSTATUS.MIMETYPEAVAILABLE;
pub const BINDSTATUS_CACHEFILENAMEAVAILABLE = BINDSTATUS.CACHEFILENAMEAVAILABLE;
pub const BINDSTATUS_BEGINSYNCOPERATION = BINDSTATUS.BEGINSYNCOPERATION;
pub const BINDSTATUS_ENDSYNCOPERATION = BINDSTATUS.ENDSYNCOPERATION;
pub const BINDSTATUS_BEGINUPLOADDATA = BINDSTATUS.BEGINUPLOADDATA;
pub const BINDSTATUS_UPLOADINGDATA = BINDSTATUS.UPLOADINGDATA;
pub const BINDSTATUS_ENDUPLOADDATA = BINDSTATUS.ENDUPLOADDATA;
pub const BINDSTATUS_PROTOCOLCLASSID = BINDSTATUS.PROTOCOLCLASSID;
pub const BINDSTATUS_ENCODING = BINDSTATUS.ENCODING;
pub const BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = BINDSTATUS.VERIFIEDMIMETYPEAVAILABLE;
pub const BINDSTATUS_CLASSINSTALLLOCATION = BINDSTATUS.CLASSINSTALLLOCATION;
pub const BINDSTATUS_DECODING = BINDSTATUS.DECODING;
pub const BINDSTATUS_LOADINGMIMEHANDLER = BINDSTATUS.LOADINGMIMEHANDLER;
pub const BINDSTATUS_CONTENTDISPOSITIONATTACH = BINDSTATUS.CONTENTDISPOSITIONATTACH;
pub const BINDSTATUS_FILTERREPORTMIMETYPE = BINDSTATUS.FILTERREPORTMIMETYPE;
pub const BINDSTATUS_CLSIDCANINSTANTIATE = BINDSTATUS.CLSIDCANINSTANTIATE;
pub const BINDSTATUS_IUNKNOWNAVAILABLE = BINDSTATUS.IUNKNOWNAVAILABLE;
pub const BINDSTATUS_DIRECTBIND = BINDSTATUS.DIRECTBIND;
pub const BINDSTATUS_RAWMIMETYPE = BINDSTATUS.RAWMIMETYPE;
pub const BINDSTATUS_PROXYDETECTING = BINDSTATUS.PROXYDETECTING;
pub const BINDSTATUS_ACCEPTRANGES = BINDSTATUS.ACCEPTRANGES;
pub const BINDSTATUS_COOKIE_SENT = BINDSTATUS.COOKIE_SENT;
pub const BINDSTATUS_COMPACT_POLICY_RECEIVED = BINDSTATUS.COMPACT_POLICY_RECEIVED;
pub const BINDSTATUS_COOKIE_SUPPRESSED = BINDSTATUS.COOKIE_SUPPRESSED;
pub const BINDSTATUS_COOKIE_STATE_UNKNOWN = BINDSTATUS.COOKIE_STATE_UNKNOWN;
pub const BINDSTATUS_COOKIE_STATE_ACCEPT = BINDSTATUS.COOKIE_STATE_ACCEPT;
pub const BINDSTATUS_COOKIE_STATE_REJECT = BINDSTATUS.COOKIE_STATE_REJECT;
pub const BINDSTATUS_COOKIE_STATE_PROMPT = BINDSTATUS.COOKIE_STATE_PROMPT;
pub const BINDSTATUS_COOKIE_STATE_LEASH = BINDSTATUS.COOKIE_STATE_LEASH;
pub const BINDSTATUS_COOKIE_STATE_DOWNGRADE = BINDSTATUS.COOKIE_STATE_DOWNGRADE;
pub const BINDSTATUS_POLICY_HREF = BINDSTATUS.POLICY_HREF;
pub const BINDSTATUS_P3P_HEADER = BINDSTATUS.P3P_HEADER;
pub const BINDSTATUS_SESSION_COOKIE_RECEIVED = BINDSTATUS.SESSION_COOKIE_RECEIVED;
pub const BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = BINDSTATUS.PERSISTENT_COOKIE_RECEIVED;
pub const BINDSTATUS_SESSION_COOKIES_ALLOWED = BINDSTATUS.SESSION_COOKIES_ALLOWED;
pub const BINDSTATUS_CACHECONTROL = BINDSTATUS.CACHECONTROL;
pub const BINDSTATUS_CONTENTDISPOSITIONFILENAME = BINDSTATUS.CONTENTDISPOSITIONFILENAME;
pub const BINDSTATUS_MIMETEXTPLAINMISMATCH = BINDSTATUS.MIMETEXTPLAINMISMATCH;
pub const BINDSTATUS_PUBLISHERAVAILABLE = BINDSTATUS.PUBLISHERAVAILABLE;
pub const BINDSTATUS_DISPLAYNAMEAVAILABLE = BINDSTATUS.DISPLAYNAMEAVAILABLE;
pub const BINDSTATUS_SSLUX_NAVBLOCKED = BINDSTATUS.SSLUX_NAVBLOCKED;
pub const BINDSTATUS_SERVER_MIMETYPEAVAILABLE = BINDSTATUS.SERVER_MIMETYPEAVAILABLE;
pub const BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = BINDSTATUS.SNIFFED_CLASSIDAVAILABLE;
pub const BINDSTATUS_64BIT_PROGRESS = BINDSTATUS.@"64BIT_PROGRESS";
pub const BINDSTATUS_LAST = BINDSTATUS.@"64BIT_PROGRESS";
pub const BINDSTATUS_RESERVED_0 = BINDSTATUS.RESERVED_0;
pub const BINDSTATUS_RESERVED_1 = BINDSTATUS.RESERVED_1;
pub const BINDSTATUS_RESERVED_2 = BINDSTATUS.RESERVED_2;
pub const BINDSTATUS_RESERVED_3 = BINDSTATUS.RESERVED_3;
pub const BINDSTATUS_RESERVED_4 = BINDSTATUS.RESERVED_4;
pub const BINDSTATUS_RESERVED_5 = BINDSTATUS.RESERVED_5;
pub const BINDSTATUS_RESERVED_6 = BINDSTATUS.RESERVED_6;
pub const BINDSTATUS_RESERVED_7 = BINDSTATUS.RESERVED_7;
pub const BINDSTATUS_RESERVED_8 = BINDSTATUS.RESERVED_8;
pub const BINDSTATUS_RESERVED_9 = BINDSTATUS.RESERVED_9;
pub const BINDSTATUS_RESERVED_A = BINDSTATUS.RESERVED_A;
pub const BINDSTATUS_RESERVED_B = BINDSTATUS.RESERVED_B;
pub const BINDSTATUS_RESERVED_C = BINDSTATUS.RESERVED_C;
pub const BINDSTATUS_RESERVED_D = BINDSTATUS.RESERVED_D;
pub const BINDSTATUS_RESERVED_E = BINDSTATUS.RESERVED_E;
pub const BINDSTATUS_RESERVED_F = BINDSTATUS.RESERVED_F;
pub const BINDSTATUS_RESERVED_10 = BINDSTATUS.RESERVED_10;
pub const BINDSTATUS_RESERVED_11 = BINDSTATUS.RESERVED_11;
pub const BINDSTATUS_RESERVED_12 = BINDSTATUS.RESERVED_12;
pub const BINDSTATUS_RESERVED_13 = BINDSTATUS.RESERVED_13;
pub const BINDSTATUS_LAST_PRIVATE = BINDSTATUS.RESERVED_13;

const IID_IBindStatusCallback_Value = @import("../zig.zig").Guid.initString("79eac9c1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindStatusCallback = &IID_IBindStatusCallback_Value;
pub const IBindStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartBinding: fn(
            self: *const IBindStatusCallback,
            dwReserved: u32,
            pib: ?*IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IBindStatusCallback,
            pnPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLowResource: fn(
            self: *const IBindStatusCallback,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: fn(
            self: *const IBindStatusCallback,
            ulProgress: u32,
            ulProgressMax: u32,
            ulStatusCode: u32,
            szStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStopBinding: fn(
            self: *const IBindStatusCallback,
            hresult: HRESULT,
            szError: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindInfo: fn(
            self: *const IBindStatusCallback,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataAvailable: fn(
            self: *const IBindStatusCallback,
            grfBSCF: u32,
            dwSize: u32,
            pformatetc: ?*FORMATETC,
            pstgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnObjectAvailable: fn(
            self: *const IBindStatusCallback,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnStartBinding(self: *const T, dwReserved: u32, pib: ?*IBinding) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnStartBinding(@ptrCast(*const IBindStatusCallback, self), dwReserved, pib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).GetPriority(@ptrCast(*const IBindStatusCallback, self), pnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnLowResource(self: *const T, reserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnLowResource(@ptrCast(*const IBindStatusCallback, self), reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnProgress(self: *const T, ulProgress: u32, ulProgressMax: u32, ulStatusCode: u32, szStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnProgress(@ptrCast(*const IBindStatusCallback, self), ulProgress, ulProgressMax, ulStatusCode, szStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnStopBinding(self: *const T, hresult: HRESULT, szError: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnStopBinding(@ptrCast(*const IBindStatusCallback, self), hresult, szError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_GetBindInfo(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).GetBindInfo(@ptrCast(*const IBindStatusCallback, self), grfBINDF, pbindinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnDataAvailable(self: *const T, grfBSCF: u32, dwSize: u32, pformatetc: ?*FORMATETC, pstgmed: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnDataAvailable(@ptrCast(*const IBindStatusCallback, self), grfBSCF, dwSize, pformatetc, pstgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnObjectAvailable(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnObjectAvailable(@ptrCast(*const IBindStatusCallback, self), riid, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDF2 = enum(i32) {
    DISABLEBASICOVERHTTP = 1,
    DISABLEAUTOCOOKIEHANDLING = 2,
    READ_DATA_GREATER_THAN_4GB = 4,
    DISABLE_HTTP_REDIRECT_XSECURITYID = 8,
    SETDOWNLOADMODE = 32,
    DISABLE_HTTP_REDIRECT_CACHING = 64,
    KEEP_CALLBACK_MODULE_LOADED = 128,
    ALLOW_PROXY_CRED_PROMPT = 256,
    RESERVED_17 = 512,
    RESERVED_16 = 1024,
    RESERVED_15 = 2048,
    RESERVED_14 = 4096,
    RESERVED_13 = 8192,
    RESERVED_12 = 16384,
    RESERVED_11 = 32768,
    RESERVED_10 = 65536,
    RESERVED_F = 131072,
    RESERVED_E = 262144,
    RESERVED_D = 524288,
    RESERVED_C = 1048576,
    RESERVED_B = 2097152,
    RESERVED_A = 4194304,
    RESERVED_9 = 8388608,
    RESERVED_8 = 16777216,
    RESERVED_7 = 33554432,
    RESERVED_6 = 67108864,
    RESERVED_5 = 134217728,
    RESERVED_4 = 268435456,
    RESERVED_3 = 536870912,
    RESERVED_2 = 1073741824,
    RESERVED_1 = -2147483648,
};
pub const BINDF2_DISABLEBASICOVERHTTP = BINDF2.DISABLEBASICOVERHTTP;
pub const BINDF2_DISABLEAUTOCOOKIEHANDLING = BINDF2.DISABLEAUTOCOOKIEHANDLING;
pub const BINDF2_READ_DATA_GREATER_THAN_4GB = BINDF2.READ_DATA_GREATER_THAN_4GB;
pub const BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = BINDF2.DISABLE_HTTP_REDIRECT_XSECURITYID;
pub const BINDF2_SETDOWNLOADMODE = BINDF2.SETDOWNLOADMODE;
pub const BINDF2_DISABLE_HTTP_REDIRECT_CACHING = BINDF2.DISABLE_HTTP_REDIRECT_CACHING;
pub const BINDF2_KEEP_CALLBACK_MODULE_LOADED = BINDF2.KEEP_CALLBACK_MODULE_LOADED;
pub const BINDF2_ALLOW_PROXY_CRED_PROMPT = BINDF2.ALLOW_PROXY_CRED_PROMPT;
pub const BINDF2_RESERVED_17 = BINDF2.RESERVED_17;
pub const BINDF2_RESERVED_16 = BINDF2.RESERVED_16;
pub const BINDF2_RESERVED_15 = BINDF2.RESERVED_15;
pub const BINDF2_RESERVED_14 = BINDF2.RESERVED_14;
pub const BINDF2_RESERVED_13 = BINDF2.RESERVED_13;
pub const BINDF2_RESERVED_12 = BINDF2.RESERVED_12;
pub const BINDF2_RESERVED_11 = BINDF2.RESERVED_11;
pub const BINDF2_RESERVED_10 = BINDF2.RESERVED_10;
pub const BINDF2_RESERVED_F = BINDF2.RESERVED_F;
pub const BINDF2_RESERVED_E = BINDF2.RESERVED_E;
pub const BINDF2_RESERVED_D = BINDF2.RESERVED_D;
pub const BINDF2_RESERVED_C = BINDF2.RESERVED_C;
pub const BINDF2_RESERVED_B = BINDF2.RESERVED_B;
pub const BINDF2_RESERVED_A = BINDF2.RESERVED_A;
pub const BINDF2_RESERVED_9 = BINDF2.RESERVED_9;
pub const BINDF2_RESERVED_8 = BINDF2.RESERVED_8;
pub const BINDF2_RESERVED_7 = BINDF2.RESERVED_7;
pub const BINDF2_RESERVED_6 = BINDF2.RESERVED_6;
pub const BINDF2_RESERVED_5 = BINDF2.RESERVED_5;
pub const BINDF2_RESERVED_4 = BINDF2.RESERVED_4;
pub const BINDF2_RESERVED_3 = BINDF2.RESERVED_3;
pub const BINDF2_RESERVED_2 = BINDF2.RESERVED_2;
pub const BINDF2_RESERVED_1 = BINDF2.RESERVED_1;

const IID_IBindStatusCallbackEx_Value = @import("../zig.zig").Guid.initString("aaa74ef9-8ee7-4659-88d9-f8c504da73cc");
pub const IID_IBindStatusCallbackEx = &IID_IBindStatusCallbackEx_Value;
pub const IBindStatusCallbackEx = extern struct {
    pub const VTable = extern struct {
        base: IBindStatusCallback.VTable,
        GetBindInfoEx: fn(
            self: *const IBindStatusCallbackEx,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
            grfBINDF2: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBindStatusCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallbackEx_GetBindInfoEx(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO, grfBINDF2: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallbackEx.VTable, self.vtable).GetBindInfoEx(@ptrCast(*const IBindStatusCallbackEx, self), grfBINDF, pbindinfo, grfBINDF2, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuthenticate_Value = @import("../zig.zig").Guid.initString("79eac9d0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IAuthenticate = &IID_IAuthenticate_Value;
pub const IAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Authenticate: fn(
            self: *const IAuthenticate,
            phwnd: ?*?HWND,
            pszUsername: ?*?PWSTR,
            pszPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuthenticate_Authenticate(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuthenticate.VTable, self.vtable).Authenticate(@ptrCast(*const IAuthenticate, self), phwnd, pszUsername, pszPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUTHENTICATEF = enum(i32) {
    PROXY = 1,
    BASIC = 2,
    HTTP = 4,
};
pub const AUTHENTICATEF_PROXY = AUTHENTICATEF.PROXY;
pub const AUTHENTICATEF_BASIC = AUTHENTICATEF.BASIC;
pub const AUTHENTICATEF_HTTP = AUTHENTICATEF.HTTP;

pub const AUTHENTICATEINFO = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

const IID_IAuthenticateEx_Value = @import("../zig.zig").Guid.initString("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd");
pub const IID_IAuthenticateEx = &IID_IAuthenticateEx_Value;
pub const IAuthenticateEx = extern struct {
    pub const VTable = extern struct {
        base: IAuthenticate.VTable,
        AuthenticateEx: fn(
            self: *const IAuthenticateEx,
            phwnd: ?*?HWND,
            pszUsername: ?*?PWSTR,
            pszPassword: ?*?PWSTR,
            pauthinfo: ?*AUTHENTICATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAuthenticate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuthenticateEx_AuthenticateEx(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR, pauthinfo: ?*AUTHENTICATEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuthenticateEx.VTable, self.vtable).AuthenticateEx(@ptrCast(*const IAuthenticateEx, self), phwnd, pszUsername, pszPassword, pauthinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpNegotiate_Value = @import("../zig.zig").Guid.initString("79eac9d2-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHttpNegotiate = &IID_IHttpNegotiate_Value;
pub const IHttpNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginningTransaction: fn(
            self: *const IHttpNegotiate,
            szURL: ?[*:0]const u16,
            szHeaders: ?[*:0]const u16,
            dwReserved: u32,
            pszAdditionalHeaders: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnResponse: fn(
            self: *const IHttpNegotiate,
            dwResponseCode: u32,
            szResponseHeaders: ?[*:0]const u16,
            szRequestHeaders: ?[*:0]const u16,
            pszAdditionalRequestHeaders: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate_BeginningTransaction(self: *const T, szURL: ?[*:0]const u16, szHeaders: ?[*:0]const u16, dwReserved: u32, pszAdditionalHeaders: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate.VTable, self.vtable).BeginningTransaction(@ptrCast(*const IHttpNegotiate, self), szURL, szHeaders, dwReserved, pszAdditionalHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate_OnResponse(self: *const T, dwResponseCode: u32, szResponseHeaders: ?[*:0]const u16, szRequestHeaders: ?[*:0]const u16, pszAdditionalRequestHeaders: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate.VTable, self.vtable).OnResponse(@ptrCast(*const IHttpNegotiate, self), dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpNegotiate2_Value = @import("../zig.zig").Guid.initString("4f9f9fcb-e0f4-48eb-b7ab-fa2ea9365cb4");
pub const IID_IHttpNegotiate2 = &IID_IHttpNegotiate2_Value;
pub const IHttpNegotiate2 = extern struct {
    pub const VTable = extern struct {
        base: IHttpNegotiate.VTable,
        GetRootSecurityId: fn(
            self: *const IHttpNegotiate2,
            pbSecurityId: [*:0]u8,
            pcbSecurityId: ?*u32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHttpNegotiate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate2_GetRootSecurityId(self: *const T, pbSecurityId: [*:0]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate2.VTable, self.vtable).GetRootSecurityId(@ptrCast(*const IHttpNegotiate2, self), pbSecurityId, pcbSecurityId, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpNegotiate3_Value = @import("../zig.zig").Guid.initString("57b6c80a-34c2-4602-bc26-66a02fc57153");
pub const IID_IHttpNegotiate3 = &IID_IHttpNegotiate3_Value;
pub const IHttpNegotiate3 = extern struct {
    pub const VTable = extern struct {
        base: IHttpNegotiate2.VTable,
        GetSerializedClientCertContext: fn(
            self: *const IHttpNegotiate3,
            ppbCert: [*]?*u8,
            pcbCert: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHttpNegotiate2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate3_GetSerializedClientCertContext(self: *const T, ppbCert: [*]?*u8, pcbCert: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate3.VTable, self.vtable).GetSerializedClientCertContext(@ptrCast(*const IHttpNegotiate3, self), ppbCert, pcbCert);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetFileStream_Value = @import("../zig.zig").Guid.initString("f134c4b7-b1f8-4e75-b886-74b90943becb");
pub const IID_IWinInetFileStream = &IID_IWinInetFileStream_Value;
pub const IWinInetFileStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHandleForUnlock: fn(
            self: *const IWinInetFileStream,
            hWinInetLockHandle: usize,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeleteFile: fn(
            self: *const IWinInetFileStream,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetFileStream_SetHandleForUnlock(self: *const T, hWinInetLockHandle: usize, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetFileStream.VTable, self.vtable).SetHandleForUnlock(@ptrCast(*const IWinInetFileStream, self), hWinInetLockHandle, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetFileStream_SetDeleteFile(self: *const T, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetFileStream.VTable, self.vtable).SetDeleteFile(@ptrCast(*const IWinInetFileStream, self), dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowForBindingUI_Value = @import("../zig.zig").Guid.initString("79eac9d5-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWindowForBindingUI = &IID_IWindowForBindingUI_Value;
pub const IWindowForBindingUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: fn(
            self: *const IWindowForBindingUI,
            rguidReason: ?*const Guid,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowForBindingUI_GetWindow(self: *const T, rguidReason: ?*const Guid, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowForBindingUI.VTable, self.vtable).GetWindow(@ptrCast(*const IWindowForBindingUI, self), rguidReason, phwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CIP_STATUS = enum(i32) {
    DISK_FULL = 0,
    ACCESS_DENIED = 1,
    NEWER_VERSION_EXISTS = 2,
    OLDER_VERSION_EXISTS = 3,
    NAME_CONFLICT = 4,
    TRUST_VERIFICATION_COMPONENT_MISSING = 5,
    EXE_SELF_REGISTERATION_TIMEOUT = 6,
    UNSAFE_TO_ABORT = 7,
    NEED_REBOOT = 8,
    NEED_REBOOT_UI_PERMISSION = 9,
};
pub const CIP_DISK_FULL = CIP_STATUS.DISK_FULL;
pub const CIP_ACCESS_DENIED = CIP_STATUS.ACCESS_DENIED;
pub const CIP_NEWER_VERSION_EXISTS = CIP_STATUS.NEWER_VERSION_EXISTS;
pub const CIP_OLDER_VERSION_EXISTS = CIP_STATUS.OLDER_VERSION_EXISTS;
pub const CIP_NAME_CONFLICT = CIP_STATUS.NAME_CONFLICT;
pub const CIP_TRUST_VERIFICATION_COMPONENT_MISSING = CIP_STATUS.TRUST_VERIFICATION_COMPONENT_MISSING;
pub const CIP_EXE_SELF_REGISTERATION_TIMEOUT = CIP_STATUS.EXE_SELF_REGISTERATION_TIMEOUT;
pub const CIP_UNSAFE_TO_ABORT = CIP_STATUS.UNSAFE_TO_ABORT;
pub const CIP_NEED_REBOOT = CIP_STATUS.NEED_REBOOT;
pub const CIP_NEED_REBOOT_UI_PERMISSION = CIP_STATUS.NEED_REBOOT_UI_PERMISSION;

const IID_ICodeInstall_Value = @import("../zig.zig").Guid.initString("79eac9d1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_ICodeInstall = &IID_ICodeInstall_Value;
pub const ICodeInstall = extern struct {
    pub const VTable = extern struct {
        base: IWindowForBindingUI.VTable,
        OnCodeInstallProblem: fn(
            self: *const ICodeInstall,
            ulStatusCode: u32,
            szDestination: ?[*:0]const u16,
            szSource: ?[*:0]const u16,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowForBindingUI.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodeInstall_OnCodeInstallProblem(self: *const T, ulStatusCode: u32, szDestination: ?[*:0]const u16, szSource: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodeInstall.VTable, self.vtable).OnCodeInstallProblem(@ptrCast(*const ICodeInstall, self), ulStatusCode, szDestination, szSource, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Uri_PROPERTY = enum(i32) {
    ABSOLUTE_URI = 0,
    // STRING_START = 0, this enum value conflicts with ABSOLUTE_URI
    AUTHORITY = 1,
    DISPLAY_URI = 2,
    DOMAIN = 3,
    EXTENSION = 4,
    FRAGMENT = 5,
    HOST = 6,
    PASSWORD = 7,
    PATH = 8,
    PATH_AND_QUERY = 9,
    QUERY = 10,
    RAW_URI = 11,
    SCHEME_NAME = 12,
    USER_INFO = 13,
    USER_NAME = 14,
    // STRING_LAST = 14, this enum value conflicts with USER_NAME
    HOST_TYPE = 15,
    // DWORD_START = 15, this enum value conflicts with HOST_TYPE
    PORT = 16,
    SCHEME = 17,
    ZONE = 18,
    // DWORD_LAST = 18, this enum value conflicts with ZONE
};
pub const Uri_PROPERTY_ABSOLUTE_URI = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_STRING_START = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_AUTHORITY = Uri_PROPERTY.AUTHORITY;
pub const Uri_PROPERTY_DISPLAY_URI = Uri_PROPERTY.DISPLAY_URI;
pub const Uri_PROPERTY_DOMAIN = Uri_PROPERTY.DOMAIN;
pub const Uri_PROPERTY_EXTENSION = Uri_PROPERTY.EXTENSION;
pub const Uri_PROPERTY_FRAGMENT = Uri_PROPERTY.FRAGMENT;
pub const Uri_PROPERTY_HOST = Uri_PROPERTY.HOST;
pub const Uri_PROPERTY_PASSWORD = Uri_PROPERTY.PASSWORD;
pub const Uri_PROPERTY_PATH = Uri_PROPERTY.PATH;
pub const Uri_PROPERTY_PATH_AND_QUERY = Uri_PROPERTY.PATH_AND_QUERY;
pub const Uri_PROPERTY_QUERY = Uri_PROPERTY.QUERY;
pub const Uri_PROPERTY_RAW_URI = Uri_PROPERTY.RAW_URI;
pub const Uri_PROPERTY_SCHEME_NAME = Uri_PROPERTY.SCHEME_NAME;
pub const Uri_PROPERTY_USER_INFO = Uri_PROPERTY.USER_INFO;
pub const Uri_PROPERTY_USER_NAME = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_STRING_LAST = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_HOST_TYPE = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_DWORD_START = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_PORT = Uri_PROPERTY.PORT;
pub const Uri_PROPERTY_SCHEME = Uri_PROPERTY.SCHEME;
pub const Uri_PROPERTY_ZONE = Uri_PROPERTY.ZONE;
pub const Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY.ZONE;

pub const Uri_HOST_TYPE = enum(i32) {
    UNKNOWN = 0,
    DNS = 1,
    IPV4 = 2,
    IPV6 = 3,
    IDN = 4,
};
pub const Uri_HOST_UNKNOWN = Uri_HOST_TYPE.UNKNOWN;
pub const Uri_HOST_DNS = Uri_HOST_TYPE.DNS;
pub const Uri_HOST_IPV4 = Uri_HOST_TYPE.IPV4;
pub const Uri_HOST_IPV6 = Uri_HOST_TYPE.IPV6;
pub const Uri_HOST_IDN = Uri_HOST_TYPE.IDN;

const IID_IUri_Value = @import("../zig.zig").Guid.initString("a39ee748-6a27-4817-a6f2-13914bef5890");
pub const IID_IUri = &IID_IUri_Value;
pub const IUri = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyBSTR: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pbstrProperty: ?*?BSTR,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyLength: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pcchProperty: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDWORD: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pdwProperty: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasProperty: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pfHasProperty: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAbsoluteUri: fn(
            self: *const IUri,
            pbstrAbsoluteUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthority: fn(
            self: *const IUri,
            pbstrAuthority: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayUri: fn(
            self: *const IUri,
            pbstrDisplayString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomain: fn(
            self: *const IUri,
            pbstrDomain: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: fn(
            self: *const IUri,
            pbstrExtension: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: fn(
            self: *const IUri,
            pbstrFragment: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: fn(
            self: *const IUri,
            pbstrHost: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: fn(
            self: *const IUri,
            pbstrPassword: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IUri,
            pbstrPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPathAndQuery: fn(
            self: *const IUri,
            pbstrPathAndQuery: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: fn(
            self: *const IUri,
            pbstrQuery: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawUri: fn(
            self: *const IUri,
            pbstrRawUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: fn(
            self: *const IUri,
            pbstrSchemeName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserInfo: fn(
            self: *const IUri,
            pbstrUserInfo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: fn(
            self: *const IUri,
            pbstrUserName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHostType: fn(
            self: *const IUri,
            pdwHostType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: fn(
            self: *const IUri,
            pdwPort: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheme: fn(
            self: *const IUri,
            pdwScheme: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZone: fn(
            self: *const IUri,
            pdwZone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IUri,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IUri,
            pUri: ?*IUri,
            pfEqual: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyBSTR(self: *const T, uriProp: Uri_PROPERTY, pbstrProperty: ?*?BSTR, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyBSTR(@ptrCast(*const IUri, self), uriProp, pbstrProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyLength(self: *const T, uriProp: Uri_PROPERTY, pcchProperty: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyLength(@ptrCast(*const IUri, self), uriProp, pcchProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyDWORD(self: *const T, uriProp: Uri_PROPERTY, pdwProperty: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyDWORD(@ptrCast(*const IUri, self), uriProp, pdwProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_HasProperty(self: *const T, uriProp: Uri_PROPERTY, pfHasProperty: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).HasProperty(@ptrCast(*const IUri, self), uriProp, pfHasProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetAbsoluteUri(self: *const T, pbstrAbsoluteUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetAbsoluteUri(@ptrCast(*const IUri, self), pbstrAbsoluteUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetAuthority(self: *const T, pbstrAuthority: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetAuthority(@ptrCast(*const IUri, self), pbstrAuthority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetDisplayUri(self: *const T, pbstrDisplayString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetDisplayUri(@ptrCast(*const IUri, self), pbstrDisplayString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetDomain(self: *const T, pbstrDomain: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetDomain(@ptrCast(*const IUri, self), pbstrDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetExtension(self: *const T, pbstrExtension: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetExtension(@ptrCast(*const IUri, self), pbstrExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetFragment(self: *const T, pbstrFragment: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetFragment(@ptrCast(*const IUri, self), pbstrFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetHost(self: *const T, pbstrHost: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetHost(@ptrCast(*const IUri, self), pbstrHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPassword(self: *const T, pbstrPassword: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPassword(@ptrCast(*const IUri, self), pbstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPath(self: *const T, pbstrPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPath(@ptrCast(*const IUri, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPathAndQuery(self: *const T, pbstrPathAndQuery: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPathAndQuery(@ptrCast(*const IUri, self), pbstrPathAndQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetQuery(self: *const T, pbstrQuery: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetQuery(@ptrCast(*const IUri, self), pbstrQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetRawUri(self: *const T, pbstrRawUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetRawUri(@ptrCast(*const IUri, self), pbstrRawUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetSchemeName(self: *const T, pbstrSchemeName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetSchemeName(@ptrCast(*const IUri, self), pbstrSchemeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetUserInfo(self: *const T, pbstrUserInfo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetUserInfo(@ptrCast(*const IUri, self), pbstrUserInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetUserName(self: *const T, pbstrUserName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetUserName(@ptrCast(*const IUri, self), pbstrUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetHostType(self: *const T, pdwHostType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetHostType(@ptrCast(*const IUri, self), pdwHostType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPort(self: *const T, pdwPort: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPort(@ptrCast(*const IUri, self), pdwPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetScheme(self: *const T, pdwScheme: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetScheme(@ptrCast(*const IUri, self), pdwScheme);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetZone(self: *const T, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetZone(@ptrCast(*const IUri, self), pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetProperties(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetProperties(@ptrCast(*const IUri, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_IsEqual(self: *const T, pUri: ?*IUri, pfEqual: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).IsEqual(@ptrCast(*const IUri, self), pUri, pfEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriContainer_Value = @import("../zig.zig").Guid.initString("a158a630-ed6f-45fb-b987-f68676f57752");
pub const IID_IUriContainer = &IID_IUriContainer_Value;
pub const IUriContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIUri: fn(
            self: *const IUriContainer,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriContainer_GetIUri(self: *const T, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriContainer.VTable, self.vtable).GetIUri(@ptrCast(*const IUriContainer, self), ppIUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilder_Value = @import("../zig.zig").Guid.initString("4221b2e1-8955-46c0-bd5b-de9897565de7");
pub const IID_IUriBuilder = &IID_IUriBuilder_Value;
pub const IUriBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateUriSimple: fn(
            self: *const IUriBuilder,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUri: fn(
            self: *const IUriBuilder,
            dwCreateFlags: u32,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUriWithFlags: fn(
            self: *const IUriBuilder,
            dwCreateFlags: u32,
            dwUriBuilderFlags: u32,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIUri: fn(
            self: *const IUriBuilder,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIUri: fn(
            self: *const IUriBuilder,
            pIUri: ?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: fn(
            self: *const IUriBuilder,
            pcchFragment: ?*u32,
            ppwzFragment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: fn(
            self: *const IUriBuilder,
            pcchHost: ?*u32,
            ppwzHost: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: fn(
            self: *const IUriBuilder,
            pcchPassword: ?*u32,
            ppwzPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IUriBuilder,
            pcchPath: ?*u32,
            ppwzPath: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: fn(
            self: *const IUriBuilder,
            pfHasPort: ?*BOOL,
            pdwPort: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: fn(
            self: *const IUriBuilder,
            pcchQuery: ?*u32,
            ppwzQuery: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: fn(
            self: *const IUriBuilder,
            pcchSchemeName: ?*u32,
            ppwzSchemeName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: fn(
            self: *const IUriBuilder,
            pcchUserName: ?*u32,
            ppwzUserName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFragment: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHost: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassword: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPort: fn(
            self: *const IUriBuilder,
            fHasPort: BOOL,
            dwNewValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuery: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSchemeName: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserName: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProperties: fn(
            self: *const IUriBuilder,
            dwPropertyMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasBeenModified: fn(
            self: *const IUriBuilder,
            pfModified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUriSimple(self: *const T, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUriSimple(@ptrCast(*const IUriBuilder, self), dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUri(self: *const T, dwCreateFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUri(@ptrCast(*const IUriBuilder, self), dwCreateFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUriWithFlags(self: *const T, dwCreateFlags: u32, dwUriBuilderFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUriWithFlags(@ptrCast(*const IUriBuilder, self), dwCreateFlags, dwUriBuilderFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetIUri(self: *const T, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetIUri(@ptrCast(*const IUriBuilder, self), ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetIUri(self: *const T, pIUri: ?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetIUri(@ptrCast(*const IUriBuilder, self), pIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetFragment(self: *const T, pcchFragment: ?*u32, ppwzFragment: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetFragment(@ptrCast(*const IUriBuilder, self), pcchFragment, ppwzFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetHost(self: *const T, pcchHost: ?*u32, ppwzHost: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetHost(@ptrCast(*const IUriBuilder, self), pcchHost, ppwzHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPassword(self: *const T, pcchPassword: ?*u32, ppwzPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPassword(@ptrCast(*const IUriBuilder, self), pcchPassword, ppwzPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPath(self: *const T, pcchPath: ?*u32, ppwzPath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPath(@ptrCast(*const IUriBuilder, self), pcchPath, ppwzPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPort(self: *const T, pfHasPort: ?*BOOL, pdwPort: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPort(@ptrCast(*const IUriBuilder, self), pfHasPort, pdwPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetQuery(self: *const T, pcchQuery: ?*u32, ppwzQuery: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetQuery(@ptrCast(*const IUriBuilder, self), pcchQuery, ppwzQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetSchemeName(self: *const T, pcchSchemeName: ?*u32, ppwzSchemeName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetSchemeName(@ptrCast(*const IUriBuilder, self), pcchSchemeName, ppwzSchemeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetUserName(self: *const T, pcchUserName: ?*u32, ppwzUserName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetUserName(@ptrCast(*const IUriBuilder, self), pcchUserName, ppwzUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetFragment(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetFragment(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetHost(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetHost(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPassword(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPassword(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPath(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPath(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPort(self: *const T, fHasPort: BOOL, dwNewValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPort(@ptrCast(*const IUriBuilder, self), fHasPort, dwNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetQuery(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetQuery(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetSchemeName(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetSchemeName(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetUserName(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetUserName(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_RemoveProperties(self: *const T, dwPropertyMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).RemoveProperties(@ptrCast(*const IUriBuilder, self), dwPropertyMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_HasBeenModified(self: *const T, pfModified: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).HasBeenModified(@ptrCast(*const IUriBuilder, self), pfModified);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilderFactory_Value = @import("../zig.zig").Guid.initString("e982ce48-0b96-440c-bc37-0c869b27a29e");
pub const IID_IUriBuilderFactory = &IID_IUriBuilderFactory_Value;
pub const IUriBuilderFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIUriBuilder: fn(
            self: *const IUriBuilderFactory,
            dwFlags: u32,
            dwReserved: usize,
            ppIUriBuilder: ?*?*IUriBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInitializedIUriBuilder: fn(
            self: *const IUriBuilderFactory,
            dwFlags: u32,
            dwReserved: usize,
            ppIUriBuilder: ?*?*IUriBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilderFactory_CreateIUriBuilder(self: *const T, dwFlags: u32, dwReserved: usize, ppIUriBuilder: ?*?*IUriBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilderFactory.VTable, self.vtable).CreateIUriBuilder(@ptrCast(*const IUriBuilderFactory, self), dwFlags, dwReserved, ppIUriBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilderFactory_CreateInitializedIUriBuilder(self: *const T, dwFlags: u32, dwReserved: usize, ppIUriBuilder: ?*?*IUriBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilderFactory.VTable, self.vtable).CreateInitializedIUriBuilder(@ptrCast(*const IUriBuilderFactory, self), dwFlags, dwReserved, ppIUriBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetInfo_Value = @import("../zig.zig").Guid.initString("79eac9d6-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWinInetInfo = &IID_IWinInetInfo_Value;
pub const IWinInetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOption: fn(
            self: *const IWinInetInfo,
            dwOption: u32,
            pBuffer: [*]u8,
            pcbBuf: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetInfo_QueryOption(self: *const T, dwOption: u32, pBuffer: [*]u8, pcbBuf: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetInfo.VTable, self.vtable).QueryOption(@ptrCast(*const IWinInetInfo, self), dwOption, pBuffer, pcbBuf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpSecurity_Value = @import("../zig.zig").Guid.initString("79eac9d7-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IHttpSecurity = &IID_IHttpSecurity_Value;
pub const IHttpSecurity = extern struct {
    pub const VTable = extern struct {
        base: IWindowForBindingUI.VTable,
        OnSecurityProblem: fn(
            self: *const IHttpSecurity,
            dwProblem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowForBindingUI.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpSecurity_OnSecurityProblem(self: *const T, dwProblem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpSecurity.VTable, self.vtable).OnSecurityProblem(@ptrCast(*const IHttpSecurity, self), dwProblem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetHttpInfo_Value = @import("../zig.zig").Guid.initString("79eac9d8-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWinInetHttpInfo = &IID_IWinInetHttpInfo_Value;
pub const IWinInetHttpInfo = extern struct {
    pub const VTable = extern struct {
        base: IWinInetInfo.VTable,
        QueryInfo: fn(
            self: *const IWinInetHttpInfo,
            dwOption: u32,
            pBuffer: [*]u8,
            pcbBuf: ?*u32,
            pdwFlags: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWinInetInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetHttpInfo_QueryInfo(self: *const T, dwOption: u32, pBuffer: [*]u8, pcbBuf: ?*u32, pdwFlags: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetHttpInfo.VTable, self.vtable).QueryInfo(@ptrCast(*const IWinInetHttpInfo, self), dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetHttpTimeouts_Value = @import("../zig.zig").Guid.initString("f286fa56-c1fd-4270-8e67-b3eb790a81e8");
pub const IID_IWinInetHttpTimeouts = &IID_IWinInetHttpTimeouts_Value;
pub const IWinInetHttpTimeouts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequestTimeouts: fn(
            self: *const IWinInetHttpTimeouts,
            pdwConnectTimeout: ?*u32,
            pdwSendTimeout: ?*u32,
            pdwReceiveTimeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetHttpTimeouts_GetRequestTimeouts(self: *const T, pdwConnectTimeout: ?*u32, pdwSendTimeout: ?*u32, pdwReceiveTimeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetHttpTimeouts.VTable, self.vtable).GetRequestTimeouts(@ptrCast(*const IWinInetHttpTimeouts, self), pdwConnectTimeout, pdwSendTimeout, pdwReceiveTimeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetCacheHints_Value = @import("../zig.zig").Guid.initString("dd1ec3b3-8391-4fdb-a9e6-347c3caaa7dd");
pub const IID_IWinInetCacheHints = &IID_IWinInetCacheHints_Value;
pub const IWinInetCacheHints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCacheExtension: fn(
            self: *const IWinInetCacheHints,
            pwzExt: ?[*:0]const u16,
            pszCacheFile: [*]u8,
            pcbCacheFile: ?*u32,
            pdwWinInetError: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetCacheHints_SetCacheExtension(self: *const T, pwzExt: ?[*:0]const u16, pszCacheFile: [*]u8, pcbCacheFile: ?*u32, pdwWinInetError: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetCacheHints.VTable, self.vtable).SetCacheExtension(@ptrCast(*const IWinInetCacheHints, self), pwzExt, pszCacheFile, pcbCacheFile, pdwWinInetError, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetCacheHints2_Value = @import("../zig.zig").Guid.initString("7857aeac-d31f-49bf-884e-dd46df36780a");
pub const IID_IWinInetCacheHints2 = &IID_IWinInetCacheHints2_Value;
pub const IWinInetCacheHints2 = extern struct {
    pub const VTable = extern struct {
        base: IWinInetCacheHints.VTable,
        SetCacheExtension2: fn(
            self: *const IWinInetCacheHints2,
            pwzExt: ?[*:0]const u16,
            pwzCacheFile: ?PWSTR,
            pcchCacheFile: ?*u32,
            pdwWinInetError: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWinInetCacheHints.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetCacheHints2_SetCacheExtension2(self: *const T, pwzExt: ?[*:0]const u16, pwzCacheFile: ?PWSTR, pcchCacheFile: ?*u32, pdwWinInetError: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetCacheHints2.VTable, self.vtable).SetCacheExtension2(@ptrCast(*const IWinInetCacheHints2, self), pwzExt, pwzCacheFile, pcchCacheFile, pdwWinInetError, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHost_Value = @import("../zig.zig").Guid.initString("fc4801a1-2ba9-11cf-a229-00aa003d7352");
pub const IID_IBindHost = &IID_IBindHost_Value;
pub const IBindHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMoniker: fn(
            self: *const IBindHost,
            szName: ?PWSTR,
            pBC: ?*IBindCtx,
            ppmk: ?*?*IMoniker,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToStorage: fn(
            self: *const IBindHost,
            pMk: ?*IMoniker,
            pBC: ?*IBindCtx,
            pBSC: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToObject: fn(
            self: *const IBindHost,
            pMk: ?*IMoniker,
            pBC: ?*IBindCtx,
            pBSC: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_CreateMoniker(self: *const T, szName: ?PWSTR, pBC: ?*IBindCtx, ppmk: ?*?*IMoniker, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).CreateMoniker(@ptrCast(*const IBindHost, self), szName, pBC, ppmk, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_MonikerBindToStorage(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).MonikerBindToStorage(@ptrCast(*const IBindHost, self), pMk, pBC, pBSC, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_MonikerBindToObject(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).MonikerBindToObject(@ptrCast(*const IBindHost, self), pMk, pBC, pBSC, riid, ppvObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternet_Value = @import("../zig.zig").Guid.initString("79eac9e0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternet = &IID_IInternet_Value;
pub const IInternet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDSTRING = enum(i32) {
    HEADERS = 1,
    ACCEPT_MIMES = 2,
    EXTRA_URL = 3,
    LANGUAGE = 4,
    USERNAME = 5,
    PASSWORD = 6,
    UA_PIXELS = 7,
    UA_COLOR = 8,
    OS = 9,
    USER_AGENT = 10,
    ACCEPT_ENCODINGS = 11,
    POST_COOKIE = 12,
    POST_DATA_MIME = 13,
    URL = 14,
    IID = 15,
    FLAG_BIND_TO_OBJECT = 16,
    PTR_BIND_CONTEXT = 17,
    XDR_ORIGIN = 18,
    DOWNLOADPATH = 19,
    ROOTDOC_URL = 20,
    INITIAL_FILENAME = 21,
    PROXY_USERNAME = 22,
    PROXY_PASSWORD = 23,
    ENTERPRISE_ID = 24,
    DOC_URL = 25,
    SAMESITE_COOKIE_LEVEL = 26,
};
pub const BINDSTRING_HEADERS = BINDSTRING.HEADERS;
pub const BINDSTRING_ACCEPT_MIMES = BINDSTRING.ACCEPT_MIMES;
pub const BINDSTRING_EXTRA_URL = BINDSTRING.EXTRA_URL;
pub const BINDSTRING_LANGUAGE = BINDSTRING.LANGUAGE;
pub const BINDSTRING_USERNAME = BINDSTRING.USERNAME;
pub const BINDSTRING_PASSWORD = BINDSTRING.PASSWORD;
pub const BINDSTRING_UA_PIXELS = BINDSTRING.UA_PIXELS;
pub const BINDSTRING_UA_COLOR = BINDSTRING.UA_COLOR;
pub const BINDSTRING_OS = BINDSTRING.OS;
pub const BINDSTRING_USER_AGENT = BINDSTRING.USER_AGENT;
pub const BINDSTRING_ACCEPT_ENCODINGS = BINDSTRING.ACCEPT_ENCODINGS;
pub const BINDSTRING_POST_COOKIE = BINDSTRING.POST_COOKIE;
pub const BINDSTRING_POST_DATA_MIME = BINDSTRING.POST_DATA_MIME;
pub const BINDSTRING_URL = BINDSTRING.URL;
pub const BINDSTRING_IID = BINDSTRING.IID;
pub const BINDSTRING_FLAG_BIND_TO_OBJECT = BINDSTRING.FLAG_BIND_TO_OBJECT;
pub const BINDSTRING_PTR_BIND_CONTEXT = BINDSTRING.PTR_BIND_CONTEXT;
pub const BINDSTRING_XDR_ORIGIN = BINDSTRING.XDR_ORIGIN;
pub const BINDSTRING_DOWNLOADPATH = BINDSTRING.DOWNLOADPATH;
pub const BINDSTRING_ROOTDOC_URL = BINDSTRING.ROOTDOC_URL;
pub const BINDSTRING_INITIAL_FILENAME = BINDSTRING.INITIAL_FILENAME;
pub const BINDSTRING_PROXY_USERNAME = BINDSTRING.PROXY_USERNAME;
pub const BINDSTRING_PROXY_PASSWORD = BINDSTRING.PROXY_PASSWORD;
pub const BINDSTRING_ENTERPRISE_ID = BINDSTRING.ENTERPRISE_ID;
pub const BINDSTRING_DOC_URL = BINDSTRING.DOC_URL;
pub const BINDSTRING_SAMESITE_COOKIE_LEVEL = BINDSTRING.SAMESITE_COOKIE_LEVEL;

const IID_IInternetBindInfo_Value = @import("../zig.zig").Guid.initString("79eac9e1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetBindInfo = &IID_IInternetBindInfo_Value;
pub const IInternetBindInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBindInfo: fn(
            self: *const IInternetBindInfo,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindString: fn(
            self: *const IInternetBindInfo,
            ulStringType: u32,
            ppwzStr: ?*?PWSTR,
            cEl: u32,
            pcElFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfo_GetBindInfo(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfo.VTable, self.vtable).GetBindInfo(@ptrCast(*const IInternetBindInfo, self), grfBINDF, pbindinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfo_GetBindString(self: *const T, ulStringType: u32, ppwzStr: ?*?PWSTR, cEl: u32, pcElFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfo.VTable, self.vtable).GetBindString(@ptrCast(*const IInternetBindInfo, self), ulStringType, ppwzStr, cEl, pcElFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetBindInfoEx_Value = @import("../zig.zig").Guid.initString("a3e015b7-a82c-4dcd-a150-569aeeed36ab");
pub const IID_IInternetBindInfoEx = &IID_IInternetBindInfoEx_Value;
pub const IInternetBindInfoEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetBindInfo.VTable,
        GetBindInfoEx: fn(
            self: *const IInternetBindInfoEx,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
            grfBINDF2: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetBindInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfoEx_GetBindInfoEx(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO, grfBINDF2: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfoEx.VTable, self.vtable).GetBindInfoEx(@ptrCast(*const IInternetBindInfoEx, self), grfBINDF, pbindinfo, grfBINDF2, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PI_FLAGS = enum(i32) {
    I_PARSE_URL = 1,
    I_FILTER_MODE = 2,
    I_FORCE_ASYNC = 4,
    I_USE_WORKERTHREAD = 8,
    I_MIMEVERIFICATION = 16,
    I_CLSIDLOOKUP = 32,
    I_DATAPROGRESS = 64,
    I_SYNCHRONOUS = 128,
    I_APARTMENTTHREADED = 256,
    I_CLASSINSTALL = 512,
    I_PASSONBINDCTX = 8192,
    I_NOMIMEHANDLER = 32768,
    I_LOADAPPDIRECT = 16384,
    D_FORCE_SWITCH = 65536,
    I_PREFERDEFAULTHANDLER = 131072,
};
pub const PI_PARSE_URL = PI_FLAGS.I_PARSE_URL;
pub const PI_FILTER_MODE = PI_FLAGS.I_FILTER_MODE;
pub const PI_FORCE_ASYNC = PI_FLAGS.I_FORCE_ASYNC;
pub const PI_USE_WORKERTHREAD = PI_FLAGS.I_USE_WORKERTHREAD;
pub const PI_MIMEVERIFICATION = PI_FLAGS.I_MIMEVERIFICATION;
pub const PI_CLSIDLOOKUP = PI_FLAGS.I_CLSIDLOOKUP;
pub const PI_DATAPROGRESS = PI_FLAGS.I_DATAPROGRESS;
pub const PI_SYNCHRONOUS = PI_FLAGS.I_SYNCHRONOUS;
pub const PI_APARTMENTTHREADED = PI_FLAGS.I_APARTMENTTHREADED;
pub const PI_CLASSINSTALL = PI_FLAGS.I_CLASSINSTALL;
pub const PI_PASSONBINDCTX = PI_FLAGS.I_PASSONBINDCTX;
pub const PI_NOMIMEHANDLER = PI_FLAGS.I_NOMIMEHANDLER;
pub const PI_LOADAPPDIRECT = PI_FLAGS.I_LOADAPPDIRECT;
pub const PD_FORCE_SWITCH = PI_FLAGS.D_FORCE_SWITCH;
pub const PI_PREFERDEFAULTHANDLER = PI_FLAGS.I_PREFERDEFAULTHANDLER;

pub const PROTOCOLDATA = extern struct {
    grfFlags: u32,
    dwState: u32,
    pData: ?*c_void,
    cbData: u32,
};

pub const StartParam = extern struct {
    iid: Guid,
    pIBindCtx: ?*IBindCtx,
    pItf: ?*IUnknown,
};

const IID_IInternetProtocolRoot_Value = @import("../zig.zig").Guid.initString("79eac9e3-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolRoot = &IID_IInternetProtocolRoot_Value;
pub const IInternetProtocolRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IInternetProtocolRoot,
            szUrl: ?[*:0]const u16,
            pOIProtSink: ?*IInternetProtocolSink,
            pOIBindInfo: ?*IInternetBindInfo,
            grfPI: u32,
            dwReserved: HANDLE_PTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Continue: fn(
            self: *const IInternetProtocolRoot,
            pProtocolData: ?*PROTOCOLDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IInternetProtocolRoot,
            hrReason: HRESULT,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IInternetProtocolRoot,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IInternetProtocolRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IInternetProtocolRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Start(self: *const T, szUrl: ?[*:0]const u16, pOIProtSink: ?*IInternetProtocolSink, pOIBindInfo: ?*IInternetBindInfo, grfPI: u32, dwReserved: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Start(@ptrCast(*const IInternetProtocolRoot, self), szUrl, pOIProtSink, pOIBindInfo, grfPI, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Continue(self: *const T, pProtocolData: ?*PROTOCOLDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Continue(@ptrCast(*const IInternetProtocolRoot, self), pProtocolData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Abort(self: *const T, hrReason: HRESULT, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Abort(@ptrCast(*const IInternetProtocolRoot, self), hrReason, dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Terminate(self: *const T, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Terminate(@ptrCast(*const IInternetProtocolRoot, self), dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Suspend(@ptrCast(*const IInternetProtocolRoot, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Resume(@ptrCast(*const IInternetProtocolRoot, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocol_Value = @import("../zig.zig").Guid.initString("79eac9e4-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocol = &IID_IInternetProtocol_Value;
pub const IInternetProtocol = extern struct {
    pub const VTable = extern struct {
        base: IInternetProtocolRoot.VTable,
        Read: fn(
            self: *const IInternetProtocol,
            pv: [*]u8,
            cb: u32,
            pcbRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: fn(
            self: *const IInternetProtocol,
            dlibMove: LARGE_INTEGER,
            dwOrigin: u32,
            plibNewPosition: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRequest: fn(
            self: *const IInternetProtocol,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRequest: fn(
            self: *const IInternetProtocol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetProtocolRoot.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_Read(self: *const T, pv: [*]u8, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).Read(@ptrCast(*const IInternetProtocol, self), pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_Seek(self: *const T, dlibMove: LARGE_INTEGER, dwOrigin: u32, plibNewPosition: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).Seek(@ptrCast(*const IInternetProtocol, self), dlibMove, dwOrigin, plibNewPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_LockRequest(self: *const T, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).LockRequest(@ptrCast(*const IInternetProtocol, self), dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_UnlockRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).UnlockRequest(@ptrCast(*const IInternetProtocol, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolEx_Value = @import("../zig.zig").Guid.initString("c7a98e66-1010-492c-a1c8-c809e1f75905");
pub const IID_IInternetProtocolEx = &IID_IInternetProtocolEx_Value;
pub const IInternetProtocolEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetProtocol.VTable,
        StartEx: fn(
            self: *const IInternetProtocolEx,
            pUri: ?*IUri,
            pOIProtSink: ?*IInternetProtocolSink,
            pOIBindInfo: ?*IInternetBindInfo,
            grfPI: u32,
            dwReserved: HANDLE_PTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetProtocol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolEx_StartEx(self: *const T, pUri: ?*IUri, pOIProtSink: ?*IInternetProtocolSink, pOIBindInfo: ?*IInternetBindInfo, grfPI: u32, dwReserved: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolEx.VTable, self.vtable).StartEx(@ptrCast(*const IInternetProtocolEx, self), pUri, pOIProtSink, pOIBindInfo, grfPI, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolSink_Value = @import("../zig.zig").Guid.initString("79eac9e5-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolSink = &IID_IInternetProtocolSink_Value;
pub const IInternetProtocolSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Switch: fn(
            self: *const IInternetProtocolSink,
            pProtocolData: ?*PROTOCOLDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportProgress: fn(
            self: *const IInternetProtocolSink,
            ulStatusCode: u32,
            szStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportData: fn(
            self: *const IInternetProtocolSink,
            grfBSCF: u32,
            ulProgress: u32,
            ulProgressMax: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportResult: fn(
            self: *const IInternetProtocolSink,
            hrResult: HRESULT,
            dwError: u32,
            szResult: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_Switch(self: *const T, pProtocolData: ?*PROTOCOLDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).Switch(@ptrCast(*const IInternetProtocolSink, self), pProtocolData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportProgress(self: *const T, ulStatusCode: u32, szStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportProgress(@ptrCast(*const IInternetProtocolSink, self), ulStatusCode, szStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportData(self: *const T, grfBSCF: u32, ulProgress: u32, ulProgressMax: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportData(@ptrCast(*const IInternetProtocolSink, self), grfBSCF, ulProgress, ulProgressMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportResult(self: *const T, hrResult: HRESULT, dwError: u32, szResult: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportResult(@ptrCast(*const IInternetProtocolSink, self), hrResult, dwError, szResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolSinkStackable_Value = @import("../zig.zig").Guid.initString("79eac9f0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolSinkStackable = &IID_IInternetProtocolSinkStackable_Value;
pub const IInternetProtocolSinkStackable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchSink: fn(
            self: *const IInternetProtocolSinkStackable,
            pOIProtSink: ?*IInternetProtocolSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitSwitch: fn(
            self: *const IInternetProtocolSinkStackable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RollbackSwitch: fn(
            self: *const IInternetProtocolSinkStackable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_SwitchSink(self: *const T, pOIProtSink: ?*IInternetProtocolSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).SwitchSink(@ptrCast(*const IInternetProtocolSinkStackable, self), pOIProtSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_CommitSwitch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).CommitSwitch(@ptrCast(*const IInternetProtocolSinkStackable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_RollbackSwitch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).RollbackSwitch(@ptrCast(*const IInternetProtocolSinkStackable, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OIBDG_FLAGS = enum(i32) {
    APARTMENTTHREADED = 256,
    DATAONLY = 4096,
};
pub const OIBDG_APARTMENTTHREADED = OIBDG_FLAGS.APARTMENTTHREADED;
pub const OIBDG_DATAONLY = OIBDG_FLAGS.DATAONLY;

const IID_IInternetSession_Value = @import("../zig.zig").Guid.initString("79eac9e7-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSession = &IID_IInternetSession_Value;
pub const IInternetSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterNameSpace: fn(
            self: *const IInternetSession,
            pCF: ?*IClassFactory,
            rclsid: ?*const Guid,
            pwzProtocol: ?[*:0]const u16,
            cPatterns: u32,
            ppwzPatterns: ?*const ?PWSTR,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterNameSpace: fn(
            self: *const IInternetSession,
            pCF: ?*IClassFactory,
            pszProtocol: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterMimeFilter: fn(
            self: *const IInternetSession,
            pCF: ?*IClassFactory,
            rclsid: ?*const Guid,
            pwzType: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterMimeFilter: fn(
            self: *const IInternetSession,
            pCF: ?*IClassFactory,
            pwzType: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBinding: fn(
            self: *const IInternetSession,
            pBC: ?*IBindCtx,
            szUrl: ?[*:0]const u16,
            pUnkOuter: ?*IUnknown,
            ppUnk: ?*?*IUnknown,
            ppOInetProt: ?*?*IInternetProtocol,
            dwOption: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSessionOption: fn(
            self: *const IInternetSession,
            dwOption: u32,
            pBuffer: ?*c_void,
            dwBufferLength: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionOption: fn(
            self: *const IInternetSession,
            dwOption: u32,
            pBuffer: ?*c_void,
            pdwBufferLength: ?*u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_RegisterNameSpace(self: *const T, pCF: ?*IClassFactory, rclsid: ?*const Guid, pwzProtocol: ?[*:0]const u16, cPatterns: u32, ppwzPatterns: ?*const ?PWSTR, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).RegisterNameSpace(@ptrCast(*const IInternetSession, self), pCF, rclsid, pwzProtocol, cPatterns, ppwzPatterns, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_UnregisterNameSpace(self: *const T, pCF: ?*IClassFactory, pszProtocol: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).UnregisterNameSpace(@ptrCast(*const IInternetSession, self), pCF, pszProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_RegisterMimeFilter(self: *const T, pCF: ?*IClassFactory, rclsid: ?*const Guid, pwzType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).RegisterMimeFilter(@ptrCast(*const IInternetSession, self), pCF, rclsid, pwzType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_UnregisterMimeFilter(self: *const T, pCF: ?*IClassFactory, pwzType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).UnregisterMimeFilter(@ptrCast(*const IInternetSession, self), pCF, pwzType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_CreateBinding(self: *const T, pBC: ?*IBindCtx, szUrl: ?[*:0]const u16, pUnkOuter: ?*IUnknown, ppUnk: ?*?*IUnknown, ppOInetProt: ?*?*IInternetProtocol, dwOption: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).CreateBinding(@ptrCast(*const IInternetSession, self), pBC, szUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_SetSessionOption(self: *const T, dwOption: u32, pBuffer: ?*c_void, dwBufferLength: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).SetSessionOption(@ptrCast(*const IInternetSession, self), dwOption, pBuffer, dwBufferLength, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_GetSessionOption(self: *const T, dwOption: u32, pBuffer: ?*c_void, pdwBufferLength: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).GetSessionOption(@ptrCast(*const IInternetSession, self), dwOption, pBuffer, pdwBufferLength, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetThreadSwitch_Value = @import("../zig.zig").Guid.initString("79eac9e8-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetThreadSwitch = &IID_IInternetThreadSwitch_Value;
pub const IInternetThreadSwitch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: fn(
            self: *const IInternetThreadSwitch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Continue: fn(
            self: *const IInternetThreadSwitch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetThreadSwitch_Prepare(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetThreadSwitch.VTable, self.vtable).Prepare(@ptrCast(*const IInternetThreadSwitch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetThreadSwitch_Continue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetThreadSwitch.VTable, self.vtable).Continue(@ptrCast(*const IInternetThreadSwitch, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetPriority_Value = @import("../zig.zig").Guid.initString("79eac9eb-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetPriority = &IID_IInternetPriority_Value;
pub const IInternetPriority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPriority: fn(
            self: *const IInternetPriority,
            nPriority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IInternetPriority,
            pnPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetPriority_SetPriority(self: *const T, nPriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetPriority.VTable, self.vtable).SetPriority(@ptrCast(*const IInternetPriority, self), nPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetPriority_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetPriority.VTable, self.vtable).GetPriority(@ptrCast(*const IInternetPriority, self), pnPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PARSEACTION = enum(i32) {
    CANONICALIZE = 1,
    FRIENDLY = 2,
    SECURITY_URL = 3,
    ROOTDOCUMENT = 4,
    DOCUMENT = 5,
    ANCHOR = 6,
    ENCODE_IS_UNESCAPE = 7,
    DECODE_IS_ESCAPE = 8,
    PATH_FROM_URL = 9,
    URL_FROM_PATH = 10,
    MIME = 11,
    SERVER = 12,
    SCHEMA = 13,
    SITE = 14,
    DOMAIN = 15,
    LOCATION = 16,
    SECURITY_DOMAIN = 17,
    ESCAPE = 18,
    UNESCAPE = 19,
};
pub const PARSE_CANONICALIZE = PARSEACTION.CANONICALIZE;
pub const PARSE_FRIENDLY = PARSEACTION.FRIENDLY;
pub const PARSE_SECURITY_URL = PARSEACTION.SECURITY_URL;
pub const PARSE_ROOTDOCUMENT = PARSEACTION.ROOTDOCUMENT;
pub const PARSE_DOCUMENT = PARSEACTION.DOCUMENT;
pub const PARSE_ANCHOR = PARSEACTION.ANCHOR;
pub const PARSE_ENCODE_IS_UNESCAPE = PARSEACTION.ENCODE_IS_UNESCAPE;
pub const PARSE_DECODE_IS_ESCAPE = PARSEACTION.DECODE_IS_ESCAPE;
pub const PARSE_PATH_FROM_URL = PARSEACTION.PATH_FROM_URL;
pub const PARSE_URL_FROM_PATH = PARSEACTION.URL_FROM_PATH;
pub const PARSE_MIME = PARSEACTION.MIME;
pub const PARSE_SERVER = PARSEACTION.SERVER;
pub const PARSE_SCHEMA = PARSEACTION.SCHEMA;
pub const PARSE_SITE = PARSEACTION.SITE;
pub const PARSE_DOMAIN = PARSEACTION.DOMAIN;
pub const PARSE_LOCATION = PARSEACTION.LOCATION;
pub const PARSE_SECURITY_DOMAIN = PARSEACTION.SECURITY_DOMAIN;
pub const PARSE_ESCAPE = PARSEACTION.ESCAPE;
pub const PARSE_UNESCAPE = PARSEACTION.UNESCAPE;

pub const PSUACTION = enum(i32) {
    DEFAULT = 1,
    SECURITY_URL_ONLY = 2,
};
pub const PSU_DEFAULT = PSUACTION.DEFAULT;
pub const PSU_SECURITY_URL_ONLY = PSUACTION.SECURITY_URL_ONLY;

pub const QUERYOPTION = enum(i32) {
    EXPIRATION_DATE = 1,
    TIME_OF_LAST_CHANGE = 2,
    CONTENT_ENCODING = 3,
    CONTENT_TYPE = 4,
    REFRESH = 5,
    RECOMBINE = 6,
    CAN_NAVIGATE = 7,
    USES_NETWORK = 8,
    IS_CACHED = 9,
    IS_INSTALLEDENTRY = 10,
    IS_CACHED_OR_MAPPED = 11,
    USES_CACHE = 12,
    IS_SECURE = 13,
    IS_SAFE = 14,
    USES_HISTORYFOLDER = 15,
    IS_CACHED_AND_USABLE_OFFLINE = 16,
};
pub const QUERY_EXPIRATION_DATE = QUERYOPTION.EXPIRATION_DATE;
pub const QUERY_TIME_OF_LAST_CHANGE = QUERYOPTION.TIME_OF_LAST_CHANGE;
pub const QUERY_CONTENT_ENCODING = QUERYOPTION.CONTENT_ENCODING;
pub const QUERY_CONTENT_TYPE = QUERYOPTION.CONTENT_TYPE;
pub const QUERY_REFRESH = QUERYOPTION.REFRESH;
pub const QUERY_RECOMBINE = QUERYOPTION.RECOMBINE;
pub const QUERY_CAN_NAVIGATE = QUERYOPTION.CAN_NAVIGATE;
pub const QUERY_USES_NETWORK = QUERYOPTION.USES_NETWORK;
pub const QUERY_IS_CACHED = QUERYOPTION.IS_CACHED;
pub const QUERY_IS_INSTALLEDENTRY = QUERYOPTION.IS_INSTALLEDENTRY;
pub const QUERY_IS_CACHED_OR_MAPPED = QUERYOPTION.IS_CACHED_OR_MAPPED;
pub const QUERY_USES_CACHE = QUERYOPTION.USES_CACHE;
pub const QUERY_IS_SECURE = QUERYOPTION.IS_SECURE;
pub const QUERY_IS_SAFE = QUERYOPTION.IS_SAFE;
pub const QUERY_USES_HISTORYFOLDER = QUERYOPTION.USES_HISTORYFOLDER;
pub const QUERY_IS_CACHED_AND_USABLE_OFFLINE = QUERYOPTION.IS_CACHED_AND_USABLE_OFFLINE;

const IID_IInternetProtocolInfo_Value = @import("../zig.zig").Guid.initString("79eac9ec-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolInfo = &IID_IInternetProtocolInfo_Value;
pub const IInternetProtocolInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseUrl: fn(
            self: *const IInternetProtocolInfo,
            pwzUrl: ?[*:0]const u16,
            ParseAction: PARSEACTION,
            dwParseFlags: u32,
            pwzResult: ?PWSTR,
            cchResult: u32,
            pcchResult: ?*u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CombineUrl: fn(
            self: *const IInternetProtocolInfo,
            pwzBaseUrl: ?[*:0]const u16,
            pwzRelativeUrl: ?[*:0]const u16,
            dwCombineFlags: u32,
            pwzResult: ?PWSTR,
            cchResult: u32,
            pcchResult: ?*u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareUrl: fn(
            self: *const IInternetProtocolInfo,
            pwzUrl1: ?[*:0]const u16,
            pwzUrl2: ?[*:0]const u16,
            dwCompareFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInfo: fn(
            self: *const IInternetProtocolInfo,
            pwzUrl: ?[*:0]const u16,
            OueryOption: QUERYOPTION,
            dwQueryFlags: u32,
            pBuffer: [*]u8,
            cbBuffer: u32,
            pcbBuf: ?*u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_ParseUrl(self: *const T, pwzUrl: ?[*:0]const u16, ParseAction: PARSEACTION, dwParseFlags: u32, pwzResult: ?PWSTR, cchResult: u32, pcchResult: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).ParseUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl, ParseAction, dwParseFlags, pwzResult, cchResult, pcchResult, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_CombineUrl(self: *const T, pwzBaseUrl: ?[*:0]const u16, pwzRelativeUrl: ?[*:0]const u16, dwCombineFlags: u32, pwzResult: ?PWSTR, cchResult: u32, pcchResult: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).CombineUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pwzResult, cchResult, pcchResult, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_CompareUrl(self: *const T, pwzUrl1: ?[*:0]const u16, pwzUrl2: ?[*:0]const u16, dwCompareFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).CompareUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl1, pwzUrl2, dwCompareFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_QueryInfo(self: *const T, pwzUrl: ?[*:0]const u16, OueryOption: QUERYOPTION, dwQueryFlags: u32, pBuffer: [*]u8, cbBuffer: u32, pcbBuf: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).QueryInfo(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl, OueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const INTERNETFEATURELIST = enum(i32) {
    OBJECT_CACHING = 0,
    ZONE_ELEVATION = 1,
    MIME_HANDLING = 2,
    MIME_SNIFFING = 3,
    WINDOW_RESTRICTIONS = 4,
    WEBOC_POPUPMANAGEMENT = 5,
    BEHAVIORS = 6,
    DISABLE_MK_PROTOCOL = 7,
    LOCALMACHINE_LOCKDOWN = 8,
    SECURITYBAND = 9,
    RESTRICT_ACTIVEXINSTALL = 10,
    VALIDATE_NAVIGATE_URL = 11,
    RESTRICT_FILEDOWNLOAD = 12,
    ADDON_MANAGEMENT = 13,
    PROTOCOL_LOCKDOWN = 14,
    HTTP_USERNAME_PASSWORD_DISABLE = 15,
    SAFE_BINDTOOBJECT = 16,
    UNC_SAVEDFILECHECK = 17,
    GET_URL_DOM_FILEPATH_UNENCODED = 18,
    TABBED_BROWSING = 19,
    SSLUX = 20,
    DISABLE_NAVIGATION_SOUNDS = 21,
    DISABLE_LEGACY_COMPRESSION = 22,
    FORCE_ADDR_AND_STATUS = 23,
    XMLHTTP = 24,
    DISABLE_TELNET_PROTOCOL = 25,
    FEEDS = 26,
    BLOCK_INPUT_PROMPTS = 27,
    ENTRY_COUNT = 28,
};
pub const FEATURE_OBJECT_CACHING = INTERNETFEATURELIST.OBJECT_CACHING;
pub const FEATURE_ZONE_ELEVATION = INTERNETFEATURELIST.ZONE_ELEVATION;
pub const FEATURE_MIME_HANDLING = INTERNETFEATURELIST.MIME_HANDLING;
pub const FEATURE_MIME_SNIFFING = INTERNETFEATURELIST.MIME_SNIFFING;
pub const FEATURE_WINDOW_RESTRICTIONS = INTERNETFEATURELIST.WINDOW_RESTRICTIONS;
pub const FEATURE_WEBOC_POPUPMANAGEMENT = INTERNETFEATURELIST.WEBOC_POPUPMANAGEMENT;
pub const FEATURE_BEHAVIORS = INTERNETFEATURELIST.BEHAVIORS;
pub const FEATURE_DISABLE_MK_PROTOCOL = INTERNETFEATURELIST.DISABLE_MK_PROTOCOL;
pub const FEATURE_LOCALMACHINE_LOCKDOWN = INTERNETFEATURELIST.LOCALMACHINE_LOCKDOWN;
pub const FEATURE_SECURITYBAND = INTERNETFEATURELIST.SECURITYBAND;
pub const FEATURE_RESTRICT_ACTIVEXINSTALL = INTERNETFEATURELIST.RESTRICT_ACTIVEXINSTALL;
pub const FEATURE_VALIDATE_NAVIGATE_URL = INTERNETFEATURELIST.VALIDATE_NAVIGATE_URL;
pub const FEATURE_RESTRICT_FILEDOWNLOAD = INTERNETFEATURELIST.RESTRICT_FILEDOWNLOAD;
pub const FEATURE_ADDON_MANAGEMENT = INTERNETFEATURELIST.ADDON_MANAGEMENT;
pub const FEATURE_PROTOCOL_LOCKDOWN = INTERNETFEATURELIST.PROTOCOL_LOCKDOWN;
pub const FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = INTERNETFEATURELIST.HTTP_USERNAME_PASSWORD_DISABLE;
pub const FEATURE_SAFE_BINDTOOBJECT = INTERNETFEATURELIST.SAFE_BINDTOOBJECT;
pub const FEATURE_UNC_SAVEDFILECHECK = INTERNETFEATURELIST.UNC_SAVEDFILECHECK;
pub const FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = INTERNETFEATURELIST.GET_URL_DOM_FILEPATH_UNENCODED;
pub const FEATURE_TABBED_BROWSING = INTERNETFEATURELIST.TABBED_BROWSING;
pub const FEATURE_SSLUX = INTERNETFEATURELIST.SSLUX;
pub const FEATURE_DISABLE_NAVIGATION_SOUNDS = INTERNETFEATURELIST.DISABLE_NAVIGATION_SOUNDS;
pub const FEATURE_DISABLE_LEGACY_COMPRESSION = INTERNETFEATURELIST.DISABLE_LEGACY_COMPRESSION;
pub const FEATURE_FORCE_ADDR_AND_STATUS = INTERNETFEATURELIST.FORCE_ADDR_AND_STATUS;
pub const FEATURE_XMLHTTP = INTERNETFEATURELIST.XMLHTTP;
pub const FEATURE_DISABLE_TELNET_PROTOCOL = INTERNETFEATURELIST.DISABLE_TELNET_PROTOCOL;
pub const FEATURE_FEEDS = INTERNETFEATURELIST.FEEDS;
pub const FEATURE_BLOCK_INPUT_PROMPTS = INTERNETFEATURELIST.BLOCK_INPUT_PROMPTS;
pub const FEATURE_ENTRY_COUNT = INTERNETFEATURELIST.ENTRY_COUNT;

const IID_IInternetSecurityMgrSite_Value = @import("../zig.zig").Guid.initString("79eac9ed-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSecurityMgrSite = &IID_IInternetSecurityMgrSite_Value;
pub const IInternetSecurityMgrSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: fn(
            self: *const IInternetSecurityMgrSite,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IInternetSecurityMgrSite,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityMgrSite_GetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityMgrSite.VTable, self.vtable).GetWindow(@ptrCast(*const IInternetSecurityMgrSite, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityMgrSite_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityMgrSite.VTable, self.vtable).EnableModeless(@ptrCast(*const IInternetSecurityMgrSite, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PUAF = enum(i32) {
    DEFAULT = 0,
    NOUI = 1,
    ISFILE = 2,
    WARN_IF_DENIED = 4,
    FORCEUI_FOREGROUND = 8,
    CHECK_TIFS = 16,
    DONTCHECKBOXINDIALOG = 32,
    TRUSTED = 64,
    ACCEPT_WILDCARD_SCHEME = 128,
    ENFORCERESTRICTED = 256,
    NOSAVEDFILECHECK = 512,
    REQUIRESAVEDFILECHECK = 1024,
    DONT_USE_CACHE = 4096,
    RESERVED1 = 8192,
    RESERVED2 = 16384,
    LMZ_UNLOCKED = 65536,
    LMZ_LOCKED = 131072,
    DEFAULTZONEPOL = 262144,
    NPL_USE_LOCKED_IF_RESTRICTED = 524288,
    NOUIIFLOCKED = 1048576,
    DRAGPROTOCOLCHECK = 2097152,
};
pub const PUAF_DEFAULT = PUAF.DEFAULT;
pub const PUAF_NOUI = PUAF.NOUI;
pub const PUAF_ISFILE = PUAF.ISFILE;
pub const PUAF_WARN_IF_DENIED = PUAF.WARN_IF_DENIED;
pub const PUAF_FORCEUI_FOREGROUND = PUAF.FORCEUI_FOREGROUND;
pub const PUAF_CHECK_TIFS = PUAF.CHECK_TIFS;
pub const PUAF_DONTCHECKBOXINDIALOG = PUAF.DONTCHECKBOXINDIALOG;
pub const PUAF_TRUSTED = PUAF.TRUSTED;
pub const PUAF_ACCEPT_WILDCARD_SCHEME = PUAF.ACCEPT_WILDCARD_SCHEME;
pub const PUAF_ENFORCERESTRICTED = PUAF.ENFORCERESTRICTED;
pub const PUAF_NOSAVEDFILECHECK = PUAF.NOSAVEDFILECHECK;
pub const PUAF_REQUIRESAVEDFILECHECK = PUAF.REQUIRESAVEDFILECHECK;
pub const PUAF_DONT_USE_CACHE = PUAF.DONT_USE_CACHE;
pub const PUAF_RESERVED1 = PUAF.RESERVED1;
pub const PUAF_RESERVED2 = PUAF.RESERVED2;
pub const PUAF_LMZ_UNLOCKED = PUAF.LMZ_UNLOCKED;
pub const PUAF_LMZ_LOCKED = PUAF.LMZ_LOCKED;
pub const PUAF_DEFAULTZONEPOL = PUAF.DEFAULTZONEPOL;
pub const PUAF_NPL_USE_LOCKED_IF_RESTRICTED = PUAF.NPL_USE_LOCKED_IF_RESTRICTED;
pub const PUAF_NOUIIFLOCKED = PUAF.NOUIIFLOCKED;
pub const PUAF_DRAGPROTOCOLCHECK = PUAF.DRAGPROTOCOLCHECK;

pub const PUAFOUT = enum(i32) {
    DEFAULT = 0,
    ISLOCKZONEPOLICY = 1,
};
pub const PUAFOUT_DEFAULT = PUAFOUT.DEFAULT;
pub const PUAFOUT_ISLOCKZONEPOLICY = PUAFOUT.ISLOCKZONEPOLICY;

pub const SZM_FLAGS = enum(i32) {
    CREATE = 0,
    DELETE = 1,
};
pub const SZM_CREATE = SZM_FLAGS.CREATE;
pub const SZM_DELETE = SZM_FLAGS.DELETE;

const IID_IInternetSecurityManager_Value = @import("../zig.zig").Guid.initString("79eac9ee-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSecurityManager = &IID_IInternetSecurityManager_Value;
pub const IInternetSecurityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSecuritySite: fn(
            self: *const IInternetSecurityManager,
            pSite: ?*IInternetSecurityMgrSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecuritySite: fn(
            self: *const IInternetSecurityManager,
            ppSite: ?*?*IInternetSecurityMgrSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapUrlToZone: fn(
            self: *const IInternetSecurityManager,
            pwszUrl: ?[*:0]const u16,
            pdwZone: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityId: fn(
            self: *const IInternetSecurityManager,
            pwszUrl: ?[*:0]const u16,
            pbSecurityId: *[512]u8,
            pcbSecurityId: ?*u32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUrlAction: fn(
            self: *const IInternetSecurityManager,
            pwszUrl: ?[*:0]const u16,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            pContext: ?*u8,
            cbContext: u32,
            dwFlags: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCustomPolicy: fn(
            self: *const IInternetSecurityManager,
            pwszUrl: ?[*:0]const u16,
            guidKey: ?*const Guid,
            ppPolicy: [*]?*u8,
            pcbPolicy: ?*u32,
            pContext: ?*u8,
            cbContext: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZoneMapping: fn(
            self: *const IInternetSecurityManager,
            dwZone: u32,
            lpszPattern: ?[*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZoneMappings: fn(
            self: *const IInternetSecurityManager,
            dwZone: u32,
            ppenumString: ?*?*IEnumString,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_SetSecuritySite(self: *const T, pSite: ?*IInternetSecurityMgrSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).SetSecuritySite(@ptrCast(*const IInternetSecurityManager, self), pSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetSecuritySite(self: *const T, ppSite: ?*?*IInternetSecurityMgrSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetSecuritySite(@ptrCast(*const IInternetSecurityManager, self), ppSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_MapUrlToZone(self: *const T, pwszUrl: ?[*:0]const u16, pdwZone: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).MapUrlToZone(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, pdwZone, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetSecurityId(self: *const T, pwszUrl: ?[*:0]const u16, pbSecurityId: *[512]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetSecurityId(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_ProcessUrlAction(self: *const T, pwszUrl: ?[*:0]const u16, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).ProcessUrlAction(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_QueryCustomPolicy(self: *const T, pwszUrl: ?[*:0]const u16, guidKey: ?*const Guid, ppPolicy: [*]?*u8, pcbPolicy: ?*u32, pContext: ?*u8, cbContext: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).QueryCustomPolicy(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_SetZoneMapping(self: *const T, dwZone: u32, lpszPattern: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).SetZoneMapping(@ptrCast(*const IInternetSecurityManager, self), dwZone, lpszPattern, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetZoneMappings(self: *const T, dwZone: u32, ppenumString: ?*?*IEnumString, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetZoneMappings(@ptrCast(*const IInternetSecurityManager, self), dwZone, ppenumString, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetSecurityManagerEx_Value = @import("../zig.zig").Guid.initString("f164edf1-cc7c-4f0d-9a94-34222625c393");
pub const IID_IInternetSecurityManagerEx = &IID_IInternetSecurityManagerEx_Value;
pub const IInternetSecurityManagerEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetSecurityManager.VTable,
        ProcessUrlActionEx: fn(
            self: *const IInternetSecurityManagerEx,
            pwszUrl: ?[*:0]const u16,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            pContext: ?*u8,
            cbContext: u32,
            dwFlags: u32,
            dwReserved: u32,
            pdwOutFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetSecurityManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx_ProcessUrlActionEx(self: *const T, pwszUrl: ?[*:0]const u16, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: u32, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx.VTable, self.vtable).ProcessUrlActionEx(@ptrCast(*const IInternetSecurityManagerEx, self), pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved, pdwOutFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetSecurityManagerEx2_Value = @import("../zig.zig").Guid.initString("f1e50292-a795-4117-8e09-2b560a72ac60");
pub const IID_IInternetSecurityManagerEx2 = &IID_IInternetSecurityManagerEx2_Value;
pub const IInternetSecurityManagerEx2 = extern struct {
    pub const VTable = extern struct {
        base: IInternetSecurityManagerEx.VTable,
        MapUrlToZoneEx2: fn(
            self: *const IInternetSecurityManagerEx2,
            pUri: ?*IUri,
            pdwZone: ?*u32,
            dwFlags: u32,
            ppwszMappedUrl: ?*?PWSTR,
            pdwOutFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUrlActionEx2: fn(
            self: *const IInternetSecurityManagerEx2,
            pUri: ?*IUri,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            pContext: ?*u8,
            cbContext: u32,
            dwFlags: u32,
            dwReserved: usize,
            pdwOutFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityIdEx2: fn(
            self: *const IInternetSecurityManagerEx2,
            pUri: ?*IUri,
            pbSecurityId: *[512]u8,
            pcbSecurityId: ?*u32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCustomPolicyEx2: fn(
            self: *const IInternetSecurityManagerEx2,
            pUri: ?*IUri,
            guidKey: ?*const Guid,
            ppPolicy: [*]?*u8,
            pcbPolicy: ?*u32,
            pContext: ?*u8,
            cbContext: u32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetSecurityManagerEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_MapUrlToZoneEx2(self: *const T, pUri: ?*IUri, pdwZone: ?*u32, dwFlags: u32, ppwszMappedUrl: ?*?PWSTR, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).MapUrlToZoneEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, pdwZone, dwFlags, ppwszMappedUrl, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_ProcessUrlActionEx2(self: *const T, pUri: ?*IUri, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: usize, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).ProcessUrlActionEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_GetSecurityIdEx2(self: *const T, pUri: ?*IUri, pbSecurityId: *[512]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).GetSecurityIdEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_QueryCustomPolicyEx2(self: *const T, pUri: ?*IUri, guidKey: ?*const Guid, ppPolicy: [*]?*u8, pcbPolicy: ?*u32, pContext: ?*u8, cbContext: u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).QueryCustomPolicyEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IZoneIdentifier_Value = @import("../zig.zig").Guid.initString("cd45f185-1b21-48e2-967b-ead743a8914e");
pub const IID_IZoneIdentifier = &IID_IZoneIdentifier_Value;
pub const IZoneIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IZoneIdentifier,
            pdwZone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetId: fn(
            self: *const IZoneIdentifier,
            dwZone: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IZoneIdentifier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_GetId(self: *const T, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).GetId(@ptrCast(*const IZoneIdentifier, self), pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_SetId(self: *const T, dwZone: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).SetId(@ptrCast(*const IZoneIdentifier, self), dwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_Remove(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).Remove(@ptrCast(*const IZoneIdentifier, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IZoneIdentifier2_Value = @import("../zig.zig").Guid.initString("eb5e760c-09ef-45c0-b510-70830ce31e6a");
pub const IID_IZoneIdentifier2 = &IID_IZoneIdentifier2_Value;
pub const IZoneIdentifier2 = extern struct {
    pub const VTable = extern struct {
        base: IZoneIdentifier.VTable,
        GetLastWriterPackageFamilyName: fn(
            self: *const IZoneIdentifier2,
            packageFamilyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLastWriterPackageFamilyName: fn(
            self: *const IZoneIdentifier2,
            packageFamilyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveLastWriterPackageFamilyName: fn(
            self: *const IZoneIdentifier2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppZoneId: fn(
            self: *const IZoneIdentifier2,
            zone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAppZoneId: fn(
            self: *const IZoneIdentifier2,
            zone: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAppZoneId: fn(
            self: *const IZoneIdentifier2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IZoneIdentifier.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_GetLastWriterPackageFamilyName(self: *const T, packageFamilyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).GetLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self), packageFamilyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_SetLastWriterPackageFamilyName(self: *const T, packageFamilyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).SetLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self), packageFamilyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_RemoveLastWriterPackageFamilyName(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).RemoveLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_GetAppZoneId(self: *const T, zone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).GetAppZoneId(@ptrCast(*const IZoneIdentifier2, self), zone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_SetAppZoneId(self: *const T, zone: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).SetAppZoneId(@ptrCast(*const IZoneIdentifier2, self), zone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_RemoveAppZoneId(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).RemoveAppZoneId(@ptrCast(*const IZoneIdentifier2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetHostSecurityManager_Value = @import("../zig.zig").Guid.initString("3af280b6-cb3f-11d0-891e-00c04fb6bfc4");
pub const IID_IInternetHostSecurityManager = &IID_IInternetHostSecurityManager_Value;
pub const IInternetHostSecurityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecurityId: fn(
            self: *const IInternetHostSecurityManager,
            pbSecurityId: [*:0]u8,
            pcbSecurityId: ?*u32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUrlAction: fn(
            self: *const IInternetHostSecurityManager,
            dwAction: u32,
            pPolicy: ?*u8,
            cbPolicy: u32,
            pContext: ?[*:0]u8,
            cbContext: u32,
            dwFlags: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCustomPolicy: fn(
            self: *const IInternetHostSecurityManager,
            guidKey: ?*const Guid,
            ppPolicy: ?[*]?*u8,
            pcbPolicy: ?*u32,
            pContext: [*:0]u8,
            cbContext: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_GetSecurityId(self: *const T, pbSecurityId: [*:0]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).GetSecurityId(@ptrCast(*const IInternetHostSecurityManager, self), pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_ProcessUrlAction(self: *const T, dwAction: u32, pPolicy: ?*u8, cbPolicy: u32, pContext: ?[*:0]u8, cbContext: u32, dwFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).ProcessUrlAction(@ptrCast(*const IInternetHostSecurityManager, self), dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_QueryCustomPolicy(self: *const T, guidKey: ?*const Guid, ppPolicy: ?[*]?*u8, pcbPolicy: ?*u32, pContext: [*:0]u8, cbContext: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).QueryCustomPolicy(@ptrCast(*const IInternetHostSecurityManager, self), guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const URLZONE = enum(i32) {
    INVALID = -1,
    PREDEFINED_MIN = 0,
    // LOCAL_MACHINE = 0, this enum value conflicts with PREDEFINED_MIN
    INTRANET = 1,
    TRUSTED = 2,
    INTERNET = 3,
    UNTRUSTED = 4,
    PREDEFINED_MAX = 999,
    USER_MIN = 1000,
    USER_MAX = 10000,
};
pub const URLZONE_INVALID = URLZONE.INVALID;
pub const URLZONE_PREDEFINED_MIN = URLZONE.PREDEFINED_MIN;
pub const URLZONE_LOCAL_MACHINE = URLZONE.PREDEFINED_MIN;
pub const URLZONE_INTRANET = URLZONE.INTRANET;
pub const URLZONE_TRUSTED = URLZONE.TRUSTED;
pub const URLZONE_INTERNET = URLZONE.INTERNET;
pub const URLZONE_UNTRUSTED = URLZONE.UNTRUSTED;
pub const URLZONE_PREDEFINED_MAX = URLZONE.PREDEFINED_MAX;
pub const URLZONE_USER_MIN = URLZONE.USER_MIN;
pub const URLZONE_USER_MAX = URLZONE.USER_MAX;

pub const URLTEMPLATE = enum(i32) {
    CUSTOM = 0,
    PREDEFINED_MIN = 65536,
    // LOW = 65536, this enum value conflicts with PREDEFINED_MIN
    MEDLOW = 66816,
    MEDIUM = 69632,
    MEDHIGH = 70912,
    HIGH = 73728,
    PREDEFINED_MAX = 131072,
};
pub const URLTEMPLATE_CUSTOM = URLTEMPLATE.CUSTOM;
pub const URLTEMPLATE_PREDEFINED_MIN = URLTEMPLATE.PREDEFINED_MIN;
pub const URLTEMPLATE_LOW = URLTEMPLATE.PREDEFINED_MIN;
pub const URLTEMPLATE_MEDLOW = URLTEMPLATE.MEDLOW;
pub const URLTEMPLATE_MEDIUM = URLTEMPLATE.MEDIUM;
pub const URLTEMPLATE_MEDHIGH = URLTEMPLATE.MEDHIGH;
pub const URLTEMPLATE_HIGH = URLTEMPLATE.HIGH;
pub const URLTEMPLATE_PREDEFINED_MAX = URLTEMPLATE.PREDEFINED_MAX;

pub const INET_ZONE_MANAGER_CONSTANTS = enum(i32) {
    PATH = 260,
    DESCRIPTION = 200,
};
pub const MAX_ZONE_PATH = INET_ZONE_MANAGER_CONSTANTS.PATH;
pub const MAX_ZONE_DESCRIPTION = INET_ZONE_MANAGER_CONSTANTS.DESCRIPTION;

pub const ZAFLAGS = enum(i32) {
    CUSTOM_EDIT = 1,
    ADD_SITES = 2,
    REQUIRE_VERIFICATION = 4,
    INCLUDE_PROXY_OVERRIDE = 8,
    INCLUDE_INTRANET_SITES = 16,
    NO_UI = 32,
    SUPPORTS_VERIFICATION = 64,
    UNC_AS_INTRANET = 128,
    DETECT_INTRANET = 256,
    USE_LOCKED_ZONES = 65536,
    VERIFY_TEMPLATE_SETTINGS = 131072,
    NO_CACHE = 262144,
};
pub const ZAFLAGS_CUSTOM_EDIT = ZAFLAGS.CUSTOM_EDIT;
pub const ZAFLAGS_ADD_SITES = ZAFLAGS.ADD_SITES;
pub const ZAFLAGS_REQUIRE_VERIFICATION = ZAFLAGS.REQUIRE_VERIFICATION;
pub const ZAFLAGS_INCLUDE_PROXY_OVERRIDE = ZAFLAGS.INCLUDE_PROXY_OVERRIDE;
pub const ZAFLAGS_INCLUDE_INTRANET_SITES = ZAFLAGS.INCLUDE_INTRANET_SITES;
pub const ZAFLAGS_NO_UI = ZAFLAGS.NO_UI;
pub const ZAFLAGS_SUPPORTS_VERIFICATION = ZAFLAGS.SUPPORTS_VERIFICATION;
pub const ZAFLAGS_UNC_AS_INTRANET = ZAFLAGS.UNC_AS_INTRANET;
pub const ZAFLAGS_DETECT_INTRANET = ZAFLAGS.DETECT_INTRANET;
pub const ZAFLAGS_USE_LOCKED_ZONES = ZAFLAGS.USE_LOCKED_ZONES;
pub const ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = ZAFLAGS.VERIFY_TEMPLATE_SETTINGS;
pub const ZAFLAGS_NO_CACHE = ZAFLAGS.NO_CACHE;

pub const ZONEATTRIBUTES = extern struct {
    cbSize: u32,
    szDisplayName: [260]u16,
    szDescription: [200]u16,
    szIconPath: [260]u16,
    dwTemplateMinLevel: u32,
    dwTemplateRecommended: u32,
    dwTemplateCurrentLevel: u32,
    dwFlags: u32,
};

pub const URLZONEREG = enum(i32) {
    DEFAULT = 0,
    HKLM = 1,
    HKCU = 2,
};
pub const URLZONEREG_DEFAULT = URLZONEREG.DEFAULT;
pub const URLZONEREG_HKLM = URLZONEREG.HKLM;
pub const URLZONEREG_HKCU = URLZONEREG.HKCU;

const IID_IInternetZoneManager_Value = @import("../zig.zig").Guid.initString("79eac9ef-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetZoneManager = &IID_IInternetZoneManager_Value;
pub const IInternetZoneManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetZoneAttributes: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            pZoneAttributes: ?*ZONEATTRIBUTES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZoneAttributes: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            pZoneAttributes: ?*ZONEATTRIBUTES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZoneCustomPolicy: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            guidKey: ?*const Guid,
            ppPolicy: ?*?*u8,
            pcbPolicy: ?*u32,
            urlZoneReg: URLZONEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZoneCustomPolicy: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            guidKey: ?*const Guid,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            urlZoneReg: URLZONEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZoneActionPolicy: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            urlZoneReg: URLZONEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZoneActionPolicy: fn(
            self: *const IInternetZoneManager,
            dwZone: u32,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            urlZoneReg: URLZONEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptAction: fn(
            self: *const IInternetZoneManager,
            dwAction: u32,
            hwndParent: ?HWND,
            pwszUrl: ?[*:0]const u16,
            pwszText: ?[*:0]const u16,
            dwPromptFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LogAction: fn(
            self: *const IInternetZoneManager,
            dwAction: u32,
            pwszUrl: ?[*:0]const u16,
            pwszText: ?[*:0]const u16,
            dwLogFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateZoneEnumerator: fn(
            self: *const IInternetZoneManager,
            pdwEnum: ?*u32,
            pdwCount: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZoneAt: fn(
            self: *const IInternetZoneManager,
            dwEnum: u32,
            dwIndex: u32,
            pdwZone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyZoneEnumerator: fn(
            self: *const IInternetZoneManager,
            dwEnum: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTemplatePoliciesToZone: fn(
            self: *const IInternetZoneManager,
            dwTemplate: u32,
            dwZone: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneAttributes(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneAttributes(@ptrCast(*const IInternetZoneManager, self), dwZone, pZoneAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneAttributes(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneAttributes(@ptrCast(*const IInternetZoneManager, self), dwZone, pZoneAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneCustomPolicy(self: *const T, dwZone: u32, guidKey: ?*const Guid, ppPolicy: ?*?*u8, pcbPolicy: ?*u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneCustomPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, guidKey, ppPolicy, pcbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneCustomPolicy(self: *const T, dwZone: u32, guidKey: ?*const Guid, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneCustomPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, guidKey, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneActionPolicy(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneActionPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneActionPolicy(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneActionPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_PromptAction(self: *const T, dwAction: u32, hwndParent: ?HWND, pwszUrl: ?[*:0]const u16, pwszText: ?[*:0]const u16, dwPromptFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).PromptAction(@ptrCast(*const IInternetZoneManager, self), dwAction, hwndParent, pwszUrl, pwszText, dwPromptFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_LogAction(self: *const T, dwAction: u32, pwszUrl: ?[*:0]const u16, pwszText: ?[*:0]const u16, dwLogFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).LogAction(@ptrCast(*const IInternetZoneManager, self), dwAction, pwszUrl, pwszText, dwLogFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_CreateZoneEnumerator(self: *const T, pdwEnum: ?*u32, pdwCount: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).CreateZoneEnumerator(@ptrCast(*const IInternetZoneManager, self), pdwEnum, pdwCount, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneAt(self: *const T, dwEnum: u32, dwIndex: u32, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneAt(@ptrCast(*const IInternetZoneManager, self), dwEnum, dwIndex, pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_DestroyZoneEnumerator(self: *const T, dwEnum: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).DestroyZoneEnumerator(@ptrCast(*const IInternetZoneManager, self), dwEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_CopyTemplatePoliciesToZone(self: *const T, dwTemplate: u32, dwZone: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).CopyTemplatePoliciesToZone(@ptrCast(*const IInternetZoneManager, self), dwTemplate, dwZone, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetZoneManagerEx_Value = @import("../zig.zig").Guid.initString("a4c23339-8e06-431e-9bf4-7e711c085648");
pub const IID_IInternetZoneManagerEx = &IID_IInternetZoneManagerEx_Value;
pub const IInternetZoneManagerEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetZoneManager.VTable,
        GetZoneActionPolicyEx: fn(
            self: *const IInternetZoneManagerEx,
            dwZone: u32,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            urlZoneReg: URLZONEREG,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZoneActionPolicyEx: fn(
            self: *const IInternetZoneManagerEx,
            dwZone: u32,
            dwAction: u32,
            pPolicy: [*:0]u8,
            cbPolicy: u32,
            urlZoneReg: URLZONEREG,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetZoneManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx_GetZoneActionPolicyEx(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx.VTable, self.vtable).GetZoneActionPolicyEx(@ptrCast(*const IInternetZoneManagerEx, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx_SetZoneActionPolicyEx(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx.VTable, self.vtable).SetZoneActionPolicyEx(@ptrCast(*const IInternetZoneManagerEx, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetZoneManagerEx2_Value = @import("../zig.zig").Guid.initString("edc17559-dd5d-4846-8eef-8becba5a4abf");
pub const IID_IInternetZoneManagerEx2 = &IID_IInternetZoneManagerEx2_Value;
pub const IInternetZoneManagerEx2 = extern struct {
    pub const VTable = extern struct {
        base: IInternetZoneManagerEx.VTable,
        GetZoneAttributesEx: fn(
            self: *const IInternetZoneManagerEx2,
            dwZone: u32,
            pZoneAttributes: ?*ZONEATTRIBUTES,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZoneSecurityState: fn(
            self: *const IInternetZoneManagerEx2,
            dwZoneIndex: u32,
            fRespectPolicy: BOOL,
            pdwState: ?*u32,
            pfPolicyEncountered: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIESecurityState: fn(
            self: *const IInternetZoneManagerEx2,
            fRespectPolicy: BOOL,
            pdwState: ?*u32,
            pfPolicyEncountered: ?*BOOL,
            fNoCache: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FixUnsecureSettings: fn(
            self: *const IInternetZoneManagerEx2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetZoneManagerEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetZoneAttributesEx(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetZoneAttributesEx(@ptrCast(*const IInternetZoneManagerEx2, self), dwZone, pZoneAttributes, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetZoneSecurityState(self: *const T, dwZoneIndex: u32, fRespectPolicy: BOOL, pdwState: ?*u32, pfPolicyEncountered: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetZoneSecurityState(@ptrCast(*const IInternetZoneManagerEx2, self), dwZoneIndex, fRespectPolicy, pdwState, pfPolicyEncountered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetIESecurityState(self: *const T, fRespectPolicy: BOOL, pdwState: ?*u32, pfPolicyEncountered: ?*BOOL, fNoCache: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetIESecurityState(@ptrCast(*const IInternetZoneManagerEx2, self), fRespectPolicy, pdwState, pfPolicyEncountered, fNoCache);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_FixUnsecureSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).FixUnsecureSettings(@ptrCast(*const IInternetZoneManagerEx2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CODEBASEHOLD = extern struct {
    cbSize: u32,
    szDistUnit: ?PWSTR,
    szCodeBase: ?PWSTR,
    dwVersionMS: u32,
    dwVersionLS: u32,
    dwStyle: u32,
};

const IID_ISoftDistExt_Value = @import("../zig.zig").Guid.initString("b15b8dc1-c7e1-11d0-8680-00aa00bdcb71");
pub const IID_ISoftDistExt = &IID_ISoftDistExt_Value;
pub const ISoftDistExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessSoftDist: fn(
            self: *const ISoftDistExt,
            szCDFURL: ?[*:0]const u16,
            pSoftDistElement: ?*IXMLElement,
            lpsdi: ?*SOFTDISTINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstCodeBase: fn(
            self: *const ISoftDistExt,
            szCodeBase: ?*?PWSTR,
            dwMaxSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextCodeBase: fn(
            self: *const ISoftDistExt,
            szCodeBase: ?*?PWSTR,
            dwMaxSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AsyncInstallDistributionUnit: fn(
            self: *const ISoftDistExt,
            pbc: ?*IBindCtx,
            pvReserved: ?*c_void,
            flags: u32,
            lpcbh: ?*CODEBASEHOLD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_ProcessSoftDist(self: *const T, szCDFURL: ?[*:0]const u16, pSoftDistElement: ?*IXMLElement, lpsdi: ?*SOFTDISTINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).ProcessSoftDist(@ptrCast(*const ISoftDistExt, self), szCDFURL, pSoftDistElement, lpsdi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_GetFirstCodeBase(self: *const T, szCodeBase: ?*?PWSTR, dwMaxSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).GetFirstCodeBase(@ptrCast(*const ISoftDistExt, self), szCodeBase, dwMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_GetNextCodeBase(self: *const T, szCodeBase: ?*?PWSTR, dwMaxSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).GetNextCodeBase(@ptrCast(*const ISoftDistExt, self), szCodeBase, dwMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_AsyncInstallDistributionUnit(self: *const T, pbc: ?*IBindCtx, pvReserved: ?*c_void, flags: u32, lpcbh: ?*CODEBASEHOLD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).AsyncInstallDistributionUnit(@ptrCast(*const ISoftDistExt, self), pbc, pvReserved, flags, lpcbh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICatalogFileInfo_Value = @import("../zig.zig").Guid.initString("711c7600-6b48-11d1-b403-00aa00b92af1");
pub const IID_ICatalogFileInfo = &IID_ICatalogFileInfo_Value;
pub const ICatalogFileInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCatalogFile: fn(
            self: *const ICatalogFileInfo,
            ppszCatalogFile: ?*?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJavaTrust: fn(
            self: *const ICatalogFileInfo,
            ppJavaTrust: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogFileInfo_GetCatalogFile(self: *const T, ppszCatalogFile: ?*?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatalogFileInfo.VTable, self.vtable).GetCatalogFile(@ptrCast(*const ICatalogFileInfo, self), ppszCatalogFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogFileInfo_GetJavaTrust(self: *const T, ppJavaTrust: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatalogFileInfo.VTable, self.vtable).GetJavaTrust(@ptrCast(*const ICatalogFileInfo, self), ppJavaTrust);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataFilter_Value = @import("../zig.zig").Guid.initString("69d14c80-c18e-11d0-a9ce-006097942311");
pub const IID_IDataFilter = &IID_IDataFilter_Value;
pub const IDataFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoEncode: fn(
            self: *const IDataFilter,
            dwFlags: u32,
            lInBufferSize: i32,
            pbInBuffer: [*:0]u8,
            lOutBufferSize: i32,
            pbOutBuffer: [*:0]u8,
            lInBytesAvailable: i32,
            plInBytesRead: ?*i32,
            plOutBytesWritten: ?*i32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoDecode: fn(
            self: *const IDataFilter,
            dwFlags: u32,
            lInBufferSize: i32,
            pbInBuffer: [*:0]u8,
            lOutBufferSize: i32,
            pbOutBuffer: [*:0]u8,
            lInBytesAvailable: i32,
            plInBytesRead: ?*i32,
            plOutBytesWritten: ?*i32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEncodingLevel: fn(
            self: *const IDataFilter,
            dwEncLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_DoEncode(self: *const T, dwFlags: u32, lInBufferSize: i32, pbInBuffer: [*:0]u8, lOutBufferSize: i32, pbOutBuffer: [*:0]u8, lInBytesAvailable: i32, plInBytesRead: ?*i32, plOutBytesWritten: ?*i32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).DoEncode(@ptrCast(*const IDataFilter, self), dwFlags, lInBufferSize, pbInBuffer, lOutBufferSize, pbOutBuffer, lInBytesAvailable, plInBytesRead, plOutBytesWritten, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_DoDecode(self: *const T, dwFlags: u32, lInBufferSize: i32, pbInBuffer: [*:0]u8, lOutBufferSize: i32, pbOutBuffer: [*:0]u8, lInBytesAvailable: i32, plInBytesRead: ?*i32, plOutBytesWritten: ?*i32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).DoDecode(@ptrCast(*const IDataFilter, self), dwFlags, lInBufferSize, pbInBuffer, lOutBufferSize, pbOutBuffer, lInBytesAvailable, plInBytesRead, plOutBytesWritten, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_SetEncodingLevel(self: *const T, dwEncLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).SetEncodingLevel(@ptrCast(*const IDataFilter, self), dwEncLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROTOCOLFILTERDATA = extern struct {
    cbSize: u32,
    pProtocolSink: ?*IInternetProtocolSink,
    pProtocol: ?*IInternetProtocol,
    pUnk: ?*IUnknown,
    dwFilterFlags: u32,
};

pub const DATAINFO = extern struct {
    ulTotalSize: u32,
    ulavrPacketSize: u32,
    ulConnectSpeed: u32,
    ulProcessorSpeed: u32,
};

const IID_IEncodingFilterFactory_Value = @import("../zig.zig").Guid.initString("70bdde00-c18e-11d0-a9ce-006097942311");
pub const IID_IEncodingFilterFactory = &IID_IEncodingFilterFactory_Value;
pub const IEncodingFilterFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindBestFilter: fn(
            self: *const IEncodingFilterFactory,
            pwzCodeIn: ?[*:0]const u16,
            pwzCodeOut: ?[*:0]const u16,
            info: DATAINFO,
            ppDF: ?*?*IDataFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultFilter: fn(
            self: *const IEncodingFilterFactory,
            pwzCodeIn: ?[*:0]const u16,
            pwzCodeOut: ?[*:0]const u16,
            ppDF: ?*?*IDataFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncodingFilterFactory_FindBestFilter(self: *const T, pwzCodeIn: ?[*:0]const u16, pwzCodeOut: ?[*:0]const u16, info: DATAINFO, ppDF: ?*?*IDataFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncodingFilterFactory.VTable, self.vtable).FindBestFilter(@ptrCast(*const IEncodingFilterFactory, self), pwzCodeIn, pwzCodeOut, info, ppDF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncodingFilterFactory_GetDefaultFilter(self: *const T, pwzCodeIn: ?[*:0]const u16, pwzCodeOut: ?[*:0]const u16, ppDF: ?*?*IDataFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncodingFilterFactory.VTable, self.vtable).GetDefaultFilter(@ptrCast(*const IEncodingFilterFactory, self), pwzCodeIn, pwzCodeOut, ppDF);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HIT_LOGGING_INFO = extern struct {
    dwStructSize: u32,
    lpszLoggedUrlName: ?PSTR,
    StartTime: SYSTEMTIME,
    EndTime: SYSTEMTIME,
    lpszExtendedInfo: ?PSTR,
};

pub const CONFIRMSAFETY = extern struct {
    clsid: Guid,
    pUnk: ?*IUnknown,
    dwFlags: u32,
};

const IID_IWrappedProtocol_Value = @import("../zig.zig").Guid.initString("53c84785-8425-4dc5-971b-e58d9c19f9b6");
pub const IID_IWrappedProtocol = &IID_IWrappedProtocol_Value;
pub const IWrappedProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWrapperCode: fn(
            self: *const IWrappedProtocol,
            pnCode: ?*i32,
            dwReserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWrappedProtocol_GetWrapperCode(self: *const T, pnCode: ?*i32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWrappedProtocol.VTable, self.vtable).GetWrapperCode(@ptrCast(*const IWrappedProtocol, self), pnCode, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDHANDLETYPES = enum(i32) {
    APPCACHE = 0,
    DEPENDENCY = 1,
    COUNT = 2,
};
pub const BINDHANDLETYPES_APPCACHE = BINDHANDLETYPES.APPCACHE;
pub const BINDHANDLETYPES_DEPENDENCY = BINDHANDLETYPES.DEPENDENCY;
pub const BINDHANDLETYPES_COUNT = BINDHANDLETYPES.COUNT;

const IID_IGetBindHandle_Value = @import("../zig.zig").Guid.initString("af0ff408-129d-4b20-91f0-02bd23d88352");
pub const IID_IGetBindHandle = &IID_IGetBindHandle_Value;
pub const IGetBindHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBindHandle: fn(
            self: *const IGetBindHandle,
            enumRequestedHandle: BINDHANDLETYPES,
            pRetHandle: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetBindHandle_GetBindHandle(self: *const T, enumRequestedHandle: BINDHANDLETYPES, pRetHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetBindHandle.VTable, self.vtable).GetBindHandle(@ptrCast(*const IGetBindHandle, self), enumRequestedHandle, pRetHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROTOCOL_ARGUMENT = extern struct {
    szMethod: ?[*:0]const u16,
    szTargetUrl: ?[*:0]const u16,
};

const IID_IBindCallbackRedirect_Value = @import("../zig.zig").Guid.initString("11c81bc2-121e-4ed5-b9c4-b430bd54f2c0");
pub const IID_IBindCallbackRedirect = &IID_IBindCallbackRedirect_Value;
pub const IBindCallbackRedirect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Redirect: fn(
            self: *const IBindCallbackRedirect,
            lpcUrl: ?[*:0]const u16,
            vbCancel: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCallbackRedirect_Redirect(self: *const T, lpcUrl: ?[*:0]const u16, vbCancel: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCallbackRedirect.VTable, self.vtable).Redirect(@ptrCast(*const IBindCallbackRedirect, self), lpcUrl, vbCancel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHttpSecurity_Value = @import("../zig.zig").Guid.initString("a9eda967-f50e-4a33-b358-206f6ef3086d");
pub const IID_IBindHttpSecurity = &IID_IBindHttpSecurity_Value;
pub const IBindHttpSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIgnoreCertMask: fn(
            self: *const IBindHttpSecurity,
            pdwIgnoreCertMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHttpSecurity_GetIgnoreCertMask(self: *const T, pdwIgnoreCertMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHttpSecurity.VTable, self.vtable).GetIgnoreCertMask(@ptrCast(*const IBindHttpSecurity, self), pdwIgnoreCertMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLESTREAMVTBL = extern struct {
    Get: isize,
    Put: isize,
};

pub const OLESTREAM = extern struct {
    lpstbl: ?*OLESTREAMVTBL,
};

pub const STDMSHLFLAGS = enum(i32) {
    SERVER = 1,
    HANDLER = 2,
};
pub const SMEXF_SERVER = STDMSHLFLAGS.SERVER;
pub const SMEXF_HANDLER = STDMSHLFLAGS.HANDLER;

pub const COWAIT_FLAGS = enum(i32) {
    DEFAULT = 0,
    WAITALL = 1,
    ALERTABLE = 2,
    INPUTAVAILABLE = 4,
    DISPATCH_CALLS = 8,
    DISPATCH_WINDOW_MESSAGES = 16,
};
pub const COWAIT_DEFAULT = COWAIT_FLAGS.DEFAULT;
pub const COWAIT_WAITALL = COWAIT_FLAGS.WAITALL;
pub const COWAIT_ALERTABLE = COWAIT_FLAGS.ALERTABLE;
pub const COWAIT_INPUTAVAILABLE = COWAIT_FLAGS.INPUTAVAILABLE;
pub const COWAIT_DISPATCH_CALLS = COWAIT_FLAGS.DISPATCH_CALLS;
pub const COWAIT_DISPATCH_WINDOW_MESSAGES = COWAIT_FLAGS.DISPATCH_WINDOW_MESSAGES;

pub const CWMO_FLAGS = enum(i32) {
    EFAULT = 0,
    ISPATCH_CALLS = 1,
    ISPATCH_WINDOW_MESSAGES = 2,
};
pub const CWMO_DEFAULT = CWMO_FLAGS.EFAULT;
pub const CWMO_DISPATCH_CALLS = CWMO_FLAGS.ISPATCH_CALLS;
pub const CWMO_DISPATCH_WINDOW_MESSAGES = CWMO_FLAGS.ISPATCH_WINDOW_MESSAGES;

pub const LPFNGETCLASSOBJECT = fn(
    param0: ?*const Guid,
    param1: ?*const Guid,
    param2: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNCANUNLOADNOW = fn(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const UASFLAGS = enum(i32) {
    NORMAL = 0,
    BLOCKED = 1,
    NOPARENTENABLE = 2,
    MASK = 3,
};
pub const UAS_NORMAL = UASFLAGS.NORMAL;
pub const UAS_BLOCKED = UASFLAGS.BLOCKED;
pub const UAS_NOPARENTENABLE = UASFLAGS.NOPARENTENABLE;
pub const UAS_MASK = UASFLAGS.MASK;

pub const READYSTATE = enum(i32) {
    UNINITIALIZED = 0,
    LOADING = 1,
    LOADED = 2,
    INTERACTIVE = 3,
    COMPLETE = 4,
};
pub const READYSTATE_UNINITIALIZED = READYSTATE.UNINITIALIZED;
pub const READYSTATE_LOADING = READYSTATE.LOADING;
pub const READYSTATE_LOADED = READYSTATE.LOADED;
pub const READYSTATE_INTERACTIVE = READYSTATE.INTERACTIVE;
pub const READYSTATE_COMPLETE = READYSTATE.COMPLETE;

pub const CONNECTDATA = extern struct {
    pUnk: ?*IUnknown,
    dwCookie: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnections_Value = @import("../zig.zig").Guid.initString("b196b287-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnections = &IID_IEnumConnections_Value;
pub const IEnumConnections = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumConnections,
            cConnections: u32,
            rgcd: [*]CONNECTDATA,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumConnections,
            cConnections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumConnections,
            ppEnum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Next(self: *const T, cConnections: u32, rgcd: [*]CONNECTDATA, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Next(@ptrCast(*const IEnumConnections, self), cConnections, rgcd, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Skip(self: *const T, cConnections: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Skip(@ptrCast(*const IEnumConnections, self), cConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Reset(@ptrCast(*const IEnumConnections, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Clone(self: *const T, ppEnum: ?*?*IEnumConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Clone(@ptrCast(*const IEnumConnections, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPoint_Value = @import("../zig.zig").Guid.initString("b196b286-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPoint = &IID_IConnectionPoint_Value;
pub const IConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectionInterface: fn(
            self: *const IConnectionPoint,
            pIID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectionPointContainer: fn(
            self: *const IConnectionPoint,
            ppCPC: ?*?*IConnectionPointContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IConnectionPoint,
            pUnkSink: ?*IUnknown,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IConnectionPoint,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumConnections: fn(
            self: *const IConnectionPoint,
            ppEnum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_GetConnectionInterface(self: *const T, pIID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).GetConnectionInterface(@ptrCast(*const IConnectionPoint, self), pIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_GetConnectionPointContainer(self: *const T, ppCPC: ?*?*IConnectionPointContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).GetConnectionPointContainer(@ptrCast(*const IConnectionPoint, self), ppCPC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_Advise(self: *const T, pUnkSink: ?*IUnknown, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).Advise(@ptrCast(*const IConnectionPoint, self), pUnkSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).Unadvise(@ptrCast(*const IConnectionPoint, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_EnumConnections(self: *const T, ppEnum: ?*?*IEnumConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).EnumConnections(@ptrCast(*const IConnectionPoint, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnectionPoints_Value = @import("../zig.zig").Guid.initString("b196b285-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnectionPoints = &IID_IEnumConnectionPoints_Value;
pub const IEnumConnectionPoints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumConnectionPoints,
            cConnections: u32,
            ppCP: [*]?*IConnectionPoint,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumConnectionPoints,
            cConnections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumConnectionPoints,
            ppEnum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Next(self: *const T, cConnections: u32, ppCP: [*]?*IConnectionPoint, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Next(@ptrCast(*const IEnumConnectionPoints, self), cConnections, ppCP, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Skip(self: *const T, cConnections: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Skip(@ptrCast(*const IEnumConnectionPoints, self), cConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Reset(@ptrCast(*const IEnumConnectionPoints, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Clone(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Clone(@ptrCast(*const IEnumConnectionPoints, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPointContainer_Value = @import("../zig.zig").Guid.initString("b196b284-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPointContainer = &IID_IConnectionPointContainer_Value;
pub const IConnectionPointContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnectionPoints: fn(
            self: *const IConnectionPointContainer,
            ppEnum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindConnectionPoint: fn(
            self: *const IConnectionPointContainer,
            riid: ?*const Guid,
            ppCP: ?*?*IConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPointContainer_EnumConnectionPoints(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPointContainer.VTable, self.vtable).EnumConnectionPoints(@ptrCast(*const IConnectionPointContainer, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPointContainer_FindConnectionPoint(self: *const T, riid: ?*const Guid, ppCP: ?*?*IConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPointContainer.VTable, self.vtable).FindConnectionPoint(@ptrCast(*const IConnectionPointContainer, self), riid, ppCP);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LICINFO = extern struct {
    cbLicInfo: i32,
    fRuntimeKeyAvail: BOOL,
    fLicVerified: BOOL,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory2_Value = @import("../zig.zig").Guid.initString("b196b28f-bab4-101a-b69c-00aa00341d07");
pub const IID_IClassFactory2 = &IID_IClassFactory2_Value;
pub const IClassFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
        GetLicInfo: fn(
            self: *const IClassFactory2,
            pLicInfo: ?*LICINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLicKey: fn(
            self: *const IClassFactory2,
            dwReserved: u32,
            pBstrKey: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceLic: fn(
            self: *const IClassFactory2,
            pUnkOuter: ?*IUnknown,
            pUnkReserved: ?*IUnknown,
            riid: ?*const Guid,
            bstrKey: ?BSTR,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IClassFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory2_GetLicInfo(self: *const T, pLicInfo: ?*LICINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory2.VTable, self.vtable).GetLicInfo(@ptrCast(*const IClassFactory2, self), pLicInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory2_RequestLicKey(self: *const T, dwReserved: u32, pBstrKey: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory2.VTable, self.vtable).RequestLicKey(@ptrCast(*const IClassFactory2, self), dwReserved, pBstrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory2_CreateInstanceLic(self: *const T, pUnkOuter: ?*IUnknown, pUnkReserved: ?*IUnknown, riid: ?*const Guid, bstrKey: ?BSTR, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory2.VTable, self.vtable).CreateInstanceLic(@ptrCast(*const IClassFactory2, self), pUnkOuter, pUnkReserved, riid, bstrKey, ppvObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideClassInfo_Value = @import("../zig.zig").Guid.initString("b196b283-bab4-101a-b69c-00aa00341d07");
pub const IID_IProvideClassInfo = &IID_IProvideClassInfo_Value;
pub const IProvideClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassInfo: fn(
            self: *const IProvideClassInfo,
            ppTI: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideClassInfo_GetClassInfo(self: *const T, ppTI: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideClassInfo.VTable, self.vtable).GetClassInfo(@ptrCast(*const IProvideClassInfo, self), ppTI);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const GUIDKIND = enum(i32) {
    D = 1,
};
pub const GUIDKIND_DEFAULT_SOURCE_DISP_IID = GUIDKIND.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideClassInfo2_Value = @import("../zig.zig").Guid.initString("a6bc3ac0-dbaa-11ce-9de3-00aa004bb851");
pub const IID_IProvideClassInfo2 = &IID_IProvideClassInfo2_Value;
pub const IProvideClassInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IProvideClassInfo.VTable,
        GetGUID: fn(
            self: *const IProvideClassInfo2,
            dwGuidKind: u32,
            pGUID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IProvideClassInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideClassInfo2_GetGUID(self: *const T, dwGuidKind: u32, pGUID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideClassInfo2.VTable, self.vtable).GetGUID(@ptrCast(*const IProvideClassInfo2, self), dwGuidKind, pGUID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideMultipleClassInfo_Value = @import("../zig.zig").Guid.initString("a7aba9c1-8983-11cf-8f20-00805f2cd064");
pub const IID_IProvideMultipleClassInfo = &IID_IProvideMultipleClassInfo_Value;
pub const IProvideMultipleClassInfo = extern struct {
    pub const VTable = extern struct {
        base: IProvideClassInfo2.VTable,
        GetMultiTypeInfoCount: fn(
            self: *const IProvideMultipleClassInfo,
            pcti: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfoOfIndex: fn(
            self: *const IProvideMultipleClassInfo,
            iti: u32,
            dwFlags: MULTICLASSINFO_FLAGS,
            pptiCoClass: ?*?*ITypeInfo,
            pdwTIFlags: ?*u32,
            pcdispidReserved: ?*u32,
            piidPrimary: ?*Guid,
            piidSource: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IProvideClassInfo2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideMultipleClassInfo_GetMultiTypeInfoCount(self: *const T, pcti: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideMultipleClassInfo.VTable, self.vtable).GetMultiTypeInfoCount(@ptrCast(*const IProvideMultipleClassInfo, self), pcti);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideMultipleClassInfo_GetInfoOfIndex(self: *const T, iti: u32, dwFlags: MULTICLASSINFO_FLAGS, pptiCoClass: ?*?*ITypeInfo, pdwTIFlags: ?*u32, pcdispidReserved: ?*u32, piidPrimary: ?*Guid, piidSource: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideMultipleClassInfo.VTable, self.vtable).GetInfoOfIndex(@ptrCast(*const IProvideMultipleClassInfo, self), iti, dwFlags, pptiCoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONTROLINFO = extern struct {
    cb: u32,
    hAccel: ?HACCEL,
    cAccel: u16,
    dwFlags: u32,
};

pub const CTRLINFO = enum(i32) {
    RETURN = 1,
    ESCAPE = 2,
};
pub const CTRLINFO_EATS_RETURN = CTRLINFO.RETURN;
pub const CTRLINFO_EATS_ESCAPE = CTRLINFO.ESCAPE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleControl_Value = @import("../zig.zig").Guid.initString("b196b288-bab4-101a-b69c-00aa00341d07");
pub const IID_IOleControl = &IID_IOleControl_Value;
pub const IOleControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetControlInfo: fn(
            self: *const IOleControl,
            pCI: ?*CONTROLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMnemonic: fn(
            self: *const IOleControl,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAmbientPropertyChange: fn(
            self: *const IOleControl,
            dispID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreezeEvents: fn(
            self: *const IOleControl,
            bFreeze: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControl_GetControlInfo(self: *const T, pCI: ?*CONTROLINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControl.VTable, self.vtable).GetControlInfo(@ptrCast(*const IOleControl, self), pCI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControl_OnMnemonic(self: *const T, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControl.VTable, self.vtable).OnMnemonic(@ptrCast(*const IOleControl, self), pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControl_OnAmbientPropertyChange(self: *const T, dispID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControl.VTable, self.vtable).OnAmbientPropertyChange(@ptrCast(*const IOleControl, self), dispID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControl_FreezeEvents(self: *const T, bFreeze: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControl.VTable, self.vtable).FreezeEvents(@ptrCast(*const IOleControl, self), bFreeze);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const POINTF = extern struct {
    x: f32,
    y: f32,
};

pub const XFORMCOORDS = enum(i32) {
    POSITION = 1,
    SIZE = 2,
    HIMETRICTOCONTAINER = 4,
    CONTAINERTOHIMETRIC = 8,
    EVENTCOMPAT = 16,
};
pub const XFORMCOORDS_POSITION = XFORMCOORDS.POSITION;
pub const XFORMCOORDS_SIZE = XFORMCOORDS.SIZE;
pub const XFORMCOORDS_HIMETRICTOCONTAINER = XFORMCOORDS.HIMETRICTOCONTAINER;
pub const XFORMCOORDS_CONTAINERTOHIMETRIC = XFORMCOORDS.CONTAINERTOHIMETRIC;
pub const XFORMCOORDS_EVENTCOMPAT = XFORMCOORDS.EVENTCOMPAT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleControlSite_Value = @import("../zig.zig").Guid.initString("b196b289-bab4-101a-b69c-00aa00341d07");
pub const IID_IOleControlSite = &IID_IOleControlSite_Value;
pub const IOleControlSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnControlInfoChanged: fn(
            self: *const IOleControlSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockInPlaceActive: fn(
            self: *const IOleControlSite,
            fLock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedControl: fn(
            self: *const IOleControlSite,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformCoords: fn(
            self: *const IOleControlSite,
            pPtlHimetric: ?*POINTL,
            pPtfContainer: ?*POINTF,
            dwFlags: XFORMCOORDS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IOleControlSite,
            pMsg: ?*MSG,
            grfModifiers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFocus: fn(
            self: *const IOleControlSite,
            fGotFocus: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowPropertyFrame: fn(
            self: *const IOleControlSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_OnControlInfoChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).OnControlInfoChanged(@ptrCast(*const IOleControlSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_LockInPlaceActive(self: *const T, fLock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).LockInPlaceActive(@ptrCast(*const IOleControlSite, self), fLock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_GetExtendedControl(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).GetExtendedControl(@ptrCast(*const IOleControlSite, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_TransformCoords(self: *const T, pPtlHimetric: ?*POINTL, pPtfContainer: ?*POINTF, dwFlags: XFORMCOORDS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).TransformCoords(@ptrCast(*const IOleControlSite, self), pPtlHimetric, pPtfContainer, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_TranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IOleControlSite, self), pMsg, grfModifiers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_OnFocus(self: *const T, fGotFocus: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).OnFocus(@ptrCast(*const IOleControlSite, self), fGotFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleControlSite_ShowPropertyFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleControlSite.VTable, self.vtable).ShowPropertyFrame(@ptrCast(*const IOleControlSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROPPAGEINFO = extern struct {
    cb: u32,
    pszTitle: ?PWSTR,
    size: SIZE,
    pszDocString: ?PWSTR,
    pszHelpFile: ?PWSTR,
    dwHelpContext: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPage_Value = @import("../zig.zig").Guid.initString("b196b28d-bab4-101a-b69c-00aa00341d07");
pub const IID_IPropertyPage = &IID_IPropertyPage_Value;
pub const IPropertyPage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPageSite: fn(
            self: *const IPropertyPage,
            pPageSite: ?*IPropertyPageSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const IPropertyPage,
            hWndParent: ?HWND,
            pRect: ?*RECT,
            bModal: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const IPropertyPage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageInfo: fn(
            self: *const IPropertyPage,
            pPageInfo: ?*PROPPAGEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjects: fn(
            self: *const IPropertyPage,
            cObjects: u32,
            ppUnk: [*]?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IPropertyPage,
            nCmdShow: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const IPropertyPage,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPageDirty: fn(
            self: *const IPropertyPage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: fn(
            self: *const IPropertyPage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Help: fn(
            self: *const IPropertyPage,
            pszHelpDir: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IPropertyPage,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_SetPageSite(self: *const T, pPageSite: ?*IPropertyPageSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).SetPageSite(@ptrCast(*const IPropertyPage, self), pPageSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Activate(self: *const T, hWndParent: ?HWND, pRect: ?*RECT, bModal: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Activate(@ptrCast(*const IPropertyPage, self), hWndParent, pRect, bModal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Deactivate(@ptrCast(*const IPropertyPage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_GetPageInfo(self: *const T, pPageInfo: ?*PROPPAGEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).GetPageInfo(@ptrCast(*const IPropertyPage, self), pPageInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_SetObjects(self: *const T, cObjects: u32, ppUnk: [*]?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).SetObjects(@ptrCast(*const IPropertyPage, self), cObjects, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Show(self: *const T, nCmdShow: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Show(@ptrCast(*const IPropertyPage, self), nCmdShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Move(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Move(@ptrCast(*const IPropertyPage, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_IsPageDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).IsPageDirty(@ptrCast(*const IPropertyPage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Apply(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Apply(@ptrCast(*const IPropertyPage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_Help(self: *const T, pszHelpDir: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).Help(@ptrCast(*const IPropertyPage, self), pszHelpDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage_TranslateAccelerator(self: *const T, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IPropertyPage, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPage2_Value = @import("../zig.zig").Guid.initString("01e44665-24ac-101b-84ed-08002b2ec713");
pub const IID_IPropertyPage2 = &IID_IPropertyPage2_Value;
pub const IPropertyPage2 = extern struct {
    pub const VTable = extern struct {
        base: IPropertyPage.VTable,
        EditProperty: fn(
            self: *const IPropertyPage2,
            dispID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyPage.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPage2_EditProperty(self: *const T, dispID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPage2.VTable, self.vtable).EditProperty(@ptrCast(*const IPropertyPage2, self), dispID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROPPAGESTATUS = enum(i32) {
    DIRTY = 1,
    VALIDATE = 2,
    CLEAN = 4,
};
pub const PROPPAGESTATUS_DIRTY = PROPPAGESTATUS.DIRTY;
pub const PROPPAGESTATUS_VALIDATE = PROPPAGESTATUS.VALIDATE;
pub const PROPPAGESTATUS_CLEAN = PROPPAGESTATUS.CLEAN;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyPageSite_Value = @import("../zig.zig").Guid.initString("b196b28c-bab4-101a-b69c-00aa00341d07");
pub const IID_IPropertyPageSite = &IID_IPropertyPageSite_Value;
pub const IPropertyPageSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatusChange: fn(
            self: *const IPropertyPageSite,
            dwFlags: PROPPAGESTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleID: fn(
            self: *const IPropertyPageSite,
            pLocaleID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageContainer: fn(
            self: *const IPropertyPageSite,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IPropertyPageSite,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPageSite_OnStatusChange(self: *const T, dwFlags: PROPPAGESTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPageSite.VTable, self.vtable).OnStatusChange(@ptrCast(*const IPropertyPageSite, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPageSite_GetLocaleID(self: *const T, pLocaleID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPageSite.VTable, self.vtable).GetLocaleID(@ptrCast(*const IPropertyPageSite, self), pLocaleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPageSite_GetPageContainer(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPageSite.VTable, self.vtable).GetPageContainer(@ptrCast(*const IPropertyPageSite, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyPageSite_TranslateAccelerator(self: *const T, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyPageSite.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IPropertyPageSite, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyNotifySink_Value = @import("../zig.zig").Guid.initString("9bfbbc02-eff1-101a-84ed-00aa00341d07");
pub const IID_IPropertyNotifySink = &IID_IPropertyNotifySink_Value;
pub const IPropertyNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChanged: fn(
            self: *const IPropertyNotifySink,
            dispID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRequestEdit: fn(
            self: *const IPropertyNotifySink,
            dispID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyNotifySink_OnChanged(self: *const T, dispID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyNotifySink.VTable, self.vtable).OnChanged(@ptrCast(*const IPropertyNotifySink, self), dispID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyNotifySink_OnRequestEdit(self: *const T, dispID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyNotifySink.VTable, self.vtable).OnRequestEdit(@ptrCast(*const IPropertyNotifySink, self), dispID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CAUUID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISpecifyPropertyPages_Value = @import("../zig.zig").Guid.initString("b196b28b-bab4-101a-b69c-00aa00341d07");
pub const IID_ISpecifyPropertyPages = &IID_ISpecifyPropertyPages_Value;
pub const ISpecifyPropertyPages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPages: fn(
            self: *const ISpecifyPropertyPages,
            pPages: ?*CAUUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpecifyPropertyPages_GetPages(self: *const T, pPages: ?*CAUUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpecifyPropertyPages.VTable, self.vtable).GetPages(@ptrCast(*const ISpecifyPropertyPages, self), pPages);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistMemory_Value = @import("../zig.zig").Guid.initString("bd1ae5e0-a6ae-11ce-bd37-504200c10000");
pub const IID_IPersistMemory = &IID_IPersistMemory_Value;
pub const IPersistMemory = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistMemory,
            pMem: [*]u8,
            cbSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistMemory,
            pMem: [*]u8,
            fClearDirty: BOOL,
            cbSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistMemory,
            pCbSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: fn(
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistMemory, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_Load(self: *const T, pMem: [*]u8, cbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).Load(@ptrCast(*const IPersistMemory, self), pMem, cbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_Save(self: *const T, pMem: [*]u8, fClearDirty: BOOL, cbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).Save(@ptrCast(*const IPersistMemory, self), pMem, fClearDirty, cbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_GetSizeMax(self: *const T, pCbSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistMemory, self), pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).InitNew(@ptrCast(*const IPersistMemory, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStreamInit_Value = @import("../zig.zig").Guid.initString("7fd52380-4e07-101b-ae2d-08002b2ec713");
pub const IID_IPersistStreamInit = &IID_IPersistStreamInit_Value;
pub const IPersistStreamInit = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistStreamInit,
            pStm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistStreamInit,
            pStm: ?*IStream,
            fClearDirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistStreamInit,
            pCbSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: fn(
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistStreamInit, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_Load(self: *const T, pStm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).Load(@ptrCast(*const IPersistStreamInit, self), pStm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).Save(@ptrCast(*const IPersistStreamInit, self), pStm, fClearDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_GetSizeMax(self: *const T, pCbSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistStreamInit, self), pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).InitNew(@ptrCast(*const IPersistStreamInit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistPropertyBag_Value = @import("../zig.zig").Guid.initString("37d84f60-42cb-11ce-8135-00aa004bb851");
pub const IID_IPersistPropertyBag = &IID_IPersistPropertyBag_Value;
pub const IPersistPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: fn(
            self: *const IPersistPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistPropertyBag,
            pPropBag: ?*IPropertyBag,
            pErrorLog: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistPropertyBag,
            pPropBag: ?*IPropertyBag,
            fClearDirty: BOOL,
            fSaveAllProperties: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag.VTable, self.vtable).InitNew(@ptrCast(*const IPersistPropertyBag, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag_Load(self: *const T, pPropBag: ?*IPropertyBag, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag.VTable, self.vtable).Load(@ptrCast(*const IPersistPropertyBag, self), pPropBag, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag_Save(self: *const T, pPropBag: ?*IPropertyBag, fClearDirty: BOOL, fSaveAllProperties: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag.VTable, self.vtable).Save(@ptrCast(*const IPersistPropertyBag, self), pPropBag, fClearDirty, fSaveAllProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISimpleFrameSite_Value = @import("../zig.zig").Guid.initString("742b0e01-14e6-101b-914e-00aa00300cab");
pub const IID_ISimpleFrameSite = &IID_ISimpleFrameSite_Value;
pub const ISimpleFrameSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreMessageFilter: fn(
            self: *const ISimpleFrameSite,
            hWnd: ?HWND,
            msg: u32,
            wp: WPARAM,
            lp: LPARAM,
            plResult: ?*LRESULT,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostMessageFilter: fn(
            self: *const ISimpleFrameSite,
            hWnd: ?HWND,
            msg: u32,
            wp: WPARAM,
            lp: LPARAM,
            plResult: ?*LRESULT,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleFrameSite_PreMessageFilter(self: *const T, hWnd: ?HWND, msg: u32, wp: WPARAM, lp: LPARAM, plResult: ?*LRESULT, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleFrameSite.VTable, self.vtable).PreMessageFilter(@ptrCast(*const ISimpleFrameSite, self), hWnd, msg, wp, lp, plResult, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleFrameSite_PostMessageFilter(self: *const T, hWnd: ?HWND, msg: u32, wp: WPARAM, lp: LPARAM, plResult: ?*LRESULT, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleFrameSite.VTable, self.vtable).PostMessageFilter(@ptrCast(*const ISimpleFrameSite, self), hWnd, msg, wp, lp, plResult, dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFont_Value = @import("../zig.zig").Guid.initString("bef6e002-a874-101a-8bba-00aa00300cab");
pub const IID_IFont = &IID_IFont_Value;
pub const IFont = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFont,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFont,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: fn(
            self: *const IFont,
            pSize: ?*CY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Size: fn(
            self: *const IFont,
            size: CY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bold: fn(
            self: *const IFont,
            pBold: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bold: fn(
            self: *const IFont,
            bold: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Italic: fn(
            self: *const IFont,
            pItalic: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Italic: fn(
            self: *const IFont,
            italic: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Underline: fn(
            self: *const IFont,
            pUnderline: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Underline: fn(
            self: *const IFont,
            underline: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strikethrough: fn(
            self: *const IFont,
            pStrikethrough: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Strikethrough: fn(
            self: *const IFont,
            strikethrough: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Weight: fn(
            self: *const IFont,
            pWeight: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Weight: fn(
            self: *const IFont,
            weight: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Charset: fn(
            self: *const IFont,
            pCharset: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Charset: fn(
            self: *const IFont,
            charset: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hFont: fn(
            self: *const IFont,
            phFont: ?*?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IFont,
            ppFont: ?*?*IFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IFont,
            pFontOther: ?*IFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRatio: fn(
            self: *const IFont,
            cyLogical: i32,
            cyHimetric: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryTextMetrics: fn(
            self: *const IFont,
            pTM: ?*TEXTMETRICW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRefHfont: fn(
            self: *const IFont,
            hFont: ?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseHfont: fn(
            self: *const IFont,
            hFont: ?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHdc: fn(
            self: *const IFont,
            hDC: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Name(@ptrCast(*const IFont, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Name(@ptrCast(*const IFont, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Size(self: *const T, pSize: ?*CY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Size(@ptrCast(*const IFont, self), pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Size(self: *const T, size: CY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Size(@ptrCast(*const IFont, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Bold(self: *const T, pBold: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Bold(@ptrCast(*const IFont, self), pBold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Bold(self: *const T, bold: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Bold(@ptrCast(*const IFont, self), bold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Italic(self: *const T, pItalic: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Italic(@ptrCast(*const IFont, self), pItalic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Italic(self: *const T, italic: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Italic(@ptrCast(*const IFont, self), italic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Underline(self: *const T, pUnderline: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Underline(@ptrCast(*const IFont, self), pUnderline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Underline(self: *const T, underline: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Underline(@ptrCast(*const IFont, self), underline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Strikethrough(self: *const T, pStrikethrough: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Strikethrough(@ptrCast(*const IFont, self), pStrikethrough);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Strikethrough(self: *const T, strikethrough: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Strikethrough(@ptrCast(*const IFont, self), strikethrough);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Weight(self: *const T, pWeight: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Weight(@ptrCast(*const IFont, self), pWeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Weight(self: *const T, weight: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Weight(@ptrCast(*const IFont, self), weight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_Charset(self: *const T, pCharset: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_Charset(@ptrCast(*const IFont, self), pCharset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_put_Charset(self: *const T, charset: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).put_Charset(@ptrCast(*const IFont, self), charset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_get_hFont(self: *const T, phFont: ?*?HFONT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).get_hFont(@ptrCast(*const IFont, self), phFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_Clone(self: *const T, ppFont: ?*?*IFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).Clone(@ptrCast(*const IFont, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_IsEqual(self: *const T, pFontOther: ?*IFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).IsEqual(@ptrCast(*const IFont, self), pFontOther);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_SetRatio(self: *const T, cyLogical: i32, cyHimetric: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).SetRatio(@ptrCast(*const IFont, self), cyLogical, cyHimetric);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_QueryTextMetrics(self: *const T, pTM: ?*TEXTMETRICW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).QueryTextMetrics(@ptrCast(*const IFont, self), pTM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_AddRefHfont(self: *const T, hFont: ?HFONT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).AddRefHfont(@ptrCast(*const IFont, self), hFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_ReleaseHfont(self: *const T, hFont: ?HFONT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).ReleaseHfont(@ptrCast(*const IFont, self), hFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFont_SetHdc(self: *const T, hDC: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFont.VTable, self.vtable).SetHdc(@ptrCast(*const IFont, self), hDC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PictureAttributes = enum(i32) {
    SCALABLE = 1,
    TRANSPARENT = 2,
};
pub const PICTURE_SCALABLE = PictureAttributes.SCALABLE;
pub const PICTURE_TRANSPARENT = PictureAttributes.TRANSPARENT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPicture_Value = @import("../zig.zig").Guid.initString("7bf80980-bf32-101a-8bbb-00aa00300cab");
pub const IID_IPicture = &IID_IPicture_Value;
pub const IPicture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Handle: fn(
            self: *const IPicture,
            pHandle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hPal: fn(
            self: *const IPicture,
            phPal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IPicture,
            pType: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IPicture,
            pWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IPicture,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: fn(
            self: *const IPicture,
            hDC: ?HDC,
            x: i32,
            y: i32,
            cx: i32,
            cy: i32,
            xSrc: i32,
            ySrc: i32,
            cxSrc: i32,
            cySrc: i32,
            pRcWBounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_hPal: fn(
            self: *const IPicture,
            hPal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurDC: fn(
            self: *const IPicture,
            phDC: ?*?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectPicture: fn(
            self: *const IPicture,
            hDCIn: ?HDC,
            phDCOut: ?*?HDC,
            phBmpOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeepOriginalFormat: fn(
            self: *const IPicture,
            pKeep: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeepOriginalFormat: fn(
            self: *const IPicture,
            keep: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PictureChanged: fn(
            self: *const IPicture,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsFile: fn(
            self: *const IPicture,
            pStream: ?*IStream,
            fSaveMemCopy: BOOL,
            pCbSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: fn(
            self: *const IPicture,
            pDwAttr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_Handle(self: *const T, pHandle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_Handle(@ptrCast(*const IPicture, self), pHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_hPal(self: *const T, phPal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_hPal(@ptrCast(*const IPicture, self), phPal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_Type(self: *const T, pType: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_Type(@ptrCast(*const IPicture, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_Width(self: *const T, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_Width(@ptrCast(*const IPicture, self), pWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_Height(self: *const T, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_Height(@ptrCast(*const IPicture, self), pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_Render(self: *const T, hDC: ?HDC, x: i32, y: i32, cx: i32, cy: i32, xSrc: i32, ySrc: i32, cxSrc: i32, cySrc: i32, pRcWBounds: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).Render(@ptrCast(*const IPicture, self), hDC, x, y, cx, cy, xSrc, ySrc, cxSrc, cySrc, pRcWBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_set_hPal(self: *const T, hPal: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).set_hPal(@ptrCast(*const IPicture, self), hPal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_CurDC(self: *const T, phDC: ?*?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_CurDC(@ptrCast(*const IPicture, self), phDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_SelectPicture(self: *const T, hDCIn: ?HDC, phDCOut: ?*?HDC, phBmpOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).SelectPicture(@ptrCast(*const IPicture, self), hDCIn, phDCOut, phBmpOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_KeepOriginalFormat(self: *const T, pKeep: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_KeepOriginalFormat(@ptrCast(*const IPicture, self), pKeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_put_KeepOriginalFormat(self: *const T, keep: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).put_KeepOriginalFormat(@ptrCast(*const IPicture, self), keep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_PictureChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).PictureChanged(@ptrCast(*const IPicture, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_SaveAsFile(self: *const T, pStream: ?*IStream, fSaveMemCopy: BOOL, pCbSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).SaveAsFile(@ptrCast(*const IPicture, self), pStream, fSaveMemCopy, pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture_get_Attributes(self: *const T, pDwAttr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture.VTable, self.vtable).get_Attributes(@ptrCast(*const IPicture, self), pDwAttr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPicture2_Value = @import("../zig.zig").Guid.initString("f5185dd8-2012-4b0b-aad9-f052c6bd482b");
pub const IID_IPicture2 = &IID_IPicture2_Value;
pub const IPicture2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Handle: fn(
            self: *const IPicture2,
            pHandle: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hPal: fn(
            self: *const IPicture2,
            phPal: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IPicture2,
            pType: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IPicture2,
            pWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IPicture2,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: fn(
            self: *const IPicture2,
            hDC: ?HDC,
            x: i32,
            y: i32,
            cx: i32,
            cy: i32,
            xSrc: i32,
            ySrc: i32,
            cxSrc: i32,
            cySrc: i32,
            pRcWBounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_hPal: fn(
            self: *const IPicture2,
            hPal: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurDC: fn(
            self: *const IPicture2,
            phDC: ?*?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectPicture: fn(
            self: *const IPicture2,
            hDCIn: ?HDC,
            phDCOut: ?*?HDC,
            phBmpOut: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeepOriginalFormat: fn(
            self: *const IPicture2,
            pKeep: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeepOriginalFormat: fn(
            self: *const IPicture2,
            keep: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PictureChanged: fn(
            self: *const IPicture2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsFile: fn(
            self: *const IPicture2,
            pStream: ?*IStream,
            fSaveMemCopy: BOOL,
            pCbSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: fn(
            self: *const IPicture2,
            pDwAttr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_Handle(self: *const T, pHandle: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_Handle(@ptrCast(*const IPicture2, self), pHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_hPal(self: *const T, phPal: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_hPal(@ptrCast(*const IPicture2, self), phPal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_Type(self: *const T, pType: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_Type(@ptrCast(*const IPicture2, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_Width(self: *const T, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_Width(@ptrCast(*const IPicture2, self), pWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_Height(self: *const T, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_Height(@ptrCast(*const IPicture2, self), pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_Render(self: *const T, hDC: ?HDC, x: i32, y: i32, cx: i32, cy: i32, xSrc: i32, ySrc: i32, cxSrc: i32, cySrc: i32, pRcWBounds: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).Render(@ptrCast(*const IPicture2, self), hDC, x, y, cx, cy, xSrc, ySrc, cxSrc, cySrc, pRcWBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_set_hPal(self: *const T, hPal: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).set_hPal(@ptrCast(*const IPicture2, self), hPal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_CurDC(self: *const T, phDC: ?*?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_CurDC(@ptrCast(*const IPicture2, self), phDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_SelectPicture(self: *const T, hDCIn: ?HDC, phDCOut: ?*?HDC, phBmpOut: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).SelectPicture(@ptrCast(*const IPicture2, self), hDCIn, phDCOut, phBmpOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_KeepOriginalFormat(self: *const T, pKeep: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_KeepOriginalFormat(@ptrCast(*const IPicture2, self), pKeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_put_KeepOriginalFormat(self: *const T, keep: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).put_KeepOriginalFormat(@ptrCast(*const IPicture2, self), keep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_PictureChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).PictureChanged(@ptrCast(*const IPicture2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_SaveAsFile(self: *const T, pStream: ?*IStream, fSaveMemCopy: BOOL, pCbSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).SaveAsFile(@ptrCast(*const IPicture2, self), pStream, fSaveMemCopy, pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPicture2_get_Attributes(self: *const T, pDwAttr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPicture2.VTable, self.vtable).get_Attributes(@ptrCast(*const IPicture2, self), pDwAttr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFontEventsDisp_Value = @import("../zig.zig").Guid.initString("4ef6100a-af88-11d0-9846-00c04fc29993");
pub const IID_IFontEventsDisp = &IID_IFontEventsDisp_Value;
pub const IFontEventsDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFontDisp_Value = @import("../zig.zig").Guid.initString("bef6e003-a874-101a-8bba-00aa00300cab");
pub const IID_IFontDisp = &IID_IFontDisp_Value;
pub const IFontDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPictureDisp_Value = @import("../zig.zig").Guid.initString("7bf80981-bf32-101a-8bbb-00aa00300cab");
pub const IID_IPictureDisp = &IID_IPictureDisp_Value;
pub const IPictureDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceObjectWindowless_Value = @import("../zig.zig").Guid.initString("1c2056cc-5ef4-101b-8bc8-00aa003e3b29");
pub const IID_IOleInPlaceObjectWindowless = &IID_IOleInPlaceObjectWindowless_Value;
pub const IOleInPlaceObjectWindowless = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceObject.VTable,
        OnWindowMessage: fn(
            self: *const IOleInPlaceObjectWindowless,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropTarget: fn(
            self: *const IOleInPlaceObjectWindowless,
            ppDropTarget: ?*?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleInPlaceObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObjectWindowless_OnWindowMessage(self: *const T, msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObjectWindowless.VTable, self.vtable).OnWindowMessage(@ptrCast(*const IOleInPlaceObjectWindowless, self), msg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceObjectWindowless_GetDropTarget(self: *const T, ppDropTarget: ?*?*IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceObjectWindowless.VTable, self.vtable).GetDropTarget(@ptrCast(*const IOleInPlaceObjectWindowless, self), ppDropTarget);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACTIVATEFLAGS = enum(i32) {
    S = 1,
};
pub const ACTIVATE_WINDOWLESS = ACTIVATEFLAGS.S;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSiteEx_Value = @import("../zig.zig").Guid.initString("9c2cad80-3424-11cf-b670-00aa004cd6d8");
pub const IID_IOleInPlaceSiteEx = &IID_IOleInPlaceSiteEx_Value;
pub const IOleInPlaceSiteEx = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceSite.VTable,
        OnInPlaceActivateEx: fn(
            self: *const IOleInPlaceSiteEx,
            pfNoRedraw: ?*BOOL,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInPlaceDeactivateEx: fn(
            self: *const IOleInPlaceSiteEx,
            fNoRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestUIActivate: fn(
            self: *const IOleInPlaceSiteEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleInPlaceSite.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteEx_OnInPlaceActivateEx(self: *const T, pfNoRedraw: ?*BOOL, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteEx.VTable, self.vtable).OnInPlaceActivateEx(@ptrCast(*const IOleInPlaceSiteEx, self), pfNoRedraw, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteEx_OnInPlaceDeactivateEx(self: *const T, fNoRedraw: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteEx.VTable, self.vtable).OnInPlaceDeactivateEx(@ptrCast(*const IOleInPlaceSiteEx, self), fNoRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteEx_RequestUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteEx.VTable, self.vtable).RequestUIActivate(@ptrCast(*const IOleInPlaceSiteEx, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEDCFLAGS = enum(i32) {
    NODRAW = 1,
    PAINTBKGND = 2,
    OFFSCREEN = 4,
};
pub const OLEDC_NODRAW = OLEDCFLAGS.NODRAW;
pub const OLEDC_PAINTBKGND = OLEDCFLAGS.PAINTBKGND;
pub const OLEDC_OFFSCREEN = OLEDCFLAGS.OFFSCREEN;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleInPlaceSiteWindowless_Value = @import("../zig.zig").Guid.initString("922eada0-3424-11cf-b670-00aa004cd6d8");
pub const IID_IOleInPlaceSiteWindowless = &IID_IOleInPlaceSiteWindowless_Value;
pub const IOleInPlaceSiteWindowless = extern struct {
    pub const VTable = extern struct {
        base: IOleInPlaceSiteEx.VTable,
        CanWindowlessActivate: fn(
            self: *const IOleInPlaceSiteWindowless,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapture: fn(
            self: *const IOleInPlaceSiteWindowless,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCapture: fn(
            self: *const IOleInPlaceSiteWindowless,
            fCapture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: fn(
            self: *const IOleInPlaceSiteWindowless,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const IOleInPlaceSiteWindowless,
            fFocus: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDC: fn(
            self: *const IOleInPlaceSiteWindowless,
            pRect: ?*RECT,
            grfFlags: u32,
            phDC: ?*?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDC: fn(
            self: *const IOleInPlaceSiteWindowless,
            hDC: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRect: fn(
            self: *const IOleInPlaceSiteWindowless,
            pRect: ?*RECT,
            fErase: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRgn: fn(
            self: *const IOleInPlaceSiteWindowless,
            hRGN: ?HRGN,
            fErase: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollRect: fn(
            self: *const IOleInPlaceSiteWindowless,
            dx: i32,
            dy: i32,
            pRectScroll: ?*RECT,
            pRectClip: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdjustRect: fn(
            self: *const IOleInPlaceSiteWindowless,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefWindowMessage: fn(
            self: *const IOleInPlaceSiteWindowless,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleInPlaceSiteEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_CanWindowlessActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).CanWindowlessActivate(@ptrCast(*const IOleInPlaceSiteWindowless, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_GetCapture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).GetCapture(@ptrCast(*const IOleInPlaceSiteWindowless, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_SetCapture(self: *const T, fCapture: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).SetCapture(@ptrCast(*const IOleInPlaceSiteWindowless, self), fCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_GetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).GetFocus(@ptrCast(*const IOleInPlaceSiteWindowless, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_SetFocus(self: *const T, fFocus: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).SetFocus(@ptrCast(*const IOleInPlaceSiteWindowless, self), fFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_GetDC(self: *const T, pRect: ?*RECT, grfFlags: u32, phDC: ?*?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).GetDC(@ptrCast(*const IOleInPlaceSiteWindowless, self), pRect, grfFlags, phDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_ReleaseDC(self: *const T, hDC: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).ReleaseDC(@ptrCast(*const IOleInPlaceSiteWindowless, self), hDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_InvalidateRect(self: *const T, pRect: ?*RECT, fErase: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).InvalidateRect(@ptrCast(*const IOleInPlaceSiteWindowless, self), pRect, fErase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_InvalidateRgn(self: *const T, hRGN: ?HRGN, fErase: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).InvalidateRgn(@ptrCast(*const IOleInPlaceSiteWindowless, self), hRGN, fErase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_ScrollRect(self: *const T, dx: i32, dy: i32, pRectScroll: ?*RECT, pRectClip: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).ScrollRect(@ptrCast(*const IOleInPlaceSiteWindowless, self), dx, dy, pRectScroll, pRectClip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_AdjustRect(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).AdjustRect(@ptrCast(*const IOleInPlaceSiteWindowless, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleInPlaceSiteWindowless_OnDefWindowMessage(self: *const T, msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleInPlaceSiteWindowless.VTable, self.vtable).OnDefWindowMessage(@ptrCast(*const IOleInPlaceSiteWindowless, self), msg, wParam, lParam, plResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VIEWSTATUS = enum(i32) {
    OPAQUE = 1,
    SOLIDBKGND = 2,
    DVASPECTOPAQUE = 4,
    DVASPECTTRANSPARENT = 8,
    SURFACE = 16,
    @"3DSURFACE" = 32,
};
pub const VIEWSTATUS_OPAQUE = VIEWSTATUS.OPAQUE;
pub const VIEWSTATUS_SOLIDBKGND = VIEWSTATUS.SOLIDBKGND;
pub const VIEWSTATUS_DVASPECTOPAQUE = VIEWSTATUS.DVASPECTOPAQUE;
pub const VIEWSTATUS_DVASPECTTRANSPARENT = VIEWSTATUS.DVASPECTTRANSPARENT;
pub const VIEWSTATUS_SURFACE = VIEWSTATUS.SURFACE;
pub const VIEWSTATUS_3DSURFACE = VIEWSTATUS.@"3DSURFACE";

pub const HITRESULT = enum(i32) {
    OUTSIDE = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const HITRESULT_OUTSIDE = HITRESULT.OUTSIDE;
pub const HITRESULT_TRANSPARENT = HITRESULT.TRANSPARENT;
pub const HITRESULT_CLOSE = HITRESULT.CLOSE;
pub const HITRESULT_HIT = HITRESULT.HIT;

pub const DVASPECT2 = enum(i32) {
    OPAQUE = 16,
    TRANSPARENT = 32,
};
pub const DVASPECT_OPAQUE = DVASPECT2.OPAQUE;
pub const DVASPECT_TRANSPARENT = DVASPECT2.TRANSPARENT;

pub const ExtentInfo = extern struct {
    cb: u32,
    dwExtentMode: u32,
    sizelProposed: SIZE,
};

pub const ExtentMode = enum(i32) {
    CONTENT = 0,
    INTEGRAL = 1,
};
pub const DVEXTENT_CONTENT = ExtentMode.CONTENT;
pub const DVEXTENT_INTEGRAL = ExtentMode.INTEGRAL;

pub const AspectInfoFlag = enum(i32) {
    E = 1,
};
pub const DVASPECTINFOFLAG_CANOPTIMIZE = AspectInfoFlag.E;

pub const AspectInfo = extern struct {
    cb: u32,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IViewObjectEx_Value = @import("../zig.zig").Guid.initString("3af24292-0c96-11ce-a0cf-00aa00600ab8");
pub const IID_IViewObjectEx = &IID_IViewObjectEx_Value;
pub const IViewObjectEx = extern struct {
    pub const VTable = extern struct {
        base: IViewObject2.VTable,
        GetRect: fn(
            self: *const IViewObjectEx,
            dwAspect: u32,
            pRect: ?*RECTL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewStatus: fn(
            self: *const IViewObjectEx,
            pdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHitPoint: fn(
            self: *const IViewObjectEx,
            dwAspect: u32,
            pRectBounds: ?*RECT,
            ptlLoc: POINT,
            lCloseHint: i32,
            pHitResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHitRect: fn(
            self: *const IViewObjectEx,
            dwAspect: u32,
            pRectBounds: ?*RECT,
            pRectLoc: ?*RECT,
            lCloseHint: i32,
            pHitResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNaturalExtent: fn(
            self: *const IViewObjectEx,
            dwAspect: DVASPECT,
            lindex: i32,
            ptd: ?*DVTARGETDEVICE,
            hicTargetDev: ?HDC,
            pExtentInfo: ?*ExtentInfo,
            pSizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IViewObject2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectEx_GetRect(self: *const T, dwAspect: u32, pRect: ?*RECTL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectEx.VTable, self.vtable).GetRect(@ptrCast(*const IViewObjectEx, self), dwAspect, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectEx_GetViewStatus(self: *const T, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectEx.VTable, self.vtable).GetViewStatus(@ptrCast(*const IViewObjectEx, self), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectEx_QueryHitPoint(self: *const T, dwAspect: u32, pRectBounds: ?*RECT, ptlLoc: POINT, lCloseHint: i32, pHitResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectEx.VTable, self.vtable).QueryHitPoint(@ptrCast(*const IViewObjectEx, self), dwAspect, pRectBounds, ptlLoc, lCloseHint, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectEx_QueryHitRect(self: *const T, dwAspect: u32, pRectBounds: ?*RECT, pRectLoc: ?*RECT, lCloseHint: i32, pHitResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectEx.VTable, self.vtable).QueryHitRect(@ptrCast(*const IViewObjectEx, self), dwAspect, pRectBounds, pRectLoc, lCloseHint, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectEx_GetNaturalExtent(self: *const T, dwAspect: DVASPECT, lindex: i32, ptd: ?*DVTARGETDEVICE, hicTargetDev: ?HDC, pExtentInfo: ?*ExtentInfo, pSizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectEx.VTable, self.vtable).GetNaturalExtent(@ptrCast(*const IViewObjectEx, self), dwAspect, lindex, ptd, hicTargetDev, pExtentInfo, pSizel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleUndoUnit_Value = @import("../zig.zig").Guid.initString("894ad3b0-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleUndoUnit = &IID_IOleUndoUnit_Value;
pub const IOleUndoUnit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Do: fn(
            self: *const IOleUndoUnit,
            pUndoManager: ?*IOleUndoManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IOleUndoUnit,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnitType: fn(
            self: *const IOleUndoUnit,
            pClsid: ?*Guid,
            plID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNextAdd: fn(
            self: *const IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoUnit_Do(self: *const T, pUndoManager: ?*IOleUndoManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoUnit.VTable, self.vtable).Do(@ptrCast(*const IOleUndoUnit, self), pUndoManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoUnit_GetDescription(self: *const T, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoUnit.VTable, self.vtable).GetDescription(@ptrCast(*const IOleUndoUnit, self), pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoUnit_GetUnitType(self: *const T, pClsid: ?*Guid, plID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoUnit.VTable, self.vtable).GetUnitType(@ptrCast(*const IOleUndoUnit, self), pClsid, plID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoUnit_OnNextAdd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoUnit.VTable, self.vtable).OnNextAdd(@ptrCast(*const IOleUndoUnit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleParentUndoUnit_Value = @import("../zig.zig").Guid.initString("a1faf330-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleParentUndoUnit = &IID_IOleParentUndoUnit_Value;
pub const IOleParentUndoUnit = extern struct {
    pub const VTable = extern struct {
        base: IOleUndoUnit.VTable,
        Open: fn(
            self: *const IOleParentUndoUnit,
            pPUU: ?*IOleParentUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IOleParentUndoUnit,
            pPUU: ?*IOleParentUndoUnit,
            fCommit: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IOleParentUndoUnit,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindUnit: fn(
            self: *const IOleParentUndoUnit,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentState: fn(
            self: *const IOleParentUndoUnit,
            pdwState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleUndoUnit.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleParentUndoUnit_Open(self: *const T, pPUU: ?*IOleParentUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleParentUndoUnit.VTable, self.vtable).Open(@ptrCast(*const IOleParentUndoUnit, self), pPUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleParentUndoUnit_Close(self: *const T, pPUU: ?*IOleParentUndoUnit, fCommit: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleParentUndoUnit.VTable, self.vtable).Close(@ptrCast(*const IOleParentUndoUnit, self), pPUU, fCommit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleParentUndoUnit_Add(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleParentUndoUnit.VTable, self.vtable).Add(@ptrCast(*const IOleParentUndoUnit, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleParentUndoUnit_FindUnit(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleParentUndoUnit.VTable, self.vtable).FindUnit(@ptrCast(*const IOleParentUndoUnit, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleParentUndoUnit_GetParentState(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleParentUndoUnit.VTable, self.vtable).GetParentState(@ptrCast(*const IOleParentUndoUnit, self), pdwState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOleUndoUnits_Value = @import("../zig.zig").Guid.initString("b3e7c340-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IEnumOleUndoUnits = &IID_IEnumOleUndoUnits_Value;
pub const IEnumOleUndoUnits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumOleUndoUnits,
            cElt: u32,
            rgElt: [*]?*IOleUndoUnit,
            pcEltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumOleUndoUnits,
            cElt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumOleUndoUnits,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumOleUndoUnits,
            ppEnum: ?*?*IEnumOleUndoUnits,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleUndoUnits_Next(self: *const T, cElt: u32, rgElt: [*]?*IOleUndoUnit, pcEltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleUndoUnits.VTable, self.vtable).Next(@ptrCast(*const IEnumOleUndoUnits, self), cElt, rgElt, pcEltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleUndoUnits_Skip(self: *const T, cElt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleUndoUnits.VTable, self.vtable).Skip(@ptrCast(*const IEnumOleUndoUnits, self), cElt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleUndoUnits_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleUndoUnits.VTable, self.vtable).Reset(@ptrCast(*const IEnumOleUndoUnits, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleUndoUnits_Clone(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleUndoUnits.VTable, self.vtable).Clone(@ptrCast(*const IEnumOleUndoUnits, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleUndoManager_Value = @import("../zig.zig").Guid.initString("d001f200-ef97-11ce-9bc9-00aa00608e01");
pub const IID_IOleUndoManager = &IID_IOleUndoManager_Value;
pub const IOleUndoManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IOleUndoManager,
            pPUU: ?*IOleParentUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IOleUndoManager,
            pPUU: ?*IOleParentUndoUnit,
            fCommit: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IOleUndoManager,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenParentState: fn(
            self: *const IOleUndoManager,
            pdwState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardFrom: fn(
            self: *const IOleUndoManager,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UndoTo: fn(
            self: *const IOleUndoManager,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RedoTo: fn(
            self: *const IOleUndoManager,
            pUU: ?*IOleUndoUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumUndoable: fn(
            self: *const IOleUndoManager,
            ppEnum: ?*?*IEnumOleUndoUnits,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRedoable: fn(
            self: *const IOleUndoManager,
            ppEnum: ?*?*IEnumOleUndoUnits,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastUndoDescription: fn(
            self: *const IOleUndoManager,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastRedoDescription: fn(
            self: *const IOleUndoManager,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IOleUndoManager,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_Open(self: *const T, pPUU: ?*IOleParentUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).Open(@ptrCast(*const IOleUndoManager, self), pPUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_Close(self: *const T, pPUU: ?*IOleParentUndoUnit, fCommit: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).Close(@ptrCast(*const IOleUndoManager, self), pPUU, fCommit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_Add(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).Add(@ptrCast(*const IOleUndoManager, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_GetOpenParentState(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).GetOpenParentState(@ptrCast(*const IOleUndoManager, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_DiscardFrom(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).DiscardFrom(@ptrCast(*const IOleUndoManager, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_UndoTo(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).UndoTo(@ptrCast(*const IOleUndoManager, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_RedoTo(self: *const T, pUU: ?*IOleUndoUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).RedoTo(@ptrCast(*const IOleUndoManager, self), pUU);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_EnumUndoable(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).EnumUndoable(@ptrCast(*const IOleUndoManager, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_EnumRedoable(self: *const T, ppEnum: ?*?*IEnumOleUndoUnits) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).EnumRedoable(@ptrCast(*const IOleUndoManager, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_GetLastUndoDescription(self: *const T, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).GetLastUndoDescription(@ptrCast(*const IOleUndoManager, self), pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_GetLastRedoDescription(self: *const T, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).GetLastRedoDescription(@ptrCast(*const IOleUndoManager, self), pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUndoManager_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUndoManager.VTable, self.vtable).Enable(@ptrCast(*const IOleUndoManager, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const POINTERINACTIVE = enum(i32) {
    ACTIVATEONENTRY = 1,
    DEACTIVATEONLEAVE = 2,
    ACTIVATEONDRAG = 4,
};
pub const POINTERINACTIVE_ACTIVATEONENTRY = POINTERINACTIVE.ACTIVATEONENTRY;
pub const POINTERINACTIVE_DEACTIVATEONLEAVE = POINTERINACTIVE.DEACTIVATEONLEAVE;
pub const POINTERINACTIVE_ACTIVATEONDRAG = POINTERINACTIVE.ACTIVATEONDRAG;

// TODO: this type is limited to platform 'windows5.0'
const IID_IPointerInactive_Value = @import("../zig.zig").Guid.initString("55980ba0-35aa-11cf-b671-00aa004cd6d8");
pub const IID_IPointerInactive = &IID_IPointerInactive_Value;
pub const IPointerInactive = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActivationPolicy: fn(
            self: *const IPointerInactive,
            pdwPolicy: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInactiveMouseMove: fn(
            self: *const IPointerInactive,
            pRectBounds: ?*RECT,
            x: i32,
            y: i32,
            grfKeyState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInactiveSetCursor: fn(
            self: *const IPointerInactive,
            pRectBounds: ?*RECT,
            x: i32,
            y: i32,
            dwMouseMsg: u32,
            fSetAlways: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPointerInactive_GetActivationPolicy(self: *const T, pdwPolicy: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPointerInactive.VTable, self.vtable).GetActivationPolicy(@ptrCast(*const IPointerInactive, self), pdwPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPointerInactive_OnInactiveMouseMove(self: *const T, pRectBounds: ?*RECT, x: i32, y: i32, grfKeyState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPointerInactive.VTable, self.vtable).OnInactiveMouseMove(@ptrCast(*const IPointerInactive, self), pRectBounds, x, y, grfKeyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPointerInactive_OnInactiveSetCursor(self: *const T, pRectBounds: ?*RECT, x: i32, y: i32, dwMouseMsg: u32, fSetAlways: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPointerInactive.VTable, self.vtable).OnInactiveSetCursor(@ptrCast(*const IPointerInactive, self), pRectBounds, x, y, dwMouseMsg, fSetAlways);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IObjectWithSite_Value = @import("../zig.zig").Guid.initString("fc4801a3-2ba9-11cf-a229-00aa003d7352");
pub const IID_IObjectWithSite = &IID_IObjectWithSite_Value;
pub const IObjectWithSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSite: fn(
            self: *const IObjectWithSite,
            pUnkSite: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSite: fn(
            self: *const IObjectWithSite,
            riid: ?*const Guid,
            ppvSite: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithSite_SetSite(self: *const T, pUnkSite: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithSite.VTable, self.vtable).SetSite(@ptrCast(*const IObjectWithSite, self), pUnkSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithSite_GetSite(self: *const T, riid: ?*const Guid, ppvSite: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithSite.VTable, self.vtable).GetSite(@ptrCast(*const IObjectWithSite, self), riid, ppvSite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CALPOLESTR = extern struct {
    cElems: u32,
    pElems: ?*?PWSTR,
};

pub const CADWORD = extern struct {
    cElems: u32,
    pElems: ?*u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPerPropertyBrowsing_Value = @import("../zig.zig").Guid.initString("376bd3aa-3845-101b-84ed-08002b2ec713");
pub const IID_IPerPropertyBrowsing = &IID_IPerPropertyBrowsing_Value;
pub const IPerPropertyBrowsing = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: fn(
            self: *const IPerPropertyBrowsing,
            dispID: i32,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapPropertyToPage: fn(
            self: *const IPerPropertyBrowsing,
            dispID: i32,
            pClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPredefinedStrings: fn(
            self: *const IPerPropertyBrowsing,
            dispID: i32,
            pCaStringsOut: ?*CALPOLESTR,
            pCaCookiesOut: ?*CADWORD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPredefinedValue: fn(
            self: *const IPerPropertyBrowsing,
            dispID: i32,
            dwCookie: u32,
            pVarOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing_GetDisplayString(self: *const T, dispID: i32, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing.VTable, self.vtable).GetDisplayString(@ptrCast(*const IPerPropertyBrowsing, self), dispID, pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing_MapPropertyToPage(self: *const T, dispID: i32, pClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing.VTable, self.vtable).MapPropertyToPage(@ptrCast(*const IPerPropertyBrowsing, self), dispID, pClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing_GetPredefinedStrings(self: *const T, dispID: i32, pCaStringsOut: ?*CALPOLESTR, pCaCookiesOut: ?*CADWORD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing.VTable, self.vtable).GetPredefinedStrings(@ptrCast(*const IPerPropertyBrowsing, self), dispID, pCaStringsOut, pCaCookiesOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing_GetPredefinedValue(self: *const T, dispID: i32, dwCookie: u32, pVarOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing.VTable, self.vtable).GetPredefinedValue(@ptrCast(*const IPerPropertyBrowsing, self), dispID, dwCookie, pVarOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROPBAG2_TYPE = enum(i32) {
    UNDEFINED = 0,
    DATA = 1,
    URL = 2,
    OBJECT = 3,
    STREAM = 4,
    STORAGE = 5,
    MONIKER = 6,
};
pub const PROPBAG2_TYPE_UNDEFINED = PROPBAG2_TYPE.UNDEFINED;
pub const PROPBAG2_TYPE_DATA = PROPBAG2_TYPE.DATA;
pub const PROPBAG2_TYPE_URL = PROPBAG2_TYPE.URL;
pub const PROPBAG2_TYPE_OBJECT = PROPBAG2_TYPE.OBJECT;
pub const PROPBAG2_TYPE_STREAM = PROPBAG2_TYPE.STREAM;
pub const PROPBAG2_TYPE_STORAGE = PROPBAG2_TYPE.STORAGE;
pub const PROPBAG2_TYPE_MONIKER = PROPBAG2_TYPE.MONIKER;

pub const PROPBAG2 = extern struct {
    dwType: u32,
    vt: u16,
    cfType: u16,
    dwHint: u32,
    pstrName: ?PWSTR,
    clsid: Guid,
};

const IID_IPropertyBag2_Value = @import("../zig.zig").Guid.initString("22f55882-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPropertyBag2 = &IID_IPropertyBag2_Value;
pub const IPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: fn(
            self: *const IPropertyBag2,
            cProperties: u32,
            pPropBag: [*]PROPBAG2,
            pErrLog: ?*IErrorLog,
            pvarValue: [*]VARIANT,
            phrError: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IPropertyBag2,
            cProperties: u32,
            pPropBag: [*]PROPBAG2,
            pvarValue: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CountProperties: fn(
            self: *const IPropertyBag2,
            pcProperties: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const IPropertyBag2,
            iProperty: u32,
            cProperties: u32,
            pPropBag: [*]PROPBAG2,
            pcProperties: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadObject: fn(
            self: *const IPropertyBag2,
            pstrName: ?[*:0]const u16,
            dwHint: u32,
            pUnkObject: ?*IUnknown,
            pErrLog: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Read(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pErrLog: ?*IErrorLog, pvarValue: [*]VARIANT, phrError: [*]HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag2.VTable, self.vtable).Read(@ptrCast(*const IPropertyBag2, self), cProperties, pPropBag, pErrLog, pvarValue, phrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Write(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pvarValue: [*]VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag2.VTable, self.vtable).Write(@ptrCast(*const IPropertyBag2, self), cProperties, pPropBag, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_CountProperties(self: *const T, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag2.VTable, self.vtable).CountProperties(@ptrCast(*const IPropertyBag2, self), pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_GetPropertyInfo(self: *const T, iProperty: u32, cProperties: u32, pPropBag: [*]PROPBAG2, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag2.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const IPropertyBag2, self), iProperty, cProperties, pPropBag, pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_LoadObject(self: *const T, pstrName: ?[*:0]const u16, dwHint: u32, pUnkObject: ?*IUnknown, pErrLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag2.VTable, self.vtable).LoadObject(@ptrCast(*const IPropertyBag2, self), pstrName, dwHint, pUnkObject, pErrLog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistPropertyBag2_Value = @import("../zig.zig").Guid.initString("22f55881-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPersistPropertyBag2 = &IID_IPersistPropertyBag2_Value;
pub const IPersistPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: fn(
            self: *const IPersistPropertyBag2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistPropertyBag2,
            pPropBag: ?*IPropertyBag2,
            pErrLog: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistPropertyBag2,
            pPropBag: ?*IPropertyBag2,
            fClearDirty: BOOL,
            fSaveAllProperties: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirty: fn(
            self: *const IPersistPropertyBag2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag2_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag2.VTable, self.vtable).InitNew(@ptrCast(*const IPersistPropertyBag2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag2_Load(self: *const T, pPropBag: ?*IPropertyBag2, pErrLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag2.VTable, self.vtable).Load(@ptrCast(*const IPersistPropertyBag2, self), pPropBag, pErrLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag2_Save(self: *const T, pPropBag: ?*IPropertyBag2, fClearDirty: BOOL, fSaveAllProperties: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag2.VTable, self.vtable).Save(@ptrCast(*const IPersistPropertyBag2, self), pPropBag, fClearDirty, fSaveAllProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistPropertyBag2_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistPropertyBag2.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistPropertyBag2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSinkEx_Value = @import("../zig.zig").Guid.initString("3af24290-0c96-11ce-a0cf-00aa00600ab8");
pub const IID_IAdviseSinkEx = &IID_IAdviseSinkEx_Value;
pub const IAdviseSinkEx = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnViewStatusChange: fn(
            self: *const IAdviseSinkEx,
            dwViewStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAdviseSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSinkEx_OnViewStatusChange(self: *const T, dwViewStatus: u32) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSinkEx.VTable, self.vtable).OnViewStatusChange(@ptrCast(*const IAdviseSinkEx, self), dwViewStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const QACONTAINERFLAGS = enum(i32) {
    SHOWHATCHING = 1,
    SHOWGRABHANDLES = 2,
    USERMODE = 4,
    DISPLAYASDEFAULT = 8,
    UIDEAD = 16,
    AUTOCLIP = 32,
    MESSAGEREFLECT = 64,
    SUPPORTSMNEMONICS = 128,
};
pub const QACONTAINER_SHOWHATCHING = QACONTAINERFLAGS.SHOWHATCHING;
pub const QACONTAINER_SHOWGRABHANDLES = QACONTAINERFLAGS.SHOWGRABHANDLES;
pub const QACONTAINER_USERMODE = QACONTAINERFLAGS.USERMODE;
pub const QACONTAINER_DISPLAYASDEFAULT = QACONTAINERFLAGS.DISPLAYASDEFAULT;
pub const QACONTAINER_UIDEAD = QACONTAINERFLAGS.UIDEAD;
pub const QACONTAINER_AUTOCLIP = QACONTAINERFLAGS.AUTOCLIP;
pub const QACONTAINER_MESSAGEREFLECT = QACONTAINERFLAGS.MESSAGEREFLECT;
pub const QACONTAINER_SUPPORTSMNEMONICS = QACONTAINERFLAGS.SUPPORTSMNEMONICS;

pub const QACONTAINER = extern struct {
    cbSize: u32,
    pClientSite: ?*IOleClientSite,
    pAdviseSink: ?*IAdviseSinkEx,
    pPropertyNotifySink: ?*IPropertyNotifySink,
    pUnkEventSink: ?*IUnknown,
    dwAmbientFlags: u32,
    colorFore: u32,
    colorBack: u32,
    pFont: ?*IFont,
    pUndoMgr: ?*IOleUndoManager,
    dwAppearance: u32,
    lcid: i32,
    hpal: ?HPALETTE,
    pBindHost: ?*IBindHost,
    pOleControlSite: ?*IOleControlSite,
    pServiceProvider: ?*IServiceProvider,
};

pub const QACONTROL = extern struct {
    cbSize: u32,
    dwMiscStatus: u32,
    dwViewStatus: u32,
    dwEventCookie: u32,
    dwPropNotifyCookie: u32,
    dwPointerActivationPolicy: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQuickActivate_Value = @import("../zig.zig").Guid.initString("cf51ed10-62fe-11cf-bf86-00a0c9034836");
pub const IID_IQuickActivate = &IID_IQuickActivate_Value;
pub const IQuickActivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QuickActivate: fn(
            self: *const IQuickActivate,
            pQaContainer: ?*QACONTAINER,
            pQaControl: ?*QACONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContentExtent: fn(
            self: *const IQuickActivate,
            pSizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentExtent: fn(
            self: *const IQuickActivate,
            pSizel: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuickActivate_QuickActivate(self: *const T, pQaContainer: ?*QACONTAINER, pQaControl: ?*QACONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuickActivate.VTable, self.vtable).QuickActivate(@ptrCast(*const IQuickActivate, self), pQaContainer, pQaControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuickActivate_SetContentExtent(self: *const T, pSizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuickActivate.VTable, self.vtable).SetContentExtent(@ptrCast(*const IQuickActivate, self), pSizel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuickActivate_GetContentExtent(self: *const T, pSizel: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuickActivate.VTable, self.vtable).GetContentExtent(@ptrCast(*const IQuickActivate, self), pSizel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OCPFIPARAMS = extern struct {
    cbStructSize: u32,
    hWndOwner: ?HWND,
    x: i32,
    y: i32,
    lpszCaption: ?[*:0]const u16,
    cObjects: u32,
    lplpUnk: ?*?*IUnknown,
    cPages: u32,
    lpPages: ?*Guid,
    lcid: u32,
    dispidInitialProperty: i32,
};

pub const FONTDESC = extern struct {
    cbSizeofstruct: u32,
    lpstrName: ?PWSTR,
    cySize: CY,
    sWeight: i16,
    sCharset: i16,
    fItalic: BOOL,
    fUnderline: BOOL,
    fStrikethrough: BOOL,
};

pub const PICTDESC = extern struct {
    cbSizeofstruct: u32,
    picType: u32,
    Anonymous: extern union {
        bmp: extern struct {
            hbitmap: ?HBITMAP,
            hpal: ?HPALETTE,
        },
        wmf: extern struct {
            hmeta: ?HMETAFILE,
            xExt: i32,
            yExt: i32,
        },
        icon: extern struct {
            hicon: ?HICON,
        },
        emf: extern struct {
            hemf: ?HENHMETAFILE,
        },
    },
};

pub const OLE_TRISTATE = enum(i32) {
    Unchecked = 0,
    Checked = 1,
    Gray = 2,
};
pub const triUnchecked = OLE_TRISTATE.Unchecked;
pub const triChecked = OLE_TRISTATE.Checked;
pub const triGray = OLE_TRISTATE.Gray;

const IID_IVBGetControl_Value = @import("../zig.zig").Guid.initString("40a050a0-3c31-101b-a82e-08002b2b2337");
pub const IID_IVBGetControl = &IID_IVBGetControl_Value;
pub const IVBGetControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumControls: fn(
            self: *const IVBGetControl,
            dwOleContF: OLECONTF,
            dwWhich: ENUM_CONTROLS_WHICH_FLAGS,
            ppenumUnk: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBGetControl_EnumControls(self: *const T, dwOleContF: OLECONTF, dwWhich: ENUM_CONTROLS_WHICH_FLAGS, ppenumUnk: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBGetControl.VTable, self.vtable).EnumControls(@ptrCast(*const IVBGetControl, self), dwOleContF, dwWhich, ppenumUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetOleObject_Value = @import("../zig.zig").Guid.initString("8a701da0-4feb-101b-a82e-08002b2b2337");
pub const IID_IGetOleObject = &IID_IGetOleObject_Value;
pub const IGetOleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOleObject: fn(
            self: *const IGetOleObject,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetOleObject_GetOleObject(self: *const T, riid: ?*const Guid, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetOleObject.VTable, self.vtable).GetOleObject(@ptrCast(*const IGetOleObject, self), riid, ppvObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBFormat_Value = @import("../zig.zig").Guid.initString("9849fd60-3768-101b-8d72-ae6164ffe3cf");
pub const IID_IVBFormat = &IID_IVBFormat_Value;
pub const IVBFormat = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Format: fn(
            self: *const IVBFormat,
            vData: ?*VARIANT,
            bstrFormat: ?BSTR,
            lpBuffer: ?*c_void,
            cb: u16,
            lcid: i32,
            sFirstDayOfWeek: i16,
            sFirstWeekOfYear: u16,
            rcb: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBFormat_Format(self: *const T, vData: ?*VARIANT, bstrFormat: ?BSTR, lpBuffer: ?*c_void, cb: u16, lcid: i32, sFirstDayOfWeek: i16, sFirstWeekOfYear: u16, rcb: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBFormat.VTable, self.vtable).Format(@ptrCast(*const IVBFormat, self), vData, bstrFormat, lpBuffer, cb, lcid, sFirstDayOfWeek, sFirstWeekOfYear, rcb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetVBAObject_Value = @import("../zig.zig").Guid.initString("91733a60-3f4c-101b-a3f6-00aa0034e4e9");
pub const IID_IGetVBAObject = &IID_IGetVBAObject_Value;
pub const IGetVBAObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObject: fn(
            self: *const IGetVBAObject,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetVBAObject_GetObject(self: *const T, riid: ?*const Guid, ppvObj: ?*?*c_void, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetVBAObject.VTable, self.vtable).GetObject(@ptrCast(*const IGetVBAObject, self), riid, ppvObj, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DOCMISC = enum(i32) {
    CANCREATEMULTIPLEVIEWS = 1,
    SUPPORTCOMPLEXRECTANGLES = 2,
    CANTOPENEDIT = 4,
    NOFILESUPPORT = 8,
};
pub const DOCMISC_CANCREATEMULTIPLEVIEWS = DOCMISC.CANCREATEMULTIPLEVIEWS;
pub const DOCMISC_SUPPORTCOMPLEXRECTANGLES = DOCMISC.SUPPORTCOMPLEXRECTANGLES;
pub const DOCMISC_CANTOPENEDIT = DOCMISC.CANTOPENEDIT;
pub const DOCMISC_NOFILESUPPORT = DOCMISC.NOFILESUPPORT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocument_Value = @import("../zig.zig").Guid.initString("b722bcc5-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocument = &IID_IOleDocument_Value;
pub const IOleDocument = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: fn(
            self: *const IOleDocument,
            pIPSite: ?*IOleInPlaceSite,
            pstm: ?*IStream,
            dwReserved: u32,
            ppView: ?*?*IOleDocumentView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocMiscStatus: fn(
            self: *const IOleDocument,
            pdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumViews: fn(
            self: *const IOleDocument,
            ppEnum: ?*?*IEnumOleDocumentViews,
            ppView: ?*?*IOleDocumentView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocument_CreateView(self: *const T, pIPSite: ?*IOleInPlaceSite, pstm: ?*IStream, dwReserved: u32, ppView: ?*?*IOleDocumentView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocument.VTable, self.vtable).CreateView(@ptrCast(*const IOleDocument, self), pIPSite, pstm, dwReserved, ppView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocument_GetDocMiscStatus(self: *const T, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocument.VTable, self.vtable).GetDocMiscStatus(@ptrCast(*const IOleDocument, self), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocument_EnumViews(self: *const T, ppEnum: ?*?*IEnumOleDocumentViews, ppView: ?*?*IOleDocumentView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocument.VTable, self.vtable).EnumViews(@ptrCast(*const IOleDocument, self), ppEnum, ppView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocumentSite_Value = @import("../zig.zig").Guid.initString("b722bcc7-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocumentSite = &IID_IOleDocumentSite_Value;
pub const IOleDocumentSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateMe: fn(
            self: *const IOleDocumentSite,
            pViewToActivate: ?*IOleDocumentView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentSite_ActivateMe(self: *const T, pViewToActivate: ?*IOleDocumentView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentSite.VTable, self.vtable).ActivateMe(@ptrCast(*const IOleDocumentSite, self), pViewToActivate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleDocumentView_Value = @import("../zig.zig").Guid.initString("b722bcc6-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleDocumentView = &IID_IOleDocumentView_Value;
pub const IOleDocumentView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInPlaceSite: fn(
            self: *const IOleDocumentView,
            pIPSite: ?*IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceSite: fn(
            self: *const IOleDocumentView,
            ppIPSite: ?*?*IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocument: fn(
            self: *const IOleDocumentView,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRect: fn(
            self: *const IOleDocumentView,
            prcView: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: fn(
            self: *const IOleDocumentView,
            prcView: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRectComplex: fn(
            self: *const IOleDocumentView,
            prcView: ?*RECT,
            prcHScroll: ?*RECT,
            prcVScroll: ?*RECT,
            prcSizeBox: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IOleDocumentView,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UIActivate: fn(
            self: *const IOleDocumentView,
            fUIActivate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const IOleDocumentView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseView: fn(
            self: *const IOleDocumentView,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveViewState: fn(
            self: *const IOleDocumentView,
            pstm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyViewState: fn(
            self: *const IOleDocumentView,
            pstm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOleDocumentView,
            pIPSiteNew: ?*IOleInPlaceSite,
            ppViewNew: ?*?*IOleDocumentView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_SetInPlaceSite(self: *const T, pIPSite: ?*IOleInPlaceSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).SetInPlaceSite(@ptrCast(*const IOleDocumentView, self), pIPSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_GetInPlaceSite(self: *const T, ppIPSite: ?*?*IOleInPlaceSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).GetInPlaceSite(@ptrCast(*const IOleDocumentView, self), ppIPSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_GetDocument(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).GetDocument(@ptrCast(*const IOleDocumentView, self), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_SetRect(self: *const T, prcView: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).SetRect(@ptrCast(*const IOleDocumentView, self), prcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_GetRect(self: *const T, prcView: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).GetRect(@ptrCast(*const IOleDocumentView, self), prcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_SetRectComplex(self: *const T, prcView: ?*RECT, prcHScroll: ?*RECT, prcVScroll: ?*RECT, prcSizeBox: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).SetRectComplex(@ptrCast(*const IOleDocumentView, self), prcView, prcHScroll, prcVScroll, prcSizeBox);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_Show(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).Show(@ptrCast(*const IOleDocumentView, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_UIActivate(self: *const T, fUIActivate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).UIActivate(@ptrCast(*const IOleDocumentView, self), fUIActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).Open(@ptrCast(*const IOleDocumentView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_CloseView(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).CloseView(@ptrCast(*const IOleDocumentView, self), dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_SaveViewState(self: *const T, pstm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).SaveViewState(@ptrCast(*const IOleDocumentView, self), pstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_ApplyViewState(self: *const T, pstm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).ApplyViewState(@ptrCast(*const IOleDocumentView, self), pstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleDocumentView_Clone(self: *const T, pIPSiteNew: ?*IOleInPlaceSite, ppViewNew: ?*?*IOleDocumentView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleDocumentView.VTable, self.vtable).Clone(@ptrCast(*const IOleDocumentView, self), pIPSiteNew, ppViewNew);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumOleDocumentViews_Value = @import("../zig.zig").Guid.initString("b722bcc8-4e68-101b-a2bc-00aa00404770");
pub const IID_IEnumOleDocumentViews = &IID_IEnumOleDocumentViews_Value;
pub const IEnumOleDocumentViews = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumOleDocumentViews,
            cViews: u32,
            rgpView: ?*?*IOleDocumentView,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumOleDocumentViews,
            cViews: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumOleDocumentViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumOleDocumentViews,
            ppEnum: ?*?*IEnumOleDocumentViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleDocumentViews_Next(self: *const T, cViews: u32, rgpView: ?*?*IOleDocumentView, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleDocumentViews.VTable, self.vtable).Next(@ptrCast(*const IEnumOleDocumentViews, self), cViews, rgpView, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleDocumentViews_Skip(self: *const T, cViews: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleDocumentViews.VTable, self.vtable).Skip(@ptrCast(*const IEnumOleDocumentViews, self), cViews);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleDocumentViews_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleDocumentViews.VTable, self.vtable).Reset(@ptrCast(*const IEnumOleDocumentViews, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOleDocumentViews_Clone(self: *const T, ppEnum: ?*?*IEnumOleDocumentViews) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumOleDocumentViews.VTable, self.vtable).Clone(@ptrCast(*const IEnumOleDocumentViews, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContinueCallback_Value = @import("../zig.zig").Guid.initString("b722bcca-4e68-101b-a2bc-00aa00404770");
pub const IID_IContinueCallback = &IID_IContinueCallback_Value;
pub const IContinueCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FContinue: fn(
            self: *const IContinueCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FContinuePrinting: fn(
            self: *const IContinueCallback,
            nCntPrinted: i32,
            nCurPage: i32,
            pwszPrintStatus: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContinueCallback_FContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContinueCallback.VTable, self.vtable).FContinue(@ptrCast(*const IContinueCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContinueCallback_FContinuePrinting(self: *const T, nCntPrinted: i32, nCurPage: i32, pwszPrintStatus: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContinueCallback.VTable, self.vtable).FContinuePrinting(@ptrCast(*const IContinueCallback, self), nCntPrinted, nCurPage, pwszPrintStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PRINTFLAG = enum(u32) {
    MAYBOTHERUSER = 1,
    PROMPTUSER = 2,
    USERMAYCHANGEPRINTER = 4,
    RECOMPOSETODEVICE = 8,
    DONTACTUALLYPRINT = 16,
    FORCEPROPERTIES = 32,
    PRINTTOFILE = 64,
    _,
    pub fn initFlags(o: struct {
        MAYBOTHERUSER: u1 = 0,
        PROMPTUSER: u1 = 0,
        USERMAYCHANGEPRINTER: u1 = 0,
        RECOMPOSETODEVICE: u1 = 0,
        DONTACTUALLYPRINT: u1 = 0,
        FORCEPROPERTIES: u1 = 0,
        PRINTTOFILE: u1 = 0,
    }) PRINTFLAG {
        return @intToEnum(PRINTFLAG,
              (if (o.MAYBOTHERUSER == 1) @enumToInt(PRINTFLAG.MAYBOTHERUSER) else 0)
            | (if (o.PROMPTUSER == 1) @enumToInt(PRINTFLAG.PROMPTUSER) else 0)
            | (if (o.USERMAYCHANGEPRINTER == 1) @enumToInt(PRINTFLAG.USERMAYCHANGEPRINTER) else 0)
            | (if (o.RECOMPOSETODEVICE == 1) @enumToInt(PRINTFLAG.RECOMPOSETODEVICE) else 0)
            | (if (o.DONTACTUALLYPRINT == 1) @enumToInt(PRINTFLAG.DONTACTUALLYPRINT) else 0)
            | (if (o.FORCEPROPERTIES == 1) @enumToInt(PRINTFLAG.FORCEPROPERTIES) else 0)
            | (if (o.PRINTTOFILE == 1) @enumToInt(PRINTFLAG.PRINTTOFILE) else 0)
        );
    }
};
pub const PRINTFLAG_MAYBOTHERUSER = PRINTFLAG.MAYBOTHERUSER;
pub const PRINTFLAG_PROMPTUSER = PRINTFLAG.PROMPTUSER;
pub const PRINTFLAG_USERMAYCHANGEPRINTER = PRINTFLAG.USERMAYCHANGEPRINTER;
pub const PRINTFLAG_RECOMPOSETODEVICE = PRINTFLAG.RECOMPOSETODEVICE;
pub const PRINTFLAG_DONTACTUALLYPRINT = PRINTFLAG.DONTACTUALLYPRINT;
pub const PRINTFLAG_FORCEPROPERTIES = PRINTFLAG.FORCEPROPERTIES;
pub const PRINTFLAG_PRINTTOFILE = PRINTFLAG.PRINTTOFILE;

pub const PAGERANGE = extern struct {
    nFromPage: i32,
    nToPage: i32,
};

pub const PAGESET = extern struct {
    cbStruct: u32,
    fOddPages: BOOL,
    fEvenPages: BOOL,
    cPageRange: u32,
    rgPages: [1]PAGERANGE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPrint_Value = @import("../zig.zig").Guid.initString("b722bcc9-4e68-101b-a2bc-00aa00404770");
pub const IID_IPrint = &IID_IPrint_Value;
pub const IPrint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInitialPageNum: fn(
            self: *const IPrint,
            nFirstPage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageInfo: fn(
            self: *const IPrint,
            pnFirstPage: ?*i32,
            pcPages: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Print: fn(
            self: *const IPrint,
            grfFlags: u32,
            pptd: ?*?*DVTARGETDEVICE,
            ppPageSet: ?*?*PAGESET,
            pstgmOptions: ?*STGMEDIUM,
            pcallback: ?*IContinueCallback,
            nFirstPage: i32,
            pcPagesPrinted: ?*i32,
            pnLastPage: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrint_SetInitialPageNum(self: *const T, nFirstPage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrint.VTable, self.vtable).SetInitialPageNum(@ptrCast(*const IPrint, self), nFirstPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrint_GetPageInfo(self: *const T, pnFirstPage: ?*i32, pcPages: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrint.VTable, self.vtable).GetPageInfo(@ptrCast(*const IPrint, self), pnFirstPage, pcPages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrint_Print(self: *const T, grfFlags: u32, pptd: ?*?*DVTARGETDEVICE, ppPageSet: ?*?*PAGESET, pstgmOptions: ?*STGMEDIUM, pcallback: ?*IContinueCallback, nFirstPage: i32, pcPagesPrinted: ?*i32, pnLastPage: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrint.VTable, self.vtable).Print(@ptrCast(*const IPrint, self), grfFlags, pptd, ppPageSet, pstgmOptions, pcallback, nFirstPage, pcPagesPrinted, pnLastPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLECMDF = enum(i32) {
    SUPPORTED = 1,
    ENABLED = 2,
    LATCHED = 4,
    NINCHED = 8,
    INVISIBLE = 16,
    DEFHIDEONCTXTMENU = 32,
};
pub const OLECMDF_SUPPORTED = OLECMDF.SUPPORTED;
pub const OLECMDF_ENABLED = OLECMDF.ENABLED;
pub const OLECMDF_LATCHED = OLECMDF.LATCHED;
pub const OLECMDF_NINCHED = OLECMDF.NINCHED;
pub const OLECMDF_INVISIBLE = OLECMDF.INVISIBLE;
pub const OLECMDF_DEFHIDEONCTXTMENU = OLECMDF.DEFHIDEONCTXTMENU;

pub const OLECMD = extern struct {
    cmdID: u32,
    cmdf: u32,
};

pub const OLECMDTEXT = extern struct {
    cmdtextf: u32,
    cwActual: u32,
    cwBuf: u32,
    rgwz: [1]u16,
};

pub const OLECMDTEXTF = enum(i32) {
    NONE = 0,
    NAME = 1,
    STATUS = 2,
};
pub const OLECMDTEXTF_NONE = OLECMDTEXTF.NONE;
pub const OLECMDTEXTF_NAME = OLECMDTEXTF.NAME;
pub const OLECMDTEXTF_STATUS = OLECMDTEXTF.STATUS;

pub const OLECMDEXECOPT = enum(i32) {
    DODEFAULT = 0,
    PROMPTUSER = 1,
    DONTPROMPTUSER = 2,
    SHOWHELP = 3,
};
pub const OLECMDEXECOPT_DODEFAULT = OLECMDEXECOPT.DODEFAULT;
pub const OLECMDEXECOPT_PROMPTUSER = OLECMDEXECOPT.PROMPTUSER;
pub const OLECMDEXECOPT_DONTPROMPTUSER = OLECMDEXECOPT.DONTPROMPTUSER;
pub const OLECMDEXECOPT_SHOWHELP = OLECMDEXECOPT.SHOWHELP;

pub const OLECMDID = enum(i32) {
    OPEN = 1,
    NEW = 2,
    SAVE = 3,
    SAVEAS = 4,
    SAVECOPYAS = 5,
    PRINT = 6,
    PRINTPREVIEW = 7,
    PAGESETUP = 8,
    SPELL = 9,
    PROPERTIES = 10,
    CUT = 11,
    COPY = 12,
    PASTE = 13,
    PASTESPECIAL = 14,
    UNDO = 15,
    REDO = 16,
    SELECTALL = 17,
    CLEARSELECTION = 18,
    ZOOM = 19,
    GETZOOMRANGE = 20,
    UPDATECOMMANDS = 21,
    REFRESH = 22,
    STOP = 23,
    HIDETOOLBARS = 24,
    SETPROGRESSMAX = 25,
    SETPROGRESSPOS = 26,
    SETPROGRESSTEXT = 27,
    SETTITLE = 28,
    SETDOWNLOADSTATE = 29,
    STOPDOWNLOAD = 30,
    ONTOOLBARACTIVATED = 31,
    FIND = 32,
    DELETE = 33,
    HTTPEQUIV = 34,
    HTTPEQUIV_DONE = 35,
    ENABLE_INTERACTION = 36,
    ONUNLOAD = 37,
    PROPERTYBAG2 = 38,
    PREREFRESH = 39,
    SHOWSCRIPTERROR = 40,
    SHOWMESSAGE = 41,
    SHOWFIND = 42,
    SHOWPAGESETUP = 43,
    SHOWPRINT = 44,
    CLOSE = 45,
    ALLOWUILESSSAVEAS = 46,
    DONTDOWNLOADCSS = 47,
    UPDATEPAGESTATUS = 48,
    PRINT2 = 49,
    PRINTPREVIEW2 = 50,
    SETPRINTTEMPLATE = 51,
    GETPRINTTEMPLATE = 52,
    PAGEACTIONBLOCKED = 55,
    PAGEACTIONUIQUERY = 56,
    FOCUSVIEWCONTROLS = 57,
    FOCUSVIEWCONTROLSQUERY = 58,
    SHOWPAGEACTIONMENU = 59,
    ADDTRAVELENTRY = 60,
    UPDATETRAVELENTRY = 61,
    UPDATEBACKFORWARDSTATE = 62,
    OPTICAL_ZOOM = 63,
    OPTICAL_GETZOOMRANGE = 64,
    WINDOWSTATECHANGED = 65,
    ACTIVEXINSTALLSCOPE = 66,
    UPDATETRAVELENTRY_DATARECOVERY = 67,
    SHOWTASKDLG = 68,
    POPSTATEEVENT = 69,
    VIEWPORT_MODE = 70,
    LAYOUT_VIEWPORT_WIDTH = 71,
    VISUAL_VIEWPORT_EXCLUDE_BOTTOM = 72,
    USER_OPTICAL_ZOOM = 73,
    PAGEAVAILABLE = 74,
    GETUSERSCALABLE = 75,
    UPDATE_CARET = 76,
    ENABLE_VISIBILITY = 77,
    MEDIA_PLAYBACK = 78,
    SETFAVICON = 79,
    SET_HOST_FULLSCREENMODE = 80,
    EXITFULLSCREEN = 81,
    SCROLLCOMPLETE = 82,
    ONBEFOREUNLOAD = 83,
    SHOWMESSAGE_BLOCKABLE = 84,
    SHOWTASKDLG_BLOCKABLE = 85,
};
pub const OLECMDID_OPEN = OLECMDID.OPEN;
pub const OLECMDID_NEW = OLECMDID.NEW;
pub const OLECMDID_SAVE = OLECMDID.SAVE;
pub const OLECMDID_SAVEAS = OLECMDID.SAVEAS;
pub const OLECMDID_SAVECOPYAS = OLECMDID.SAVECOPYAS;
pub const OLECMDID_PRINT = OLECMDID.PRINT;
pub const OLECMDID_PRINTPREVIEW = OLECMDID.PRINTPREVIEW;
pub const OLECMDID_PAGESETUP = OLECMDID.PAGESETUP;
pub const OLECMDID_SPELL = OLECMDID.SPELL;
pub const OLECMDID_PROPERTIES = OLECMDID.PROPERTIES;
pub const OLECMDID_CUT = OLECMDID.CUT;
pub const OLECMDID_COPY = OLECMDID.COPY;
pub const OLECMDID_PASTE = OLECMDID.PASTE;
pub const OLECMDID_PASTESPECIAL = OLECMDID.PASTESPECIAL;
pub const OLECMDID_UNDO = OLECMDID.UNDO;
pub const OLECMDID_REDO = OLECMDID.REDO;
pub const OLECMDID_SELECTALL = OLECMDID.SELECTALL;
pub const OLECMDID_CLEARSELECTION = OLECMDID.CLEARSELECTION;
pub const OLECMDID_ZOOM = OLECMDID.ZOOM;
pub const OLECMDID_GETZOOMRANGE = OLECMDID.GETZOOMRANGE;
pub const OLECMDID_UPDATECOMMANDS = OLECMDID.UPDATECOMMANDS;
pub const OLECMDID_REFRESH = OLECMDID.REFRESH;
pub const OLECMDID_STOP = OLECMDID.STOP;
pub const OLECMDID_HIDETOOLBARS = OLECMDID.HIDETOOLBARS;
pub const OLECMDID_SETPROGRESSMAX = OLECMDID.SETPROGRESSMAX;
pub const OLECMDID_SETPROGRESSPOS = OLECMDID.SETPROGRESSPOS;
pub const OLECMDID_SETPROGRESSTEXT = OLECMDID.SETPROGRESSTEXT;
pub const OLECMDID_SETTITLE = OLECMDID.SETTITLE;
pub const OLECMDID_SETDOWNLOADSTATE = OLECMDID.SETDOWNLOADSTATE;
pub const OLECMDID_STOPDOWNLOAD = OLECMDID.STOPDOWNLOAD;
pub const OLECMDID_ONTOOLBARACTIVATED = OLECMDID.ONTOOLBARACTIVATED;
pub const OLECMDID_FIND = OLECMDID.FIND;
pub const OLECMDID_DELETE = OLECMDID.DELETE;
pub const OLECMDID_HTTPEQUIV = OLECMDID.HTTPEQUIV;
pub const OLECMDID_HTTPEQUIV_DONE = OLECMDID.HTTPEQUIV_DONE;
pub const OLECMDID_ENABLE_INTERACTION = OLECMDID.ENABLE_INTERACTION;
pub const OLECMDID_ONUNLOAD = OLECMDID.ONUNLOAD;
pub const OLECMDID_PROPERTYBAG2 = OLECMDID.PROPERTYBAG2;
pub const OLECMDID_PREREFRESH = OLECMDID.PREREFRESH;
pub const OLECMDID_SHOWSCRIPTERROR = OLECMDID.SHOWSCRIPTERROR;
pub const OLECMDID_SHOWMESSAGE = OLECMDID.SHOWMESSAGE;
pub const OLECMDID_SHOWFIND = OLECMDID.SHOWFIND;
pub const OLECMDID_SHOWPAGESETUP = OLECMDID.SHOWPAGESETUP;
pub const OLECMDID_SHOWPRINT = OLECMDID.SHOWPRINT;
pub const OLECMDID_CLOSE = OLECMDID.CLOSE;
pub const OLECMDID_ALLOWUILESSSAVEAS = OLECMDID.ALLOWUILESSSAVEAS;
pub const OLECMDID_DONTDOWNLOADCSS = OLECMDID.DONTDOWNLOADCSS;
pub const OLECMDID_UPDATEPAGESTATUS = OLECMDID.UPDATEPAGESTATUS;
pub const OLECMDID_PRINT2 = OLECMDID.PRINT2;
pub const OLECMDID_PRINTPREVIEW2 = OLECMDID.PRINTPREVIEW2;
pub const OLECMDID_SETPRINTTEMPLATE = OLECMDID.SETPRINTTEMPLATE;
pub const OLECMDID_GETPRINTTEMPLATE = OLECMDID.GETPRINTTEMPLATE;
pub const OLECMDID_PAGEACTIONBLOCKED = OLECMDID.PAGEACTIONBLOCKED;
pub const OLECMDID_PAGEACTIONUIQUERY = OLECMDID.PAGEACTIONUIQUERY;
pub const OLECMDID_FOCUSVIEWCONTROLS = OLECMDID.FOCUSVIEWCONTROLS;
pub const OLECMDID_FOCUSVIEWCONTROLSQUERY = OLECMDID.FOCUSVIEWCONTROLSQUERY;
pub const OLECMDID_SHOWPAGEACTIONMENU = OLECMDID.SHOWPAGEACTIONMENU;
pub const OLECMDID_ADDTRAVELENTRY = OLECMDID.ADDTRAVELENTRY;
pub const OLECMDID_UPDATETRAVELENTRY = OLECMDID.UPDATETRAVELENTRY;
pub const OLECMDID_UPDATEBACKFORWARDSTATE = OLECMDID.UPDATEBACKFORWARDSTATE;
pub const OLECMDID_OPTICAL_ZOOM = OLECMDID.OPTICAL_ZOOM;
pub const OLECMDID_OPTICAL_GETZOOMRANGE = OLECMDID.OPTICAL_GETZOOMRANGE;
pub const OLECMDID_WINDOWSTATECHANGED = OLECMDID.WINDOWSTATECHANGED;
pub const OLECMDID_ACTIVEXINSTALLSCOPE = OLECMDID.ACTIVEXINSTALLSCOPE;
pub const OLECMDID_UPDATETRAVELENTRY_DATARECOVERY = OLECMDID.UPDATETRAVELENTRY_DATARECOVERY;
pub const OLECMDID_SHOWTASKDLG = OLECMDID.SHOWTASKDLG;
pub const OLECMDID_POPSTATEEVENT = OLECMDID.POPSTATEEVENT;
pub const OLECMDID_VIEWPORT_MODE = OLECMDID.VIEWPORT_MODE;
pub const OLECMDID_LAYOUT_VIEWPORT_WIDTH = OLECMDID.LAYOUT_VIEWPORT_WIDTH;
pub const OLECMDID_VISUAL_VIEWPORT_EXCLUDE_BOTTOM = OLECMDID.VISUAL_VIEWPORT_EXCLUDE_BOTTOM;
pub const OLECMDID_USER_OPTICAL_ZOOM = OLECMDID.USER_OPTICAL_ZOOM;
pub const OLECMDID_PAGEAVAILABLE = OLECMDID.PAGEAVAILABLE;
pub const OLECMDID_GETUSERSCALABLE = OLECMDID.GETUSERSCALABLE;
pub const OLECMDID_UPDATE_CARET = OLECMDID.UPDATE_CARET;
pub const OLECMDID_ENABLE_VISIBILITY = OLECMDID.ENABLE_VISIBILITY;
pub const OLECMDID_MEDIA_PLAYBACK = OLECMDID.MEDIA_PLAYBACK;
pub const OLECMDID_SETFAVICON = OLECMDID.SETFAVICON;
pub const OLECMDID_SET_HOST_FULLSCREENMODE = OLECMDID.SET_HOST_FULLSCREENMODE;
pub const OLECMDID_EXITFULLSCREEN = OLECMDID.EXITFULLSCREEN;
pub const OLECMDID_SCROLLCOMPLETE = OLECMDID.SCROLLCOMPLETE;
pub const OLECMDID_ONBEFOREUNLOAD = OLECMDID.ONBEFOREUNLOAD;
pub const OLECMDID_SHOWMESSAGE_BLOCKABLE = OLECMDID.SHOWMESSAGE_BLOCKABLE;
pub const OLECMDID_SHOWTASKDLG_BLOCKABLE = OLECMDID.SHOWTASKDLG_BLOCKABLE;

pub const MEDIAPLAYBACK_STATE = enum(i32) {
    RESUME = 0,
    PAUSE = 1,
    PAUSE_AND_SUSPEND = 2,
    RESUME_FROM_SUSPEND = 3,
};
pub const MEDIAPLAYBACK_RESUME = MEDIAPLAYBACK_STATE.RESUME;
pub const MEDIAPLAYBACK_PAUSE = MEDIAPLAYBACK_STATE.PAUSE;
pub const MEDIAPLAYBACK_PAUSE_AND_SUSPEND = MEDIAPLAYBACK_STATE.PAUSE_AND_SUSPEND;
pub const MEDIAPLAYBACK_RESUME_FROM_SUSPEND = MEDIAPLAYBACK_STATE.RESUME_FROM_SUSPEND;

pub const IGNOREMIME = enum(i32) {
    PROMPT = 1,
    TEXT = 2,
};
pub const IGNOREMIME_PROMPT = IGNOREMIME.PROMPT;
pub const IGNOREMIME_TEXT = IGNOREMIME.TEXT;

pub const WPCSETTING = enum(i32) {
    LOGGING_ENABLED = 1,
    FILEDOWNLOAD_BLOCKED = 2,
};
pub const WPCSETTING_LOGGING_ENABLED = WPCSETTING.LOGGING_ENABLED;
pub const WPCSETTING_FILEDOWNLOAD_BLOCKED = WPCSETTING.FILEDOWNLOAD_BLOCKED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOleCommandTarget_Value = @import("../zig.zig").Guid.initString("b722bccb-4e68-101b-a2bc-00aa00404770");
pub const IID_IOleCommandTarget = &IID_IOleCommandTarget_Value;
pub const IOleCommandTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryStatus: fn(
            self: *const IOleCommandTarget,
            pguidCmdGroup: ?*const Guid,
            cCmds: u32,
            prgCmds: ?*OLECMD,
            pCmdText: ?*OLECMDTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exec: fn(
            self: *const IOleCommandTarget,
            pguidCmdGroup: ?*const Guid,
            nCmdID: u32,
            nCmdexecopt: u32,
            pvaIn: ?*VARIANT,
            pvaOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCommandTarget_QueryStatus(self: *const T, pguidCmdGroup: ?*const Guid, cCmds: u32, prgCmds: ?*OLECMD, pCmdText: ?*OLECMDTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCommandTarget.VTable, self.vtable).QueryStatus(@ptrCast(*const IOleCommandTarget, self), pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleCommandTarget_Exec(self: *const T, pguidCmdGroup: ?*const Guid, nCmdID: u32, nCmdexecopt: u32, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleCommandTarget.VTable, self.vtable).Exec(@ptrCast(*const IOleCommandTarget, self), pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLECMDID_REFRESHFLAG = enum(i32) {
    NORMAL = 0,
    IFEXPIRED = 1,
    CONTINUE = 2,
    COMPLETELY = 3,
    NO_CACHE = 4,
    RELOAD = 5,
    LEVELMASK = 255,
    CLEARUSERINPUT = 4096,
    PROMPTIFOFFLINE = 8192,
    THROUGHSCRIPT = 16384,
    SKIPBEFOREUNLOADEVENT = 32768,
    PAGEACTION_ACTIVEXINSTALL = 65536,
    PAGEACTION_FILEDOWNLOAD = 131072,
    PAGEACTION_LOCALMACHINE = 262144,
    PAGEACTION_POPUPWINDOW = 524288,
    PAGEACTION_PROTLOCKDOWNLOCALMACHINE = 1048576,
    PAGEACTION_PROTLOCKDOWNTRUSTED = 2097152,
    PAGEACTION_PROTLOCKDOWNINTRANET = 4194304,
    PAGEACTION_PROTLOCKDOWNINTERNET = 8388608,
    PAGEACTION_PROTLOCKDOWNRESTRICTED = 16777216,
    PAGEACTION_MIXEDCONTENT = 33554432,
    PAGEACTION_INVALID_CERT = 67108864,
    PAGEACTION_ALLOW_VERSION = 134217728,
};
pub const OLECMDIDF_REFRESH_NORMAL = OLECMDID_REFRESHFLAG.NORMAL;
pub const OLECMDIDF_REFRESH_IFEXPIRED = OLECMDID_REFRESHFLAG.IFEXPIRED;
pub const OLECMDIDF_REFRESH_CONTINUE = OLECMDID_REFRESHFLAG.CONTINUE;
pub const OLECMDIDF_REFRESH_COMPLETELY = OLECMDID_REFRESHFLAG.COMPLETELY;
pub const OLECMDIDF_REFRESH_NO_CACHE = OLECMDID_REFRESHFLAG.NO_CACHE;
pub const OLECMDIDF_REFRESH_RELOAD = OLECMDID_REFRESHFLAG.RELOAD;
pub const OLECMDIDF_REFRESH_LEVELMASK = OLECMDID_REFRESHFLAG.LEVELMASK;
pub const OLECMDIDF_REFRESH_CLEARUSERINPUT = OLECMDID_REFRESHFLAG.CLEARUSERINPUT;
pub const OLECMDIDF_REFRESH_PROMPTIFOFFLINE = OLECMDID_REFRESHFLAG.PROMPTIFOFFLINE;
pub const OLECMDIDF_REFRESH_THROUGHSCRIPT = OLECMDID_REFRESHFLAG.THROUGHSCRIPT;
pub const OLECMDIDF_REFRESH_SKIPBEFOREUNLOADEVENT = OLECMDID_REFRESHFLAG.SKIPBEFOREUNLOADEVENT;
pub const OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL = OLECMDID_REFRESHFLAG.PAGEACTION_ACTIVEXINSTALL;
pub const OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD = OLECMDID_REFRESHFLAG.PAGEACTION_FILEDOWNLOAD;
pub const OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE = OLECMDID_REFRESHFLAG.PAGEACTION_LOCALMACHINE;
pub const OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW = OLECMDID_REFRESHFLAG.PAGEACTION_POPUPWINDOW;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNLOCALMACHINE;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNTRUSTED;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNINTRANET;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNINTERNET;
pub const OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED = OLECMDID_REFRESHFLAG.PAGEACTION_PROTLOCKDOWNRESTRICTED;
pub const OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT = OLECMDID_REFRESHFLAG.PAGEACTION_MIXEDCONTENT;
pub const OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT = OLECMDID_REFRESHFLAG.PAGEACTION_INVALID_CERT;
pub const OLECMDIDF_REFRESH_PAGEACTION_ALLOW_VERSION = OLECMDID_REFRESHFLAG.PAGEACTION_ALLOW_VERSION;

pub const OLECMDID_PAGEACTIONFLAG = enum(i32) {
    FILEDOWNLOAD = 1,
    ACTIVEXINSTALL = 2,
    ACTIVEXTRUSTFAIL = 4,
    ACTIVEXUSERDISABLE = 8,
    ACTIVEXDISALLOW = 16,
    ACTIVEXUNSAFE = 32,
    POPUPWINDOW = 64,
    LOCALMACHINE = 128,
    MIMETEXTPLAIN = 256,
    SCRIPTNAVIGATE = 512,
    // SCRIPTNAVIGATE_ACTIVEXINSTALL = 512, this enum value conflicts with SCRIPTNAVIGATE
    PROTLOCKDOWNLOCALMACHINE = 1024,
    PROTLOCKDOWNTRUSTED = 2048,
    PROTLOCKDOWNINTRANET = 4096,
    PROTLOCKDOWNINTERNET = 8192,
    PROTLOCKDOWNRESTRICTED = 16384,
    PROTLOCKDOWNDENY = 32768,
    POPUPALLOWED = 65536,
    SCRIPTPROMPT = 131072,
    ACTIVEXUSERAPPROVAL = 262144,
    MIXEDCONTENT = 524288,
    INVALID_CERT = 1048576,
    INTRANETZONEREQUEST = 2097152,
    XSSFILTERED = 4194304,
    SPOOFABLEIDNHOST = 8388608,
    ACTIVEX_EPM_INCOMPATIBLE = 16777216,
    SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 33554432,
    WPCBLOCKED = 67108864,
    WPCBLOCKED_ACTIVEX = 134217728,
    EXTENSION_COMPAT_BLOCKED = 268435456,
    NORESETACTIVEX = 536870912,
    GENERIC_STATE = 1073741824,
    RESET = -2147483648,
};
pub const OLECMDIDF_PAGEACTION_FILEDOWNLOAD = OLECMDID_PAGEACTIONFLAG.FILEDOWNLOAD;
pub const OLECMDIDF_PAGEACTION_ACTIVEXINSTALL = OLECMDID_PAGEACTIONFLAG.ACTIVEXINSTALL;
pub const OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL = OLECMDID_PAGEACTIONFLAG.ACTIVEXTRUSTFAIL;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE = OLECMDID_PAGEACTIONFLAG.ACTIVEXUSERDISABLE;
pub const OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW = OLECMDID_PAGEACTIONFLAG.ACTIVEXDISALLOW;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE = OLECMDID_PAGEACTIONFLAG.ACTIVEXUNSAFE;
pub const OLECMDIDF_PAGEACTION_POPUPWINDOW = OLECMDID_PAGEACTIONFLAG.POPUPWINDOW;
pub const OLECMDIDF_PAGEACTION_LOCALMACHINE = OLECMDID_PAGEACTIONFLAG.LOCALMACHINE;
pub const OLECMDIDF_PAGEACTION_MIMETEXTPLAIN = OLECMDID_PAGEACTIONFLAG.MIMETEXTPLAIN;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNLOCALMACHINE;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNTRUSTED;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNINTRANET;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNINTERNET;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNRESTRICTED;
pub const OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY = OLECMDID_PAGEACTIONFLAG.PROTLOCKDOWNDENY;
pub const OLECMDIDF_PAGEACTION_POPUPALLOWED = OLECMDID_PAGEACTIONFLAG.POPUPALLOWED;
pub const OLECMDIDF_PAGEACTION_SCRIPTPROMPT = OLECMDID_PAGEACTIONFLAG.SCRIPTPROMPT;
pub const OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL = OLECMDID_PAGEACTIONFLAG.ACTIVEXUSERAPPROVAL;
pub const OLECMDIDF_PAGEACTION_MIXEDCONTENT = OLECMDID_PAGEACTIONFLAG.MIXEDCONTENT;
pub const OLECMDIDF_PAGEACTION_INVALID_CERT = OLECMDID_PAGEACTIONFLAG.INVALID_CERT;
pub const OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST = OLECMDID_PAGEACTIONFLAG.INTRANETZONEREQUEST;
pub const OLECMDIDF_PAGEACTION_XSSFILTERED = OLECMDID_PAGEACTIONFLAG.XSSFILTERED;
pub const OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST = OLECMDID_PAGEACTIONFLAG.SPOOFABLEIDNHOST;
pub const OLECMDIDF_PAGEACTION_ACTIVEX_EPM_INCOMPATIBLE = OLECMDID_PAGEACTIONFLAG.ACTIVEX_EPM_INCOMPATIBLE;
pub const OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = OLECMDID_PAGEACTIONFLAG.SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL;
pub const OLECMDIDF_PAGEACTION_WPCBLOCKED = OLECMDID_PAGEACTIONFLAG.WPCBLOCKED;
pub const OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX = OLECMDID_PAGEACTIONFLAG.WPCBLOCKED_ACTIVEX;
pub const OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED = OLECMDID_PAGEACTIONFLAG.EXTENSION_COMPAT_BLOCKED;
pub const OLECMDIDF_PAGEACTION_NORESETACTIVEX = OLECMDID_PAGEACTIONFLAG.NORESETACTIVEX;
pub const OLECMDIDF_PAGEACTION_GENERIC_STATE = OLECMDID_PAGEACTIONFLAG.GENERIC_STATE;
pub const OLECMDIDF_PAGEACTION_RESET = OLECMDID_PAGEACTIONFLAG.RESET;

pub const OLECMDID_BROWSERSTATEFLAG = enum(i32) {
    EXTENSIONSOFF = 1,
    IESECURITY = 2,
    PROTECTEDMODE_OFF = 4,
    RESET = 8,
    REQUIRESACTIVEX = 16,
    DESKTOPHTMLDIALOG = 32,
    BLOCKEDVERSION = 64,
};
pub const OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF = OLECMDID_BROWSERSTATEFLAG.EXTENSIONSOFF;
pub const OLECMDIDF_BROWSERSTATE_IESECURITY = OLECMDID_BROWSERSTATEFLAG.IESECURITY;
pub const OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF = OLECMDID_BROWSERSTATEFLAG.PROTECTEDMODE_OFF;
pub const OLECMDIDF_BROWSERSTATE_RESET = OLECMDID_BROWSERSTATEFLAG.RESET;
pub const OLECMDIDF_BROWSERSTATE_REQUIRESACTIVEX = OLECMDID_BROWSERSTATEFLAG.REQUIRESACTIVEX;
pub const OLECMDIDF_BROWSERSTATE_DESKTOPHTMLDIALOG = OLECMDID_BROWSERSTATEFLAG.DESKTOPHTMLDIALOG;
pub const OLECMDIDF_BROWSERSTATE_BLOCKEDVERSION = OLECMDID_BROWSERSTATEFLAG.BLOCKEDVERSION;

pub const OLECMDID_OPTICAL_ZOOMFLAG = enum(i32) {
    NOPERSIST = 1,
    NOLAYOUT = 16,
    NOTRANSIENT = 32,
    RELOADFORNEWTAB = 64,
};
pub const OLECMDIDF_OPTICAL_ZOOM_NOPERSIST = OLECMDID_OPTICAL_ZOOMFLAG.NOPERSIST;
pub const OLECMDIDF_OPTICAL_ZOOM_NOLAYOUT = OLECMDID_OPTICAL_ZOOMFLAG.NOLAYOUT;
pub const OLECMDIDF_OPTICAL_ZOOM_NOTRANSIENT = OLECMDID_OPTICAL_ZOOMFLAG.NOTRANSIENT;
pub const OLECMDIDF_OPTICAL_ZOOM_RELOADFORNEWTAB = OLECMDID_OPTICAL_ZOOMFLAG.RELOADFORNEWTAB;

pub const PAGEACTION_UI = enum(i32) {
    DEFAULT = 0,
    MODAL = 1,
    MODELESS = 2,
    SILENT = 3,
};
pub const PAGEACTION_UI_DEFAULT = PAGEACTION_UI.DEFAULT;
pub const PAGEACTION_UI_MODAL = PAGEACTION_UI.MODAL;
pub const PAGEACTION_UI_MODELESS = PAGEACTION_UI.MODELESS;
pub const PAGEACTION_UI_SILENT = PAGEACTION_UI.SILENT;

pub const OLECMDID_WINDOWSTATE_FLAG = enum(i32) {
    USERVISIBLE = 1,
    ENABLED = 2,
    USERVISIBLE_VALID = 65536,
    ENABLED_VALID = 131072,
};
pub const OLECMDIDF_WINDOWSTATE_USERVISIBLE = OLECMDID_WINDOWSTATE_FLAG.USERVISIBLE;
pub const OLECMDIDF_WINDOWSTATE_ENABLED = OLECMDID_WINDOWSTATE_FLAG.ENABLED;
pub const OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID = OLECMDID_WINDOWSTATE_FLAG.USERVISIBLE_VALID;
pub const OLECMDIDF_WINDOWSTATE_ENABLED_VALID = OLECMDID_WINDOWSTATE_FLAG.ENABLED_VALID;

pub const OLECMDID_VIEWPORT_MODE_FLAG = enum(i32) {
    FIXED_LAYOUT_WIDTH = 1,
    EXCLUDE_VISUAL_BOTTOM = 2,
    FIXED_LAYOUT_WIDTH_VALID = 65536,
    EXCLUDE_VISUAL_BOTTOM_VALID = 131072,
};
pub const OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH = OLECMDID_VIEWPORT_MODE_FLAG.FIXED_LAYOUT_WIDTH;
pub const OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM = OLECMDID_VIEWPORT_MODE_FLAG.EXCLUDE_VISUAL_BOTTOM;
pub const OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH_VALID = OLECMDID_VIEWPORT_MODE_FLAG.FIXED_LAYOUT_WIDTH_VALID;
pub const OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM_VALID = OLECMDID_VIEWPORT_MODE_FLAG.EXCLUDE_VISUAL_BOTTOM_VALID;

const IID_IZoomEvents_Value = @import("../zig.zig").Guid.initString("41b68150-904c-4e17-a0ba-a438182e359d");
pub const IID_IZoomEvents = &IID_IZoomEvents_Value;
pub const IZoomEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnZoomPercentChanged: fn(
            self: *const IZoomEvents,
            ulZoomPercent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoomEvents_OnZoomPercentChanged(self: *const T, ulZoomPercent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoomEvents.VTable, self.vtable).OnZoomPercentChanged(@ptrCast(*const IZoomEvents, self), ulZoomPercent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectFocus_Value = @import("../zig.zig").Guid.initString("d81f90a3-8156-44f7-ad28-5abb87003274");
pub const IID_IProtectFocus = &IID_IProtectFocus_Value;
pub const IProtectFocus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowFocusChange: fn(
            self: *const IProtectFocus,
            pfAllow: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectFocus_AllowFocusChange(self: *const T, pfAllow: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectFocus.VTable, self.vtable).AllowFocusChange(@ptrCast(*const IProtectFocus, self), pfAllow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectedModeMenuServices_Value = @import("../zig.zig").Guid.initString("73c105ee-9dff-4a07-b83c-7eff290c266e");
pub const IID_IProtectedModeMenuServices = &IID_IProtectedModeMenuServices_Value;
pub const IProtectedModeMenuServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMenu: fn(
            self: *const IProtectedModeMenuServices,
            phMenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadMenu: fn(
            self: *const IProtectedModeMenuServices,
            pszModuleName: ?[*:0]const u16,
            pszMenuName: ?[*:0]const u16,
            phMenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadMenuID: fn(
            self: *const IProtectedModeMenuServices,
            pszModuleName: ?[*:0]const u16,
            wResourceID: u16,
            phMenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectedModeMenuServices_CreateMenu(self: *const T, phMenu: ?*?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectedModeMenuServices.VTable, self.vtable).CreateMenu(@ptrCast(*const IProtectedModeMenuServices, self), phMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectedModeMenuServices_LoadMenu(self: *const T, pszModuleName: ?[*:0]const u16, pszMenuName: ?[*:0]const u16, phMenu: ?*?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectedModeMenuServices.VTable, self.vtable).LoadMenu(@ptrCast(*const IProtectedModeMenuServices, self), pszModuleName, pszMenuName, phMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectedModeMenuServices_LoadMenuID(self: *const T, pszModuleName: ?[*:0]const u16, wResourceID: u16, phMenu: ?*?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectedModeMenuServices.VTable, self.vtable).LoadMenuID(@ptrCast(*const IProtectedModeMenuServices, self), pszModuleName, wResourceID, phMenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPFNOLEUIHOOK = fn(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const OLEUIINSERTOBJECTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    clsid: Guid,
    lpszFile: ?PWSTR,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: ?*IOleClientSite,
    lpIStorage: ?*IStorage,
    ppvObj: ?*?*c_void,
    sc: i32,
    hMetaPict: isize,
};

pub const OLEUIINSERTOBJECTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    clsid: Guid,
    lpszFile: ?PSTR,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: ?*IOleClientSite,
    lpIStorage: ?*IStorage,
    ppvObj: ?*?*c_void,
    sc: i32,
    hMetaPict: isize,
};

pub const OLEUIPASTEFLAG = enum(i32) {
    ENABLEICON = 2048,
    PASTEONLY = 0,
    PASTE = 512,
    LINKANYTYPE = 1024,
    LINKTYPE1 = 1,
    LINKTYPE2 = 2,
    LINKTYPE3 = 4,
    LINKTYPE4 = 8,
    LINKTYPE5 = 16,
    LINKTYPE6 = 32,
    LINKTYPE7 = 64,
    LINKTYPE8 = 128,
};
pub const OLEUIPASTE_ENABLEICON = OLEUIPASTEFLAG.ENABLEICON;
pub const OLEUIPASTE_PASTEONLY = OLEUIPASTEFLAG.PASTEONLY;
pub const OLEUIPASTE_PASTE = OLEUIPASTEFLAG.PASTE;
pub const OLEUIPASTE_LINKANYTYPE = OLEUIPASTEFLAG.LINKANYTYPE;
pub const OLEUIPASTE_LINKTYPE1 = OLEUIPASTEFLAG.LINKTYPE1;
pub const OLEUIPASTE_LINKTYPE2 = OLEUIPASTEFLAG.LINKTYPE2;
pub const OLEUIPASTE_LINKTYPE3 = OLEUIPASTEFLAG.LINKTYPE3;
pub const OLEUIPASTE_LINKTYPE4 = OLEUIPASTEFLAG.LINKTYPE4;
pub const OLEUIPASTE_LINKTYPE5 = OLEUIPASTEFLAG.LINKTYPE5;
pub const OLEUIPASTE_LINKTYPE6 = OLEUIPASTEFLAG.LINKTYPE6;
pub const OLEUIPASTE_LINKTYPE7 = OLEUIPASTEFLAG.LINKTYPE7;
pub const OLEUIPASTE_LINKTYPE8 = OLEUIPASTEFLAG.LINKTYPE8;

pub const OLEUIPASTEENTRYW = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?[*:0]const u16,
    lpstrResultText: ?[*:0]const u16,
    dwFlags: u32,
    dwScratchSpace: u32,
};

pub const OLEUIPASTEENTRYA = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?[*:0]const u8,
    lpstrResultText: ?[*:0]const u8,
    dwFlags: u32,
    dwScratchSpace: u32,
};

pub const OLEUIPASTESPECIALW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpSrcDataObj: ?*IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYW,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: isize,
    sizel: SIZE,
};

pub const OLEUIPASTESPECIALA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpSrcDataObj: ?*IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYA,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: isize,
    sizel: SIZE,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkContainerW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextLink: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        SetLinkUpdateOptions: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
            dwUpdateOpt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkUpdateOptions: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
            lpdwUpdateOpt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkSource: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
            lpszDisplayName: ?PWSTR,
            lenFileName: u32,
            pchEaten: ?*u32,
            fValidateSource: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkSource: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
            lplpszDisplayName: ?*?PWSTR,
            lplenFileName: ?*u32,
            lplpszFullLinkType: ?*?PWSTR,
            lplpszShortLinkType: ?*?PWSTR,
            lpfSourceAvailable: ?*BOOL,
            lpfIsSelected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLinkSource: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateLink: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
            fErrorMessage: BOOL,
            fReserved: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelLink: fn(
            self: *const IOleUILinkContainerW,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_GetNextLink(self: *const T, dwLink: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).GetNextLink(@ptrCast(*const IOleUILinkContainerW, self), dwLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_SetLinkUpdateOptions(self: *const T, dwLink: u32, dwUpdateOpt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).SetLinkUpdateOptions(@ptrCast(*const IOleUILinkContainerW, self), dwLink, dwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_GetLinkUpdateOptions(self: *const T, dwLink: u32, lpdwUpdateOpt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).GetLinkUpdateOptions(@ptrCast(*const IOleUILinkContainerW, self), dwLink, lpdwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_SetLinkSource(self: *const T, dwLink: u32, lpszDisplayName: ?PWSTR, lenFileName: u32, pchEaten: ?*u32, fValidateSource: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).SetLinkSource(@ptrCast(*const IOleUILinkContainerW, self), dwLink, lpszDisplayName, lenFileName, pchEaten, fValidateSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_GetLinkSource(self: *const T, dwLink: u32, lplpszDisplayName: ?*?PWSTR, lplenFileName: ?*u32, lplpszFullLinkType: ?*?PWSTR, lplpszShortLinkType: ?*?PWSTR, lpfSourceAvailable: ?*BOOL, lpfIsSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).GetLinkSource(@ptrCast(*const IOleUILinkContainerW, self), dwLink, lplpszDisplayName, lplenFileName, lplpszFullLinkType, lplpszShortLinkType, lpfSourceAvailable, lpfIsSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_OpenLinkSource(self: *const T, dwLink: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).OpenLinkSource(@ptrCast(*const IOleUILinkContainerW, self), dwLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_UpdateLink(self: *const T, dwLink: u32, fErrorMessage: BOOL, fReserved: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).UpdateLink(@ptrCast(*const IOleUILinkContainerW, self), dwLink, fErrorMessage, fReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerW_CancelLink(self: *const T, dwLink: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerW.VTable, self.vtable).CancelLink(@ptrCast(*const IOleUILinkContainerW, self), dwLink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkContainerA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextLink: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        SetLinkUpdateOptions: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
            dwUpdateOpt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkUpdateOptions: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
            lpdwUpdateOpt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkSource: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
            lpszDisplayName: ?PSTR,
            lenFileName: u32,
            pchEaten: ?*u32,
            fValidateSource: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkSource: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
            lplpszDisplayName: ?*?PSTR,
            lplenFileName: ?*u32,
            lplpszFullLinkType: ?*?PSTR,
            lplpszShortLinkType: ?*?PSTR,
            lpfSourceAvailable: ?*BOOL,
            lpfIsSelected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLinkSource: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateLink: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
            fErrorMessage: BOOL,
            fReserved: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelLink: fn(
            self: *const IOleUILinkContainerA,
            dwLink: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_GetNextLink(self: *const T, dwLink: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).GetNextLink(@ptrCast(*const IOleUILinkContainerA, self), dwLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_SetLinkUpdateOptions(self: *const T, dwLink: u32, dwUpdateOpt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).SetLinkUpdateOptions(@ptrCast(*const IOleUILinkContainerA, self), dwLink, dwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_GetLinkUpdateOptions(self: *const T, dwLink: u32, lpdwUpdateOpt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).GetLinkUpdateOptions(@ptrCast(*const IOleUILinkContainerA, self), dwLink, lpdwUpdateOpt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_SetLinkSource(self: *const T, dwLink: u32, lpszDisplayName: ?PSTR, lenFileName: u32, pchEaten: ?*u32, fValidateSource: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).SetLinkSource(@ptrCast(*const IOleUILinkContainerA, self), dwLink, lpszDisplayName, lenFileName, pchEaten, fValidateSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_GetLinkSource(self: *const T, dwLink: u32, lplpszDisplayName: ?*?PSTR, lplenFileName: ?*u32, lplpszFullLinkType: ?*?PSTR, lplpszShortLinkType: ?*?PSTR, lpfSourceAvailable: ?*BOOL, lpfIsSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).GetLinkSource(@ptrCast(*const IOleUILinkContainerA, self), dwLink, lplpszDisplayName, lplenFileName, lplpszFullLinkType, lplpszShortLinkType, lpfSourceAvailable, lpfIsSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_OpenLinkSource(self: *const T, dwLink: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).OpenLinkSource(@ptrCast(*const IOleUILinkContainerA, self), dwLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_UpdateLink(self: *const T, dwLink: u32, fErrorMessage: BOOL, fReserved: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).UpdateLink(@ptrCast(*const IOleUILinkContainerA, self), dwLink, fErrorMessage, fReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkContainerA_CancelLink(self: *const T, dwLink: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkContainerA.VTable, self.vtable).CancelLink(@ptrCast(*const IOleUILinkContainerA, self), dwLink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUIEDITLINKSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpOleUILinkContainer: ?*IOleUILinkContainerW,
};

pub const OLEUIEDITLINKSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpOleUILinkContainer: ?*IOleUILinkContainerA,
};

pub const OLEUICHANGEICONW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    hMetaPict: isize,
    clsid: Guid,
    szIconExe: [260]u16,
    cchIconExe: i32,
};

pub const OLEUICHANGEICONA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    hMetaPict: isize,
    clsid: Guid,
    szIconExe: [260]CHAR,
    cchIconExe: i32,
};

pub const OLEUICONVERTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: isize,
    lpszUserType: ?PWSTR,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?PWSTR,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};

pub const OLEUICONVERTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: isize,
    lpszUserType: ?PSTR,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?PSTR,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};

pub const OLEUIBUSYW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    hTask: ?HTASK,
    lphWndDialog: ?*?HWND,
};

pub const OLEUIBUSYA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    hTask: ?HTASK,
    lphWndDialog: ?*?HWND,
};

pub const OLEUICHANGESOURCEW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u16,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u16,
    hResource: ?HRSRC,
    lpOFN: ?*OPENFILENAMEW,
    dwReserved1: [4]u32,
    lpOleUILinkContainer: ?*IOleUILinkContainerW,
    dwLink: u32,
    lpszDisplayName: ?PWSTR,
    nFileLength: u32,
    lpszFrom: ?PWSTR,
    lpszTo: ?PWSTR,
};

pub const OLEUICHANGESOURCEA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: ?HWND,
    lpszCaption: ?[*:0]const u8,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: ?HINSTANCE,
    lpszTemplate: ?[*:0]const u8,
    hResource: ?HRSRC,
    lpOFN: ?*OPENFILENAMEA,
    dwReserved1: [4]u32,
    lpOleUILinkContainer: ?*IOleUILinkContainerA,
    dwLink: u32,
    lpszDisplayName: ?PSTR,
    nFileLength: u32,
    lpszFrom: ?PSTR,
    lpszTo: ?PSTR,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUIObjInfoW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectInfo: fn(
            self: *const IOleUIObjInfoW,
            dwObject: u32,
            lpdwObjSize: ?*u32,
            lplpszLabel: ?*?PWSTR,
            lplpszType: ?*?PWSTR,
            lplpszShortType: ?*?PWSTR,
            lplpszLocation: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConvertInfo: fn(
            self: *const IOleUIObjInfoW,
            dwObject: u32,
            lpClassID: ?*Guid,
            lpwFormat: ?*u16,
            lpConvertDefaultClassID: ?*Guid,
            lplpClsidExclude: ?*?*Guid,
            lpcClsidExclude: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IOleUIObjInfoW,
            dwObject: u32,
            clsidNew: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewInfo: fn(
            self: *const IOleUIObjInfoW,
            dwObject: u32,
            phMetaPict: ?*isize,
            pdvAspect: ?*u32,
            pnCurrentScale: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewInfo: fn(
            self: *const IOleUIObjInfoW,
            dwObject: u32,
            hMetaPict: isize,
            dvAspect: u32,
            nCurrentScale: i32,
            bRelativeToOrig: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoW_GetObjectInfo(self: *const T, dwObject: u32, lpdwObjSize: ?*u32, lplpszLabel: ?*?PWSTR, lplpszType: ?*?PWSTR, lplpszShortType: ?*?PWSTR, lplpszLocation: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoW.VTable, self.vtable).GetObjectInfo(@ptrCast(*const IOleUIObjInfoW, self), dwObject, lpdwObjSize, lplpszLabel, lplpszType, lplpszShortType, lplpszLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoW_GetConvertInfo(self: *const T, dwObject: u32, lpClassID: ?*Guid, lpwFormat: ?*u16, lpConvertDefaultClassID: ?*Guid, lplpClsidExclude: ?*?*Guid, lpcClsidExclude: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoW.VTable, self.vtable).GetConvertInfo(@ptrCast(*const IOleUIObjInfoW, self), dwObject, lpClassID, lpwFormat, lpConvertDefaultClassID, lplpClsidExclude, lpcClsidExclude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoW_ConvertObject(self: *const T, dwObject: u32, clsidNew: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoW.VTable, self.vtable).ConvertObject(@ptrCast(*const IOleUIObjInfoW, self), dwObject, clsidNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoW_GetViewInfo(self: *const T, dwObject: u32, phMetaPict: ?*isize, pdvAspect: ?*u32, pnCurrentScale: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoW.VTable, self.vtable).GetViewInfo(@ptrCast(*const IOleUIObjInfoW, self), dwObject, phMetaPict, pdvAspect, pnCurrentScale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoW_SetViewInfo(self: *const T, dwObject: u32, hMetaPict: isize, dvAspect: u32, nCurrentScale: i32, bRelativeToOrig: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoW.VTable, self.vtable).SetViewInfo(@ptrCast(*const IOleUIObjInfoW, self), dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUIObjInfoA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectInfo: fn(
            self: *const IOleUIObjInfoA,
            dwObject: u32,
            lpdwObjSize: ?*u32,
            lplpszLabel: ?*?PSTR,
            lplpszType: ?*?PSTR,
            lplpszShortType: ?*?PSTR,
            lplpszLocation: ?*?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConvertInfo: fn(
            self: *const IOleUIObjInfoA,
            dwObject: u32,
            lpClassID: ?*Guid,
            lpwFormat: ?*u16,
            lpConvertDefaultClassID: ?*Guid,
            lplpClsidExclude: ?*?*Guid,
            lpcClsidExclude: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IOleUIObjInfoA,
            dwObject: u32,
            clsidNew: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewInfo: fn(
            self: *const IOleUIObjInfoA,
            dwObject: u32,
            phMetaPict: ?*isize,
            pdvAspect: ?*u32,
            pnCurrentScale: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewInfo: fn(
            self: *const IOleUIObjInfoA,
            dwObject: u32,
            hMetaPict: isize,
            dvAspect: u32,
            nCurrentScale: i32,
            bRelativeToOrig: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoA_GetObjectInfo(self: *const T, dwObject: u32, lpdwObjSize: ?*u32, lplpszLabel: ?*?PSTR, lplpszType: ?*?PSTR, lplpszShortType: ?*?PSTR, lplpszLocation: ?*?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoA.VTable, self.vtable).GetObjectInfo(@ptrCast(*const IOleUIObjInfoA, self), dwObject, lpdwObjSize, lplpszLabel, lplpszType, lplpszShortType, lplpszLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoA_GetConvertInfo(self: *const T, dwObject: u32, lpClassID: ?*Guid, lpwFormat: ?*u16, lpConvertDefaultClassID: ?*Guid, lplpClsidExclude: ?*?*Guid, lpcClsidExclude: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoA.VTable, self.vtable).GetConvertInfo(@ptrCast(*const IOleUIObjInfoA, self), dwObject, lpClassID, lpwFormat, lpConvertDefaultClassID, lplpClsidExclude, lpcClsidExclude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoA_ConvertObject(self: *const T, dwObject: u32, clsidNew: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoA.VTable, self.vtable).ConvertObject(@ptrCast(*const IOleUIObjInfoA, self), dwObject, clsidNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoA_GetViewInfo(self: *const T, dwObject: u32, phMetaPict: ?*isize, pdvAspect: ?*u32, pnCurrentScale: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoA.VTable, self.vtable).GetViewInfo(@ptrCast(*const IOleUIObjInfoA, self), dwObject, phMetaPict, pdvAspect, pnCurrentScale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUIObjInfoA_SetViewInfo(self: *const T, dwObject: u32, hMetaPict: isize, dvAspect: u32, nCurrentScale: i32, bRelativeToOrig: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUIObjInfoA.VTable, self.vtable).SetViewInfo(@ptrCast(*const IOleUIObjInfoA, self), dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkInfoW = extern struct {
    pub const VTable = extern struct {
        base: IOleUILinkContainerW.VTable,
        GetLastUpdate: fn(
            self: *const IOleUILinkInfoW,
            dwLink: u32,
            lpLastUpdate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleUILinkContainerW.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkInfoW_GetLastUpdate(self: *const T, dwLink: u32, lpLastUpdate: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkInfoW.VTable, self.vtable).GetLastUpdate(@ptrCast(*const IOleUILinkInfoW, self), dwLink, lpLastUpdate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IOleUILinkInfoA = extern struct {
    pub const VTable = extern struct {
        base: IOleUILinkContainerA.VTable,
        GetLastUpdate: fn(
            self: *const IOleUILinkInfoA,
            dwLink: u32,
            lpLastUpdate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleUILinkContainerA.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOleUILinkInfoA_GetLastUpdate(self: *const T, dwLink: u32, lpLastUpdate: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOleUILinkInfoA.VTable, self.vtable).GetLastUpdate(@ptrCast(*const IOleUILinkInfoA, self), dwLink, lpLastUpdate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLEUIGNRLPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};

pub const OLEUIGNRLPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};

pub const OLEUIVIEWPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
    nScaleMin: i32,
    nScaleMax: i32,
};

pub const OLEUIVIEWPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
    nScaleMin: i32,
    nScaleMax: i32,
};

pub const OLEUILINKPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};

pub const OLEUILINKPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: [2]u32,
    lpfnHook: ?LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: [3]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};

pub const OLEUIOBJECTPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERW_V2,
    dwObject: u32,
    lpObjInfo: ?*IOleUIObjInfoW,
    dwLink: u32,
    lpLinkInfo: ?*IOleUILinkInfoW,
    lpGP: ?*OLEUIGNRLPROPSW,
    lpVP: ?*OLEUIVIEWPROPSW,
    lpLP: ?*OLEUILINKPROPSW,
};

pub const OLEUIOBJECTPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERA_V2,
    dwObject: u32,
    lpObjInfo: ?*IOleUIObjInfoA,
    dwLink: u32,
    lpLinkInfo: ?*IOleUILinkInfoA,
    lpGP: ?*OLEUIGNRLPROPSA,
    lpVP: ?*OLEUIVIEWPROPSA,
    lpLP: ?*OLEUILINKPROPSA,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumGUID_Value = @import("../zig.zig").Guid.initString("0002e000-0000-0000-c000-000000000046");
pub const IID_IEnumGUID = &IID_IEnumGUID_Value;
pub const IEnumGUID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumGUID,
            celt: u32,
            rgelt: [*]Guid,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumGUID,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumGUID,
            ppenum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Next(@ptrCast(*const IEnumGUID, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Skip(@ptrCast(*const IEnumGUID, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Reset(@ptrCast(*const IEnumGUID, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Clone(self: *const T, ppenum: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Clone(@ptrCast(*const IEnumGUID, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO = extern struct {
    catid: Guid,
    lcid: u32,
    szDescription: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumCATEGORYINFO_Value = @import("../zig.zig").Guid.initString("0002e011-0000-0000-c000-000000000046");
pub const IID_IEnumCATEGORYINFO = &IID_IEnumCATEGORYINFO_Value;
pub const IEnumCATEGORYINFO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumCATEGORYINFO,
            celt: u32,
            rgelt: [*]CATEGORYINFO,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCATEGORYINFO,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCATEGORYINFO,
            ppenum: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Next(self: *const T, celt: u32, rgelt: [*]CATEGORYINFO, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Next(@ptrCast(*const IEnumCATEGORYINFO, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Skip(@ptrCast(*const IEnumCATEGORYINFO, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Reset(@ptrCast(*const IEnumCATEGORYINFO, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Clone(self: *const T, ppenum: ?*?*IEnumCATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Clone(@ptrCast(*const IEnumCATEGORYINFO, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatRegister_Value = @import("../zig.zig").Guid.initString("0002e012-0000-0000-c000-000000000046");
pub const IID_ICatRegister = &IID_ICatRegister_Value;
pub const ICatRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategories: fn(
            self: *const ICatRegister,
            cCategories: u32,
            rgCategoryInfo: [*]CATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterCategories: fn(
            self: *const ICatRegister,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassImplCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassImplCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassReqCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassReqCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterCategories(self: *const T, cCategories: u32, rgCategoryInfo: [*]CATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterCategories(@ptrCast(*const ICatRegister, self), cCategories, rgCategoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterCategories(self: *const T, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterCategories(@ptrCast(*const ICatRegister, self), cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterClassImplCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterClassImplCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterClassReqCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterClassReqCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatInformation_Value = @import("../zig.zig").Guid.initString("0002e013-0000-0000-c000-000000000046");
pub const IID_ICatInformation = &IID_ICatInformation_Value;
pub const ICatInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCategories: fn(
            self: *const ICatInformation,
            lcid: u32,
            ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryDesc: fn(
            self: *const ICatInformation,
            rcatid: ?*Guid,
            lcid: u32,
            pszDesc: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumClassesOfCategories: fn(
            self: *const ICatInformation,
            cImplemented: u32,
            rgcatidImpl: [*]const Guid,
            cRequired: u32,
            rgcatidReq: [*]const Guid,
            ppenumClsid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsClassOfCategories: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            cImplemented: u32,
            rgcatidImpl: [*]const Guid,
            cRequired: u32,
            rgcatidReq: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumImplCategoriesOfClass: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenumCatid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumReqCategoriesOfClass: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenumCatid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumCategories(self: *const T, lcid: u32, ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumCategories(@ptrCast(*const ICatInformation, self), lcid, ppenumCategoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_GetCategoryDesc(self: *const T, rcatid: ?*Guid, lcid: u32, pszDesc: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).GetCategoryDesc(@ptrCast(*const ICatInformation, self), rcatid, lcid, pszDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumClassesOfCategories(self: *const T, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid, ppenumClsid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumClassesOfCategories(@ptrCast(*const ICatInformation, self), cImplemented, rgcatidImpl, cRequired, rgcatidReq, ppenumClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_IsClassOfCategories(self: *const T, rclsid: ?*const Guid, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).IsClassOfCategories(@ptrCast(*const ICatInformation, self), rclsid, cImplemented, rgcatidImpl, cRequired, rgcatidReq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumImplCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumImplCategoriesOfClass(@ptrCast(*const ICatInformation, self), rclsid, ppenumCatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumReqCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumReqCategoriesOfClass(@ptrCast(*const ICatInformation, self), rclsid, ppenumCatid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CALLFRAMEINFO = extern struct {
    iMethod: u32,
    fHasInValues: BOOL,
    fHasInOutValues: BOOL,
    fHasOutValues: BOOL,
    fDerivesFromIDispatch: BOOL,
    cInInterfacesMax: i32,
    cInOutInterfacesMax: i32,
    cOutInterfacesMax: i32,
    cTopLevelInInterfaces: i32,
    iid: Guid,
    cMethod: u32,
    cParams: u32,
};

pub const CALLFRAMEPARAMINFO = extern struct {
    fIn: BOOLEAN,
    fOut: BOOLEAN,
    stackOffset: u32,
    cbParam: u32,
};

pub const CALLFRAME_COPY = enum(i32) {
    NESTED = 1,
    INDEPENDENT = 2,
};
pub const CALLFRAME_COPY_NESTED = CALLFRAME_COPY.NESTED;
pub const CALLFRAME_COPY_INDEPENDENT = CALLFRAME_COPY.INDEPENDENT;

pub const CALLFRAME_FREE = enum(i32) {
    NONE = 0,
    IN = 1,
    INOUT = 2,
    OUT = 4,
    TOP_INOUT = 8,
    TOP_OUT = 16,
    ALL = 31,
};
pub const CALLFRAME_FREE_NONE = CALLFRAME_FREE.NONE;
pub const CALLFRAME_FREE_IN = CALLFRAME_FREE.IN;
pub const CALLFRAME_FREE_INOUT = CALLFRAME_FREE.INOUT;
pub const CALLFRAME_FREE_OUT = CALLFRAME_FREE.OUT;
pub const CALLFRAME_FREE_TOP_INOUT = CALLFRAME_FREE.TOP_INOUT;
pub const CALLFRAME_FREE_TOP_OUT = CALLFRAME_FREE.TOP_OUT;
pub const CALLFRAME_FREE_ALL = CALLFRAME_FREE.ALL;

pub const CALLFRAME_NULL = enum(i32) {
    NONE = 0,
    INOUT = 2,
    OUT = 4,
    ALL = 6,
};
pub const CALLFRAME_NULL_NONE = CALLFRAME_NULL.NONE;
pub const CALLFRAME_NULL_INOUT = CALLFRAME_NULL.INOUT;
pub const CALLFRAME_NULL_OUT = CALLFRAME_NULL.OUT;
pub const CALLFRAME_NULL_ALL = CALLFRAME_NULL.ALL;

pub const CALLFRAME_WALK = enum(i32) {
    IN = 1,
    INOUT = 2,
    OUT = 4,
};
pub const CALLFRAME_WALK_IN = CALLFRAME_WALK.IN;
pub const CALLFRAME_WALK_INOUT = CALLFRAME_WALK.INOUT;
pub const CALLFRAME_WALK_OUT = CALLFRAME_WALK.OUT;

pub const CALLFRAME_MARSHALCONTEXT = extern struct {
    fIn: BOOLEAN,
    dwDestContext: u32,
    pvDestContext: ?*c_void,
    punkReserved: ?*IUnknown,
    guidTransferSyntax: Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrame_Value = @import("../zig.zig").Guid.initString("d573b4b0-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallFrame = &IID_ICallFrame_Value;
pub const ICallFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: fn(
            self: *const ICallFrame,
            pInfo: ?*CALLFRAMEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDAndMethod: fn(
            self: *const ICallFrame,
            pIID: ?*Guid,
            piMethod: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: fn(
            self: *const ICallFrame,
            pwszInterface: ?*?PWSTR,
            pwszMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackLocation: fn(
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        SetStackLocation: fn(
            self: *const ICallFrame,
            pvStack: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetReturnValue: fn(
            self: *const ICallFrame,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetReturnValue: fn(
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamInfo: fn(
            self: *const ICallFrame,
            iparam: u32,
            pInfo: ?*CALLFRAMEPARAMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ICallFrame,
            copyControl: CALLFRAME_COPY,
            pWalker: ?*ICallFrameWalker,
            ppFrame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: fn(
            self: *const ICallFrame,
            pframeArgsDest: ?*ICallFrame,
            pWalkerDestFree: ?*ICallFrameWalker,
            pWalkerCopy: ?*ICallFrameWalker,
            freeFlags: u32,
            pWalkerFree: ?*ICallFrameWalker,
            nullFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            freeFlags: u32,
            pWalkerFree: ?*ICallFrameWalker,
            nullFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WalkFrame: fn(
            self: *const ICallFrame,
            walkWhat: u32,
            pWalker: ?*ICallFrameWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarshalSizeMax: fn(
            self: *const ICallFrame,
            pmshlContext: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            pcbBufferNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Marshal: fn(
            self: *const ICallFrame,
            pmshlContext: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            pBuffer: [*]u8,
            cbBuffer: u32,
            pcbBufferUsed: ?*u32,
            pdataRep: ?*u32,
            prpcFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmarshal: fn(
            self: *const ICallFrame,
            pBuffer: [*]u8,
            cbBuffer: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcbUnmarshalled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: fn(
            self: *const ICallFrame,
            pBuffer: [*]u8,
            cbBuffer: u32,
            ibFirstRelease: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const ICallFrame,
            pvReceiver: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetInfo(self: *const T, pInfo: ?*CALLFRAMEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetInfo(@ptrCast(*const ICallFrame, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetIIDAndMethod(self: *const T, pIID: ?*Guid, piMethod: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetIIDAndMethod(@ptrCast(*const ICallFrame, self), pIID, piMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetNames(self: *const T, pwszInterface: ?*?PWSTR, pwszMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetNames(@ptrCast(*const ICallFrame, self), pwszInterface, pwszMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetStackLocation(self: *const T) callconv(.Inline) ?*c_void {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetStackLocation(@ptrCast(*const ICallFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetStackLocation(self: *const T, pvStack: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetStackLocation(@ptrCast(*const ICallFrame, self), pvStack);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetReturnValue(self: *const T, hr: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetReturnValue(@ptrCast(*const ICallFrame, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetReturnValue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetReturnValue(@ptrCast(*const ICallFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetParamInfo(self: *const T, iparam: u32, pInfo: ?*CALLFRAMEPARAMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetParamInfo(@ptrCast(*const ICallFrame, self), iparam, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetParam(self: *const T, iparam: u32, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetParam(@ptrCast(*const ICallFrame, self), iparam, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetParam(self: *const T, iparam: u32, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetParam(@ptrCast(*const ICallFrame, self), iparam, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Copy(self: *const T, copyControl: CALLFRAME_COPY, pWalker: ?*ICallFrameWalker, ppFrame: ?*?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Copy(@ptrCast(*const ICallFrame, self), copyControl, pWalker, ppFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Free(self: *const T, pframeArgsDest: ?*ICallFrame, pWalkerDestFree: ?*ICallFrameWalker, pWalkerCopy: ?*ICallFrameWalker, freeFlags: u32, pWalkerFree: ?*ICallFrameWalker, nullFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Free(@ptrCast(*const ICallFrame, self), pframeArgsDest, pWalkerDestFree, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_FreeParam(self: *const T, iparam: u32, freeFlags: u32, pWalkerFree: ?*ICallFrameWalker, nullFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).FreeParam(@ptrCast(*const ICallFrame, self), iparam, freeFlags, pWalkerFree, nullFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_WalkFrame(self: *const T, walkWhat: u32, pWalker: ?*ICallFrameWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).WalkFrame(@ptrCast(*const ICallFrame, self), walkWhat, pWalker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetMarshalSizeMax(self: *const T, pmshlContext: ?*CALLFRAME_MARSHALCONTEXT, mshlflags: MSHLFLAGS, pcbBufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetMarshalSizeMax(@ptrCast(*const ICallFrame, self), pmshlContext, mshlflags, pcbBufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Marshal(self: *const T, pmshlContext: ?*CALLFRAME_MARSHALCONTEXT, mshlflags: MSHLFLAGS, pBuffer: [*]u8, cbBuffer: u32, pcbBufferUsed: ?*u32, pdataRep: ?*u32, prpcFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Marshal(@ptrCast(*const ICallFrame, self), pmshlContext, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Unmarshal(self: *const T, pBuffer: [*]u8, cbBuffer: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT, pcbUnmarshalled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Unmarshal(@ptrCast(*const ICallFrame, self), pBuffer, cbBuffer, dataRep, pcontext, pcbUnmarshalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_ReleaseMarshalData(self: *const T, pBuffer: [*]u8, cbBuffer: u32, ibFirstRelease: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).ReleaseMarshalData(@ptrCast(*const ICallFrame, self), pBuffer, cbBuffer, ibFirstRelease, dataRep, pcontext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Invoke(self: *const T, pvReceiver: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Invoke(@ptrCast(*const ICallFrame, self), pvReceiver);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallIndirect_Value = @import("../zig.zig").Guid.initString("d573b4b1-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallIndirect = &IID_ICallIndirect_Value;
pub const ICallIndirect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallIndirect: fn(
            self: *const ICallIndirect,
            phrReturn: ?*HRESULT,
            iMethod: u32,
            pvArgs: ?*c_void,
            cbArgs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMethodInfo: fn(
            self: *const ICallIndirect,
            iMethod: u32,
            pInfo: ?*CALLFRAMEINFO,
            pwszMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackSize: fn(
            self: *const ICallIndirect,
            iMethod: u32,
            cbArgs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: fn(
            self: *const ICallIndirect,
            piid: ?*Guid,
            pfDerivesFromIDispatch: ?*BOOL,
            pcMethod: ?*u32,
            pwszInterface: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_CallIndirect(self: *const T, phrReturn: ?*HRESULT, iMethod: u32, pvArgs: ?*c_void, cbArgs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).CallIndirect(@ptrCast(*const ICallIndirect, self), phrReturn, iMethod, pvArgs, cbArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetMethodInfo(self: *const T, iMethod: u32, pInfo: ?*CALLFRAMEINFO, pwszMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetMethodInfo(@ptrCast(*const ICallIndirect, self), iMethod, pInfo, pwszMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetStackSize(self: *const T, iMethod: u32, cbArgs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetStackSize(@ptrCast(*const ICallIndirect, self), iMethod, cbArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetIID(self: *const T, piid: ?*Guid, pfDerivesFromIDispatch: ?*BOOL, pcMethod: ?*u32, pwszInterface: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetIID(@ptrCast(*const ICallIndirect, self), piid, pfDerivesFromIDispatch, pcMethod, pwszInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallInterceptor_Value = @import("../zig.zig").Guid.initString("60c7ca75-896d-11d2-b8b6-00c04fb9618a");
pub const IID_ICallInterceptor = &IID_ICallInterceptor_Value;
pub const ICallInterceptor = extern struct {
    pub const VTable = extern struct {
        base: ICallIndirect.VTable,
        RegisterSink: fn(
            self: *const ICallInterceptor,
            psink: ?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisteredSink: fn(
            self: *const ICallInterceptor,
            ppsink: ?*?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICallIndirect.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallInterceptor_RegisterSink(self: *const T, psink: ?*ICallFrameEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallInterceptor.VTable, self.vtable).RegisterSink(@ptrCast(*const ICallInterceptor, self), psink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallInterceptor_GetRegisteredSink(self: *const T, ppsink: ?*?*ICallFrameEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallInterceptor.VTable, self.vtable).GetRegisteredSink(@ptrCast(*const ICallInterceptor, self), ppsink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameEvents_Value = @import("../zig.zig").Guid.initString("fd5e0843-fc91-11d0-97d7-00c04fb9618a");
pub const IID_ICallFrameEvents = &IID_ICallFrameEvents_Value;
pub const ICallFrameEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCall: fn(
            self: *const ICallFrameEvents,
            pFrame: ?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrameEvents_OnCall(self: *const T, pFrame: ?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrameEvents.VTable, self.vtable).OnCall(@ptrCast(*const ICallFrameEvents, self), pFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallUnmarshal_Value = @import("../zig.zig").Guid.initString("5333b003-2e42-11d2-b89d-00c04fb9618a");
pub const IID_ICallUnmarshal = &IID_ICallUnmarshal_Value;
pub const ICallUnmarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unmarshal: fn(
            self: *const ICallUnmarshal,
            iMethod: u32,
            pBuffer: [*]u8,
            cbBuffer: u32,
            fForceBufferCopy: BOOL,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcbUnmarshalled: ?*u32,
            ppFrame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: fn(
            self: *const ICallUnmarshal,
            iMethod: u32,
            pBuffer: [*]u8,
            cbBuffer: u32,
            ibFirstRelease: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallUnmarshal_Unmarshal(self: *const T, iMethod: u32, pBuffer: [*]u8, cbBuffer: u32, fForceBufferCopy: BOOL, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT, pcbUnmarshalled: ?*u32, ppFrame: ?*?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallUnmarshal.VTable, self.vtable).Unmarshal(@ptrCast(*const ICallUnmarshal, self), iMethod, pBuffer, cbBuffer, fForceBufferCopy, dataRep, pcontext, pcbUnmarshalled, ppFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallUnmarshal_ReleaseMarshalData(self: *const T, iMethod: u32, pBuffer: [*]u8, cbBuffer: u32, ibFirstRelease: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallUnmarshal.VTable, self.vtable).ReleaseMarshalData(@ptrCast(*const ICallUnmarshal, self), iMethod, pBuffer, cbBuffer, ibFirstRelease, dataRep, pcontext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameWalker_Value = @import("../zig.zig").Guid.initString("08b23919-392d-11d2-b8a4-00c04fb9618a");
pub const IID_ICallFrameWalker = &IID_ICallFrameWalker_Value;
pub const ICallFrameWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWalkInterface: fn(
            self: *const ICallFrameWalker,
            iid: ?*const Guid,
            ppvInterface: ?*?*c_void,
            fIn: BOOL,
            fOut: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrameWalker_OnWalkInterface(self: *const T, iid: ?*const Guid, ppvInterface: ?*?*c_void, fIn: BOOL, fOut: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrameWalker.VTable, self.vtable).OnWalkInterface(@ptrCast(*const ICallFrameWalker, self), iid, ppvInterface, fIn, fOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInterfaceRelated_Value = @import("../zig.zig").Guid.initString("d1fb5a79-7706-11d1-adba-00c04fc2adc0");
pub const IID_IInterfaceRelated = &IID_IInterfaceRelated_Value;
pub const IInterfaceRelated = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIID: fn(
            self: *const IInterfaceRelated,
            iid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: fn(
            self: *const IInterfaceRelated,
            piid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInterfaceRelated_SetIID(self: *const T, iid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInterfaceRelated.VTable, self.vtable).SetIID(@ptrCast(*const IInterfaceRelated, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInterfaceRelated_GetIID(self: *const T, piid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInterfaceRelated.VTable, self.vtable).GetIID(@ptrCast(*const IInterfaceRelated, self), piid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMessageDispatcher_Value = @import("../zig.zig").Guid.initString("f5f84c8f-cfd0-4cd6-b66b-c5d26ff1689d");
pub const IID_IMessageDispatcher = &IID_IMessageDispatcher_Value;
pub const IMessageDispatcher = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        PumpMessages: fn(
            self: *const IMessageDispatcher,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageDispatcher_PumpMessages(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageDispatcher.VTable, self.vtable).PumpMessages(@ptrCast(*const IMessageDispatcher, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ComCallData = extern struct {
    dwDispid: u32,
    dwReserved: u32,
    pUserDefined: ?*c_void,
};

pub const PFNCONTEXTCALL = fn(
    pParam: ?*ComCallData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextCallback_Value = @import("../zig.zig").Guid.initString("000001da-0000-0000-c000-000000000046");
pub const IID_IContextCallback = &IID_IContextCallback_Value;
pub const IContextCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ContextCallback: fn(
            self: *const IContextCallback,
            pfnCallback: ?PFNCONTEXTCALL,
            pParam: ?*ComCallData,
            riid: ?*const Guid,
            iMethod: i32,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextCallback_ContextCallback(self: *const T, pfnCallback: ?PFNCONTEXTCALL, pParam: ?*ComCallData, riid: ?*const Guid, iMethod: i32, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextCallback.VTable, self.vtable).ContextCallback(@ptrCast(*const IContextCallback, self), pfnCallback, pParam, riid, iMethod, pUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEventPublisher_Value = @import("../zig.zig").Guid.initString("e341516b-2e32-11d1-9964-00c04fbbb345");
pub const IID_IEventPublisher = &IID_IEventPublisher_Value;
pub const IEventPublisher = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherID: fn(
            self: *const IEventPublisher,
            pbstrPublisherID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PublisherID: fn(
            self: *const IEventPublisher,
            bstrPublisherID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherName: fn(
            self: *const IEventPublisher,
            pbstrPublisherName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PublisherName: fn(
            self: *const IEventPublisher,
            bstrPublisherName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherType: fn(
            self: *const IEventPublisher,
            pbstrPublisherType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PublisherType: fn(
            self: *const IEventPublisher,
            bstrPublisherType: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OwnerSID: fn(
            self: *const IEventPublisher,
            pbstrOwnerSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OwnerSID: fn(
            self: *const IEventPublisher,
            bstrOwnerSID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IEventPublisher,
            pbstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IEventPublisher,
            bstrDescription: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultProperty: fn(
            self: *const IEventPublisher,
            bstrPropertyName: ?BSTR,
            propertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutDefaultProperty: fn(
            self: *const IEventPublisher,
            bstrPropertyName: ?BSTR,
            propertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDefaultProperty: fn(
            self: *const IEventPublisher,
            bstrPropertyName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultPropertyCollection: fn(
            self: *const IEventPublisher,
            collection: ?*?*IEventObjectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_get_PublisherID(self: *const T, pbstrPublisherID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).get_PublisherID(@ptrCast(*const IEventPublisher, self), pbstrPublisherID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_put_PublisherID(self: *const T, bstrPublisherID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).put_PublisherID(@ptrCast(*const IEventPublisher, self), bstrPublisherID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_get_PublisherName(self: *const T, pbstrPublisherName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).get_PublisherName(@ptrCast(*const IEventPublisher, self), pbstrPublisherName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_put_PublisherName(self: *const T, bstrPublisherName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).put_PublisherName(@ptrCast(*const IEventPublisher, self), bstrPublisherName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_get_PublisherType(self: *const T, pbstrPublisherType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).get_PublisherType(@ptrCast(*const IEventPublisher, self), pbstrPublisherType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_put_PublisherType(self: *const T, bstrPublisherType: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).put_PublisherType(@ptrCast(*const IEventPublisher, self), bstrPublisherType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_get_OwnerSID(self: *const T, pbstrOwnerSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).get_OwnerSID(@ptrCast(*const IEventPublisher, self), pbstrOwnerSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_put_OwnerSID(self: *const T, bstrOwnerSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).put_OwnerSID(@ptrCast(*const IEventPublisher, self), bstrOwnerSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_get_Description(self: *const T, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).get_Description(@ptrCast(*const IEventPublisher, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_put_Description(self: *const T, bstrDescription: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).put_Description(@ptrCast(*const IEventPublisher, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_GetDefaultProperty(self: *const T, bstrPropertyName: ?BSTR, propertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).GetDefaultProperty(@ptrCast(*const IEventPublisher, self), bstrPropertyName, propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_PutDefaultProperty(self: *const T, bstrPropertyName: ?BSTR, propertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).PutDefaultProperty(@ptrCast(*const IEventPublisher, self), bstrPropertyName, propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_RemoveDefaultProperty(self: *const T, bstrPropertyName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).RemoveDefaultProperty(@ptrCast(*const IEventPublisher, self), bstrPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventPublisher_GetDefaultPropertyCollection(self: *const T, collection: ?*?*IEventObjectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventPublisher.VTable, self.vtable).GetDefaultPropertyCollection(@ptrCast(*const IEventPublisher, self), collection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EOC_ChangeType = enum(i32) {
    NewObject = 0,
    ModifiedObject = 1,
    DeletedObject = 2,
};
pub const EOC_NewObject = EOC_ChangeType.NewObject;
pub const EOC_ModifiedObject = EOC_ChangeType.ModifiedObject;
pub const EOC_DeletedObject = EOC_ChangeType.DeletedObject;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEventProperty_Value = @import("../zig.zig").Guid.initString("da538ee2-f4de-11d1-b6bb-00805fc79216");
pub const IID_IEventProperty = &IID_IEventProperty_Value;
pub const IEventProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IEventProperty,
            propertyName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IEventProperty,
            propertyName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IEventProperty,
            propertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IEventProperty,
            propertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventProperty_get_Name(self: *const T, propertyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventProperty.VTable, self.vtable).get_Name(@ptrCast(*const IEventProperty, self), propertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventProperty_put_Name(self: *const T, propertyName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventProperty.VTable, self.vtable).put_Name(@ptrCast(*const IEventProperty, self), propertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventProperty_get_Value(self: *const T, propertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventProperty.VTable, self.vtable).get_Value(@ptrCast(*const IEventProperty, self), propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventProperty_put_Value(self: *const T, propertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventProperty.VTable, self.vtable).put_Value(@ptrCast(*const IEventProperty, self), propertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibilityDockingServiceCallback_Value = @import("../zig.zig").Guid.initString("157733fd-a592-42e5-b594-248468c5a81b");
pub const IID_IAccessibilityDockingServiceCallback = &IID_IAccessibilityDockingServiceCallback_Value;
pub const IAccessibilityDockingServiceCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Undocked: fn(
            self: *const IAccessibilityDockingServiceCallback,
            undockReason: UNDOCK_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingServiceCallback_Undocked(self: *const T, undockReason: UNDOCK_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingServiceCallback.VTable, self.vtable).Undocked(@ptrCast(*const IAccessibilityDockingServiceCallback, self), undockReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibilityDockingService_Value = @import("../zig.zig").Guid.initString("8849dc22-cedf-4c95-998d-051419dd3f76");
pub const IID_IAccessibilityDockingService = &IID_IAccessibilityDockingService_Value;
pub const IAccessibilityDockingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableSize: fn(
            self: *const IAccessibilityDockingService,
            hMonitor: ?HMONITOR,
            pcxFixed: ?*u32,
            pcyMax: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DockWindow: fn(
            self: *const IAccessibilityDockingService,
            hwnd: ?HWND,
            hMonitor: ?HMONITOR,
            cyRequested: u32,
            pCallback: ?*IAccessibilityDockingServiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UndockWindow: fn(
            self: *const IAccessibilityDockingService,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_GetAvailableSize(self: *const T, hMonitor: ?HMONITOR, pcxFixed: ?*u32, pcyMax: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).GetAvailableSize(@ptrCast(*const IAccessibilityDockingService, self), hMonitor, pcxFixed, pcyMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_DockWindow(self: *const T, hwnd: ?HWND, hMonitor: ?HMONITOR, cyRequested: u32, pCallback: ?*IAccessibilityDockingServiceCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).DockWindow(@ptrCast(*const IAccessibilityDockingService, self), hwnd, hMonitor, cyRequested, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_UndockWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).UndockWindow(@ptrCast(*const IAccessibilityDockingService, self), hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COINIT = enum(u32) {
    APARTMENTTHREADED = 2,
    MULTITHREADED = 0,
    DISABLE_OLE1DDE = 4,
    SPEED_OVER_MEMORY = 8,
    _,
    pub fn initFlags(o: struct {
        APARTMENTTHREADED: u1 = 0,
        MULTITHREADED: u1 = 0,
        DISABLE_OLE1DDE: u1 = 0,
        SPEED_OVER_MEMORY: u1 = 0,
    }) COINIT {
        return @intToEnum(COINIT,
              (if (o.APARTMENTTHREADED == 1) @enumToInt(COINIT.APARTMENTTHREADED) else 0)
            | (if (o.MULTITHREADED == 1) @enumToInt(COINIT.MULTITHREADED) else 0)
            | (if (o.DISABLE_OLE1DDE == 1) @enumToInt(COINIT.DISABLE_OLE1DDE) else 0)
            | (if (o.SPEED_OVER_MEMORY == 1) @enumToInt(COINIT.SPEED_OVER_MEMORY) else 0)
        );
    }
};
pub const COINIT_APARTMENTTHREADED = COINIT.APARTMENTTHREADED;
pub const COINIT_MULTITHREADED = COINIT.MULTITHREADED;
pub const COINIT_DISABLE_OLE1DDE = COINIT.DISABLE_OLE1DDE;
pub const COINIT_SPEED_OVER_MEMORY = COINIT.SPEED_OVER_MEMORY;

pub const COMSD = enum(i32) {
    LAUNCHPERMISSIONS = 0,
    ACCESSPERMISSIONS = 1,
    LAUNCHRESTRICTIONS = 2,
    ACCESSRESTRICTIONS = 3,
};
pub const SD_LAUNCHPERMISSIONS = COMSD.LAUNCHPERMISSIONS;
pub const SD_ACCESSPERMISSIONS = COMSD.ACCESSPERMISSIONS;
pub const SD_LAUNCHRESTRICTIONS = COMSD.LAUNCHRESTRICTIONS;
pub const SD_ACCESSRESTRICTIONS = COMSD.ACCESSRESTRICTIONS;


//--------------------------------------------------------------------------------
// Section: Functions (359)
//--------------------------------------------------------------------------------
pub extern "OLE32" fn CLIPFORMAT_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn CLIPFORMAT_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn CLIPFORMAT_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn CLIPFORMAT_UserFree(
    param0: ?*u32,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HBITMAP_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HBITMAP_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HBITMAP_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HBITMAP_UserFree(
    param0: ?*u32,
    param1: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HDC_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HDC_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HDC_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HDC_UserFree(
    param0: ?*u32,
    param1: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HICON_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HICON_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HICON_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HICON_UserFree(
    param0: ?*u32,
    param1: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn SNB_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn SNB_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn SNB_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn SNB_UserFree(
    param0: ?*u32,
    param1: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn CLIPFORMAT_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn CLIPFORMAT_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn CLIPFORMAT_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn CLIPFORMAT_UserFree64(
    param0: ?*u32,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HBITMAP_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HBITMAP_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HBITMAP_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HBITMAP_UserFree64(
    param0: ?*u32,
    param1: ?*?HBITMAP,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HDC_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HDC_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HDC_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HDC_UserFree64(
    param0: ?*u32,
    param1: ?*?HDC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HICON_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HICON_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HICON_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HICON_UserFree64(
    param0: ?*u32,
    param1: ?*?HICON,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn SNB_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn SNB_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn SNB_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn SNB_UserFree64(
    param0: ?*u32,
    param1: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HACCEL_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HACCEL_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HACCEL_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HACCEL_UserFree(
    param0: ?*u32,
    param1: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HGLOBAL_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HGLOBAL_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HGLOBAL_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HGLOBAL_UserFree(
    param0: ?*u32,
    param1: ?*isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HMENU_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HMENU_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMENU_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMENU_UserFree(
    param0: ?*u32,
    param1: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HACCEL_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HACCEL_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HACCEL_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HACCEL_UserFree64(
    param0: ?*u32,
    param1: ?*?HACCEL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HGLOBAL_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HGLOBAL_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HGLOBAL_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*isize,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HGLOBAL_UserFree64(
    param0: ?*u32,
    param1: ?*isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HMENU_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HMENU_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMENU_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMENU_UserFree64(
    param0: ?*u32,
    param1: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "urlmon" fn CreateURLMoniker(
    pMkCtx: ?*IMoniker,
    szURL: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateURLMonikerEx(
    pMkCtx: ?*IMoniker,
    szURL: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetClassURL(
    szURL: ?[*:0]const u16,
    pClsID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "urlmon" fn CreateAsyncBindCtx(
    reserved: u32,
    pBSCb: ?*IBindStatusCallback,
    pEFetc: ?*IEnumFORMATETC,
    ppBC: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateURLMonikerEx2(
    pMkCtx: ?*IMoniker,
    pUri: ?*IUri,
    ppmk: ?*?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateAsyncBindCtxEx(
    pbc: ?*IBindCtx,
    dwOptions: u32,
    pBSCb: ?*IBindStatusCallback,
    pEnum: ?*IEnumFORMATETC,
    ppBC: ?*?*IBindCtx,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn MkParseDisplayNameEx(
    pbc: ?*IBindCtx,
    szDisplayName: ?[*:0]const u16,
    pchEaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterBindStatusCallback(
    pBC: ?*IBindCtx,
    pBSCb: ?*IBindStatusCallback,
    ppBSCBPrev: ?*?*IBindStatusCallback,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RevokeBindStatusCallback(
    pBC: ?*IBindCtx,
    pBSCb: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetClassFileOrMime(
    pBC: ?*IBindCtx,
    szFilename: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    cbSize: u32,
    szMime: ?[*:0]const u16,
    dwReserved: u32,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsValidURL(
    pBC: ?*IBindCtx,
    szURL: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoGetClassObjectFromURL(
    rCLASSID: ?*const Guid,
    szCODE: ?[*:0]const u16,
    dwFileVersionMS: u32,
    dwFileVersionLS: u32,
    szTYPE: ?[*:0]const u16,
    pBindCtx: ?*IBindCtx,
    dwClsContext: CLSCTX,
    pvReserved: ?*c_void,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IEInstallScope(
    pdwScope: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FaultInIEFeature(
    hWnd: ?HWND,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetComponentIDFromCLSSPEC(
    pClassspec: ?*uCLSSPEC,
    ppszComponentID: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsAsyncMoniker(
    pmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterMediaTypes(
    ctypes: u32,
    rgszTypes: [*]const ?[*:0]const u8,
    rgcfTypes: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMediaType(
    rgszTypes: ?[*:0]const u8,
    rgcfTypes: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "urlmon" fn CreateFormatEnumerator(
    cfmtetc: u32,
    rgfmtetc: [*]FORMATETC,
    ppenumfmtetc: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterFormatEnumerator(
    pBC: ?*IBindCtx,
    pEFetc: ?*IEnumFORMATETC,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RevokeFormatEnumerator(
    pBC: ?*IBindCtx,
    pEFetc: ?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterMediaTypeClass(
    pBC: ?*IBindCtx,
    ctypes: u32,
    rgszTypes: [*]const ?[*:0]const u8,
    rgclsID: [*]Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMediaTypeClass(
    pBC: ?*IBindCtx,
    szType: ?[*:0]const u8,
    pclsID: ?*Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn UrlMkSetSessionOption(
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 2?
    pBuffer: ?*c_void,
    dwBufferLength: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn UrlMkGetSessionOption(
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 2?
    pBuffer: ?*c_void,
    dwBufferLength: u32,
    pdwBufferLengthOut: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMimeFromData(
    pBC: ?*IBindCtx,
    pwzUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    cbSize: u32,
    pwzMimeProposed: ?[*:0]const u16,
    dwMimeFlags: u32,
    ppwzMimeOut: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn ObtainUserAgentString(
    dwOption: u32,
    pszUAOut: [*:0]u8,
    cbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CompareSecurityIds(
    pbSecurityId1: [*:0]u8,
    dwLen1: u32,
    pbSecurityId2: [*:0]u8,
    dwLen2: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CompatFlagsFromClsid(
    pclsid: ?*Guid,
    pdwCompatFlags: ?*u32,
    pdwMiscStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn SetAccessForIEAppContainer(
    hObject: ?HANDLE,
    ieObjectType: IEObjectType,
    dwAccessMask: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateUri(
    pwzURI: ?[*:0]const u16,
    dwFlags: URI_CREATE_FLAGS,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateUriWithFragment(
    pwzURI: ?[*:0]const u16,
    pwzFragment: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriFromMultiByteString(
    pszANSIInputUri: ?[*:0]const u8,
    dwEncodingFlags: u32,
    dwCodePage: u32,
    dwCreateFlags: u32,
    dwReserved: usize,
    ppUri: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateIUriBuilder(
    pIUri: ?*IUri,
    dwFlags: u32,
    dwReserved: usize,
    ppIUriBuilder: ?*?*IUriBuilder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkSimpleNavigateToString(
    szTarget: ?[*:0]const u16,
    szLocation: ?[*:0]const u16,
    szTargetFrameName: ?[*:0]const u16,
    pUnk: ?*IUnknown,
    pbc: ?*IBindCtx,
    param5: ?*IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkSimpleNavigateToMoniker(
    pmkTarget: ?*IMoniker,
    szLocation: ?[*:0]const u16,
    szTargetFrameName: ?[*:0]const u16,
    pUnk: ?*IUnknown,
    pbc: ?*IBindCtx,
    param5: ?*IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenPullStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenPullStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToFileA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToFileW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToCacheFileA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: [*:0]u8,
    cchFileName: u32,
    param4: u32,
    param5: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToCacheFileW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: [*:0]u16,
    cchFileName: u32,
    param4: u32,
    param5: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenBlockingStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: ?*?*IStream,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenBlockingStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: ?*?*IStream,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkGoBack(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkGoForward(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkNavigateString(
    pUnk: ?*IUnknown,
    szTarget: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkNavigateMoniker(
    pUnk: ?*IUnknown,
    pmkTarget: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetParseUrl(
    pwzUrl: ?[*:0]const u16,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pszResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetParseIUri(
    pIUri: ?*IUri,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pwzResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineUrl(
    pwzBaseUrl: ?[*:0]const u16,
    pwzRelativeUrl: ?[*:0]const u16,
    dwCombineFlags: u32,
    pszResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineUrlEx(
    pBaseUri: ?*IUri,
    pwzRelativeUrl: ?[*:0]const u16,
    dwCombineFlags: u32,
    ppCombinedUri: ?*?*IUri,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineIUri(
    pBaseUri: ?*IUri,
    pRelativeUri: ?*IUri,
    dwCombineFlags: u32,
    ppCombinedUri: ?*?*IUri,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCompareUrl(
    pwzUrl1: ?[*:0]const u16,
    pwzUrl2: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetProtocolFlags(
    pwzUrl: ?[*:0]const u16,
    pdwFlags: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetQueryInfo(
    pwzUrl: ?[*:0]const u16,
    QueryOptions: QUERYOPTION,
    dwQueryFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvBuffer: ?*c_void,
    cbBuffer: u32,
    pcbBuffer: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSession(
    dwSessionMode: u32,
    ppIInternetSession: ?*?*IInternetSession,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSecurityUrl(
    pwszUrl: ?[*:0]const u16,
    ppwszSecUrl: ?*?PWSTR,
    psuAction: PSUACTION,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSecurityUrlEx(
    pUri: ?*IUri,
    ppSecUri: ?*?*IUri,
    psuAction: PSUACTION,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetSetFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabledForUrl(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    szURL: ?[*:0]const u16,
    pSecMgr: ?*IInternetSecurityManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabledForIUri(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    pIUri: ?*IUri,
    pSecMgr: ?*IInternetSecurityManagerEx2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureZoneElevationEnabled(
    szFromURL: ?[*:0]const u16,
    szToURL: ?[*:0]const u16,
    pSecMgr: ?*IInternetSecurityManager,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CopyStgMedium(
    pcstgmedSrc: ?*const STGMEDIUM,
    pstgmedDest: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CopyBindInfo(
    pcbiSrc: ?*const BINDINFO,
    pbiDest: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn ReleaseBindInfo(
    pbindinfo: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "urlmon" fn IEGetUserPrivateNamespaceName(
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "urlmon" fn CoInternetCreateSecurityManager(
    pSP: ?*IServiceProvider,
    ppSM: ?*?*IInternetSecurityManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCreateZoneManager(
    pSP: ?*IServiceProvider,
    ppZM: ?*?*IInternetZoneManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetSoftwareUpdateInfo(
    szDistUnit: ?[*:0]const u16,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn SetSoftwareUpdateAdvertisementState(
    szDistUnit: ?[*:0]const u16,
    dwAdState: u32,
    dwAdvertisedVersionMS: u32,
    dwAdvertisedVersionLS: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsLoggingEnabledA(
    pszUrl: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "urlmon" fn IsLoggingEnabledW(
    pwszUrl: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "urlmon" fn WriteHitLogging(
    lpLogginginfo: ?*HIT_LOGGING_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateDataAdviseHolder(
    ppDAHolder: ?*?*IDataAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn OleBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleInitialize(
    pvReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleQueryLinkFromData(
    pSrcDataObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleQueryCreateFromData(
    pSrcDataObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreate(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateEx(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateFromData(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromDataEx(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateLinkFromData(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkFromDataEx(
    pSrcDataObj: ?*IDataObject,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateStaticFromData(
    pSrcDataObj: ?*IDataObject,
    iid: ?*const Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLink(
    pmkLinkSrc: ?*IMoniker,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkEx(
    pmkLinkSrc: ?*IMoniker,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateLinkToFile(
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateLinkToFileEx(
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateFromFile(
    rclsid: ?*const Guid,
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateFromFileEx(
    rclsid: ?*const Guid,
    lpszFileName: ?[*:0]const u16,
    riid: ?*const Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: ?*IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: ?*IOleClientSite,
    pStg: ?*IStorage,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleLoad(
    pStg: ?*IStorage,
    riid: ?*const Guid,
    pClientSite: ?*IOleClientSite,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleSave(
    pPS: ?*IPersistStorage,
    pStg: ?*IStorage,
    fSameAsLoad: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleLoadFromStream(
    pStm: ?*IStream,
    iidInterface: ?*const Guid,
    ppvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleSaveToStream(
    pPStm: ?*IPersistStream,
    pStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleSetContainedObject(
    pUnknown: ?*IUnknown,
    fContained: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleNoteObjectVisible(
    pUnknown: ?*IUnknown,
    fVisible: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn RegisterDragDrop(
    hwnd: ?HWND,
    pDropTarget: ?*IDropTarget,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn RevokeDragDrop(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn DoDragDrop(
    pDataObj: ?*IDataObject,
    pDropSource: ?*IDropSource,
    dwOKEffects: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleSetClipboard(
    pDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleGetClipboard(
    ppDataObj: ?*?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ole32" fn OleGetClipboardWithEnterpriseInfo(
    dataObject: ?*?*IDataObject,
    dataEnterpriseId: ?*?PWSTR,
    sourceDescription: ?*?PWSTR,
    targetDescription: ?*?PWSTR,
    dataDescription: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleFlushClipboard(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleIsCurrentClipboard(
    pDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateMenuDescriptor(
    hmenuCombined: ?HMENU,
    lpMenuWidths: ?*OleMenuGroupWidths,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleSetMenuDescriptor(
    holemenu: isize,
    hwndFrame: ?HWND,
    hwndActiveObject: ?HWND,
    lpFrame: ?*IOleInPlaceFrame,
    lpActiveObj: ?*IOleInPlaceActiveObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleDestroyMenuDescriptor(
    holemenu: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleTranslateAccelerator(
    lpFrame: ?*IOleInPlaceFrame,
    lpFrameInfo: ?*OIFI,
    lpmsg: ?*MSG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleDuplicateData(
    hSrc: ?HANDLE,
    cfFormat: u16,
    uiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleDraw(
    pUnknown: ?*IUnknown,
    dwAspect: u32,
    hdcDraw: ?HDC,
    lprcBounds: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleRun(
    pUnknown: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleIsRunning(
    pObject: ?*IOleObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleLockRunning(
    pUnknown: ?*IUnknown,
    fLock: BOOL,
    fLastUnlockCloses: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ReleaseStgMedium(
    param0: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateOleAdviseHolder(
    ppOAHolder: ?*?*IOleAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleCreateDefaultHandler(
    clsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    riid: ?*const Guid,
    lplpObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleCreateEmbeddingHelper(
    clsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    flags: u32,
    pCF: ?*IClassFactory,
    riid: ?*const Guid,
    lplpObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn IsAccelerator(
    hAccel: ?HACCEL,
    cAccelEntries: i32,
    lpMsg: ?*MSG,
    lpwCmd: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleGetIconOfFile(
    lpszPath: ?PWSTR,
    fUseFileAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleGetIconOfClass(
    rclsid: ?*const Guid,
    lpszLabel: ?PWSTR,
    fUseTypeAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleMetafilePictFromIconAndLabel(
    hIcon: ?HICON,
    lpszLabel: ?PWSTR,
    lpszSourceFile: ?PWSTR,
    iIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleRegGetUserType(
    clsid: ?*const Guid,
    dwFormOfType: u32,
    pszUserType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleRegGetMiscStatus(
    clsid: ?*const Guid,
    dwAspect: u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleRegEnumFormatEtc(
    clsid: ?*const Guid,
    dwDirection: u32,
    ppenum: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleRegEnumVerbs(
    clsid: ?*const Guid,
    ppenum: ?*?*IEnumOLEVERB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleDoAutoConvert(
    pStg: ?*IStorage,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn OleGetAutoConvert(
    clsidOld: ?*const Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleSetAutoConvert(
    clsidOld: ?*const Guid,
    clsidNew: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetMalloc(
    dwMemContext: u32,
    ppMalloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitializeEx(
    pvReserved: ?*c_void,
    dwCoInit: COINIT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCallerTID(
    lpdwTID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCurrentLogicalThreadId(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetContextToken(
    pToken: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "OLE32" fn CoGetApartmentType(
    pAptType: ?*APTTYPE,
    pAptQualifier: ?*APTTYPEQUALIFIER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoIncrementMTAUsage(
    pCookie: ?*CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoDecrementMTAUsage(
    Cookie: CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "OLE32" fn CoAllowUnmarshalerCLSID(
    clsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetObjectContext(
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetClassObject(
    rclsid: ?*const Guid,
    dwClsContext: CLSCTX,
    pvReserved: ?*c_void,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterClassObject(
    rclsid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwClsContext: CLSCTX,
    flags: u32,
    lpdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeClassObject(
    dwRegister: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoResumeClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSuspendClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoAddRefServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoReleaseServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetPSClsid(
    riid: ?*const Guid,
    pClsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterPSClsid(
    riid: ?*const Guid,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterSurrogate(
    pSurrogate: ?*ISurrogate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetMarshalSizeMax(
    pulSize: ?*u32,
    riid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*c_void,
    mshlflags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoMarshalInterface(
    pStm: ?*IStream,
    riid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*c_void,
    mshlflags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoUnmarshalInterface(
    pStm: ?*IStream,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoMarshalHresult(
    pstm: ?*IStream,
    hresult: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoUnmarshalHresult(
    pstm: ?*IStream,
    phresult: ?*HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoReleaseMarshalData(
    pStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDisconnectObject(
    pUnk: ?*IUnknown,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoLockObjectExternal(
    pUnk: ?*IUnknown,
    fLock: BOOL,
    fLastUnlockReleases: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetStandardMarshal(
    riid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*c_void,
    mshlflags: u32,
    ppMarshal: ?*?*IMarshal,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetStdMarshalEx(
    pUnkOuter: ?*IUnknown,
    smexflags: u32,
    ppUnkInner: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoIsHandlerConnected(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoMarshalInterThreadInterfaceInStream(
    riid: ?*const Guid,
    pUnk: ?*IUnknown,
    ppStm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetInterfaceAndReleaseStream(
    pStm: ?*IStream,
    iid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateFreeThreadedMarshaler(
    punkOuter: ?*IUnknown,
    ppunkMarshal: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeUnusedLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoFreeUnusedLibrariesEx(
    dwUnloadDelay: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "OLE32" fn CoDisconnectContext(
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitializeSecurity(
    pSecDesc: ?*SECURITY_DESCRIPTOR,
    cAuthSvc: i32,
    asAuthSvc: ?[*]SOLE_AUTHENTICATION_SERVICE,
    pReserved1: ?*c_void,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthList: ?*c_void,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
    pReserved3: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCallContext(
    riid: ?*const Guid,
    ppInterface: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryProxyBlanket(
    pProxy: ?*IUnknown,
    pwAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pAuthInfo: ?*?*c_void,
    pCapabilites: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSetProxyBlanket(
    pProxy: ?*IUnknown,
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pServerPrincName: ?PWSTR,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthInfo: ?*c_void,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCopyProxy(
    pProxy: ?*IUnknown,
    ppCopy: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryClientBlanket(
    pAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pPrivs: ?*?*c_void,
    pCapabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoImpersonateClient(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevertToSelf(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryAuthenticationServices(
    pcAuthSvc: ?*u32,
    asAuthSvc: ?*?*SOLE_AUTHENTICATION_SERVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSwitchCallContext(
    pNewObject: ?*IUnknown,
    ppOldObject: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateInstance(
    rclsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    dwClsContext: CLSCTX,
    riid: *const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateInstanceEx(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pServerInfo: ?*COSERVERINFO,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "OLE32" fn CoCreateInstanceFromApp(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    reserved: ?*c_void,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoRegisterActivationFilter(
    pActivationFilter: ?*IActivationFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCancelObject(
    dwThreadId: u32,
    iid: ?*const Guid,
    ppUnk: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSetCancelObject(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCancelCall(
    dwThreadId: u32,
    ulTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTestCancel(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoEnableCallCancellation(
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDisableCallCancellation(
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromCLSID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromString(
    lpsz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromIID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn IIDFromString(
    lpsz: ?[*:0]const u16,
    lpiid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ProgIDFromCLSID(
    clsid: ?*const Guid,
    lplpszProgID: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromProgID(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromGUID2(
    rguid: ?*const Guid,
    lpsz: [*:0]u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateGuid(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoWaitForMultipleHandles(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoWaitForMultipleObjects(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]const ?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetTreatAsClass(
    clsidOld: ?*const Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoInvalidateRemoteMachineBindings(
    pszMachineName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemRealloc(
    pv: ?*c_void,
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemFree(
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFileTimeNow(
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromProgIDEx(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoRegisterDeviceCatalog(
    deviceInstanceId: ?[*:0]const u16,
    cookie: ?*CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoRevokeDeviceCatalog(
    cookie: CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn HPALETTE_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HPALETTE_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HPALETTE_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HPALETTE_UserFree(
    param0: ?*u32,
    param1: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HRGN_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HRGN_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HRGN_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HRGN_UserFree(
    param0: ?*u32,
    param1: ?*?HRGN,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HPALETTE_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HPALETTE_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HPALETTE_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HPALETTE_UserFree64(
    param0: ?*u32,
    param1: ?*?HPALETTE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleCreatePropertyFrame(
    hwndOwner: ?HWND,
    x: u32,
    y: u32,
    lpszCaption: ?[*:0]const u16,
    cObjects: u32,
    ppUnk: ?*?*IUnknown,
    cPages: u32,
    pPageClsID: ?*Guid,
    lcid: u32,
    dwReserved: u32,
    pvReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleCreatePropertyFrameIndirect(
    lpParams: ?*OCPFIPARAMS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleTranslateColor(
    clr: u32,
    hpal: ?HPALETTE,
    lpcolorref: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleCreateFontIndirect(
    lpFontDesc: ?*FONTDESC,
    riid: ?*const Guid,
    lplpvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleCreatePictureIndirect(
    lpPictDesc: ?*PICTDESC,
    riid: ?*const Guid,
    fOwn: BOOL,
    lplpvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleLoadPicture(
    lpstream: ?*IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*const Guid,
    lplpvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleLoadPictureEx(
    lpstream: ?*IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*const Guid,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpvObj: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleLoadPicturePath(
    szURLorPath: ?PWSTR,
    punkCaller: ?*IUnknown,
    dwReserved: u32,
    clrReserved: u32,
    riid: ?*const Guid,
    ppvRet: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLEAUT32" fn OleIconToCursor(
    hinstExe: ?HINSTANCE,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) ?HCURSOR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIAddVerbMenuW(
    lpOleObj: ?*IOleObject,
    lpszShortType: ?[*:0]const u16,
    hMenu: ?HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIAddVerbMenuA(
    lpOleObj: ?*IOleObject,
    lpszShortType: ?[*:0]const u8,
    hMenu: ?HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*?HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIInsertObjectW(
    param0: ?*OLEUIINSERTOBJECTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIInsertObjectA(
    param0: ?*OLEUIINSERTOBJECTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPasteSpecialW(
    param0: ?*OLEUIPASTESPECIALW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPasteSpecialA(
    param0: ?*OLEUIPASTESPECIALA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIEditLinksW(
    param0: ?*OLEUIEDITLINKSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIEditLinksA(
    param0: ?*OLEUIEDITLINKSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeIconW(
    param0: ?*OLEUICHANGEICONW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeIconA(
    param0: ?*OLEUICHANGEICONA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIConvertW(
    param0: ?*OLEUICONVERTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIConvertA(
    param0: ?*OLEUICONVERTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUICanConvertOrActivateAs(
    rClsid: ?*const Guid,
    fIsLinkedObject: BOOL,
    wFormat: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIBusyW(
    param0: ?*OLEUIBUSYW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIBusyA(
    param0: ?*OLEUIBUSYA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeSourceW(
    param0: ?*OLEUICHANGESOURCEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIChangeSourceA(
    param0: ?*OLEUICHANGESOURCEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIObjectPropertiesW(
    param0: ?*OLEUIOBJECTPROPSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIObjectPropertiesA(
    param0: ?*OLEUIOBJECTPROPSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPromptUserW(
    nTemplate: i32,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIPromptUserA(
    nTemplate: i32,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIUpdateLinksW(
    lpOleUILinkCntr: ?*IOleUILinkContainerW,
    hwndParent: ?HWND,
    lpszTitle: ?PWSTR,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oledlg" fn OleUIUpdateLinksA(
    lpOleUILinkCntr: ?*IOleUILinkContainerA,
    hwndParent: ?HWND,
    lpszTitle: ?PSTR,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterceptor(
    iidIntercepted: ?*const Guid,
    punkOuter: ?*IUnknown,
    iid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoGetInterceptorFromTypeInfo(
    iidIntercepted: ?*const Guid,
    punkOuter: ?*IUnknown,
    typeInfo: ?*ITypeInfo,
    iid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoSetMessageDispatcher(
    pMessageDispatcher: ?*IMessageDispatcher,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn CoHandlePriorityEventsFromMessagePump(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitialize(
    pvReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterMallocSpy(
    pMallocSpy: ?*IMallocSpy,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeMallocSpy(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoRegisterInitializeSpy(
    pSpy: ?*IInitializeSpy,
    puliCookie: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeInitializeSpy(
    uliCookie: ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetSystemSecurityPermissions(
    comSDType: COMSD,
    ppSD: ?*?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoLoadLibrary(
    lpszLibName: ?PWSTR,
    bAutoFree: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeLibrary(
    hInst: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeAllLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetInstanceFromFile(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    grfMode: u32,
    pwszName: ?PWSTR,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetInstanceFromIStorage(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pstg: ?*IStorage,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoAllowSetForegroundWindow(
    pUnk: ?*IUnknown,
    lpvReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsOle1Class(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFileTimeToDosDateTime(
    lpFileTime: ?*FILETIME,
    lpDosDate: ?*u16,
    lpDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDosDateTimeToFileTime(
    nDosDate: u16,
    nDosTime: u16,
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterMessageFilter(
    lpMessageFilter: ?*IMessageFilter,
    lplpMessageFilter: ?*?*IMessageFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRegisterChannelHook(
    ExtensionUuid: ?*const Guid,
    pChannelHook: ?*IChannelHook,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTreatAsClass(
    clsidOld: ?*const Guid,
    clsidNew: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateDataCache(
    pUnkOuter: ?*IUnknown,
    rclsid: ?*const Guid,
    iid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoInstall(
    pbc: ?*IBindCtx,
    dwFlags: u32,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    pszCodeBase: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn BindMoniker(
    pmk: ?*IMoniker,
    grfOpt: u32,
    iidResult: ?*const Guid,
    ppvResult: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetObject(
    pszName: ?[*:0]const u16,
    pBindOptions: ?*BIND_OPTS,
    riid: ?*const Guid,
    ppv: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn MkParseDisplayName(
    pbc: ?*IBindCtx,
    szUserName: ?[*:0]const u16,
    pchEaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerRelativePathTo(
    pmkSrc: ?*IMoniker,
    pmkDest: ?*IMoniker,
    ppmkRelPath: ?*?*IMoniker,
    dwReserved: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerCommonPrefixWith(
    pmkThis: ?*IMoniker,
    pmkOther: ?*IMoniker,
    ppmkCommon: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateBindCtx(
    reserved: u32,
    ppbc: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateGenericComposite(
    pmkFirst: ?*IMoniker,
    pmkRest: ?*IMoniker,
    ppmkComposite: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetClassFile(
    szFilename: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateClassMoniker(
    rclsid: ?*const Guid,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateFileMoniker(
    lpszPathName: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateItemMoniker(
    lpszDelim: ?[*:0]const u16,
    lpszItem: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateAntiMoniker(
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreatePointerMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateObjrefMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetRunningObjectTable(
    reserved: u32,
    pprot: ?*?*IRunningObjectTable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (32)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OLEUIINSERTOBJECT = thismodule.OLEUIINSERTOBJECTA;
        pub const OLEUIPASTEENTRY = thismodule.OLEUIPASTEENTRYA;
        pub const OLEUIPASTESPECIAL = thismodule.OLEUIPASTESPECIALA;
        pub const IOleUILinkContainer = thismodule.IOleUILinkContainerA;
        pub const OLEUIEDITLINKS = thismodule.OLEUIEDITLINKSA;
        pub const OLEUICHANGEICON = thismodule.OLEUICHANGEICONA;
        pub const OLEUICONVERT = thismodule.OLEUICONVERTA;
        pub const OLEUIBUSY = thismodule.OLEUIBUSYA;
        pub const OLEUICHANGESOURCE = thismodule.OLEUICHANGESOURCEA;
        pub const IOleUIObjInfo = thismodule.IOleUIObjInfoA;
        pub const IOleUILinkInfo = thismodule.IOleUILinkInfoA;
        pub const OLEUIGNRLPROPS = thismodule.OLEUIGNRLPROPSA;
        pub const OLEUIVIEWPROPS = thismodule.OLEUIVIEWPROPSA;
        pub const OLEUILINKPROPS = thismodule.OLEUILINKPROPSA;
        pub const OLEUIOBJECTPROPS = thismodule.OLEUIOBJECTPROPSA;
        pub const URLOpenStream = thismodule.URLOpenStreamA;
        pub const URLOpenPullStream = thismodule.URLOpenPullStreamA;
        pub const URLDownloadToFile = thismodule.URLDownloadToFileA;
        pub const URLDownloadToCacheFile = thismodule.URLDownloadToCacheFileA;
        pub const URLOpenBlockingStream = thismodule.URLOpenBlockingStreamA;
        pub const IsLoggingEnabled = thismodule.IsLoggingEnabledA;
        pub const OleUIAddVerbMenu = thismodule.OleUIAddVerbMenuA;
        pub const OleUIInsertObject = thismodule.OleUIInsertObjectA;
        pub const OleUIPasteSpecial = thismodule.OleUIPasteSpecialA;
        pub const OleUIEditLinks = thismodule.OleUIEditLinksA;
        pub const OleUIChangeIcon = thismodule.OleUIChangeIconA;
        pub const OleUIConvert = thismodule.OleUIConvertA;
        pub const OleUIBusy = thismodule.OleUIBusyA;
        pub const OleUIChangeSource = thismodule.OleUIChangeSourceA;
        pub const OleUIObjectProperties = thismodule.OleUIObjectPropertiesA;
        pub const OleUIPromptUser = thismodule.OleUIPromptUserA;
        pub const OleUIUpdateLinks = thismodule.OleUIUpdateLinksA;
    },
    .wide => struct {
        pub const OLEUIINSERTOBJECT = thismodule.OLEUIINSERTOBJECTW;
        pub const OLEUIPASTEENTRY = thismodule.OLEUIPASTEENTRYW;
        pub const OLEUIPASTESPECIAL = thismodule.OLEUIPASTESPECIALW;
        pub const IOleUILinkContainer = thismodule.IOleUILinkContainerW;
        pub const OLEUIEDITLINKS = thismodule.OLEUIEDITLINKSW;
        pub const OLEUICHANGEICON = thismodule.OLEUICHANGEICONW;
        pub const OLEUICONVERT = thismodule.OLEUICONVERTW;
        pub const OLEUIBUSY = thismodule.OLEUIBUSYW;
        pub const OLEUICHANGESOURCE = thismodule.OLEUICHANGESOURCEW;
        pub const IOleUIObjInfo = thismodule.IOleUIObjInfoW;
        pub const IOleUILinkInfo = thismodule.IOleUILinkInfoW;
        pub const OLEUIGNRLPROPS = thismodule.OLEUIGNRLPROPSW;
        pub const OLEUIVIEWPROPS = thismodule.OLEUIVIEWPROPSW;
        pub const OLEUILINKPROPS = thismodule.OLEUILINKPROPSW;
        pub const OLEUIOBJECTPROPS = thismodule.OLEUIOBJECTPROPSW;
        pub const URLOpenStream = thismodule.URLOpenStreamW;
        pub const URLOpenPullStream = thismodule.URLOpenPullStreamW;
        pub const URLDownloadToFile = thismodule.URLDownloadToFileW;
        pub const URLDownloadToCacheFile = thismodule.URLDownloadToCacheFileW;
        pub const URLOpenBlockingStream = thismodule.URLOpenBlockingStreamW;
        pub const IsLoggingEnabled = thismodule.IsLoggingEnabledW;
        pub const OleUIAddVerbMenu = thismodule.OleUIAddVerbMenuW;
        pub const OleUIInsertObject = thismodule.OleUIInsertObjectW;
        pub const OleUIPasteSpecial = thismodule.OleUIPasteSpecialW;
        pub const OleUIEditLinks = thismodule.OleUIEditLinksW;
        pub const OleUIChangeIcon = thismodule.OleUIChangeIconW;
        pub const OleUIConvert = thismodule.OleUIConvertW;
        pub const OleUIBusy = thismodule.OleUIBusyW;
        pub const OleUIChangeSource = thismodule.OleUIChangeSourceW;
        pub const OleUIObjectProperties = thismodule.OleUIObjectPropertiesW;
        pub const OleUIPromptUser = thismodule.OleUIPromptUserW;
        pub const OleUIUpdateLinks = thismodule.OleUIUpdateLinksW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OLEUIINSERTOBJECT = *opaque{};
        pub const OLEUIPASTEENTRY = *opaque{};
        pub const OLEUIPASTESPECIAL = *opaque{};
        pub const IOleUILinkContainer = *opaque{};
        pub const OLEUIEDITLINKS = *opaque{};
        pub const OLEUICHANGEICON = *opaque{};
        pub const OLEUICONVERT = *opaque{};
        pub const OLEUIBUSY = *opaque{};
        pub const OLEUICHANGESOURCE = *opaque{};
        pub const IOleUIObjInfo = *opaque{};
        pub const IOleUILinkInfo = *opaque{};
        pub const OLEUIGNRLPROPS = *opaque{};
        pub const OLEUIVIEWPROPS = *opaque{};
        pub const OLEUILINKPROPS = *opaque{};
        pub const OLEUIOBJECTPROPS = *opaque{};
        pub const URLOpenStream = *opaque{};
        pub const URLOpenPullStream = *opaque{};
        pub const URLDownloadToFile = *opaque{};
        pub const URLDownloadToCacheFile = *opaque{};
        pub const URLOpenBlockingStream = *opaque{};
        pub const IsLoggingEnabled = *opaque{};
        pub const OleUIAddVerbMenu = *opaque{};
        pub const OleUIInsertObject = *opaque{};
        pub const OleUIPasteSpecial = *opaque{};
        pub const OleUIEditLinks = *opaque{};
        pub const OleUIChangeIcon = *opaque{};
        pub const OleUIConvert = *opaque{};
        pub const OleUIBusy = *opaque{};
        pub const OleUIChangeSource = *opaque{};
        pub const OleUIObjectProperties = *opaque{};
        pub const OleUIPromptUser = *opaque{};
        pub const OleUIUpdateLinks = *opaque{};
    } else struct {
        pub const OLEUIINSERTOBJECT = @compileError("'OLEUIINSERTOBJECT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTEENTRY = @compileError("'OLEUIPASTEENTRY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTESPECIAL = @compileError("'OLEUIPASTESPECIAL' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkContainer = @compileError("'IOleUILinkContainer' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIEDITLINKS = @compileError("'OLEUIEDITLINKS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGEICON = @compileError("'OLEUICHANGEICON' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICONVERT = @compileError("'OLEUICONVERT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIBUSY = @compileError("'OLEUIBUSY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGESOURCE = @compileError("'OLEUICHANGESOURCE' requires that UNICODE be set to true or false in the root module");
        pub const IOleUIObjInfo = @compileError("'IOleUIObjInfo' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkInfo = @compileError("'IOleUILinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIGNRLPROPS = @compileError("'OLEUIGNRLPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIVIEWPROPS = @compileError("'OLEUIVIEWPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUILINKPROPS = @compileError("'OLEUILINKPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIOBJECTPROPS = @compileError("'OLEUIOBJECTPROPS' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenStream = @compileError("'URLOpenStream' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenPullStream = @compileError("'URLOpenPullStream' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToFile = @compileError("'URLDownloadToFile' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToCacheFile = @compileError("'URLDownloadToCacheFile' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenBlockingStream = @compileError("'URLOpenBlockingStream' requires that UNICODE be set to true or false in the root module");
        pub const IsLoggingEnabled = @compileError("'IsLoggingEnabled' requires that UNICODE be set to true or false in the root module");
        pub const OleUIAddVerbMenu = @compileError("'OleUIAddVerbMenu' requires that UNICODE be set to true or false in the root module");
        pub const OleUIInsertObject = @compileError("'OleUIInsertObject' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPasteSpecial = @compileError("'OleUIPasteSpecial' requires that UNICODE be set to true or false in the root module");
        pub const OleUIEditLinks = @compileError("'OleUIEditLinks' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeIcon = @compileError("'OleUIChangeIcon' requires that UNICODE be set to true or false in the root module");
        pub const OleUIConvert = @compileError("'OleUIConvert' requires that UNICODE be set to true or false in the root module");
        pub const OleUIBusy = @compileError("'OleUIBusy' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeSource = @compileError("'OleUIChangeSource' requires that UNICODE be set to true or false in the root module");
        pub const OleUIObjectProperties = @compileError("'OleUIObjectProperties' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPromptUser = @compileError("'OleUIPromptUser' requires that UNICODE be set to true or false in the root module");
        pub const OleUIUpdateLinks = @compileError("'OleUIUpdateLinks' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (67)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../system/system_services.zig").CHAR;
const CY = @import("../system/system_services.zig").CY;
const FILETIME = @import("../foundation.zig").FILETIME;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HANDLE_PTR = @import("../system/system_services.zig").HANDLE_PTR;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HCURSOR = @import("../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../graphics/gdi.zig").HDC;
const HENHMETAFILE = @import("../graphics/gdi.zig").HENHMETAFILE;
const HFONT = @import("../graphics/gdi.zig").HFONT;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HMETAFILE = @import("../graphics/gdi.zig").HMETAFILE;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HRGN = @import("../graphics/gdi.zig").HRGN;
const HRSRC = @import("../system/library_loader.zig").HRSRC;
const HTASK = @import("../media/audio/core_audio.zig").HTASK;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/ole_automation.zig").IDispatch;
const IErrorLog = @import("../system/ole_automation.zig").IErrorLog;
const IEventObjectCollection = @import("../system/component_services.zig").IEventObjectCollection;
const IInspectable = @import("../system/win_rt.zig").IInspectable;
const IPropertyBag = @import("../system/ole_automation.zig").IPropertyBag;
const IServiceProvider = @import("../system/system_services.zig").IServiceProvider;
const IStorage = @import("../storage/structured_storage.zig").IStorage;
const IStream = @import("../storage/structured_storage.zig").IStream;
const ITypeInfo = @import("../system/ole_automation.zig").ITypeInfo;
const IXMLElement = @import("../data/xml/ms_xml.zig").IXMLElement;
const LARGE_INTEGER = @import("../system/system_services.zig").LARGE_INTEGER;
const LOGPALETTE = @import("../graphics/gdi.zig").LOGPALETTE;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const OPENFILENAMEA = @import("../ui/windows_and_messaging.zig").OPENFILENAMEA;
const OPENFILENAMEW = @import("../ui/windows_and_messaging.zig").OPENFILENAMEW;
const POINT = @import("../foundation.zig").POINT;
const POINTL = @import("../foundation.zig").POINTL;
const PROPSHEETHEADERA_V2 = @import("../ui/controls.zig").PROPSHEETHEADERA_V2;
const PROPSHEETHEADERW_V2 = @import("../ui/controls.zig").PROPSHEETHEADERW_V2;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RECTL = @import("../foundation.zig").RECTL;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SECURITY_DESCRIPTOR = @import("../security.zig").SECURITY_DESCRIPTOR;
const SIZE = @import("../foundation.zig").SIZE;
const SOFTDISTINFO = @import("../ui/shell.zig").SOFTDISTINFO;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TEXTMETRICW = @import("../graphics/gdi.zig").TEXTMETRICW;
const uCLSSPEC = @import("../system/system_services.zig").uCLSSPEC;
const ULARGE_INTEGER = @import("../system/system_services.zig").ULARGE_INTEGER;
const UNDOCK_REASON = @import("../ui/shell.zig").UNDOCK_REASON;
const userHBITMAP = @import("../system/system_services.zig").userHBITMAP;
const userHENHMETAFILE = @import("../system/system_services.zig").userHENHMETAFILE;
const userHGLOBAL = @import("../system/system_services.zig").userHGLOBAL;
const userHMETAFILEPICT = @import("../system/system_services.zig").userHMETAFILEPICT;
const userHPALETTE = @import("../system/system_services.zig").userHPALETTE;
const VARIANT = @import("../system/ole_automation.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNGETCLASSOBJECT")) { _ = LPFNGETCLASSOBJECT; }
    if (@hasDecl(@This(), "LPFNCANUNLOADNOW")) { _ = LPFNCANUNLOADNOW; }
    if (@hasDecl(@This(), "LPFNOLEUIHOOK")) { _ = LPFNOLEUIHOOK; }
    if (@hasDecl(@This(), "PFNCONTEXTCALL")) { _ = PFNCONTEXTCALL; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (83)
//--------------------------------------------------------------------------------
pub const FADF_AUTO = @as(u32, 1);
pub const FADF_STATIC = @as(u32, 2);
pub const FADF_EMBEDDED = @as(u32, 4);
pub const FADF_FIXEDSIZE = @as(u32, 16);
pub const FADF_RECORD = @as(u32, 32);
pub const FADF_HAVEIID = @as(u32, 64);
pub const FADF_HAVEVARTYPE = @as(u32, 128);
pub const FADF_BSTR = @as(u32, 256);
pub const FADF_UNKNOWN = @as(u32, 512);
pub const FADF_DISPATCH = @as(u32, 1024);
pub const FADF_VARIANT = @as(u32, 2048);
pub const FADF_RESERVED = @as(u32, 61448);
pub const PARAMFLAG_NONE = @as(u32, 0);
pub const PARAMFLAG_FIN = @as(u32, 1);
pub const PARAMFLAG_FOUT = @as(u32, 2);
pub const PARAMFLAG_FLCID = @as(u32, 4);
pub const PARAMFLAG_FRETVAL = @as(u32, 8);
pub const PARAMFLAG_FOPT = @as(u32, 16);
pub const PARAMFLAG_FHASDEFAULT = @as(u32, 32);
pub const PARAMFLAG_FHASCUSTDATA = @as(u32, 64);
pub const IMPLTYPEFLAG_FDEFAULT = @as(u32, 1);
pub const IMPLTYPEFLAG_FSOURCE = @as(u32, 2);
pub const IMPLTYPEFLAG_FRESTRICTED = @as(u32, 4);
pub const IMPLTYPEFLAG_FDEFAULTVTABLE = @as(u32, 8);
pub const DISPID_UNKNOWN = @as(i32, -1);
pub const DISPID_VALUE = @as(u32, 0);
pub const DISPID_PROPERTYPUT = @as(i32, -3);
pub const DISPID_NEWENUM = @as(i32, -4);
pub const DISPID_EVALUATE = @as(i32, -5);
pub const DISPID_CONSTRUCTOR = @as(i32, -6);
pub const DISPID_DESTRUCTOR = @as(i32, -7);
pub const DISPID_COLLECT = @as(i32, -8);
pub const STDOLE_MAJORVERNUM = @as(u32, 1);
pub const STDOLE_MINORVERNUM = @as(u32, 0);
pub const STDOLE_LCID = @as(u32, 0);
pub const STDOLE2_MAJORVERNUM = @as(u32, 2);
pub const STDOLE2_MINORVERNUM = @as(u32, 0);
pub const STDOLE2_LCID = @as(u32, 0);
pub const VARIANT_NOVALUEPROP = @as(u32, 1);
pub const VARIANT_ALPHABOOL = @as(u32, 2);
pub const VARIANT_NOUSEROVERRIDE = @as(u32, 4);
pub const VARIANT_CALENDAR_HIJRI = @as(u32, 8);
pub const VARIANT_LOCALBOOL = @as(u32, 16);
pub const VARIANT_CALENDAR_THAI = @as(u32, 32);
pub const VARIANT_CALENDAR_GREGORIAN = @as(u32, 64);
pub const VARIANT_USE_NLS = @as(u32, 128);
pub const LOCALE_USE_NLS = @as(u32, 268435456);
pub const VTDATEGRE_MAX = @as(u32, 2958465);
pub const VTDATEGRE_MIN = @as(i32, -657434);
pub const NUMPRS_LEADING_WHITE = @as(u32, 1);
pub const NUMPRS_TRAILING_WHITE = @as(u32, 2);
pub const NUMPRS_LEADING_PLUS = @as(u32, 4);
pub const NUMPRS_TRAILING_PLUS = @as(u32, 8);
pub const NUMPRS_LEADING_MINUS = @as(u32, 16);
pub const NUMPRS_TRAILING_MINUS = @as(u32, 32);
pub const NUMPRS_HEX_OCT = @as(u32, 64);
pub const NUMPRS_PARENS = @as(u32, 128);
pub const NUMPRS_DECIMAL = @as(u32, 256);
pub const NUMPRS_THOUSANDS = @as(u32, 512);
pub const NUMPRS_CURRENCY = @as(u32, 1024);
pub const NUMPRS_EXPONENT = @as(u32, 2048);
pub const NUMPRS_USE_ALL = @as(u32, 4096);
pub const NUMPRS_STD = @as(u32, 8191);
pub const NUMPRS_NEG = @as(u32, 65536);
pub const NUMPRS_INEXACT = @as(u32, 131072);
pub const VARCMP_LT = @as(u32, 0);
pub const VARCMP_EQ = @as(u32, 1);
pub const VARCMP_GT = @as(u32, 2);
pub const VARCMP_NULL = @as(u32, 3);
pub const ID_DEFAULTINST = @as(i32, -2);
pub const DISPATCH_METHOD = @as(u32, 1);
pub const DISPATCH_PROPERTYGET = @as(u32, 2);
pub const DISPATCH_PROPERTYPUT = @as(u32, 4);
pub const DISPATCH_PROPERTYPUTREF = @as(u32, 8);
pub const LOAD_TLB_AS_32BIT = @as(u32, 32);
pub const LOAD_TLB_AS_64BIT = @as(u32, 64);
pub const ACTIVEOBJECT_STRONG = @as(u32, 0);
pub const ACTIVEOBJECT_WEAK = @as(u32, 1);
pub const SID_VariantConversion = Guid.initString("1f101481-bccd-11d0-9336-00a0c90dcaa9");
pub const SID_GetCaller = Guid.initString("4717cc40-bcb9-11d0-9336-00a0c90dcaa9");
pub const SID_ProvideRuntimeContext = Guid.initString("74a5040c-dd0c-48f0-ac85-194c3259180a");
pub const DISPATCH_CONSTRUCT = @as(u32, 16384);
pub const DISPID_THIS = @as(i32, -613);

//--------------------------------------------------------------------------------
// Section: Types (78)
//--------------------------------------------------------------------------------
pub const LPEXCEPFINO_DEFERRED_FILLIN = fn(
    pExcepInfo: ?*EXCEPINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const SAFEARRAYBOUND = extern struct {
    cElements: u32,
    lLbound: i32,
};

pub const _wireSAFEARR_BSTR = extern struct {
    Size: u32,
    aBstr: ?*?*FLAGGED_WORD_BLOB,
};

pub const _wireSAFEARR_UNKNOWN = extern struct {
    Size: u32,
    apUnknown: ?*?*IUnknown,
};

pub const _wireSAFEARR_DISPATCH = extern struct {
    Size: u32,
    apDispatch: ?*?*IDispatch,
};

pub const _wireSAFEARR_VARIANT = extern struct {
    Size: u32,
    aVariant: ?*?*_wireVARIANT,
};

pub const _wireSAFEARR_BRECORD = extern struct {
    Size: u32,
    aRecord: ?*?*_wireBRECORD,
};

pub const _wireSAFEARR_HAVEIID = extern struct {
    Size: u32,
    apUnknown: ?*?*IUnknown,
    iid: Guid,
};

pub const SF_TYPE = enum(i32) {
    ERROR = 10,
    I1 = 16,
    I2 = 2,
    I4 = 3,
    I8 = 20,
    BSTR = 8,
    UNKNOWN = 13,
    DISPATCH = 9,
    VARIANT = 12,
    RECORD = 36,
    HAVEIID = 32781,
};
pub const SF_ERROR = SF_TYPE.ERROR;
pub const SF_I1 = SF_TYPE.I1;
pub const SF_I2 = SF_TYPE.I2;
pub const SF_I4 = SF_TYPE.I4;
pub const SF_I8 = SF_TYPE.I8;
pub const SF_BSTR = SF_TYPE.BSTR;
pub const SF_UNKNOWN = SF_TYPE.UNKNOWN;
pub const SF_DISPATCH = SF_TYPE.DISPATCH;
pub const SF_VARIANT = SF_TYPE.VARIANT;
pub const SF_RECORD = SF_TYPE.RECORD;
pub const SF_HAVEIID = SF_TYPE.HAVEIID;

pub const _wireSAFEARRAY_UNION = extern struct {
    sfType: u32,
    u: extern struct {
        BstrStr: _wireSAFEARR_BSTR,
        UnknownStr: _wireSAFEARR_UNKNOWN,
        DispatchStr: _wireSAFEARR_DISPATCH,
        VariantStr: _wireSAFEARR_VARIANT,
        RecordStr: _wireSAFEARR_BRECORD,
        HaveIidStr: _wireSAFEARR_HAVEIID,
        ByteStr: BYTE_SIZEDARR,
        WordStr: SHORT_SIZEDARR,
        LongStr: LONG_SIZEDARR,
        HyperStr: HYPER_SIZEDARR,
    },
};

pub const _wireSAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    uArrayStructs: _wireSAFEARRAY_UNION,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const SAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    pvData: ?*c_void,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const VARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                llVal: i64,
                lVal: i32,
                bVal: u8,
                iVal: i16,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                bstrVal: ?BSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                parray: ?*SAFEARRAY,
                pbVal: ?*u8,
                piVal: ?*i16,
                plVal: ?*i32,
                pllVal: ?*i64,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                __OBSOLETE__VARIANT_PBOOL: ?*i16,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*VARIANT,
                byref: ?*c_void,
                cVal: CHAR,
                uiVal: u16,
                ulVal: u32,
                ullVal: u64,
                intVal: i32,
                uintVal: u32,
                pdecVal: ?*DECIMAL,
                pcVal: ?PSTR,
                puiVal: ?*u16,
                pulVal: ?*u32,
                pullVal: ?*u64,
                pintVal: ?*i32,
                puintVal: ?*u32,
                Anonymous: extern struct {
                    pvRecord: ?*c_void,
                    pRecInfo: ?*IRecordInfo,
                },
            },
        },
        decVal: DECIMAL,
    },
};

pub const _wireBRECORD = extern struct {
    fFlags: u32,
    clSize: u32,
    pRecInfo: ?*IRecordInfo,
    pRecord: ?*u8,
};

pub const _wireVARIANT = extern struct {
    clSize: u32,
    rpcReserved: u32,
    vt: u16,
    wReserved1: u16,
    wReserved2: u16,
    wReserved3: u16,
    Anonymous: extern union {
        llVal: i64,
        lVal: i32,
        bVal: u8,
        iVal: i16,
        fltVal: f32,
        dblVal: f64,
        boolVal: i16,
        scode: i32,
        cyVal: CY,
        date: f64,
        bstrVal: ?*FLAGGED_WORD_BLOB,
        punkVal: ?*IUnknown,
        pdispVal: ?*IDispatch,
        parray: ?*?*_wireSAFEARRAY,
        brecVal: ?*_wireBRECORD,
        pbVal: ?*u8,
        piVal: ?*i16,
        plVal: ?*i32,
        pllVal: ?*i64,
        pfltVal: ?*f32,
        pdblVal: ?*f64,
        pboolVal: ?*i16,
        pscode: ?*i32,
        pcyVal: ?*CY,
        pdate: ?*f64,
        pbstrVal: ?*?*FLAGGED_WORD_BLOB,
        ppunkVal: ?*?*IUnknown,
        ppdispVal: ?*?*IDispatch,
        pparray: ?*?*?*_wireSAFEARRAY,
        pvarVal: ?*?*_wireVARIANT,
        cVal: CHAR,
        uiVal: u16,
        ulVal: u32,
        ullVal: u64,
        intVal: i32,
        uintVal: u32,
        decVal: DECIMAL,
        pdecVal: ?*DECIMAL,
        pcVal: ?PSTR,
        puiVal: ?*u16,
        pulVal: ?*u32,
        pullVal: ?*u64,
        pintVal: ?*i32,
        puintVal: ?*u32,
    },
};

pub const TYPEKIND = enum(i32) {
    ENUM = 0,
    RECORD = 1,
    MODULE = 2,
    INTERFACE = 3,
    DISPATCH = 4,
    COCLASS = 5,
    ALIAS = 6,
    UNION = 7,
    MAX = 8,
};
pub const TKIND_ENUM = TYPEKIND.ENUM;
pub const TKIND_RECORD = TYPEKIND.RECORD;
pub const TKIND_MODULE = TYPEKIND.MODULE;
pub const TKIND_INTERFACE = TYPEKIND.INTERFACE;
pub const TKIND_DISPATCH = TYPEKIND.DISPATCH;
pub const TKIND_COCLASS = TYPEKIND.COCLASS;
pub const TKIND_ALIAS = TYPEKIND.ALIAS;
pub const TKIND_UNION = TYPEKIND.UNION;
pub const TKIND_MAX = TYPEKIND.MAX;

pub const TYPEDESC = extern struct {
    Anonymous: extern union {
        lptdesc: ?*TYPEDESC,
        lpadesc: ?*ARRAYDESC,
        hreftype: u32,
    },
    vt: u16,
};

pub const ARRAYDESC = extern struct {
    tdescElem: TYPEDESC,
    cDims: u16,
    rgbounds: [1]SAFEARRAYBOUND,
};

pub const PARAMDESCEX = extern struct {
    cBytes: u32,
    varDefaultValue: VARIANT,
};

pub const PARAMDESC = extern struct {
    pparamdescex: ?*PARAMDESCEX,
    wParamFlags: u16,
};

pub const IDLDESC = extern struct {
    dwReserved: usize,
    wIDLFlags: u16,
};

pub const ELEMDESC = extern struct {
    tdesc: TYPEDESC,
    Anonymous: extern union {
        idldesc: IDLDESC,
        paramdesc: PARAMDESC,
    },
};

pub const TYPEATTR = extern struct {
    guid: Guid,
    lcid: u32,
    dwReserved: u32,
    memidConstructor: i32,
    memidDestructor: i32,
    lpstrSchema: ?PWSTR,
    cbSizeInstance: u32,
    typekind: TYPEKIND,
    cFuncs: u16,
    cVars: u16,
    cImplTypes: u16,
    cbSizeVft: u16,
    cbAlignment: u16,
    wTypeFlags: u16,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};

pub const DISPPARAMS = extern struct {
    rgvarg: ?*VARIANT,
    rgdispidNamedArgs: ?*i32,
    cArgs: u32,
    cNamedArgs: u32,
};

pub const EXCEPINFO = extern struct {
    wCode: u16,
    wReserved: u16,
    bstrSource: ?BSTR,
    bstrDescription: ?BSTR,
    bstrHelpFile: ?BSTR,
    dwHelpContext: u32,
    pvReserved: ?*c_void,
    pfnDeferredFillIn: ?LPEXCEPFINO_DEFERRED_FILLIN,
    scode: i32,
};

pub const CALLCONV = enum(i32) {
    FASTCALL = 0,
    CDECL = 1,
    MSCPASCAL = 2,
    // PASCAL = 2, this enum value conflicts with MSCPASCAL
    MACPASCAL = 3,
    STDCALL = 4,
    FPFASTCALL = 5,
    SYSCALL = 6,
    MPWCDECL = 7,
    MPWPASCAL = 8,
    MAX = 9,
};
pub const CC_FASTCALL = CALLCONV.FASTCALL;
pub const CC_CDECL = CALLCONV.CDECL;
pub const CC_MSCPASCAL = CALLCONV.MSCPASCAL;
pub const CC_PASCAL = CALLCONV.MSCPASCAL;
pub const CC_MACPASCAL = CALLCONV.MACPASCAL;
pub const CC_STDCALL = CALLCONV.STDCALL;
pub const CC_FPFASTCALL = CALLCONV.FPFASTCALL;
pub const CC_SYSCALL = CALLCONV.SYSCALL;
pub const CC_MPWCDECL = CALLCONV.MPWCDECL;
pub const CC_MPWPASCAL = CALLCONV.MPWPASCAL;
pub const CC_MAX = CALLCONV.MAX;

pub const FUNCKIND = enum(i32) {
    VIRTUAL = 0,
    PUREVIRTUAL = 1,
    NONVIRTUAL = 2,
    STATIC = 3,
    DISPATCH = 4,
};
pub const FUNC_VIRTUAL = FUNCKIND.VIRTUAL;
pub const FUNC_PUREVIRTUAL = FUNCKIND.PUREVIRTUAL;
pub const FUNC_NONVIRTUAL = FUNCKIND.NONVIRTUAL;
pub const FUNC_STATIC = FUNCKIND.STATIC;
pub const FUNC_DISPATCH = FUNCKIND.DISPATCH;

pub const INVOKEKIND = enum(i32) {
    FUNC = 1,
    PROPERTYGET = 2,
    PROPERTYPUT = 4,
    PROPERTYPUTREF = 8,
};
pub const INVOKE_FUNC = INVOKEKIND.FUNC;
pub const INVOKE_PROPERTYGET = INVOKEKIND.PROPERTYGET;
pub const INVOKE_PROPERTYPUT = INVOKEKIND.PROPERTYPUT;
pub const INVOKE_PROPERTYPUTREF = INVOKEKIND.PROPERTYPUTREF;

pub const FUNCDESC = extern struct {
    memid: i32,
    lprgscode: ?*i32,
    lprgelemdescParam: ?*ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: i16,
    cParamsOpt: i16,
    oVft: i16,
    cScodes: i16,
    elemdescFunc: ELEMDESC,
    wFuncFlags: u16,
};

pub const VARKIND = enum(i32) {
    PERINSTANCE = 0,
    STATIC = 1,
    CONST = 2,
    DISPATCH = 3,
};
pub const VAR_PERINSTANCE = VARKIND.PERINSTANCE;
pub const VAR_STATIC = VARKIND.STATIC;
pub const VAR_CONST = VARKIND.CONST;
pub const VAR_DISPATCH = VARKIND.DISPATCH;

pub const VARDESC = extern struct {
    memid: i32,
    lpstrSchema: ?PWSTR,
    Anonymous: extern union {
        oInst: u32,
        lpvarValue: ?*VARIANT,
    },
    elemdescVar: ELEMDESC,
    wVarFlags: u16,
    varkind: VARKIND,
};

pub const TYPEFLAGS = enum(i32) {
    APPOBJECT = 1,
    CANCREATE = 2,
    LICENSED = 4,
    PREDECLID = 8,
    HIDDEN = 16,
    CONTROL = 32,
    DUAL = 64,
    NONEXTENSIBLE = 128,
    OLEAUTOMATION = 256,
    RESTRICTED = 512,
    AGGREGATABLE = 1024,
    REPLACEABLE = 2048,
    DISPATCHABLE = 4096,
    REVERSEBIND = 8192,
    PROXY = 16384,
};
pub const TYPEFLAG_FAPPOBJECT = TYPEFLAGS.APPOBJECT;
pub const TYPEFLAG_FCANCREATE = TYPEFLAGS.CANCREATE;
pub const TYPEFLAG_FLICENSED = TYPEFLAGS.LICENSED;
pub const TYPEFLAG_FPREDECLID = TYPEFLAGS.PREDECLID;
pub const TYPEFLAG_FHIDDEN = TYPEFLAGS.HIDDEN;
pub const TYPEFLAG_FCONTROL = TYPEFLAGS.CONTROL;
pub const TYPEFLAG_FDUAL = TYPEFLAGS.DUAL;
pub const TYPEFLAG_FNONEXTENSIBLE = TYPEFLAGS.NONEXTENSIBLE;
pub const TYPEFLAG_FOLEAUTOMATION = TYPEFLAGS.OLEAUTOMATION;
pub const TYPEFLAG_FRESTRICTED = TYPEFLAGS.RESTRICTED;
pub const TYPEFLAG_FAGGREGATABLE = TYPEFLAGS.AGGREGATABLE;
pub const TYPEFLAG_FREPLACEABLE = TYPEFLAGS.REPLACEABLE;
pub const TYPEFLAG_FDISPATCHABLE = TYPEFLAGS.DISPATCHABLE;
pub const TYPEFLAG_FREVERSEBIND = TYPEFLAGS.REVERSEBIND;
pub const TYPEFLAG_FPROXY = TYPEFLAGS.PROXY;

pub const FUNCFLAGS = enum(i32) {
    RESTRICTED = 1,
    SOURCE = 2,
    BINDABLE = 4,
    REQUESTEDIT = 8,
    DISPLAYBIND = 16,
    DEFAULTBIND = 32,
    HIDDEN = 64,
    USESGETLASTERROR = 128,
    DEFAULTCOLLELEM = 256,
    UIDEFAULT = 512,
    NONBROWSABLE = 1024,
    REPLACEABLE = 2048,
    IMMEDIATEBIND = 4096,
};
pub const FUNCFLAG_FRESTRICTED = FUNCFLAGS.RESTRICTED;
pub const FUNCFLAG_FSOURCE = FUNCFLAGS.SOURCE;
pub const FUNCFLAG_FBINDABLE = FUNCFLAGS.BINDABLE;
pub const FUNCFLAG_FREQUESTEDIT = FUNCFLAGS.REQUESTEDIT;
pub const FUNCFLAG_FDISPLAYBIND = FUNCFLAGS.DISPLAYBIND;
pub const FUNCFLAG_FDEFAULTBIND = FUNCFLAGS.DEFAULTBIND;
pub const FUNCFLAG_FHIDDEN = FUNCFLAGS.HIDDEN;
pub const FUNCFLAG_FUSESGETLASTERROR = FUNCFLAGS.USESGETLASTERROR;
pub const FUNCFLAG_FDEFAULTCOLLELEM = FUNCFLAGS.DEFAULTCOLLELEM;
pub const FUNCFLAG_FUIDEFAULT = FUNCFLAGS.UIDEFAULT;
pub const FUNCFLAG_FNONBROWSABLE = FUNCFLAGS.NONBROWSABLE;
pub const FUNCFLAG_FREPLACEABLE = FUNCFLAGS.REPLACEABLE;
pub const FUNCFLAG_FIMMEDIATEBIND = FUNCFLAGS.IMMEDIATEBIND;

pub const VARFLAGS = enum(i32) {
    READONLY = 1,
    SOURCE = 2,
    BINDABLE = 4,
    REQUESTEDIT = 8,
    DISPLAYBIND = 16,
    DEFAULTBIND = 32,
    HIDDEN = 64,
    RESTRICTED = 128,
    DEFAULTCOLLELEM = 256,
    UIDEFAULT = 512,
    NONBROWSABLE = 1024,
    REPLACEABLE = 2048,
    IMMEDIATEBIND = 4096,
};
pub const VARFLAG_FREADONLY = VARFLAGS.READONLY;
pub const VARFLAG_FSOURCE = VARFLAGS.SOURCE;
pub const VARFLAG_FBINDABLE = VARFLAGS.BINDABLE;
pub const VARFLAG_FREQUESTEDIT = VARFLAGS.REQUESTEDIT;
pub const VARFLAG_FDISPLAYBIND = VARFLAGS.DISPLAYBIND;
pub const VARFLAG_FDEFAULTBIND = VARFLAGS.DEFAULTBIND;
pub const VARFLAG_FHIDDEN = VARFLAGS.HIDDEN;
pub const VARFLAG_FRESTRICTED = VARFLAGS.RESTRICTED;
pub const VARFLAG_FDEFAULTCOLLELEM = VARFLAGS.DEFAULTCOLLELEM;
pub const VARFLAG_FUIDEFAULT = VARFLAGS.UIDEFAULT;
pub const VARFLAG_FNONBROWSABLE = VARFLAGS.NONBROWSABLE;
pub const VARFLAG_FREPLACEABLE = VARFLAGS.REPLACEABLE;
pub const VARFLAG_FIMMEDIATEBIND = VARFLAGS.IMMEDIATEBIND;

pub const CLEANLOCALSTORAGE = extern struct {
    pInterface: ?*IUnknown,
    pStorage: ?*c_void,
    flags: u32,
};

pub const CUSTDATAITEM = extern struct {
    guid: Guid,
    varValue: VARIANT,
};

pub const CUSTDATA = extern struct {
    cCustData: u32,
    prgCustData: ?*CUSTDATAITEM,
};

const IID_ICreateTypeInfo_Value = @import("../zig.zig").Guid.initString("00020405-0000-0000-c000-000000000046");
pub const IID_ICreateTypeInfo = &IID_ICreateTypeInfo_Value;
pub const ICreateTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGuid: fn(
            self: *const ICreateTypeInfo,
            guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeFlags: fn(
            self: *const ICreateTypeInfo,
            uTypeFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocString: fn(
            self: *const ICreateTypeInfo,
            pStrDoc: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpContext: fn(
            self: *const ICreateTypeInfo,
            dwHelpContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVersion: fn(
            self: *const ICreateTypeInfo,
            wMajorVerNum: u16,
            wMinorVerNum: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRefTypeInfo: fn(
            self: *const ICreateTypeInfo,
            pTInfo: ?*ITypeInfo,
            phRefType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFuncDesc: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            pFuncDesc: ?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddImplType: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            hRefType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplTypeFlags: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            implTypeFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ICreateTypeInfo,
            cbAlignment: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSchema: fn(
            self: *const ICreateTypeInfo,
            pStrSchema: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddVarDesc: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            pVarDesc: ?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFuncAndParamNames: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            rgszNames: [*]?PWSTR,
            cNames: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVarName: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            szName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeDescAlias: fn(
            self: *const ICreateTypeInfo,
            pTDescAlias: ?*TYPEDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineFuncAsDllEntry: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            szDllName: ?PWSTR,
            szProcName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFuncDocString: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            szDocString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVarDocString: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            szDocString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFuncHelpContext: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            dwHelpContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVarHelpContext: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            dwHelpContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMops: fn(
            self: *const ICreateTypeInfo,
            index: u32,
            bstrMops: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeIdldesc: fn(
            self: *const ICreateTypeInfo,
            pIdlDesc: ?*IDLDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LayOut: fn(
            self: *const ICreateTypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetGuid(self: *const T, guid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetGuid(@ptrCast(*const ICreateTypeInfo, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetTypeFlags(self: *const T, uTypeFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetTypeFlags(@ptrCast(*const ICreateTypeInfo, self), uTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetDocString(self: *const T, pStrDoc: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetDocString(@ptrCast(*const ICreateTypeInfo, self), pStrDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetHelpContext(self: *const T, dwHelpContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetHelpContext(@ptrCast(*const ICreateTypeInfo, self), dwHelpContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetVersion(self: *const T, wMajorVerNum: u16, wMinorVerNum: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetVersion(@ptrCast(*const ICreateTypeInfo, self), wMajorVerNum, wMinorVerNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_AddRefTypeInfo(self: *const T, pTInfo: ?*ITypeInfo, phRefType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).AddRefTypeInfo(@ptrCast(*const ICreateTypeInfo, self), pTInfo, phRefType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_AddFuncDesc(self: *const T, index: u32, pFuncDesc: ?*FUNCDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).AddFuncDesc(@ptrCast(*const ICreateTypeInfo, self), index, pFuncDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_AddImplType(self: *const T, index: u32, hRefType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).AddImplType(@ptrCast(*const ICreateTypeInfo, self), index, hRefType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetImplTypeFlags(self: *const T, index: u32, implTypeFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetImplTypeFlags(@ptrCast(*const ICreateTypeInfo, self), index, implTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetAlignment(self: *const T, cbAlignment: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetAlignment(@ptrCast(*const ICreateTypeInfo, self), cbAlignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetSchema(self: *const T, pStrSchema: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetSchema(@ptrCast(*const ICreateTypeInfo, self), pStrSchema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_AddVarDesc(self: *const T, index: u32, pVarDesc: ?*VARDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).AddVarDesc(@ptrCast(*const ICreateTypeInfo, self), index, pVarDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetFuncAndParamNames(self: *const T, index: u32, rgszNames: [*]?PWSTR, cNames: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetFuncAndParamNames(@ptrCast(*const ICreateTypeInfo, self), index, rgszNames, cNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetVarName(self: *const T, index: u32, szName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetVarName(@ptrCast(*const ICreateTypeInfo, self), index, szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetTypeDescAlias(self: *const T, pTDescAlias: ?*TYPEDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetTypeDescAlias(@ptrCast(*const ICreateTypeInfo, self), pTDescAlias);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_DefineFuncAsDllEntry(self: *const T, index: u32, szDllName: ?PWSTR, szProcName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).DefineFuncAsDllEntry(@ptrCast(*const ICreateTypeInfo, self), index, szDllName, szProcName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetFuncDocString(self: *const T, index: u32, szDocString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetFuncDocString(@ptrCast(*const ICreateTypeInfo, self), index, szDocString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetVarDocString(self: *const T, index: u32, szDocString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetVarDocString(@ptrCast(*const ICreateTypeInfo, self), index, szDocString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetFuncHelpContext(self: *const T, index: u32, dwHelpContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetFuncHelpContext(@ptrCast(*const ICreateTypeInfo, self), index, dwHelpContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetVarHelpContext(self: *const T, index: u32, dwHelpContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetVarHelpContext(@ptrCast(*const ICreateTypeInfo, self), index, dwHelpContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetMops(self: *const T, index: u32, bstrMops: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetMops(@ptrCast(*const ICreateTypeInfo, self), index, bstrMops);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_SetTypeIdldesc(self: *const T, pIdlDesc: ?*IDLDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).SetTypeIdldesc(@ptrCast(*const ICreateTypeInfo, self), pIdlDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo_LayOut(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo.VTable, self.vtable).LayOut(@ptrCast(*const ICreateTypeInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeInfo2_Value = @import("../zig.zig").Guid.initString("0002040e-0000-0000-c000-000000000046");
pub const IID_ICreateTypeInfo2 = &IID_ICreateTypeInfo2_Value;
pub const ICreateTypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ICreateTypeInfo.VTable,
        DeleteFuncDesc: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFuncDescByMemId: fn(
            self: *const ICreateTypeInfo2,
            memid: i32,
            invKind: INVOKEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteVarDesc: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteVarDescByMemId: fn(
            self: *const ICreateTypeInfo2,
            memid: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteImplType: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCustData: fn(
            self: *const ICreateTypeInfo2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFuncCustData: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParamCustData: fn(
            self: *const ICreateTypeInfo2,
            indexFunc: u32,
            indexParam: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVarCustData: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplTypeCustData: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpStringContext: fn(
            self: *const ICreateTypeInfo2,
            dwHelpStringContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFuncHelpStringContext: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
            dwHelpStringContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVarHelpStringContext: fn(
            self: *const ICreateTypeInfo2,
            index: u32,
            dwHelpStringContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invalidate: fn(
            self: *const ICreateTypeInfo2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ICreateTypeInfo2,
            szName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICreateTypeInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_DeleteFuncDesc(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).DeleteFuncDesc(@ptrCast(*const ICreateTypeInfo2, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_DeleteFuncDescByMemId(self: *const T, memid: i32, invKind: INVOKEKIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).DeleteFuncDescByMemId(@ptrCast(*const ICreateTypeInfo2, self), memid, invKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_DeleteVarDesc(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).DeleteVarDesc(@ptrCast(*const ICreateTypeInfo2, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_DeleteVarDescByMemId(self: *const T, memid: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).DeleteVarDescByMemId(@ptrCast(*const ICreateTypeInfo2, self), memid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_DeleteImplType(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).DeleteImplType(@ptrCast(*const ICreateTypeInfo2, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetCustData(@ptrCast(*const ICreateTypeInfo2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetFuncCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetFuncCustData(@ptrCast(*const ICreateTypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetParamCustData(self: *const T, indexFunc: u32, indexParam: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetParamCustData(@ptrCast(*const ICreateTypeInfo2, self), indexFunc, indexParam, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetVarCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetVarCustData(@ptrCast(*const ICreateTypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetImplTypeCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetImplTypeCustData(@ptrCast(*const ICreateTypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetHelpStringContext(self: *const T, dwHelpStringContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetHelpStringContext(@ptrCast(*const ICreateTypeInfo2, self), dwHelpStringContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetFuncHelpStringContext(self: *const T, index: u32, dwHelpStringContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetFuncHelpStringContext(@ptrCast(*const ICreateTypeInfo2, self), index, dwHelpStringContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetVarHelpStringContext(self: *const T, index: u32, dwHelpStringContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetVarHelpStringContext(@ptrCast(*const ICreateTypeInfo2, self), index, dwHelpStringContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_Invalidate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).Invalidate(@ptrCast(*const ICreateTypeInfo2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeInfo2_SetName(self: *const T, szName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeInfo2.VTable, self.vtable).SetName(@ptrCast(*const ICreateTypeInfo2, self), szName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeLib_Value = @import("../zig.zig").Guid.initString("00020406-0000-0000-c000-000000000046");
pub const IID_ICreateTypeLib = &IID_ICreateTypeLib_Value;
pub const ICreateTypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTypeInfo: fn(
            self: *const ICreateTypeLib,
            szName: ?PWSTR,
            tkind: TYPEKIND,
            ppCTInfo: ?*?*ICreateTypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ICreateTypeLib,
            szName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVersion: fn(
            self: *const ICreateTypeLib,
            wMajorVerNum: u16,
            wMinorVerNum: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGuid: fn(
            self: *const ICreateTypeLib,
            guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocString: fn(
            self: *const ICreateTypeLib,
            szDoc: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpFileName: fn(
            self: *const ICreateTypeLib,
            szHelpFileName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpContext: fn(
            self: *const ICreateTypeLib,
            dwHelpContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLcid: fn(
            self: *const ICreateTypeLib,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLibFlags: fn(
            self: *const ICreateTypeLib,
            uLibFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAllChanges: fn(
            self: *const ICreateTypeLib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_CreateTypeInfo(self: *const T, szName: ?PWSTR, tkind: TYPEKIND, ppCTInfo: ?*?*ICreateTypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).CreateTypeInfo(@ptrCast(*const ICreateTypeLib, self), szName, tkind, ppCTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetName(self: *const T, szName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetName(@ptrCast(*const ICreateTypeLib, self), szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetVersion(self: *const T, wMajorVerNum: u16, wMinorVerNum: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetVersion(@ptrCast(*const ICreateTypeLib, self), wMajorVerNum, wMinorVerNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetGuid(self: *const T, guid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetGuid(@ptrCast(*const ICreateTypeLib, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetDocString(self: *const T, szDoc: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetDocString(@ptrCast(*const ICreateTypeLib, self), szDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetHelpFileName(self: *const T, szHelpFileName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetHelpFileName(@ptrCast(*const ICreateTypeLib, self), szHelpFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetHelpContext(self: *const T, dwHelpContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetHelpContext(@ptrCast(*const ICreateTypeLib, self), dwHelpContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetLcid(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetLcid(@ptrCast(*const ICreateTypeLib, self), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SetLibFlags(self: *const T, uLibFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SetLibFlags(@ptrCast(*const ICreateTypeLib, self), uLibFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib_SaveAllChanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib.VTable, self.vtable).SaveAllChanges(@ptrCast(*const ICreateTypeLib, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateTypeLib2_Value = @import("../zig.zig").Guid.initString("0002040f-0000-0000-c000-000000000046");
pub const IID_ICreateTypeLib2 = &IID_ICreateTypeLib2_Value;
pub const ICreateTypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ICreateTypeLib.VTable,
        DeleteTypeInfo: fn(
            self: *const ICreateTypeLib2,
            szName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCustData: fn(
            self: *const ICreateTypeLib2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpStringContext: fn(
            self: *const ICreateTypeLib2,
            dwHelpStringContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpStringDll: fn(
            self: *const ICreateTypeLib2,
            szFileName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICreateTypeLib.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib2_DeleteTypeInfo(self: *const T, szName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib2.VTable, self.vtable).DeleteTypeInfo(@ptrCast(*const ICreateTypeLib2, self), szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib2_SetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib2.VTable, self.vtable).SetCustData(@ptrCast(*const ICreateTypeLib2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib2_SetHelpStringContext(self: *const T, dwHelpStringContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib2.VTable, self.vtable).SetHelpStringContext(@ptrCast(*const ICreateTypeLib2, self), dwHelpStringContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateTypeLib2_SetHelpStringDll(self: *const T, szFileName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateTypeLib2.VTable, self.vtable).SetHelpStringDll(@ptrCast(*const ICreateTypeLib2, self), szFileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDispatch_Value = @import("../zig.zig").Guid.initString("00020400-0000-0000-c000-000000000046");
pub const IID_IDispatch = &IID_IDispatch_Value;
pub const IDispatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: fn(
            self: *const IDispatch,
            pctinfo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfo: fn(
            self: *const IDispatch,
            iTInfo: u32,
            lcid: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: fn(
            self: *const IDispatch,
            riid: ?*const Guid,
            rgszNames: [*]?PWSTR,
            cNames: u32,
            lcid: u32,
            rgDispId: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IDispatch,
            dispIdMember: i32,
            riid: ?*const Guid,
            lcid: u32,
            wFlags: u16,
            pDispParams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pExcepInfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetTypeInfoCount(self: *const T, pctinfo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetTypeInfoCount(@ptrCast(*const IDispatch, self), pctinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetTypeInfo(self: *const T, iTInfo: u32, lcid: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetTypeInfo(@ptrCast(*const IDispatch, self), iTInfo, lcid, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetIDsOfNames(self: *const T, riid: ?*const Guid, rgszNames: [*]?PWSTR, cNames: u32, lcid: u32, rgDispId: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetIDsOfNames(@ptrCast(*const IDispatch, self), riid, rgszNames, cNames, lcid, rgDispId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_Invoke(self: *const T, dispIdMember: i32, riid: ?*const Guid, lcid: u32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).Invoke(@ptrCast(*const IDispatch, self), dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumVARIANT_Value = @import("../zig.zig").Guid.initString("00020404-0000-0000-c000-000000000046");
pub const IID_IEnumVARIANT = &IID_IEnumVARIANT_Value;
pub const IEnumVARIANT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumVARIANT,
            celt: u32,
            rgVar: [*]VARIANT,
            pCeltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumVARIANT,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumVARIANT,
            ppEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVARIANT_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pCeltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVARIANT.VTable, self.vtable).Next(@ptrCast(*const IEnumVARIANT, self), celt, rgVar, pCeltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVARIANT_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVARIANT.VTable, self.vtable).Skip(@ptrCast(*const IEnumVARIANT, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVARIANT_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVARIANT.VTable, self.vtable).Reset(@ptrCast(*const IEnumVARIANT, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVARIANT_Clone(self: *const T, ppEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVARIANT.VTable, self.vtable).Clone(@ptrCast(*const IEnumVARIANT, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESCKIND = enum(i32) {
    NONE = 0,
    FUNCDESC = 1,
    VARDESC = 2,
    TYPECOMP = 3,
    IMPLICITAPPOBJ = 4,
    MAX = 5,
};
pub const DESCKIND_NONE = DESCKIND.NONE;
pub const DESCKIND_FUNCDESC = DESCKIND.FUNCDESC;
pub const DESCKIND_VARDESC = DESCKIND.VARDESC;
pub const DESCKIND_TYPECOMP = DESCKIND.TYPECOMP;
pub const DESCKIND_IMPLICITAPPOBJ = DESCKIND.IMPLICITAPPOBJ;
pub const DESCKIND_MAX = DESCKIND.MAX;

pub const BINDPTR = extern union {
    lpfuncdesc: ?*FUNCDESC,
    lpvardesc: ?*VARDESC,
    lptcomp: ?*ITypeComp,
};

const IID_ITypeComp_Value = @import("../zig.zig").Guid.initString("00020403-0000-0000-c000-000000000046");
pub const IID_ITypeComp = &IID_ITypeComp_Value;
pub const ITypeComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: fn(
            self: *const ITypeComp,
            szName: ?PWSTR,
            lHashVal: u32,
            wFlags: u16,
            ppTInfo: ?*?*ITypeInfo,
            pDescKind: ?*DESCKIND,
            pBindPtr: ?*BINDPTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindType: fn(
            self: *const ITypeComp,
            szName: ?PWSTR,
            lHashVal: u32,
            ppTInfo: ?*?*ITypeInfo,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeComp_Bind(self: *const T, szName: ?PWSTR, lHashVal: u32, wFlags: u16, ppTInfo: ?*?*ITypeInfo, pDescKind: ?*DESCKIND, pBindPtr: ?*BINDPTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeComp.VTable, self.vtable).Bind(@ptrCast(*const ITypeComp, self), szName, lHashVal, wFlags, ppTInfo, pDescKind, pBindPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeComp_BindType(self: *const T, szName: ?PWSTR, lHashVal: u32, ppTInfo: ?*?*ITypeInfo, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeComp.VTable, self.vtable).BindType(@ptrCast(*const ITypeComp, self), szName, lHashVal, ppTInfo, ppTComp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo_Value = @import("../zig.zig").Guid.initString("00020401-0000-0000-c000-000000000046");
pub const IID_ITypeInfo = &IID_ITypeInfo_Value;
pub const ITypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeAttr: fn(
            self: *const ITypeInfo,
            ppTypeAttr: ?*?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: fn(
            self: *const ITypeInfo,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncDesc: fn(
            self: *const ITypeInfo,
            index: u32,
            ppFuncDesc: ?*?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarDesc: fn(
            self: *const ITypeInfo,
            index: u32,
            ppVarDesc: ?*?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: fn(
            self: *const ITypeInfo,
            memid: i32,
            rgBstrNames: [*]?BSTR,
            cMaxNames: u32,
            pcNames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeOfImplType: fn(
            self: *const ITypeInfo,
            index: u32,
            pRefType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeFlags: fn(
            self: *const ITypeInfo,
            index: u32,
            pImplTypeFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: fn(
            self: *const ITypeInfo,
            rgszNames: [*]?PWSTR,
            cNames: u32,
            pMemId: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const ITypeInfo,
            pvInstance: ?*c_void,
            memid: i32,
            wFlags: u16,
            pDispParams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pExcepInfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: fn(
            self: *const ITypeInfo,
            memid: i32,
            pBstrName: ?*?BSTR,
            pBstrDocString: ?*?BSTR,
            pdwHelpContext: ?*u32,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDllEntry: fn(
            self: *const ITypeInfo,
            memid: i32,
            invKind: INVOKEKIND,
            pBstrDllName: ?*?BSTR,
            pBstrName: ?*?BSTR,
            pwOrdinal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeInfo: fn(
            self: *const ITypeInfo,
            hRefType: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddressOfMember: fn(
            self: *const ITypeInfo,
            memid: i32,
            invKind: INVOKEKIND,
            ppv: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: fn(
            self: *const ITypeInfo,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppvObj: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMops: fn(
            self: *const ITypeInfo,
            memid: i32,
            pBstrMops: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingTypeLib: fn(
            self: *const ITypeInfo,
            ppTLib: ?*?*ITypeLib,
            pIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTypeAttr: fn(
            self: *const ITypeInfo,
            pTypeAttr: ?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseFuncDesc: fn(
            self: *const ITypeInfo,
            pFuncDesc: ?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseVarDesc: fn(
            self: *const ITypeInfo,
            pVarDesc: ?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetTypeAttr(self: *const T, ppTypeAttr: ?*?*TYPEATTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetTypeAttr(@ptrCast(*const ITypeInfo, self), ppTypeAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetTypeComp(@ptrCast(*const ITypeInfo, self), ppTComp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetFuncDesc(self: *const T, index: u32, ppFuncDesc: ?*?*FUNCDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetFuncDesc(@ptrCast(*const ITypeInfo, self), index, ppFuncDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetVarDesc(self: *const T, index: u32, ppVarDesc: ?*?*VARDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetVarDesc(@ptrCast(*const ITypeInfo, self), index, ppVarDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetNames(self: *const T, memid: i32, rgBstrNames: [*]?BSTR, cMaxNames: u32, pcNames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetNames(@ptrCast(*const ITypeInfo, self), memid, rgBstrNames, cMaxNames, pcNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetRefTypeOfImplType(self: *const T, index: u32, pRefType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetRefTypeOfImplType(@ptrCast(*const ITypeInfo, self), index, pRefType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetImplTypeFlags(self: *const T, index: u32, pImplTypeFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetImplTypeFlags(@ptrCast(*const ITypeInfo, self), index, pImplTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetIDsOfNames(self: *const T, rgszNames: [*]?PWSTR, cNames: u32, pMemId: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetIDsOfNames(@ptrCast(*const ITypeInfo, self), rgszNames, cNames, pMemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_Invoke(self: *const T, pvInstance: ?*c_void, memid: i32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).Invoke(@ptrCast(*const ITypeInfo, self), pvInstance, memid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetDocumentation(self: *const T, memid: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetDocumentation(@ptrCast(*const ITypeInfo, self), memid, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetDllEntry(self: *const T, memid: i32, invKind: INVOKEKIND, pBstrDllName: ?*?BSTR, pBstrName: ?*?BSTR, pwOrdinal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetDllEntry(@ptrCast(*const ITypeInfo, self), memid, invKind, pBstrDllName, pBstrName, pwOrdinal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetRefTypeInfo(self: *const T, hRefType: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetRefTypeInfo(@ptrCast(*const ITypeInfo, self), hRefType, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_AddressOfMember(self: *const T, memid: i32, invKind: INVOKEKIND, ppv: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).AddressOfMember(@ptrCast(*const ITypeInfo, self), memid, invKind, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObj: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).CreateInstance(@ptrCast(*const ITypeInfo, self), pUnkOuter, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetMops(self: *const T, memid: i32, pBstrMops: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetMops(@ptrCast(*const ITypeInfo, self), memid, pBstrMops);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetContainingTypeLib(self: *const T, ppTLib: ?*?*ITypeLib, pIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetContainingTypeLib(@ptrCast(*const ITypeInfo, self), ppTLib, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseTypeAttr(self: *const T, pTypeAttr: ?*TYPEATTR) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseTypeAttr(@ptrCast(*const ITypeInfo, self), pTypeAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseFuncDesc(self: *const T, pFuncDesc: ?*FUNCDESC) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseFuncDesc(@ptrCast(*const ITypeInfo, self), pFuncDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseVarDesc(self: *const T, pVarDesc: ?*VARDESC) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseVarDesc(@ptrCast(*const ITypeInfo, self), pVarDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo2_Value = @import("../zig.zig").Guid.initString("00020412-0000-0000-c000-000000000046");
pub const IID_ITypeInfo2 = &IID_ITypeInfo2_Value;
pub const ITypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeInfo.VTable,
        GetTypeKind: fn(
            self: *const ITypeInfo2,
            pTypeKind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeFlags: fn(
            self: *const ITypeInfo2,
            pTypeFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncIndexOfMemId: fn(
            self: *const ITypeInfo2,
            memid: i32,
            invKind: INVOKEKIND,
            pFuncIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarIndexOfMemId: fn(
            self: *const ITypeInfo2,
            memid: i32,
            pVarIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustData: fn(
            self: *const ITypeInfo2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamCustData: fn(
            self: *const ITypeInfo2,
            indexFunc: u32,
            indexParam: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: fn(
            self: *const ITypeInfo2,
            memid: i32,
            lcid: u32,
            pbstrHelpString: ?*?BSTR,
            pdwHelpStringContext: ?*u32,
            pbstrHelpStringDll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: fn(
            self: *const ITypeInfo2,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllFuncCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllParamCustData: fn(
            self: *const ITypeInfo2,
            indexFunc: u32,
            indexParam: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVarCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllImplTypeCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITypeInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetTypeKind(self: *const T, pTypeKind: ?*TYPEKIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetTypeKind(@ptrCast(*const ITypeInfo2, self), pTypeKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetTypeFlags(self: *const T, pTypeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetTypeFlags(@ptrCast(*const ITypeInfo2, self), pTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetFuncIndexOfMemId(self: *const T, memid: i32, invKind: INVOKEKIND, pFuncIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetFuncIndexOfMemId(@ptrCast(*const ITypeInfo2, self), memid, invKind, pFuncIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetVarIndexOfMemId(self: *const T, memid: i32, pVarIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetVarIndexOfMemId(@ptrCast(*const ITypeInfo2, self), memid, pVarIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetCustData(@ptrCast(*const ITypeInfo2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetFuncCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetFuncCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetParamCustData(self: *const T, indexFunc: u32, indexParam: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetParamCustData(@ptrCast(*const ITypeInfo2, self), indexFunc, indexParam, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetVarCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetVarCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetImplTypeCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetImplTypeCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetDocumentation2(self: *const T, memid: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetDocumentation2(@ptrCast(*const ITypeInfo2, self), memid, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllCustData(@ptrCast(*const ITypeInfo2, self), pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllFuncCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllFuncCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllParamCustData(self: *const T, indexFunc: u32, indexParam: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllParamCustData(@ptrCast(*const ITypeInfo2, self), indexFunc, indexParam, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllVarCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllVarCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllImplTypeCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllImplTypeCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYSKIND = enum(i32) {
    WIN16 = 0,
    WIN32 = 1,
    MAC = 2,
    WIN64 = 3,
};
pub const SYS_WIN16 = SYSKIND.WIN16;
pub const SYS_WIN32 = SYSKIND.WIN32;
pub const SYS_MAC = SYSKIND.MAC;
pub const SYS_WIN64 = SYSKIND.WIN64;

pub const LIBFLAGS = enum(i32) {
    RESTRICTED = 1,
    CONTROL = 2,
    HIDDEN = 4,
    HASDISKIMAGE = 8,
};
pub const LIBFLAG_FRESTRICTED = LIBFLAGS.RESTRICTED;
pub const LIBFLAG_FCONTROL = LIBFLAGS.CONTROL;
pub const LIBFLAG_FHIDDEN = LIBFLAGS.HIDDEN;
pub const LIBFLAG_FHASDISKIMAGE = LIBFLAGS.HASDISKIMAGE;

pub const TLIBATTR = extern struct {
    guid: Guid,
    lcid: u32,
    syskind: SYSKIND,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    wLibFlags: u16,
};

const IID_ITypeLib_Value = @import("../zig.zig").Guid.initString("00020402-0000-0000-c000-000000000046");
pub const IID_ITypeLib = &IID_ITypeLib_Value;
pub const ITypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: fn(
            self: *const ITypeLib,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetTypeInfo: fn(
            self: *const ITypeLib,
            index: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoType: fn(
            self: *const ITypeLib,
            index: u32,
            pTKind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoOfGuid: fn(
            self: *const ITypeLib,
            guid: ?*const Guid,
            ppTinfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibAttr: fn(
            self: *const ITypeLib,
            ppTLibAttr: ?*?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: fn(
            self: *const ITypeLib,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: fn(
            self: *const ITypeLib,
            index: i32,
            pBstrName: ?*?BSTR,
            pBstrDocString: ?*?BSTR,
            pdwHelpContext: ?*u32,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsName: fn(
            self: *const ITypeLib,
            szNameBuf: ?PWSTR,
            lHashVal: u32,
            pfName: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindName: fn(
            self: *const ITypeLib,
            szNameBuf: ?PWSTR,
            lHashVal: u32,
            ppTInfo: [*]?*ITypeInfo,
            rgMemId: [*]i32,
            pcFound: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTLibAttr: fn(
            self: *const ITypeLib,
            pTLibAttr: ?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoCount(@ptrCast(*const ITypeLib, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfo(self: *const T, index: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfo(@ptrCast(*const ITypeLib, self), index, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoType(self: *const T, index: u32, pTKind: ?*TYPEKIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoType(@ptrCast(*const ITypeLib, self), index, pTKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoOfGuid(self: *const T, guid: ?*const Guid, ppTinfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoOfGuid(@ptrCast(*const ITypeLib, self), guid, ppTinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetLibAttr(self: *const T, ppTLibAttr: ?*?*TLIBATTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetLibAttr(@ptrCast(*const ITypeLib, self), ppTLibAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeComp(@ptrCast(*const ITypeLib, self), ppTComp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetDocumentation(self: *const T, index: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetDocumentation(@ptrCast(*const ITypeLib, self), index, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_IsName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, pfName: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).IsName(@ptrCast(*const ITypeLib, self), szNameBuf, lHashVal, pfName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_FindName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, ppTInfo: [*]?*ITypeInfo, rgMemId: [*]i32, pcFound: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).FindName(@ptrCast(*const ITypeLib, self), szNameBuf, lHashVal, ppTInfo, rgMemId, pcFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_ReleaseTLibAttr(self: *const T, pTLibAttr: ?*TLIBATTR) callconv(.Inline) void {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).ReleaseTLibAttr(@ptrCast(*const ITypeLib, self), pTLibAttr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLib2_Value = @import("../zig.zig").Guid.initString("00020411-0000-0000-c000-000000000046");
pub const IID_ITypeLib2 = &IID_ITypeLib2_Value;
pub const ITypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeLib.VTable,
        GetCustData: fn(
            self: *const ITypeLib2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibStatistics: fn(
            self: *const ITypeLib2,
            pcUniqueNames: ?*u32,
            pcchUniqueNames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: fn(
            self: *const ITypeLib2,
            index: i32,
            lcid: u32,
            pbstrHelpString: ?*?BSTR,
            pdwHelpStringContext: ?*u32,
            pbstrHelpStringDll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: fn(
            self: *const ITypeLib2,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITypeLib.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetCustData(@ptrCast(*const ITypeLib2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetLibStatistics(self: *const T, pcUniqueNames: ?*u32, pcchUniqueNames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetLibStatistics(@ptrCast(*const ITypeLib2, self), pcUniqueNames, pcchUniqueNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetDocumentation2(self: *const T, index: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetDocumentation2(@ptrCast(*const ITypeLib2, self), index, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetAllCustData(@ptrCast(*const ITypeLib2, self), pCustData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CHANGEKIND = enum(i32) {
    ADDMEMBER = 0,
    DELETEMEMBER = 1,
    SETNAMES = 2,
    SETDOCUMENTATION = 3,
    GENERAL = 4,
    INVALIDATE = 5,
    CHANGEFAILED = 6,
    MAX = 7,
};
pub const CHANGEKIND_ADDMEMBER = CHANGEKIND.ADDMEMBER;
pub const CHANGEKIND_DELETEMEMBER = CHANGEKIND.DELETEMEMBER;
pub const CHANGEKIND_SETNAMES = CHANGEKIND.SETNAMES;
pub const CHANGEKIND_SETDOCUMENTATION = CHANGEKIND.SETDOCUMENTATION;
pub const CHANGEKIND_GENERAL = CHANGEKIND.GENERAL;
pub const CHANGEKIND_INVALIDATE = CHANGEKIND.INVALIDATE;
pub const CHANGEKIND_CHANGEFAILED = CHANGEKIND.CHANGEFAILED;
pub const CHANGEKIND_MAX = CHANGEKIND.MAX;

const IID_ITypeChangeEvents_Value = @import("../zig.zig").Guid.initString("00020410-0000-0000-c000-000000000046");
pub const IID_ITypeChangeEvents = &IID_ITypeChangeEvents_Value;
pub const ITypeChangeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestTypeChange: fn(
            self: *const ITypeChangeEvents,
            changeKind: CHANGEKIND,
            pTInfoBefore: ?*ITypeInfo,
            pStrName: ?PWSTR,
            pfCancel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AfterTypeChange: fn(
            self: *const ITypeChangeEvents,
            changeKind: CHANGEKIND,
            pTInfoAfter: ?*ITypeInfo,
            pStrName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeChangeEvents_RequestTypeChange(self: *const T, changeKind: CHANGEKIND, pTInfoBefore: ?*ITypeInfo, pStrName: ?PWSTR, pfCancel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeChangeEvents.VTable, self.vtable).RequestTypeChange(@ptrCast(*const ITypeChangeEvents, self), changeKind, pTInfoBefore, pStrName, pfCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeChangeEvents_AfterTypeChange(self: *const T, changeKind: CHANGEKIND, pTInfoAfter: ?*ITypeInfo, pStrName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeChangeEvents.VTable, self.vtable).AfterTypeChange(@ptrCast(*const ITypeChangeEvents, self), changeKind, pTInfoAfter, pStrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorInfo_Value = @import("../zig.zig").Guid.initString("1cf2b120-547d-101b-8e65-08002b2bd119");
pub const IID_IErrorInfo = &IID_IErrorInfo_Value;
pub const IErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: fn(
            self: *const IErrorInfo,
            pGUID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: fn(
            self: *const IErrorInfo,
            pBstrSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IErrorInfo,
            pBstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpFile: fn(
            self: *const IErrorInfo,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpContext: fn(
            self: *const IErrorInfo,
            pdwHelpContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetGUID(self: *const T, pGUID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetGUID(@ptrCast(*const IErrorInfo, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetSource(self: *const T, pBstrSource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetSource(@ptrCast(*const IErrorInfo, self), pBstrSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetDescription(self: *const T, pBstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetDescription(@ptrCast(*const IErrorInfo, self), pBstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetHelpFile(self: *const T, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetHelpFile(@ptrCast(*const IErrorInfo, self), pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetHelpContext(self: *const T, pdwHelpContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetHelpContext(@ptrCast(*const IErrorInfo, self), pdwHelpContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateErrorInfo_Value = @import("../zig.zig").Guid.initString("22f03340-547d-101b-8e65-08002b2bd119");
pub const IID_ICreateErrorInfo = &IID_ICreateErrorInfo_Value;
pub const ICreateErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGUID: fn(
            self: *const ICreateErrorInfo,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSource: fn(
            self: *const ICreateErrorInfo,
            szSource: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const ICreateErrorInfo,
            szDescription: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpFile: fn(
            self: *const ICreateErrorInfo,
            szHelpFile: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHelpContext: fn(
            self: *const ICreateErrorInfo,
            dwHelpContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateErrorInfo_SetGUID(self: *const T, rguid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateErrorInfo.VTable, self.vtable).SetGUID(@ptrCast(*const ICreateErrorInfo, self), rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateErrorInfo_SetSource(self: *const T, szSource: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateErrorInfo.VTable, self.vtable).SetSource(@ptrCast(*const ICreateErrorInfo, self), szSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateErrorInfo_SetDescription(self: *const T, szDescription: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateErrorInfo.VTable, self.vtable).SetDescription(@ptrCast(*const ICreateErrorInfo, self), szDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateErrorInfo_SetHelpFile(self: *const T, szHelpFile: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateErrorInfo.VTable, self.vtable).SetHelpFile(@ptrCast(*const ICreateErrorInfo, self), szHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateErrorInfo_SetHelpContext(self: *const T, dwHelpContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateErrorInfo.VTable, self.vtable).SetHelpContext(@ptrCast(*const ICreateErrorInfo, self), dwHelpContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISupportErrorInfo_Value = @import("../zig.zig").Guid.initString("df0b3d60-548f-101b-8e65-08002b2bd119");
pub const IID_ISupportErrorInfo = &IID_ISupportErrorInfo_Value;
pub const ISupportErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InterfaceSupportsErrorInfo: fn(
            self: *const ISupportErrorInfo,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISupportErrorInfo_InterfaceSupportsErrorInfo(self: *const T, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISupportErrorInfo.VTable, self.vtable).InterfaceSupportsErrorInfo(@ptrCast(*const ISupportErrorInfo, self), riid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeFactory_Value = @import("../zig.zig").Guid.initString("0000002e-0000-0000-c000-000000000046");
pub const IID_ITypeFactory = &IID_ITypeFactory_Value;
pub const ITypeFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateFromTypeInfo: fn(
            self: *const ITypeFactory,
            pTypeInfo: ?*ITypeInfo,
            riid: ?*const Guid,
            ppv: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeFactory_CreateFromTypeInfo(self: *const T, pTypeInfo: ?*ITypeInfo, riid: ?*const Guid, ppv: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeFactory.VTable, self.vtable).CreateFromTypeInfo(@ptrCast(*const ITypeFactory, self), pTypeInfo, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeMarshal_Value = @import("../zig.zig").Guid.initString("0000002d-0000-0000-c000-000000000046");
pub const IID_ITypeMarshal = &IID_ITypeMarshal_Value;
pub const ITypeMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Size: fn(
            self: *const ITypeMarshal,
            pvType: ?*c_void,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            pSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Marshal: fn(
            self: *const ITypeMarshal,
            pvType: ?*c_void,
            dwDestContext: u32,
            pvDestContext: ?*c_void,
            cbBufferLength: u32,
            // TODO: what to do with BytesParamIndex 3?
            pBuffer: ?*u8,
            pcbWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmarshal: fn(
            self: *const ITypeMarshal,
            pvType: ?*c_void,
            dwFlags: u32,
            cbBufferLength: u32,
            pBuffer: [*:0]u8,
            pcbRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: fn(
            self: *const ITypeMarshal,
            pvType: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeMarshal_Size(self: *const T, pvType: ?*c_void, dwDestContext: u32, pvDestContext: ?*c_void, pSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeMarshal.VTable, self.vtable).Size(@ptrCast(*const ITypeMarshal, self), pvType, dwDestContext, pvDestContext, pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeMarshal_Marshal(self: *const T, pvType: ?*c_void, dwDestContext: u32, pvDestContext: ?*c_void, cbBufferLength: u32, pBuffer: ?*u8, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeMarshal.VTable, self.vtable).Marshal(@ptrCast(*const ITypeMarshal, self), pvType, dwDestContext, pvDestContext, cbBufferLength, pBuffer, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeMarshal_Unmarshal(self: *const T, pvType: ?*c_void, dwFlags: u32, cbBufferLength: u32, pBuffer: [*:0]u8, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeMarshal.VTable, self.vtable).Unmarshal(@ptrCast(*const ITypeMarshal, self), pvType, dwFlags, cbBufferLength, pBuffer, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeMarshal_Free(self: *const T, pvType: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeMarshal.VTable, self.vtable).Free(@ptrCast(*const ITypeMarshal, self), pvType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRecordInfo_Value = @import("../zig.zig").Guid.initString("0000002f-0000-0000-c000-000000000046");
pub const IID_IRecordInfo = &IID_IRecordInfo_Value;
pub const IRecordInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RecordInit: fn(
            self: *const IRecordInfo,
            pvNew: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecordClear: fn(
            self: *const IRecordInfo,
            pvExisting: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecordCopy: fn(
            self: *const IRecordInfo,
            pvExisting: ?*c_void,
            pvNew: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuid: fn(
            self: *const IRecordInfo,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IRecordInfo,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IRecordInfo,
            pcbSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfo: fn(
            self: *const IRecordInfo,
            ppTypeInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetField: fn(
            self: *const IRecordInfo,
            pvData: ?*c_void,
            szFieldName: ?[*:0]const u16,
            pvarField: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldNoCopy: fn(
            self: *const IRecordInfo,
            pvData: ?*c_void,
            szFieldName: ?[*:0]const u16,
            pvarField: ?*VARIANT,
            ppvDataCArray: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutField: fn(
            self: *const IRecordInfo,
            wFlags: u32,
            pvData: ?*c_void,
            szFieldName: ?[*:0]const u16,
            pvarField: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutFieldNoCopy: fn(
            self: *const IRecordInfo,
            wFlags: u32,
            pvData: ?*c_void,
            szFieldName: ?[*:0]const u16,
            pvarField: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldNames: fn(
            self: *const IRecordInfo,
            pcNames: ?*u32,
            rgBstrNames: [*]?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMatchingType: fn(
            self: *const IRecordInfo,
            pRecordInfo: ?*IRecordInfo,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        RecordCreate: fn(
            self: *const IRecordInfo,
        ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
        RecordCreateCopy: fn(
            self: *const IRecordInfo,
            pvSource: ?*c_void,
            ppvDest: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecordDestroy: fn(
            self: *const IRecordInfo,
            pvRecord: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordInit(self: *const T, pvNew: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordInit(@ptrCast(*const IRecordInfo, self), pvNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordClear(self: *const T, pvExisting: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordClear(@ptrCast(*const IRecordInfo, self), pvExisting);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordCopy(self: *const T, pvExisting: ?*c_void, pvNew: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordCopy(@ptrCast(*const IRecordInfo, self), pvExisting, pvNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetGuid(self: *const T, pguid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetGuid(@ptrCast(*const IRecordInfo, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetName(@ptrCast(*const IRecordInfo, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetSize(self: *const T, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetSize(@ptrCast(*const IRecordInfo, self), pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetTypeInfo(self: *const T, ppTypeInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetTypeInfo(@ptrCast(*const IRecordInfo, self), ppTypeInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetField(self: *const T, pvData: ?*c_void, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetField(@ptrCast(*const IRecordInfo, self), pvData, szFieldName, pvarField);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetFieldNoCopy(self: *const T, pvData: ?*c_void, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT, ppvDataCArray: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetFieldNoCopy(@ptrCast(*const IRecordInfo, self), pvData, szFieldName, pvarField, ppvDataCArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_PutField(self: *const T, wFlags: u32, pvData: ?*c_void, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).PutField(@ptrCast(*const IRecordInfo, self), wFlags, pvData, szFieldName, pvarField);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_PutFieldNoCopy(self: *const T, wFlags: u32, pvData: ?*c_void, szFieldName: ?[*:0]const u16, pvarField: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).PutFieldNoCopy(@ptrCast(*const IRecordInfo, self), wFlags, pvData, szFieldName, pvarField);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_GetFieldNames(self: *const T, pcNames: ?*u32, rgBstrNames: [*]?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).GetFieldNames(@ptrCast(*const IRecordInfo, self), pcNames, rgBstrNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_IsMatchingType(self: *const T, pRecordInfo: ?*IRecordInfo) callconv(.Inline) BOOL {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).IsMatchingType(@ptrCast(*const IRecordInfo, self), pRecordInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordCreate(self: *const T) callconv(.Inline) ?*c_void {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordCreate(@ptrCast(*const IRecordInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordCreateCopy(self: *const T, pvSource: ?*c_void, ppvDest: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordCreateCopy(@ptrCast(*const IRecordInfo, self), pvSource, ppvDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRecordInfo_RecordDestroy(self: *const T, pvRecord: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRecordInfo.VTable, self.vtable).RecordDestroy(@ptrCast(*const IRecordInfo, self), pvRecord);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLog_Value = @import("../zig.zig").Guid.initString("3127ca40-446e-11ce-8135-00aa004bb851");
pub const IID_IErrorLog = &IID_IErrorLog_Value;
pub const IErrorLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddError: fn(
            self: *const IErrorLog,
            pszPropName: ?[*:0]const u16,
            pExcepInfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorLog_AddError(self: *const T, pszPropName: ?[*:0]const u16, pExcepInfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorLog.VTable, self.vtable).AddError(@ptrCast(*const IErrorLog, self), pszPropName, pExcepInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPropertyBag_Value = @import("../zig.zig").Guid.initString("55272a00-42cb-11ce-8135-00aa004bb851");
pub const IID_IPropertyBag = &IID_IPropertyBag_Value;
pub const IPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: fn(
            self: *const IPropertyBag,
            pszPropName: ?[*:0]const u16,
            pVar: ?*VARIANT,
            pErrorLog: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IPropertyBag,
            pszPropName: ?[*:0]const u16,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Read(self: *const T, pszPropName: ?[*:0]const u16, pVar: ?*VARIANT, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag.VTable, self.vtable).Read(@ptrCast(*const IPropertyBag, self), pszPropName, pVar, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Write(self: *const T, pszPropName: ?[*:0]const u16, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyBag.VTable, self.vtable).Write(@ptrCast(*const IPropertyBag, self), pszPropName, pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistrationReader_Value = @import("../zig.zig").Guid.initString("ed6a8a2a-b160-4e77-8f73-aa7435cd5c27");
pub const IID_ITypeLibRegistrationReader = &IID_ITypeLibRegistrationReader_Value;
pub const ITypeLibRegistrationReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumTypeLibRegistrations: fn(
            self: *const ITypeLibRegistrationReader,
            ppEnumUnknown: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistrationReader_EnumTypeLibRegistrations(self: *const T, ppEnumUnknown: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistrationReader.VTable, self.vtable).EnumTypeLibRegistrations(@ptrCast(*const ITypeLibRegistrationReader, self), ppEnumUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistration_Value = @import("../zig.zig").Guid.initString("76a3e735-02df-4a12-98eb-043ad3600af3");
pub const IID_ITypeLibRegistration = &IID_ITypeLibRegistration_Value;
pub const ITypeLibRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuid: fn(
            self: *const ITypeLibRegistration,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITypeLibRegistration,
            pVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLcid: fn(
            self: *const ITypeLibRegistration,
            pLcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin32Path: fn(
            self: *const ITypeLibRegistration,
            pWin32Path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin64Path: fn(
            self: *const ITypeLibRegistration,
            pWin64Path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const ITypeLibRegistration,
            pDisplayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const ITypeLibRegistration,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpDir: fn(
            self: *const ITypeLibRegistration,
            pHelpDir: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetGuid(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetGuid(@ptrCast(*const ITypeLibRegistration, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetVersion(self: *const T, pVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetVersion(@ptrCast(*const ITypeLibRegistration, self), pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetLcid(self: *const T, pLcid: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetLcid(@ptrCast(*const ITypeLibRegistration, self), pLcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetWin32Path(self: *const T, pWin32Path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetWin32Path(@ptrCast(*const ITypeLibRegistration, self), pWin32Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetWin64Path(self: *const T, pWin64Path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetWin64Path(@ptrCast(*const ITypeLibRegistration, self), pWin64Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetDisplayName(self: *const T, pDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetDisplayName(@ptrCast(*const ITypeLibRegistration, self), pDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetFlags(@ptrCast(*const ITypeLibRegistration, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetHelpDir(self: *const T, pHelpDir: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetHelpDir(@ptrCast(*const ITypeLibRegistration, self), pHelpDir);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NUMPARSE = extern struct {
    cDig: i32,
    dwInFlags: u32,
    dwOutFlags: u32,
    cchUsed: i32,
    nBaseShift: i32,
    nPwr10: i32,
};

pub const UDATE = extern struct {
    st: SYSTEMTIME,
    wDayOfYear: u16,
};

pub const REGKIND = enum(i32) {
    DEFAULT = 0,
    REGISTER = 1,
    NONE = 2,
};
pub const REGKIND_DEFAULT = REGKIND.DEFAULT;
pub const REGKIND_REGISTER = REGKIND.REGISTER;
pub const REGKIND_NONE = REGKIND.NONE;

pub const PARAMDATA = extern struct {
    szName: ?PWSTR,
    vt: u16,
};

pub const METHODDATA = extern struct {
    szName: ?PWSTR,
    ppdata: ?*PARAMDATA,
    dispid: i32,
    iMeth: u32,
    cc: CALLCONV,
    cArgs: u32,
    wFlags: u16,
    vtReturn: u16,
};

pub const INTERFACEDATA = extern struct {
    pmethdata: ?*METHODDATA,
    cMembers: u32,
};

const IID_IDispatchEx_Value = @import("../zig.zig").Guid.initString("a6ef9860-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IDispatchEx = &IID_IDispatchEx_Value;
pub const IDispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDispID: fn(
            self: *const IDispatchEx,
            bstrName: ?BSTR,
            grfdex: u32,
            pid: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeEx: fn(
            self: *const IDispatchEx,
            id: i32,
            lcid: u32,
            wFlags: u16,
            pdp: ?*DISPPARAMS,
            pvarRes: ?*VARIANT,
            pei: ?*EXCEPINFO,
            pspCaller: ?*IServiceProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMemberByName: fn(
            self: *const IDispatchEx,
            bstrName: ?BSTR,
            grfdex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMemberByDispID: fn(
            self: *const IDispatchEx,
            id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberProperties: fn(
            self: *const IDispatchEx,
            id: i32,
            grfdexFetch: u32,
            pgrfdex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberName: fn(
            self: *const IDispatchEx,
            id: i32,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextDispID: fn(
            self: *const IDispatchEx,
            grfdex: u32,
            id: i32,
            pid: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameSpaceParent: fn(
            self: *const IDispatchEx,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_GetDispID(self: *const T, bstrName: ?BSTR, grfdex: u32, pid: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).GetDispID(@ptrCast(*const IDispatchEx, self), bstrName, grfdex, pid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_InvokeEx(self: *const T, id: i32, lcid: u32, wFlags: u16, pdp: ?*DISPPARAMS, pvarRes: ?*VARIANT, pei: ?*EXCEPINFO, pspCaller: ?*IServiceProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).InvokeEx(@ptrCast(*const IDispatchEx, self), id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_DeleteMemberByName(self: *const T, bstrName: ?BSTR, grfdex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).DeleteMemberByName(@ptrCast(*const IDispatchEx, self), bstrName, grfdex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_DeleteMemberByDispID(self: *const T, id: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).DeleteMemberByDispID(@ptrCast(*const IDispatchEx, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_GetMemberProperties(self: *const T, id: i32, grfdexFetch: u32, pgrfdex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).GetMemberProperties(@ptrCast(*const IDispatchEx, self), id, grfdexFetch, pgrfdex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_GetMemberName(self: *const T, id: i32, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).GetMemberName(@ptrCast(*const IDispatchEx, self), id, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_GetNextDispID(self: *const T, grfdex: u32, id: i32, pid: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).GetNextDispID(@ptrCast(*const IDispatchEx, self), grfdex, id, pid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatchEx_GetNameSpaceParent(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatchEx.VTable, self.vtable).GetNameSpaceParent(@ptrCast(*const IDispatchEx, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDispError_Value = @import("../zig.zig").Guid.initString("a6ef9861-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IDispError = &IID_IDispError_Value;
pub const IDispError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryErrorInfo: fn(
            self: *const IDispError,
            guidErrorType: Guid,
            ppde: ?*?*IDispError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDispError,
            ppde: ?*?*IDispError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHresult: fn(
            self: *const IDispError,
            phr: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: fn(
            self: *const IDispError,
            pbstrSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpInfo: fn(
            self: *const IDispError,
            pbstrFileName: ?*?BSTR,
            pdwContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IDispError,
            pbstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_QueryErrorInfo(self: *const T, guidErrorType: Guid, ppde: ?*?*IDispError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).QueryErrorInfo(@ptrCast(*const IDispError, self), guidErrorType, ppde);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_GetNext(self: *const T, ppde: ?*?*IDispError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).GetNext(@ptrCast(*const IDispError, self), ppde);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_GetHresult(self: *const T, phr: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).GetHresult(@ptrCast(*const IDispError, self), phr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_GetSource(self: *const T, pbstrSource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).GetSource(@ptrCast(*const IDispError, self), pbstrSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_GetHelpInfo(self: *const T, pbstrFileName: ?*?BSTR, pdwContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).GetHelpInfo(@ptrCast(*const IDispError, self), pbstrFileName, pdwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispError_GetDescription(self: *const T, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispError.VTable, self.vtable).GetDescription(@ptrCast(*const IDispError, self), pbstrDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVariantChangeType_Value = @import("../zig.zig").Guid.initString("a6ef9862-c720-11d0-9337-00a0c90dcaa9");
pub const IID_IVariantChangeType = &IID_IVariantChangeType_Value;
pub const IVariantChangeType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ChangeType: fn(
            self: *const IVariantChangeType,
            pvarDst: ?*VARIANT,
            pvarSrc: ?*VARIANT,
            lcid: u32,
            vtNew: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVariantChangeType_ChangeType(self: *const T, pvarDst: ?*VARIANT, pvarSrc: ?*VARIANT, lcid: u32, vtNew: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVariantChangeType.VTable, self.vtable).ChangeType(@ptrCast(*const IVariantChangeType, self), pvarDst, pvarSrc, lcid, vtNew);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectIdentity_Value = @import("../zig.zig").Guid.initString("ca04b7e6-0d21-11d1-8cc5-00c04fc2b085");
pub const IID_IObjectIdentity = &IID_IObjectIdentity_Value;
pub const IObjectIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEqualObject: fn(
            self: *const IObjectIdentity,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIdentity_IsEqualObject(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIdentity.VTable, self.vtable).IsEqualObject(@ptrCast(*const IObjectIdentity, self), punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanHandleException_Value = @import("../zig.zig").Guid.initString("c5598e60-b307-11d1-b27d-006008c3fbfb");
pub const IID_ICanHandleException = &IID_ICanHandleException_Value;
pub const ICanHandleException = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanHandleException: fn(
            self: *const ICanHandleException,
            pExcepInfo: ?*EXCEPINFO,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanHandleException_CanHandleException(self: *const T, pExcepInfo: ?*EXCEPINFO, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanHandleException.VTable, self.vtable).CanHandleException(@ptrCast(*const ICanHandleException, self), pExcepInfo, pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideRuntimeContext_Value = @import("../zig.zig").Guid.initString("10e2414a-ec59-49d2-bc51-5add2c36febc");
pub const IID_IProvideRuntimeContext = &IID_IProvideRuntimeContext_Value;
pub const IProvideRuntimeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentSourceContext: fn(
            self: *const IProvideRuntimeContext,
            pdwContext: ?*usize,
            pfExecutingGlobalCode: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideRuntimeContext_GetCurrentSourceContext(self: *const T, pdwContext: ?*usize, pfExecutingGlobalCode: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideRuntimeContext.VTable, self.vtable).GetCurrentSourceContext(@ptrCast(*const IProvideRuntimeContext, self), pdwContext, pfExecutingGlobalCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VARENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    I2 = 2,
    I4 = 3,
    R4 = 4,
    R8 = 5,
    CY = 6,
    DATE = 7,
    BSTR = 8,
    DISPATCH = 9,
    ERROR = 10,
    BOOL = 11,
    VARIANT = 12,
    UNKNOWN = 13,
    DECIMAL = 14,
    I1 = 16,
    UI1 = 17,
    UI2 = 18,
    UI4 = 19,
    I8 = 20,
    UI8 = 21,
    INT = 22,
    UINT = 23,
    VOID = 24,
    HRESULT = 25,
    PTR = 26,
    SAFEARRAY = 27,
    CARRAY = 28,
    USERDEFINED = 29,
    LPSTR = 30,
    LPWSTR = 31,
    RECORD = 36,
    INT_PTR = 37,
    UINT_PTR = 38,
    FILETIME = 64,
    BLOB = 65,
    STREAM = 66,
    STORAGE = 67,
    STREAMED_OBJECT = 68,
    STORED_OBJECT = 69,
    BLOB_OBJECT = 70,
    CF = 71,
    CLSID = 72,
    VERSIONED_STREAM = 73,
    BSTR_BLOB = 4095,
    VECTOR = 4096,
    ARRAY = 8192,
    BYREF = 16384,
    RESERVED = 32768,
    ILLEGAL = 65535,
    // ILLEGALMASKED = 4095, this enum value conflicts with BSTR_BLOB
    // TYPEMASK = 4095, this enum value conflicts with BSTR_BLOB
};
pub const VT_EMPTY = VARENUM.EMPTY;
pub const VT_NULL = VARENUM.NULL;
pub const VT_I2 = VARENUM.I2;
pub const VT_I4 = VARENUM.I4;
pub const VT_R4 = VARENUM.R4;
pub const VT_R8 = VARENUM.R8;
pub const VT_CY = VARENUM.CY;
pub const VT_DATE = VARENUM.DATE;
pub const VT_BSTR = VARENUM.BSTR;
pub const VT_DISPATCH = VARENUM.DISPATCH;
pub const VT_ERROR = VARENUM.ERROR;
pub const VT_BOOL = VARENUM.BOOL;
pub const VT_VARIANT = VARENUM.VARIANT;
pub const VT_UNKNOWN = VARENUM.UNKNOWN;
pub const VT_DECIMAL = VARENUM.DECIMAL;
pub const VT_I1 = VARENUM.I1;
pub const VT_UI1 = VARENUM.UI1;
pub const VT_UI2 = VARENUM.UI2;
pub const VT_UI4 = VARENUM.UI4;
pub const VT_I8 = VARENUM.I8;
pub const VT_UI8 = VARENUM.UI8;
pub const VT_INT = VARENUM.INT;
pub const VT_UINT = VARENUM.UINT;
pub const VT_VOID = VARENUM.VOID;
pub const VT_HRESULT = VARENUM.HRESULT;
pub const VT_PTR = VARENUM.PTR;
pub const VT_SAFEARRAY = VARENUM.SAFEARRAY;
pub const VT_CARRAY = VARENUM.CARRAY;
pub const VT_USERDEFINED = VARENUM.USERDEFINED;
pub const VT_LPSTR = VARENUM.LPSTR;
pub const VT_LPWSTR = VARENUM.LPWSTR;
pub const VT_RECORD = VARENUM.RECORD;
pub const VT_INT_PTR = VARENUM.INT_PTR;
pub const VT_UINT_PTR = VARENUM.UINT_PTR;
pub const VT_FILETIME = VARENUM.FILETIME;
pub const VT_BLOB = VARENUM.BLOB;
pub const VT_STREAM = VARENUM.STREAM;
pub const VT_STORAGE = VARENUM.STORAGE;
pub const VT_STREAMED_OBJECT = VARENUM.STREAMED_OBJECT;
pub const VT_STORED_OBJECT = VARENUM.STORED_OBJECT;
pub const VT_BLOB_OBJECT = VARENUM.BLOB_OBJECT;
pub const VT_CF = VARENUM.CF;
pub const VT_CLSID = VARENUM.CLSID;
pub const VT_VERSIONED_STREAM = VARENUM.VERSIONED_STREAM;
pub const VT_BSTR_BLOB = VARENUM.BSTR_BLOB;
pub const VT_VECTOR = VARENUM.VECTOR;
pub const VT_ARRAY = VARENUM.ARRAY;
pub const VT_BYREF = VARENUM.BYREF;
pub const VT_RESERVED = VARENUM.RESERVED;
pub const VT_ILLEGAL = VARENUM.ILLEGAL;
pub const VT_ILLEGALMASKED = VARENUM.BSTR_BLOB;
pub const VT_TYPEMASK = VARENUM.BSTR_BLOB;


//--------------------------------------------------------------------------------
// Section: Functions (402)
//--------------------------------------------------------------------------------
pub extern "OLEAUT32" fn BSTR_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn BSTR_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn BSTR_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn BSTR_UserFree(
    param0: ?*u32,
    param1: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HWND_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HWND_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HWND_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HWND_UserFree(
    param0: ?*u32,
    param1: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn VARIANT_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn VARIANT_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn VARIANT_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn VARIANT_UserFree(
    param0: ?*u32,
    param1: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn BSTR_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn BSTR_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn BSTR_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn BSTR_UserFree64(
    param0: ?*u32,
    param1: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HWND_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HWND_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HWND_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HWND_UserFree64(
    param0: ?*u32,
    param1: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn VARIANT_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn VARIANT_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn VARIANT_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn VARIANT_UserFree64(
    param0: ?*u32,
    param1: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn DosDateTimeToVariantTime(
    wDosDate: u16,
    wDosTime: u16,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "OLEAUT32" fn VariantTimeToDosDateTime(
    vtime: f64,
    pwDosDate: ?*u16,
    pwDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "OLEAUT32" fn SystemTimeToVariantTime(
    lpSystemTime: ?*SYSTEMTIME,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "OLEAUT32" fn VariantTimeToSystemTime(
    vtime: f64,
    lpSystemTime: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "OLEAUT32" fn SafeArrayAllocDescriptor(
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayAllocDescriptorEx(
    vt: u16,
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayAllocData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayCreate(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "OLEAUT32" fn SafeArrayCreateEx(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
    pvExtra: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "OLEAUT32" fn SafeArrayCopyData(
    psaSource: ?*SAFEARRAY,
    psaTarget: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn SafeArrayReleaseDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn SafeArrayDestroyDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn SafeArrayReleaseData(
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn SafeArrayDestroyData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn SafeArrayAddRef(
    psa: ?*SAFEARRAY,
    ppDataToRelease: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayDestroy(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayRedim(
    psa: ?*SAFEARRAY,
    psaboundNew: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetDim(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn SafeArrayGetElemsize(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn SafeArrayGetUBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plUbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetLBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plLbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayLock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayUnlock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayAccessData(
    psa: ?*SAFEARRAY,
    ppvData: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayUnaccessData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayPutElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayCopy(
    psa: ?*SAFEARRAY,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayPtrOfIndex(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    ppvData: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArraySetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: ?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArraySetIID(
    psa: ?*SAFEARRAY,
    guid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetIID(
    psa: ?*SAFEARRAY,
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayGetVartype(
    psa: ?*SAFEARRAY,
    pvt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SafeArrayCreateVector(
    vt: u16,
    lLbound: i32,
    cElements: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "OLEAUT32" fn SafeArrayCreateVectorEx(
    vt: u16,
    lLbound: i32,
    cElements: u32,
    pvExtra: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

pub extern "OLEAUT32" fn VariantInit(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn VariantClear(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VariantCopy(
    pvargDest: ?*VARIANT,
    pvargSrc: ?*const VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VariantCopyInd(
    pvarDest: ?*VARIANT,
    pvargSrc: ?*const VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VariantChangeType(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*const VARIANT,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VariantChangeTypeEx(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*const VARIANT,
    lcid: u32,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VectorFromBstr(
    bstr: ?BSTR,
    ppsa: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn BstrFromVector(
    psa: ?*SAFEARRAY,
    pbstr: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromI2(
    sIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromI4(
    lIn: i32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromI8(
    i64In: i64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromR4(
    fltIn: f32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromR8(
    dblIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromCy(
    cyIn: CY,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromDate(
    dateIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromBool(
    boolIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromI1(
    cIn: CHAR,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromUI2(
    uiIn: u16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromUI4(
    ulIn: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromUI8(
    ui64In: u64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI1FromDec(
    pdecIn: ?*const DECIMAL,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromUI1(
    bIn: u8,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromI4(
    lIn: i32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromI8(
    i64In: i64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromR4(
    fltIn: f32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromR8(
    dblIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromCy(
    cyIn: CY,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromDate(
    dateIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromBool(
    boolIn: i16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromI1(
    cIn: CHAR,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromUI2(
    uiIn: u16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromUI4(
    ulIn: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromUI8(
    ui64In: u64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI2FromDec(
    pdecIn: ?*const DECIMAL,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromUI1(
    bIn: u8,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromI2(
    sIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromI8(
    i64In: i64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromR4(
    fltIn: f32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromR8(
    dblIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromCy(
    cyIn: CY,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromDate(
    dateIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromBool(
    boolIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromI1(
    cIn: CHAR,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromUI2(
    uiIn: u16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromUI4(
    ulIn: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromUI8(
    ui64In: u64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI4FromDec(
    pdecIn: ?*const DECIMAL,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromUI1(
    bIn: u8,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromI2(
    sIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromR4(
    fltIn: f32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromR8(
    dblIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromCy(
    cyIn: CY,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromDate(
    dateIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromBool(
    boolIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromI1(
    cIn: CHAR,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromUI2(
    uiIn: u16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromUI4(
    ulIn: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromUI8(
    ui64In: u64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI8FromDec(
    pdecIn: ?*const DECIMAL,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromUI1(
    bIn: u8,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromI2(
    sIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromI4(
    lIn: i32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromI8(
    i64In: i64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromR8(
    dblIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromCy(
    cyIn: CY,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromDate(
    dateIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromBool(
    boolIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromI1(
    cIn: CHAR,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromUI2(
    uiIn: u16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromUI4(
    ulIn: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromUI8(
    ui64In: u64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4FromDec(
    pdecIn: ?*const DECIMAL,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromUI1(
    bIn: u8,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromI2(
    sIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromI4(
    lIn: i32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromI8(
    i64In: i64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromR4(
    fltIn: f32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromCy(
    cyIn: CY,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromDate(
    dateIn: f64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromBool(
    boolIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromI1(
    cIn: CHAR,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromUI2(
    uiIn: u16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromUI4(
    ulIn: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromUI8(
    ui64In: u64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8FromDec(
    pdecIn: ?*const DECIMAL,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUI1(
    bIn: u8,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromI2(
    sIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromI4(
    lIn: i32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromI8(
    i64In: i64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromR4(
    fltIn: f32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromR8(
    dblIn: f64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromCy(
    cyIn: CY,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromBool(
    boolIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromI1(
    cIn: CHAR,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUI2(
    uiIn: u16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUI4(
    ulIn: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUI8(
    ui64In: u64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromDec(
    pdecIn: ?*const DECIMAL,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromUI1(
    bIn: u8,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromI2(
    sIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromI4(
    lIn: i32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromI8(
    i64In: i64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromR4(
    fltIn: f32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromR8(
    dblIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromDate(
    dateIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromBool(
    boolIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromI1(
    cIn: CHAR,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromUI2(
    uiIn: u16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromUI4(
    ulIn: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromUI8(
    ui64In: u64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFromDec(
    pdecIn: ?*const DECIMAL,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromUI1(
    bVal: u8,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromI2(
    iVal: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromI4(
    lIn: i32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromI8(
    i64In: i64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromR4(
    fltIn: f32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromR8(
    dblIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromCy(
    cyIn: CY,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromDate(
    dateIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromBool(
    boolIn: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromI1(
    cIn: CHAR,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromUI2(
    uiIn: u16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromUI4(
    ulIn: u32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromUI8(
    ui64In: u64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrFromDec(
    pdecIn: ?*const DECIMAL,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromUI1(
    bIn: u8,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromI2(
    sIn: i16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromI4(
    lIn: i32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromI8(
    i64In: i64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromR4(
    fltIn: f32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromR8(
    dblIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromDate(
    dateIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromCy(
    cyIn: CY,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromI1(
    cIn: CHAR,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromUI2(
    uiIn: u16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromUI4(
    ulIn: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromUI8(
    i64In: u64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBoolFromDec(
    pdecIn: ?*const DECIMAL,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromUI1(
    bIn: u8,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromI2(
    uiIn: i16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromI4(
    lIn: i32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromI8(
    i64In: i64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromR4(
    fltIn: f32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromR8(
    dblIn: f64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromDate(
    dateIn: f64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromCy(
    cyIn: CY,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromBool(
    boolIn: i16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromUI2(
    uiIn: u16,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromUI4(
    ulIn: u32,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromUI8(
    i64In: u64,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarI1FromDec(
    pdecIn: ?*const DECIMAL,
    pcOut: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromUI1(
    bIn: u8,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromI2(
    uiIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromI4(
    lIn: i32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromI8(
    i64In: i64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromR4(
    fltIn: f32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromR8(
    dblIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromDate(
    dateIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromCy(
    cyIn: CY,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromBool(
    boolIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromI1(
    cIn: CHAR,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromUI4(
    ulIn: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromUI8(
    i64In: u64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI2FromDec(
    pdecIn: ?*const DECIMAL,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromUI1(
    bIn: u8,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromI2(
    uiIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromI4(
    lIn: i32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromI8(
    i64In: i64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromR4(
    fltIn: f32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromR8(
    dblIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromDate(
    dateIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromCy(
    cyIn: CY,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromBool(
    boolIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromI1(
    cIn: CHAR,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromUI2(
    uiIn: u16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromUI8(
    ui64In: u64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI4FromDec(
    pdecIn: ?*const DECIMAL,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromUI1(
    bIn: u8,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromI2(
    sIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromI8(
    ui64In: i64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromR4(
    fltIn: f32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromR8(
    dblIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromCy(
    cyIn: CY,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromDate(
    dateIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromBool(
    boolIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromI1(
    cIn: CHAR,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromUI2(
    uiIn: u16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromUI4(
    ulIn: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUI8FromDec(
    pdecIn: ?*const DECIMAL,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromUI1(
    bIn: u8,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromI2(
    uiIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromI4(
    lIn: i32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromI8(
    i64In: i64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromR4(
    fltIn: f32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromR8(
    dblIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromDate(
    dateIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromCy(
    cyIn: CY,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromDisp(
    pdispIn: ?*IDispatch,
    lcid: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromBool(
    boolIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromI1(
    cIn: CHAR,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromUI2(
    uiIn: u16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromUI4(
    ulIn: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFromUI8(
    ui64In: u64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarParseNumFromStr(
    strIn: ?[*:0]const u16,
    lcid: u32,
    dwFlags: u32,
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarNumFromParseNum(
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
    dwVtBits: u32,
    pvar: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarAdd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarAnd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCat(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarEqv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarIdiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarImp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarMod(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarMul(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarOr(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarPow(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarSub(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarXor(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarAbs(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFix(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarInt(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarNeg(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarNot(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarRound(
    pvarIn: ?*VARIANT,
    cDecimals: i32,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCmp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecAdd(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecDiv(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecMul(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecSub(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecAbs(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecFix(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecInt(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecNeg(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecRound(
    pdecIn: ?*DECIMAL,
    cDecimals: i32,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecCmp(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDecCmpR8(
    pdecLeft: ?*DECIMAL,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyAdd(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyMul(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyMulI4(
    cyLeft: CY,
    lRight: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyMulI8(
    cyLeft: CY,
    lRight: i64,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCySub(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyAbs(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyFix(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyInt(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyNeg(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyRound(
    cyIn: CY,
    cDecimals: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyCmp(
    cyLeft: CY,
    cyRight: CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarCyCmpR8(
    cyLeft: CY,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrCat(
    bstrLeft: ?BSTR,
    bstrRight: ?BSTR,
    pbstrResult: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarBstrCmp(
    bstrLeft: ?BSTR,
    bstrRight: ?BSTR,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8Pow(
    dblLeft: f64,
    dblRight: f64,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR4CmpR8(
    fltLeft: f32,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarR8Round(
    dblIn: f64,
    cDecimals: i32,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUdate(
    pudateIn: ?*UDATE,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarDateFromUdateEx(
    pudateIn: ?*UDATE,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarUdateFromDate(
    dateIn: f64,
    dwFlags: u32,
    pudateOut: ?*UDATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetAltMonthNames(
    lcid: u32,
    prgp: ?*?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormat(
    pvarIn: ?*VARIANT,
    pstrFormat: ?PWSTR,
    iFirstDay: i32,
    iFirstWeek: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormatDateTime(
    pvarIn: ?*VARIANT,
    iNamedFormat: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormatNumber(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormatPercent(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormatCurrency(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarWeekdayName(
    iWeekday: i32,
    fAbbrev: i32,
    iFirstDay: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarMonthName(
    iMonth: i32,
    fAbbrev: i32,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarFormatFromTokens(
    pvarIn: ?*VARIANT,
    pstrFormat: ?PWSTR,
    pbTokCur: ?*u8,
    dwFlags: u32,
    pbstrOut: ?*?BSTR,
    lcid: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn VarTokenizeFormatString(
    pstrFormat: ?PWSTR,
    rgbTok: [*:0]u8,
    cbTok: i32,
    iFirstDay: i32,
    iFirstWeek: i32,
    lcid: u32,
    pcbActual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn LHashValOfNameSysA(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn LHashValOfNameSys(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn LoadTypeLib(
    szFile: ?[*:0]const u16,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn LoadTypeLibEx(
    szFile: ?[*:0]const u16,
    regkind: REGKIND,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn LoadRegTypeLib(
    rguid: ?*const Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    pptlib: ?*?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn QueryPathOfRegTypeLib(
    guid: ?*const Guid,
    wMaj: u16,
    wMin: u16,
    lcid: u32,
    lpbstrPathName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn RegisterTypeLib(
    ptlib: ?*ITypeLib,
    szFullPath: ?[*:0]const u16,
    szHelpDir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn UnRegisterTypeLib(
    libID: ?*const Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn RegisterTypeLibForUser(
    ptlib: ?*ITypeLib,
    szFullPath: ?PWSTR,
    szHelpDir: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn UnRegisterTypeLibForUser(
    libID: ?*const Guid,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn CreateTypeLib(
    syskind: SYSKIND,
    szFile: ?[*:0]const u16,
    ppctlib: ?*?*ICreateTypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn CreateTypeLib2(
    syskind: SYSKIND,
    szFile: ?[*:0]const u16,
    ppctlib: ?*?*ICreateTypeLib2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn DispGetParam(
    pdispparams: ?*DISPPARAMS,
    position: u32,
    vtTarg: u16,
    pvarResult: ?*VARIANT,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn DispGetIDsOfNames(
    ptinfo: ?*ITypeInfo,
    rgszNames: [*]?PWSTR,
    cNames: u32,
    rgdispid: [*]i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn DispInvoke(
    _this: ?*c_void,
    ptinfo: ?*ITypeInfo,
    dispidMember: i32,
    wFlags: u16,
    pparams: ?*DISPPARAMS,
    pvarResult: ?*VARIANT,
    pexcepinfo: ?*EXCEPINFO,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn CreateDispTypeInfo(
    pidata: ?*INTERFACEDATA,
    lcid: u32,
    pptinfo: ?*?*ITypeInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn CreateStdDispatch(
    punkOuter: ?*IUnknown,
    pvThis: ?*c_void,
    ptinfo: ?*ITypeInfo,
    ppunkStdDisp: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn DispCallFunc(
    pvInstance: ?*c_void,
    oVft: usize,
    cc: CALLCONV,
    vtReturn: u16,
    cActuals: u32,
    prgvt: [*:0]u16,
    prgpvarg: [*]?*VARIANT,
    pvargResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn RegisterActiveObject(
    punk: ?*IUnknown,
    rclsid: ?*const Guid,
    dwFlags: u32,
    pdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn RevokeActiveObject(
    dwRegister: u32,
    pvReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetActiveObject(
    rclsid: ?*const Guid,
    pvReserved: ?*c_void,
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SetErrorInfo(
    dwReserved: u32,
    perrinfo: ?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetErrorInfo(
    dwReserved: u32,
    pperrinfo: ?*?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn CreateErrorInfo(
    pperrinfo: ?*?*ICreateErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetRecordInfoFromTypeInfo(
    pTypeInfo: ?*ITypeInfo,
    ppRecInfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetRecordInfoFromGuids(
    rGuidTypeLib: ?*const Guid,
    uVerMajor: u32,
    uVerMinor: u32,
    lcid: u32,
    rGuidTypeInfo: ?*const Guid,
    ppRecInfo: ?*?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn OaBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn ClearCustData(
    pCustData: ?*CUSTDATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn OaEnablePerUserTLibRegistration(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn STGMEDIUM_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn STGMEDIUM_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn STGMEDIUM_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn STGMEDIUM_UserFree(
    param0: ?*u32,
    param1: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn STGMEDIUM_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn STGMEDIUM_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn STGMEDIUM_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn STGMEDIUM_UserFree64(
    param0: ?*u32,
    param1: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEAUT32" fn OleLoadPictureFile(
    varFileName: VARIANT,
    lplpdispPicture: ?*?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn OleLoadPictureFileEx(
    varFileName: VARIANT,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpdispPicture: ?*?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn OleSavePictureFile(
    lpdispPicture: ?*IDispatch,
    bstrFileName: ?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn LPSAFEARRAY_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEAUT32" fn LPSAFEARRAY_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn LPSAFEARRAY_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLEAUT32" fn LPSAFEARRAY_UserFree(
    param0: ?*u32,
    param1: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn LPSAFEARRAY_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn LPSAFEARRAY_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn LPSAFEARRAY_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLEAUT32" fn LPSAFEARRAY_UserFree64(
    param0: ?*u32,
    param1: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (20)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const BYTE_SIZEDARR = @import("../system/com.zig").BYTE_SIZEDARR;
const CHAR = @import("../system/system_services.zig").CHAR;
const CY = @import("../system/system_services.zig").CY;
const DECIMAL = @import("../system/system_services.zig").DECIMAL;
const FLAGGED_WORD_BLOB = @import("../system/com.zig").FLAGGED_WORD_BLOB;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const HYPER_SIZEDARR = @import("../system/com.zig").HYPER_SIZEDARR;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IServiceProvider = @import("../system/system_services.zig").IServiceProvider;
const IUnknown = @import("../system/com.zig").IUnknown;
const LONG_SIZEDARR = @import("../system/com.zig").LONG_SIZEDARR;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SHORT_SIZEDARR = @import("../system/com.zig").SHORT_SIZEDARR;
const STGMEDIUM = @import("../system/com.zig").STGMEDIUM;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPEXCEPFINO_DEFERRED_FILLIN")) { _ = LPEXCEPFINO_DEFERRED_FILLIN; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (27)
//--------------------------------------------------------------------------------
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_0 = @as(u32, 0);
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_1 = @as(u32, 1);
pub const WSMAN_OPERATION_INFOV1 = @as(u32, 0);
pub const WSMAN_OPERATION_INFOV2 = @as(u32, 2864434397);
pub const WSMAN_DEFAULT_TIMEOUT_MS = @as(u32, 60000);
pub const WSMAN_FLAG_RECEIVE_RESULT_NO_MORE_DATA = @as(u32, 1);
pub const WSMAN_FLAG_RECEIVE_FLUSH = @as(u32, 2);
pub const WSMAN_FLAG_RECEIVE_RESULT_DATA_BOUNDARY = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_MAX_ENVELOPE_SIZE = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_TIMEOUT = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_REMAINING_RESULT_SIZE = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_LARGEST_RESULT_SIZE = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_LOCALE = @as(u32, 5);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_DATA_LOCALE = @as(u32, 6);
pub const WSMAN_PLUGIN_PARAMS_SHAREDHOST = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_RUNAS_USER = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_AUTORESTART = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_HOSTIDLETIMEOUTSECONDS = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_NAME = @as(u32, 5);
pub const WSMAN_PLUGIN_STARTUP_REQUEST_RECEIVED = @as(u32, 0);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_REBOOT = @as(u32, 1);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_CRASH = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_SYSTEM = @as(u32, 1);
pub const WSMAN_PLUGIN_SHUTDOWN_SERVICE = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_IISHOST = @as(u32, 3);
pub const WSMAN_PLUGIN_SHUTDOWN_IDLETIMEOUT_ELAPSED = @as(u32, 4);
pub const WSMAN_FLAG_SEND_NO_MORE_DATA = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (76)
//--------------------------------------------------------------------------------
pub const WSMAN_API = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_SESSION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_OPERATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_SHELL = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_COMMAND = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_DATA_TEXT = extern struct {
    bufferLength: u32,
    buffer: ?[*:0]const u16,
};

pub const WSMAN_DATA_BINARY = extern struct {
    dataLength: u32,
    data: ?*u8,
};

pub const WSManDataType = enum(i32) {
    NONE = 0,
    TYPE_TEXT = 1,
    TYPE_BINARY = 2,
    TYPE_DWORD = 4,
};
pub const WSMAN_DATA_NONE = WSManDataType.NONE;
pub const WSMAN_DATA_TYPE_TEXT = WSManDataType.TYPE_TEXT;
pub const WSMAN_DATA_TYPE_BINARY = WSManDataType.TYPE_BINARY;
pub const WSMAN_DATA_TYPE_DWORD = WSManDataType.TYPE_DWORD;

pub const WSMAN_DATA = extern struct {
    type: WSManDataType,
    Anonymous: extern union {
        text: WSMAN_DATA_TEXT,
        binaryData: WSMAN_DATA_BINARY,
        number: u32,
    },
};

pub const WSMAN_ERROR = extern struct {
    code: u32,
    errorDetail: ?[*:0]const u16,
    language: ?[*:0]const u16,
    machineName: ?[*:0]const u16,
    pluginName: ?[*:0]const u16,
};

pub const WSMAN_USERNAME_PASSWORD_CREDS = extern struct {
    username: ?[*:0]const u16,
    password: ?[*:0]const u16,
};

pub const WSManAuthenticationFlags = enum(i32) {
    DEFAULT_AUTHENTICATION = 0,
    NO_AUTHENTICATION = 1,
    AUTH_DIGEST = 2,
    AUTH_NEGOTIATE = 4,
    AUTH_BASIC = 8,
    AUTH_KERBEROS = 16,
    AUTH_CREDSSP = 128,
    AUTH_CLIENT_CERTIFICATE = 32,
};
pub const WSMAN_FLAG_DEFAULT_AUTHENTICATION = WSManAuthenticationFlags.DEFAULT_AUTHENTICATION;
pub const WSMAN_FLAG_NO_AUTHENTICATION = WSManAuthenticationFlags.NO_AUTHENTICATION;
pub const WSMAN_FLAG_AUTH_DIGEST = WSManAuthenticationFlags.AUTH_DIGEST;
pub const WSMAN_FLAG_AUTH_NEGOTIATE = WSManAuthenticationFlags.AUTH_NEGOTIATE;
pub const WSMAN_FLAG_AUTH_BASIC = WSManAuthenticationFlags.AUTH_BASIC;
pub const WSMAN_FLAG_AUTH_KERBEROS = WSManAuthenticationFlags.AUTH_KERBEROS;
pub const WSMAN_FLAG_AUTH_CREDSSP = WSManAuthenticationFlags.AUTH_CREDSSP;
pub const WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE = WSManAuthenticationFlags.AUTH_CLIENT_CERTIFICATE;

pub const WSMAN_AUTHENTICATION_CREDENTIALS = extern struct {
    authenticationMechanism: u32,
    Anonymous: extern union {
        userAccount: WSMAN_USERNAME_PASSWORD_CREDS,
        certificateThumbprint: ?[*:0]const u16,
    },
};

pub const WSMAN_OPTION = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
    mustComply: BOOL,
};

pub const WSMAN_OPTION_SET = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
};

pub const WSMAN_OPTION_SETEX = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
    optionTypes: ?*?PWSTR,
};

pub const WSMAN_KEY = extern struct {
    key: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_SELECTOR_SET = extern struct {
    numberKeys: u32,
    keys: ?*WSMAN_KEY,
};

pub const WSMAN_FRAGMENT = extern struct {
    path: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_FILTER = extern struct {
    filter: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_OPERATION_INFO = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SET,
    reserved: ?*c_void,
    version: u32,
};

pub const WSMAN_OPERATION_INFOEX = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SETEX,
    version: u32,
    uiLocale: ?[*:0]const u16,
    dataLocale: ?[*:0]const u16,
};

pub const WSManProxyAccessType = enum(i32) {
    IE_PROXY_CONFIG = 1,
    WINHTTP_PROXY_CONFIG = 2,
    AUTO_DETECT = 4,
    NO_PROXY_SERVER = 8,
};
pub const WSMAN_OPTION_PROXY_IE_PROXY_CONFIG = WSManProxyAccessType.IE_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG = WSManProxyAccessType.WINHTTP_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_AUTO_DETECT = WSManProxyAccessType.AUTO_DETECT;
pub const WSMAN_OPTION_PROXY_NO_PROXY_SERVER = WSManProxyAccessType.NO_PROXY_SERVER;

pub const WSMAN_PROXY_INFO = extern struct {
    accessType: u32,
    authenticationCredentials: WSMAN_AUTHENTICATION_CREDENTIALS,
};

pub const WSManSessionOption = enum(i32) {
    DEFAULT_OPERATION_TIMEOUTMS = 1,
    MAX_RETRY_TIME = 11,
    TIMEOUTMS_CREATE_SHELL = 12,
    TIMEOUTMS_RUN_SHELL_COMMAND = 13,
    TIMEOUTMS_RECEIVE_SHELL_OUTPUT = 14,
    TIMEOUTMS_SEND_SHELL_INPUT = 15,
    TIMEOUTMS_SIGNAL_SHELL = 16,
    TIMEOUTMS_CLOSE_SHELL = 17,
    SKIP_CA_CHECK = 18,
    SKIP_CN_CHECK = 19,
    UNENCRYPTED_MESSAGES = 20,
    UTF16 = 21,
    ENABLE_SPN_SERVER_PORT = 22,
    MACHINE_ID = 23,
    LOCALE = 25,
    UI_LANGUAGE = 26,
    MAX_ENVELOPE_SIZE_KB = 28,
    SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = 29,
    REDIRECT_LOCATION = 30,
    SKIP_REVOCATION_CHECK = 31,
    ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = 32,
    USE_SSL = 33,
    USE_INTEARACTIVE_TOKEN = 34,
};
pub const WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = WSManSessionOption.DEFAULT_OPERATION_TIMEOUTMS;
pub const WSMAN_OPTION_MAX_RETRY_TIME = WSManSessionOption.MAX_RETRY_TIME;
pub const WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL = WSManSessionOption.TIMEOUTMS_CREATE_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND = WSManSessionOption.TIMEOUTMS_RUN_SHELL_COMMAND;
pub const WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT = WSManSessionOption.TIMEOUTMS_RECEIVE_SHELL_OUTPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT = WSManSessionOption.TIMEOUTMS_SEND_SHELL_INPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL = WSManSessionOption.TIMEOUTMS_SIGNAL_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL = WSManSessionOption.TIMEOUTMS_CLOSE_SHELL;
pub const WSMAN_OPTION_SKIP_CA_CHECK = WSManSessionOption.SKIP_CA_CHECK;
pub const WSMAN_OPTION_SKIP_CN_CHECK = WSManSessionOption.SKIP_CN_CHECK;
pub const WSMAN_OPTION_UNENCRYPTED_MESSAGES = WSManSessionOption.UNENCRYPTED_MESSAGES;
pub const WSMAN_OPTION_UTF16 = WSManSessionOption.UTF16;
pub const WSMAN_OPTION_ENABLE_SPN_SERVER_PORT = WSManSessionOption.ENABLE_SPN_SERVER_PORT;
pub const WSMAN_OPTION_MACHINE_ID = WSManSessionOption.MACHINE_ID;
pub const WSMAN_OPTION_LOCALE = WSManSessionOption.LOCALE;
pub const WSMAN_OPTION_UI_LANGUAGE = WSManSessionOption.UI_LANGUAGE;
pub const WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB = WSManSessionOption.MAX_ENVELOPE_SIZE_KB;
pub const WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = WSManSessionOption.SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB;
pub const WSMAN_OPTION_REDIRECT_LOCATION = WSManSessionOption.REDIRECT_LOCATION;
pub const WSMAN_OPTION_SKIP_REVOCATION_CHECK = WSManSessionOption.SKIP_REVOCATION_CHECK;
pub const WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = WSManSessionOption.ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS;
pub const WSMAN_OPTION_USE_SSL = WSManSessionOption.USE_SSL;
pub const WSMAN_OPTION_USE_INTEARACTIVE_TOKEN = WSManSessionOption.USE_INTEARACTIVE_TOKEN;

pub const WSManCallbackFlags = enum(i32) {
    END_OF_OPERATION = 1,
    END_OF_STREAM = 8,
    SHELL_SUPPORTS_DISCONNECT = 32,
    SHELL_AUTODISCONNECTED = 64,
    NETWORK_FAILURE_DETECTED = 256,
    RETRYING_AFTER_NETWORK_FAILURE = 512,
    RECONNECTED_AFTER_NETWORK_FAILURE = 1024,
    SHELL_AUTODISCONNECTING = 2048,
    RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = 4096,
    RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = 8192,
};
pub const WSMAN_FLAG_CALLBACK_END_OF_OPERATION = WSManCallbackFlags.END_OF_OPERATION;
pub const WSMAN_FLAG_CALLBACK_END_OF_STREAM = WSManCallbackFlags.END_OF_STREAM;
pub const WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = WSManCallbackFlags.SHELL_SUPPORTS_DISCONNECT;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED = WSManCallbackFlags.SHELL_AUTODISCONNECTED;
pub const WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = WSManCallbackFlags.NETWORK_FAILURE_DETECTED;
pub const WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RETRYING_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RECONNECTED_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING = WSManCallbackFlags.SHELL_AUTODISCONNECTING;
pub const WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = WSManCallbackFlags.RETRY_ABORTED_DUE_TO_INTERNAL_ERROR;
pub const WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = WSManCallbackFlags.RECEIVE_DELAY_STREAM_REQUEST_PROCESSED;

pub const WSMAN_STREAM_ID_SET = extern struct {
    streamIDsCount: u32,
    streamIDs: ?*?PWSTR,
};

pub const WSMAN_ENVIRONMENT_VARIABLE = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_ENVIRONMENT_VARIABLE_SET = extern struct {
    varsCount: u32,
    vars: ?*WSMAN_ENVIRONMENT_VARIABLE,
};

pub const WSMAN_SHELL_STARTUP_INFO_V10 = extern struct {
    inputStreamSet: ?*WSMAN_STREAM_ID_SET,
    outputStreamSet: ?*WSMAN_STREAM_ID_SET,
    idleTimeoutMs: u32,
    workingDirectory: ?[*:0]const u16,
    variableSet: ?*WSMAN_ENVIRONMENT_VARIABLE_SET,
};

pub const WSMAN_SHELL_STARTUP_INFO_V11 = extern struct {
    __AnonymousBase_wsman_L665_C48: WSMAN_SHELL_STARTUP_INFO_V10,
    name: ?[*:0]const u16,
};

pub const WSMAN_SHELL_DISCONNECT_INFO = extern struct {
    idleTimeoutMs: u32,
};

pub const WSManShellFlag = enum(i32) {
    NO_COMPRESSION = 1,
    DELETE_SERVER_SESSION = 2,
    SERVER_BUFFERING_MODE_DROP = 4,
    SERVER_BUFFERING_MODE_BLOCK = 8,
    RECEIVE_DELAY_OUTPUT_STREAM = 16,
};
pub const WSMAN_FLAG_NO_COMPRESSION = WSManShellFlag.NO_COMPRESSION;
pub const WSMAN_FLAG_DELETE_SERVER_SESSION = WSManShellFlag.DELETE_SERVER_SESSION;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = WSManShellFlag.SERVER_BUFFERING_MODE_DROP;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = WSManShellFlag.SERVER_BUFFERING_MODE_BLOCK;
pub const WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = WSManShellFlag.RECEIVE_DELAY_OUTPUT_STREAM;

pub const WSMAN_RECEIVE_DATA_RESULT = extern struct {
    streamId: ?[*:0]const u16,
    streamData: WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
};

pub const WSMAN_CONNECT_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_CREATE_SHELL_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_RESPONSE_DATA = extern union {
    receiveData: WSMAN_RECEIVE_DATA_RESULT,
    connectData: WSMAN_CONNECT_DATA,
    createData: WSMAN_CREATE_SHELL_DATA,
};

pub const WSMAN_SHELL_COMPLETION_FUNCTION = fn(
    operationContext: ?*c_void,
    flags: u32,
    @"error": ?*WSMAN_ERROR,
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    operationHandle: ?*WSMAN_OPERATION,
    data: ?*WSMAN_RESPONSE_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_SHELL_ASYNC = extern struct {
    operationContext: ?*c_void,
    completionFunction: ?WSMAN_SHELL_COMPLETION_FUNCTION,
};

pub const WSMAN_COMMAND_ARG_SET = extern struct {
    argsCount: u32,
    args: ?*?PWSTR,
};

pub const WSMAN_CERTIFICATE_DETAILS = extern struct {
    subject: ?[*:0]const u16,
    issuerName: ?[*:0]const u16,
    issuerThumbprint: ?[*:0]const u16,
    subjectName: ?[*:0]const u16,
};

pub const WSMAN_SENDER_DETAILS = extern struct {
    senderName: ?[*:0]const u16,
    authenticationMechanism: ?[*:0]const u16,
    certificateDetails: ?*WSMAN_CERTIFICATE_DETAILS,
    clientToken: ?HANDLE,
    httpURL: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_REQUEST = extern struct {
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    locale: ?[*:0]const u16,
    resourceUri: ?[*:0]const u16,
    operationInfo: ?*WSMAN_OPERATION_INFO,
    shutdownNotification: i32,
    shutdownNotificationHandle: ?HANDLE,
    dataLocale: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT = fn(
    shellContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT = fn(
    shellContext: ?*c_void,
    commandContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_STARTUP = fn(
    flags: u32,
    applicationIdentification: ?[*:0]const u16,
    extraInfo: ?[*:0]const u16,
    pluginContext: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHUTDOWN = fn(
    pluginContext: ?*c_void,
    flags: u32,
    reason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHELL = fn(
    pluginContext: ?*c_void,
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    inboundShellInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_COMMAND = fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*c_void,
    commandLine: ?[*:0]const u16,
    arguments: ?*WSMAN_COMMAND_ARG_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SEND = fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*c_void,
    commandContext: ?*c_void,
    stream: ?[*:0]const u16,
    inboundData: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RECEIVE = fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*c_void,
    commandContext: ?*c_void,
    streamSet: ?*WSMAN_STREAM_ID_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SIGNAL = fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*c_void,
    commandContext: ?*c_void,
    code: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_CONNECT = fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*c_void,
    commandContext: ?*c_void,
    inboundConnectInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_AUTHZ_QUOTA = extern struct {
    maxAllowedConcurrentShells: u32,
    maxAllowedConcurrentOperations: u32,
    timeslotSize: u32,
    maxAllowedOperationsPerTimeslot: u32,
};

pub const WSMAN_PLUGIN_AUTHORIZE_USER = fn(
    pluginContext: ?*c_void,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_OPERATION = fn(
    pluginContext: ?*c_void,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    operation: u32,
    action: ?[*:0]const u16,
    resourceUri: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA = fn(
    pluginContext: ?*c_void,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT = fn(
    userAuthorizationContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WSMan_Value = @import("../zig.zig").Guid.initString("bced617b-ec03-420b-8508-977dc7a686bd");
pub const CLSID_WSMan = &CLSID_WSMan_Value;

const CLSID_WSManInternal_Value = @import("../zig.zig").Guid.initString("7de087a5-5dcb-4df7-bb12-0924ad8fbd9a");
pub const CLSID_WSManInternal = &CLSID_WSManInternal_Value;

pub const WSManSessionFlags = enum(i32) {
    UTF8 = 1,
    CredUsernamePassword = 4096,
    SkipCACheck = 8192,
    SkipCNCheck = 16384,
    UseNoAuthentication = 32768,
    UseDigest = 65536,
    UseNegotiate = 131072,
    UseBasic = 262144,
    UseKerberos = 524288,
    NoEncryption = 1048576,
    UseClientCertificate = 2097152,
    EnableSPNServerPort = 4194304,
    UTF16 = 8388608,
    UseCredSsp = 16777216,
    SkipRevocationCheck = 33554432,
    AllowNegotiateImplicitCredentials = 67108864,
    UseSsl = 134217728,
};
pub const WSManFlagUTF8 = WSManSessionFlags.UTF8;
pub const WSManFlagCredUsernamePassword = WSManSessionFlags.CredUsernamePassword;
pub const WSManFlagSkipCACheck = WSManSessionFlags.SkipCACheck;
pub const WSManFlagSkipCNCheck = WSManSessionFlags.SkipCNCheck;
pub const WSManFlagUseNoAuthentication = WSManSessionFlags.UseNoAuthentication;
pub const WSManFlagUseDigest = WSManSessionFlags.UseDigest;
pub const WSManFlagUseNegotiate = WSManSessionFlags.UseNegotiate;
pub const WSManFlagUseBasic = WSManSessionFlags.UseBasic;
pub const WSManFlagUseKerberos = WSManSessionFlags.UseKerberos;
pub const WSManFlagNoEncryption = WSManSessionFlags.NoEncryption;
pub const WSManFlagUseClientCertificate = WSManSessionFlags.UseClientCertificate;
pub const WSManFlagEnableSPNServerPort = WSManSessionFlags.EnableSPNServerPort;
pub const WSManFlagUTF16 = WSManSessionFlags.UTF16;
pub const WSManFlagUseCredSsp = WSManSessionFlags.UseCredSsp;
pub const WSManFlagSkipRevocationCheck = WSManSessionFlags.SkipRevocationCheck;
pub const WSManFlagAllowNegotiateImplicitCredentials = WSManSessionFlags.AllowNegotiateImplicitCredentials;
pub const WSManFlagUseSsl = WSManSessionFlags.UseSsl;

pub const WSManEnumFlags = enum(i32) {
    NonXmlText = 1,
    ReturnObject = 0,
    ReturnEPR = 2,
    ReturnObjectAndEPR = 4,
    // HierarchyDeep = 0, this enum value conflicts with ReturnObject
    HierarchyShallow = 32,
    HierarchyDeepBasePropsOnly = 64,
    // AssociatedInstance = 0, this enum value conflicts with ReturnObject
    AssociationInstance = 128,
};
pub const WSManFlagNonXmlText = WSManEnumFlags.NonXmlText;
pub const WSManFlagReturnObject = WSManEnumFlags.ReturnObject;
pub const WSManFlagReturnEPR = WSManEnumFlags.ReturnEPR;
pub const WSManFlagReturnObjectAndEPR = WSManEnumFlags.ReturnObjectAndEPR;
pub const WSManFlagHierarchyDeep = WSManEnumFlags.ReturnObject;
pub const WSManFlagHierarchyShallow = WSManEnumFlags.HierarchyShallow;
pub const WSManFlagHierarchyDeepBasePropsOnly = WSManEnumFlags.HierarchyDeepBasePropsOnly;
pub const WSManFlagAssociatedInstance = WSManEnumFlags.ReturnObject;
pub const WSManFlagAssociationInstance = WSManEnumFlags.AssociationInstance;

pub const WSManProxyAccessTypeFlags = enum(i32) {
    IEConfig = 1,
    WinHttpConfig = 2,
    AutoDetect = 4,
    NoProxyServer = 8,
};
pub const WSManProxyIEConfig = WSManProxyAccessTypeFlags.IEConfig;
pub const WSManProxyWinHttpConfig = WSManProxyAccessTypeFlags.WinHttpConfig;
pub const WSManProxyAutoDetect = WSManProxyAccessTypeFlags.AutoDetect;
pub const WSManProxyNoProxyServer = WSManProxyAccessTypeFlags.NoProxyServer;

pub const WSManProxyAuthenticationFlags = enum(i32) {
    Negotiate = 1,
    Basic = 2,
    Digest = 4,
};
pub const WSManFlagProxyAuthenticationUseNegotiate = WSManProxyAuthenticationFlags.Negotiate;
pub const WSManFlagProxyAuthenticationUseBasic = WSManProxyAuthenticationFlags.Basic;
pub const WSManFlagProxyAuthenticationUseDigest = WSManProxyAuthenticationFlags.Digest;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSMan_Value = @import("../zig.zig").Guid.initString("190d8637-5cd3-496d-ad24-69636bb5a3b5");
pub const IID_IWSMan = &IID_IWSMan_Value;
pub const IWSMan = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateSession: fn(
            self: *const IWSMan,
            connection: ?BSTR,
            flags: i32,
            connectionOptions: ?*IDispatch,
            session: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConnectionOptions: fn(
            self: *const IWSMan,
            connectionOptions: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CommandLine: fn(
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: fn(
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_CreateSession(self: *const T, connection: ?BSTR, flags: i32, connectionOptions: ?*IDispatch, session: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).CreateSession(@ptrCast(*const IWSMan, self), connection, flags, connectionOptions, session);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_CreateConnectionOptions(self: *const T, connectionOptions: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).CreateConnectionOptions(@ptrCast(*const IWSMan, self), connectionOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_get_CommandLine(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).get_CommandLine(@ptrCast(*const IWSMan, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_get_Error(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).get_Error(@ptrCast(*const IWSMan, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx_Value = @import("../zig.zig").Guid.initString("2d53bdaa-798e-49e6-a1aa-74d01256f411");
pub const IID_IWSManEx = &IID_IWSManEx_Value;
pub const IWSManEx = extern struct {
    pub const VTable = extern struct {
        base: IWSMan.VTable,
        CreateResourceLocator: fn(
            self: *const IWSManEx,
            strResourceLocator: ?BSTR,
            newResourceLocator: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUTF8: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagCredUsernamePassword: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCACheck: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCNCheck: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseDigest: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNegotiate: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseBasic: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseKerberos: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagNoEncryption: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagEnableSPNServerPort: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNoAuthentication: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagNonXmlText: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnEPR: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObjectAndEPR: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorMessage: fn(
            self: *const IWSManEx,
            errorNumber: u32,
            errorMessage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeep: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyShallow: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeepBasePropsOnly: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObject: fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSMan.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_CreateResourceLocator(self: *const T, strResourceLocator: ?BSTR, newResourceLocator: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).CreateResourceLocator(@ptrCast(*const IWSManEx, self), strResourceLocator, newResourceLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUTF8(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUTF8(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagCredUsernamePassword(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagCredUsernamePassword(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagSkipCACheck(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagSkipCACheck(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagSkipCNCheck(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagSkipCNCheck(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseDigest(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseDigest(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseNegotiate(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseNegotiate(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseBasic(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseBasic(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseKerberos(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseKerberos(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagNoEncryption(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagNoEncryption(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagEnableSPNServerPort(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagEnableSPNServerPort(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseNoAuthentication(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseNoAuthentication(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagNonXmlText(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagNonXmlText(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnEPR(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnEPR(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnObjectAndEPR(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnObjectAndEPR(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_GetErrorMessage(self: *const T, errorNumber: u32, errorMessage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).GetErrorMessage(@ptrCast(*const IWSManEx, self), errorNumber, errorMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyDeep(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyDeep(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyShallow(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyShallow(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyDeepBasePropsOnly(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyDeepBasePropsOnly(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnObject(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnObject(@ptrCast(*const IWSManEx, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx2_Value = @import("../zig.zig").Guid.initString("1d1b5ae0-42d9-4021-8261-3987619512e9");
pub const IID_IWSManEx2 = &IID_IWSManEx2_Value;
pub const IWSManEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx.VTable,
        SessionFlagUseClientCertificate: fn(
            self: *const IWSManEx2,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx2_SessionFlagUseClientCertificate(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx2.VTable, self.vtable).SessionFlagUseClientCertificate(@ptrCast(*const IWSManEx2, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManEx3_Value = @import("../zig.zig").Guid.initString("6400e966-011d-4eac-8474-049e0848afad");
pub const IID_IWSManEx3 = &IID_IWSManEx3_Value;
pub const IWSManEx3 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx2.VTable,
        SessionFlagUTF16: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseCredSsp: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociationInstance: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociatedInstance: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipRevocationCheck: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagAllowNegotiateImplicitCredentials: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseSsl: fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManEx2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUTF16(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUTF16(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUseCredSsp(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUseCredSsp(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_EnumerationFlagAssociationInstance(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).EnumerationFlagAssociationInstance(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_EnumerationFlagAssociatedInstance(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).EnumerationFlagAssociatedInstance(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagSkipRevocationCheck(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagSkipRevocationCheck(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagAllowNegotiateImplicitCredentials(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagAllowNegotiateImplicitCredentials(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUseSsl(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUseSsl(@ptrCast(*const IWSManEx3, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptions_Value = @import("../zig.zig").Guid.initString("f704e861-9e52-464f-b786-da5eb2320fdd");
pub const IID_IWSManConnectionOptions = &IID_IWSManConnectionOptions_Value;
pub const IWSManConnectionOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: fn(
            self: *const IWSManConnectionOptions,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserName: fn(
            self: *const IWSManConnectionOptions,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: fn(
            self: *const IWSManConnectionOptions,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_get_UserName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).get_UserName(@ptrCast(*const IWSManConnectionOptions, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_put_UserName(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).put_UserName(@ptrCast(*const IWSManConnectionOptions, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_put_Password(self: *const T, password: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).put_Password(@ptrCast(*const IWSManConnectionOptions, self), password);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptionsEx_Value = @import("../zig.zig").Guid.initString("ef43edf7-2a48-4d93-9526-8bd6ab6d4a6b");
pub const IID_IWSManConnectionOptionsEx = &IID_IWSManConnectionOptionsEx_Value;
pub const IWSManConnectionOptionsEx = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptions.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateThumbprint: fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateThumbprint: fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManConnectionOptions.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx_get_CertificateThumbprint(self: *const T, thumbprint: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx.VTable, self.vtable).get_CertificateThumbprint(@ptrCast(*const IWSManConnectionOptionsEx, self), thumbprint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx_put_CertificateThumbprint(self: *const T, thumbprint: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx.VTable, self.vtable).put_CertificateThumbprint(@ptrCast(*const IWSManConnectionOptionsEx, self), thumbprint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManConnectionOptionsEx2_Value = @import("../zig.zig").Guid.initString("f500c9ec-24ee-48ab-b38d-fc9a164c658e");
pub const IID_IWSManConnectionOptionsEx2 = &IID_IWSManConnectionOptionsEx2_Value;
pub const IWSManConnectionOptionsEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptionsEx.VTable,
        SetProxy: fn(
            self: *const IWSManConnectionOptionsEx2,
            accessType: i32,
            authenticationMechanism: i32,
            userName: ?BSTR,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyIEConfig: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyWinHttpConfig: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAutoDetect: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyNoProxyServer: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseNegotiate: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseBasic: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseDigest: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManConnectionOptionsEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_SetProxy(self: *const T, accessType: i32, authenticationMechanism: i32, userName: ?BSTR, password: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).SetProxy(@ptrCast(*const IWSManConnectionOptionsEx2, self), accessType, authenticationMechanism, userName, password);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyIEConfig(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyIEConfig(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyWinHttpConfig(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyWinHttpConfig(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAutoDetect(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAutoDetect(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyNoProxyServer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyNoProxyServer(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseNegotiate(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseNegotiate(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseBasic(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseBasic(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseDigest(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseDigest(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManSession_Value = @import("../zig.zig").Guid.initString("fc84fc58-1286-40c4-9da0-c8ef6ec241e0");
pub const IID_IWSManSession = &IID_IWSManSession_Value;
pub const IWSManSession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Get: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Put: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            resultResource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            newUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IWSManSession,
            actionUri: ?BSTR,
            resourceUri: VARIANT,
            parameters: ?BSTR,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enumerate: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            filter: ?BSTR,
            dialect: ?BSTR,
            flags: i32,
            resultSet: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Identify: fn(
            self: *const IWSManSession,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: fn(
            self: *const IWSManSession,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BatchItems: fn(
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BatchItems: fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Timeout: fn(
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Timeout: fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Get(self: *const T, resourceUri: VARIANT, flags: i32, resource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Get(@ptrCast(*const IWSManSession, self), resourceUri, flags, resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Put(self: *const T, resourceUri: VARIANT, resource: ?BSTR, flags: i32, resultResource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Put(@ptrCast(*const IWSManSession, self), resourceUri, resource, flags, resultResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Create(self: *const T, resourceUri: VARIANT, resource: ?BSTR, flags: i32, newUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Create(@ptrCast(*const IWSManSession, self), resourceUri, resource, flags, newUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Delete(self: *const T, resourceUri: VARIANT, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Delete(@ptrCast(*const IWSManSession, self), resourceUri, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Invoke(self: *const T, actionUri: ?BSTR, resourceUri: VARIANT, parameters: ?BSTR, flags: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Invoke(@ptrCast(*const IWSManSession, self), actionUri, resourceUri, parameters, flags, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Enumerate(self: *const T, resourceUri: VARIANT, filter: ?BSTR, dialect: ?BSTR, flags: i32, resultSet: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Enumerate(@ptrCast(*const IWSManSession, self), resourceUri, filter, dialect, flags, resultSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Identify(self: *const T, flags: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Identify(@ptrCast(*const IWSManSession, self), flags, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_Error(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_Error(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_BatchItems(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_BatchItems(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_put_BatchItems(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).put_BatchItems(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_Timeout(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_Timeout(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_put_Timeout(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).put_Timeout(@ptrCast(*const IWSManSession, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEnumerator_Value = @import("../zig.zig").Guid.initString("f3457ca9-abb9-4fa5-b850-90e8ca300e7f");
pub const IID_IWSManEnumerator = &IID_IWSManEnumerator_Value;
pub const IWSManEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ReadItem: fn(
            self: *const IWSManEnumerator,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AtEndOfStream: fn(
            self: *const IWSManEnumerator,
            eos: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: fn(
            self: *const IWSManEnumerator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_ReadItem(self: *const T, resource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).ReadItem(@ptrCast(*const IWSManEnumerator, self), resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_get_AtEndOfStream(self: *const T, eos: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).get_AtEndOfStream(@ptrCast(*const IWSManEnumerator, self), eos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_get_Error(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).get_Error(@ptrCast(*const IWSManEnumerator, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManResourceLocator_Value = @import("../zig.zig").Guid.initString("a7a1ba28-de41-466a-ad0a-c4059ead7428");
pub const IID_IWSManResourceLocator = &IID_IWSManResourceLocator_Value;
pub const IWSManResourceLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResourceURI: fn(
            self: *const IWSManResourceLocator,
            uri: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResourceURI: fn(
            self: *const IWSManResourceLocator,
            uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSelector: fn(
            self: *const IWSManResourceLocator,
            resourceSelName: ?BSTR,
            selValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSelectors: fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentPath: fn(
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentPath: fn(
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentDialect: fn(
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentDialect: fn(
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOption: fn(
            self: *const IWSManResourceLocator,
            OptionName: ?BSTR,
            OptionValue: VARIANT,
            mustComply: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MustUnderstandOptions: fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MustUnderstandOptions: fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearOptions: fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: fn(
            self: *const IWSManResourceLocator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_ResourceURI(self: *const T, uri: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_ResourceURI(@ptrCast(*const IWSManResourceLocator, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_ResourceURI(self: *const T, uri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_ResourceURI(@ptrCast(*const IWSManResourceLocator, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_AddSelector(self: *const T, resourceSelName: ?BSTR, selValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).AddSelector(@ptrCast(*const IWSManResourceLocator, self), resourceSelName, selValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_ClearSelectors(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).ClearSelectors(@ptrCast(*const IWSManResourceLocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_FragmentPath(self: *const T, text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_FragmentPath(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_FragmentPath(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_FragmentPath(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_FragmentDialect(self: *const T, text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_FragmentDialect(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_FragmentDialect(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_FragmentDialect(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_AddOption(self: *const T, OptionName: ?BSTR, OptionValue: VARIANT, mustComply: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).AddOption(@ptrCast(*const IWSManResourceLocator, self), OptionName, OptionValue, mustComply);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_MustUnderstandOptions(self: *const T, mustUnderstand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_MustUnderstandOptions(@ptrCast(*const IWSManResourceLocator, self), mustUnderstand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_MustUnderstandOptions(self: *const T, mustUnderstand: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_MustUnderstandOptions(@ptrCast(*const IWSManResourceLocator, self), mustUnderstand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_ClearOptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).ClearOptions(@ptrCast(*const IWSManResourceLocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_Error(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_Error(@ptrCast(*const IWSManResourceLocator, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManResourceLocatorInternal_Value = @import("../zig.zig").Guid.initString("effaead7-7ec8-4716-b9be-f2e7e9fb4adb");
pub const IID_IWSManResourceLocatorInternal = &IID_IWSManResourceLocatorInternal_Value;
pub const IWSManResourceLocatorInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManInternal_Value = @import("../zig.zig").Guid.initString("04ae2b1d-9954-4d99-94a9-a961e72c3a13");
pub const IID_IWSManInternal = &IID_IWSManInternal_Value;
pub const IWSManInternal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConfigSDDL: fn(
            self: *const IWSManInternal,
            session: ?*IDispatch,
            resourceUri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManInternal_ConfigSDDL(self: *const T, session: ?*IDispatch, resourceUri: VARIANT, flags: i32, resource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManInternal.VTable, self.vtable).ConfigSDDL(@ptrCast(*const IWSManInternal, self), session, resourceUri, flags, resource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (33)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManInitialize(
    flags: u32,
    apiHandle: ?*?*WSMAN_API,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManDeinitialize(
    apiHandle: ?*WSMAN_API,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManGetErrorMessage(
    apiHandle: ?*WSMAN_API,
    flags: u32,
    languageCode: ?[*:0]const u16,
    errorCode: u32,
    messageLength: u32,
    message: ?[*:0]u16,
    messageLengthUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCreateSession(
    apiHandle: ?*WSMAN_API,
    connection: ?[*:0]const u16,
    flags: u32,
    serverAuthenticationCredentials: ?*WSMAN_AUTHENTICATION_CREDENTIALS,
    proxyInfo: ?*WSMAN_PROXY_INFO,
    session: ?*?*WSMAN_SESSION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCloseSession(
    session: ?*WSMAN_SESSION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManSetSessionOption(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManGetSessionOptionAsDword(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManGetSessionOptionAsString(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    stringLength: u32,
    string: ?[*:0]u16,
    stringLengthUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCloseOperation(
    operationHandle: ?*WSMAN_OPERATION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCreateShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManRunShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandLine: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManSignalShell(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    code: ?[*:0]const u16,
    @"async": ?*WSMAN_SHELL_ASYNC,
    signalOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManReceiveShellOutput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    desiredStreamSet: ?*WSMAN_STREAM_ID_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    receiveOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManSendShellInput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    streamId: ?[*:0]const u16,
    streamData: ?*WSMAN_DATA,
    endOfStream: BOOL,
    @"async": ?*WSMAN_SHELL_ASYNC,
    sendOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCloseCommand(
    commandHandle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManCloseShell(
    shellHandle: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManCreateShellEx(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    shellId: ?[*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManRunShellCommandEx(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandId: ?[*:0]const u16,
    commandLine: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManDisconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    disconnectInfo: ?*WSMAN_SHELL_DISCONNECT_INFO,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManReconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManReconnectShellCommand(
    commandHandle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManConnectShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    shellID: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WsmSvc" fn WSManConnectShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandID: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginReportContext(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginReceiveResult(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    stream: ?[*:0]const u16,
    streamResult: ?*WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginOperationComplete(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    errorCode: u32,
    extendedInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginGetOperationParameters(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginGetConfiguration(
    pluginContext: ?*c_void,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginReportCompletion(
    pluginContext: ?*c_void,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginFreeRequestDetails(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginAuthzUserComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*c_void,
    impersonationToken: ?HANDLE,
    userIsAdministrator: BOOL,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginAuthzOperationComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*c_void,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "WsmSvc" fn WSManPluginAuthzQueryQuotaComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    quota: ?*WSMAN_AUTHZ_QUOTA,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/ole_automation.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/ole_automation.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "WSMAN_SHELL_COMPLETION_FUNCTION")) { _ = WSMAN_SHELL_COMPLETION_FUNCTION; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT")) { _ = WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT")) { _ = WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_STARTUP")) { _ = WSMAN_PLUGIN_STARTUP; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHUTDOWN")) { _ = WSMAN_PLUGIN_SHUTDOWN; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHELL")) { _ = WSMAN_PLUGIN_SHELL; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_COMMAND")) { _ = WSMAN_PLUGIN_COMMAND; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SEND")) { _ = WSMAN_PLUGIN_SEND; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RECEIVE")) { _ = WSMAN_PLUGIN_RECEIVE; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SIGNAL")) { _ = WSMAN_PLUGIN_SIGNAL; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_CONNECT")) { _ = WSMAN_PLUGIN_CONNECT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_USER")) { _ = WSMAN_PLUGIN_AUTHORIZE_USER; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_OPERATION")) { _ = WSMAN_PLUGIN_AUTHORIZE_OPERATION; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA")) { _ = WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT")) { _ = WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}

//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (25)
//--------------------------------------------------------------------------------
pub const SID_SEditCommandTarget = Guid.initString("3050f4b5-98b5-11cf-bb82-00aa00bdce0b");
pub const CGID_EditStateCommands = Guid.initString("3050f4b6-98b5-11cf-bb82-00aa00bdce0b");
pub const SID_SHTMLEditHost = Guid.initString("3050f6a0-98b5-11cf-bb82-00aa00bdce0b");
pub const SID_SHTMLEditServices = Guid.initString("3050f7f9-98b5-11cf-bb82-00aa00bdce0b");
pub const COOKIEACTION_NONE = @as(u32, 0);
pub const COOKIEACTION_ACCEPT = @as(u32, 1);
pub const COOKIEACTION_REJECT = @as(u32, 2);
pub const COOKIEACTION_DOWNGRADE = @as(u32, 4);
pub const COOKIEACTION_LEASH = @as(u32, 8);
pub const COOKIEACTION_SUPPRESS = @as(u32, 16);
pub const COOKIEACTION_READ = @as(u32, 32);
pub const PRIVACY_URLISTOPLEVEL = @as(u32, 65536);
pub const PRIVACY_URLHASCOMPACTPOLICY = @as(u32, 131072);
pub const PRIVACY_URLHASPOSTDATA = @as(u32, 524288);
pub const PRIVACY_URLHASPOLICYREFLINK = @as(u32, 1048576);
pub const PRIVACY_URLHASPOLICYREFHEADER = @as(u32, 2097152);
pub const PRIVACY_URLHASP3PHEADER = @as(u32, 4194304);
pub const DEBUGCALLBACKNOTIFICATION_TIMEOUT = @as(u32, 1);
pub const DEBUGCALLBACKNOTIFICATION_INTERVAL = @as(u32, 2);
pub const DEBUGCALLBACKNOTIFICATION_IMMEDIATE = @as(u32, 4);
pub const DEBUGCALLBACKNOTIFICATION_ANIMATIONFRAME = @as(u32, 8);
pub const DEBUGCALLBACKNOTIFICATION_DOMEVENT = @as(u32, 16);
pub const DEBUGDOMEVENTPROPAGATIONSTATUS_DEFAULTCANCELED = @as(u32, 1);
pub const DEBUGDOMEVENTPROPAGATIONSTATUS_STOPIMMEDIATEPROPAGATION = @as(u32, 2);
pub const DEBUGDOMEVENTPROPAGATIONSTATUS_STOPPROPAGATION = @as(u32, 4);

//--------------------------------------------------------------------------------
// Section: Types (1431)
//--------------------------------------------------------------------------------
const CLSID_HTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("30510741-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSStyleDeclaration = &CLSID_HTMLCSSStyleDeclaration_Value;

const CLSID_HTMLStyle_Value = @import("../zig.zig").Guid.initString("3050f285-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyle = &CLSID_HTMLStyle_Value;

const CLSID_HTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050f3d0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLRuleStyle = &CLSID_HTMLRuleStyle_Value;

const CLSID_HTMLCSSRule_Value = @import("../zig.zig").Guid.initString("305106ef-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSRule = &CLSID_HTMLCSSRule_Value;

const CLSID_HTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("305106f0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSImportRule = &CLSID_HTMLCSSImportRule_Value;

const CLSID_HTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("305106f1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSMediaRule = &CLSID_HTMLCSSMediaRule_Value;

const CLSID_HTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30510732-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSMediaList = &CLSID_HTMLCSSMediaList_Value;

const CLSID_HTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("305106f2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCSSNamespaceRule = &CLSID_HTMLCSSNamespaceRule_Value;

const CLSID_HTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("3051080e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMSCSSKeyframeRule = &CLSID_HTMLMSCSSKeyframeRule_Value;

const CLSID_HTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("3051080f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMSCSSKeyframesRule = &CLSID_HTMLMSCSSKeyframesRule_Value;

const CLSID_HTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050f6aa-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLRenderStyle = &CLSID_HTMLRenderStyle_Value;

const CLSID_HTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050f3dc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCurrentStyle = &CLSID_HTMLCurrentStyle_Value;

const CLSID_HTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050f4b2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDOMAttribute = &CLSID_HTMLDOMAttribute_Value;

const CLSID_HTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050f4ba-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDOMTextNode = &CLSID_HTMLDOMTextNode_Value;

const CLSID_HTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050f80e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDOMImplementation = &CLSID_HTMLDOMImplementation_Value;

const CLSID_HTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050f4cc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAttributeCollection = &CLSID_HTMLAttributeCollection_Value;

const CLSID_StaticNodeList_Value = @import("../zig.zig").Guid.initString("30510467-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_StaticNodeList = &CLSID_StaticNodeList_Value;

const CLSID_DOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050f5aa-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMChildrenCollection = &CLSID_DOMChildrenCollection_Value;

const CLSID_HTMLDefaults_Value = @import("../zig.zig").Guid.initString("3050f6c8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDefaults = &CLSID_HTMLDefaults_Value;

const CLSID_HTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050f4fc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCDefaultDispatch = &CLSID_HTCDefaultDispatch_Value;

const CLSID_HTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050f5de-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCPropertyBehavior = &CLSID_HTCPropertyBehavior_Value;

const CLSID_HTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050f630-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCMethodBehavior = &CLSID_HTCMethodBehavior_Value;

const CLSID_HTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050f4fe-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCEventBehavior = &CLSID_HTCEventBehavior_Value;

const CLSID_HTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050f5f5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCAttachBehavior = &CLSID_HTCAttachBehavior_Value;

const CLSID_HTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050f5dd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTCDescBehavior = &CLSID_HTCDescBehavior_Value;

const CLSID_HTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050f580-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLUrnCollection = &CLSID_HTMLUrnCollection_Value;

const CLSID_HTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050f4b8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLGenericElement = &CLSID_HTMLGenericElement_Value;

const CLSID_HTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050f3ce-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheetRule = &CLSID_HTMLStyleSheetRule_Value;

const CLSID_HTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050f3cd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheetRulesCollection = &CLSID_HTMLStyleSheetRulesCollection_Value;

const CLSID_HTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050f7ef-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheetPage = &CLSID_HTMLStyleSheetPage_Value;

const CLSID_HTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050f7f1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheetPagesCollection = &CLSID_HTMLStyleSheetPagesCollection_Value;

const CLSID_HTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050f2e4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheet = &CLSID_HTMLStyleSheet_Value;

const CLSID_HTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050f37f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleSheetsCollection = &CLSID_HTMLStyleSheetsCollection_Value;

const CLSID_HTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050f277-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLLinkElement = &CLSID_HTMLLinkElement_Value;

const CLSID_HTMLDOMRange_Value = @import("../zig.zig").Guid.initString("305106c3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDOMRange = &CLSID_HTMLDOMRange_Value;

const CLSID_HTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050f251-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFormElement = &CLSID_HTMLFormElement_Value;

const CLSID_HTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050f26a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTextElement = &CLSID_HTMLTextElement_Value;

const CLSID_HTMLImg_Value = @import("../zig.zig").Guid.initString("3050f241-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLImg = &CLSID_HTMLImg_Value;

const CLSID_HTMLImageElementFactory_Value = @import("../zig.zig").Guid.initString("3050f38f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLImageElementFactory = &CLSID_HTMLImageElementFactory_Value;

const CLSID_HTMLBody_Value = @import("../zig.zig").Guid.initString("3050f24a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBody = &CLSID_HTMLBody_Value;

const CLSID_HTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050f27b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFontElement = &CLSID_HTMLFontElement_Value;

const CLSID_HTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050f248-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAnchorElement = &CLSID_HTMLAnchorElement_Value;

const CLSID_HTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050f32b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLLabelElement = &CLSID_HTMLLabelElement_Value;

const CLSID_HTMLListElement_Value = @import("../zig.zig").Guid.initString("3050f272-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLListElement = &CLSID_HTMLListElement_Value;

const CLSID_HTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050f269-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLUListElement = &CLSID_HTMLUListElement_Value;

const CLSID_HTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050f270-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLOListElement = &CLSID_HTMLOListElement_Value;

const CLSID_HTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050f273-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLLIElement = &CLSID_HTMLLIElement_Value;

const CLSID_HTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050f281-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBlockElement = &CLSID_HTMLBlockElement_Value;

const CLSID_HTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050f27e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDivElement = &CLSID_HTMLDivElement_Value;

const CLSID_HTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050f27f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDDElement = &CLSID_HTMLDDElement_Value;

const CLSID_HTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050f27c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDTElement = &CLSID_HTMLDTElement_Value;

const CLSID_HTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050f280-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBRElement = &CLSID_HTMLBRElement_Value;

const CLSID_HTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050f27d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDListElement = &CLSID_HTMLDListElement_Value;

const CLSID_HTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050f252-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLHRElement = &CLSID_HTMLHRElement_Value;

const CLSID_HTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050f26f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLParaElement = &CLSID_HTMLParaElement_Value;

const CLSID_HTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050f4cb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLElementCollection = &CLSID_HTMLElementCollection_Value;

const CLSID_HTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050f27a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLHeaderElement = &CLSID_HTMLHeaderElement_Value;

const CLSID_HTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050f245-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLSelectElement = &CLSID_HTMLSelectElement_Value;

const CLSID_HTMLWndSelectElement_Value = @import("../zig.zig").Guid.initString("3050f2cf-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLWndSelectElement = &CLSID_HTMLWndSelectElement_Value;

const CLSID_HTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050f24d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLOptionElement = &CLSID_HTMLOptionElement_Value;

const CLSID_HTMLOptionElementFactory_Value = @import("../zig.zig").Guid.initString("3050f38d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLOptionElementFactory = &CLSID_HTMLOptionElementFactory_Value;

const CLSID_HTMLWndOptionElement_Value = @import("../zig.zig").Guid.initString("3050f2d0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLWndOptionElement = &CLSID_HTMLWndOptionElement_Value;

const CLSID_HTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050f5d8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLInputElement = &CLSID_HTMLInputElement_Value;

const CLSID_HTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050f2ac-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTextAreaElement = &CLSID_HTMLTextAreaElement_Value;

const CLSID_HTMLRichtextElement_Value = @import("../zig.zig").Guid.initString("3050f2df-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLRichtextElement = &CLSID_HTMLRichtextElement_Value;

const CLSID_HTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2c6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLButtonElement = &CLSID_HTMLButtonElement_Value;

const CLSID_HTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050f2b9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMarqueeElement = &CLSID_HTMLMarqueeElement_Value;

const CLSID_HTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050f491-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLHtmlElement = &CLSID_HTMLHtmlElement_Value;

const CLSID_HTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050f493-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLHeadElement = &CLSID_HTMLHeadElement_Value;

const CLSID_HTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050f284-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTitleElement = &CLSID_HTMLTitleElement_Value;

const CLSID_HTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050f275-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMetaElement = &CLSID_HTMLMetaElement_Value;

const CLSID_HTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050f276-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBaseElement = &CLSID_HTMLBaseElement_Value;

const CLSID_HTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050f278-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLIsIndexElement = &CLSID_HTMLIsIndexElement_Value;

const CLSID_HTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050f279-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLNextIdElement = &CLSID_HTMLNextIdElement_Value;

const CLSID_HTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050f282-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBaseFontElement = &CLSID_HTMLBaseFontElement_Value;

const CLSID_HTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050f268-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLUnknownElement = &CLSID_HTMLUnknownElement_Value;

const CLSID_HTMLHistory_Value = @import("../zig.zig").Guid.initString("feceaaa3-8405-11cf-8ba1-00aa00476da6");
pub const CLSID_HTMLHistory = &CLSID_HTMLHistory_Value;

const CLSID_COpsProfile_Value = @import("../zig.zig").Guid.initString("3050f402-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_COpsProfile = &CLSID_COpsProfile_Value;

const CLSID_HTMLNavigator_Value = @import("../zig.zig").Guid.initString("feceaaa6-8405-11cf-8ba1-00aa00476da6");
pub const CLSID_HTMLNavigator = &CLSID_HTMLNavigator_Value;

const CLSID_HTMLLocation_Value = @import("../zig.zig").Guid.initString("163bb1e1-6e00-11cf-837a-48dc04c10000");
pub const CLSID_HTMLLocation = &CLSID_HTMLLocation_Value;

const CLSID_CMimeTypes_Value = @import("../zig.zig").Guid.initString("3050f3fe-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CMimeTypes = &CLSID_CMimeTypes_Value;

const CLSID_CPlugins_Value = @import("../zig.zig").Guid.initString("3050f3ff-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPlugins = &CLSID_CPlugins_Value;

const CLSID_CEventObj_Value = @import("../zig.zig").Guid.initString("3050f48a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CEventObj = &CLSID_CEventObj_Value;

const CLSID_HTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3051074c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleMedia = &CLSID_HTMLStyleMedia_Value;

const CLSID_FramesCollection_Value = @import("../zig.zig").Guid.initString("3050f7f6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_FramesCollection = &CLSID_FramesCollection_Value;

const CLSID_HTMLScreen_Value = @import("../zig.zig").Guid.initString("3050f35d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLScreen = &CLSID_HTMLScreen_Value;

const CLSID_HTMLWindow2_Value = @import("../zig.zig").Guid.initString("d48a6ec6-6a4a-11cf-94a7-444553540000");
pub const CLSID_HTMLWindow2 = &CLSID_HTMLWindow2_Value;

const CLSID_HTMLWindowProxy_Value = @import("../zig.zig").Guid.initString("3050f391-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLWindowProxy = &CLSID_HTMLWindowProxy_Value;

const CLSID_HTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3051041b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDocumentCompatibleInfo = &CLSID_HTMLDocumentCompatibleInfo_Value;

const CLSID_HTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("30510419-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDocumentCompatibleInfoCollection = &CLSID_HTMLDocumentCompatibleInfoCollection_Value;

const CLSID_HTMLDocument_Value = @import("../zig.zig").Guid.initString("25336920-03f9-11cf-8fd0-00aa00686f13");
pub const CLSID_HTMLDocument = &CLSID_HTMLDocument_Value;

const CLSID_Scriptlet_Value = @import("../zig.zig").Guid.initString("ae24fdae-03c6-11d1-8b76-0080c744f389");
pub const CLSID_Scriptlet = &CLSID_Scriptlet_Value;

const CLSID_HTMLEmbed_Value = @import("../zig.zig").Guid.initString("3050f25d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLEmbed = &CLSID_HTMLEmbed_Value;

const CLSID_HTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050f4ca-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAreasCollection = &CLSID_HTMLAreasCollection_Value;

const CLSID_HTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050f271-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMapElement = &CLSID_HTMLMapElement_Value;

const CLSID_HTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050f283-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAreaElement = &CLSID_HTMLAreaElement_Value;

const CLSID_HTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050f2ec-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTableCaption = &CLSID_HTMLTableCaption_Value;

const CLSID_HTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050f317-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCommentElement = &CLSID_HTMLCommentElement_Value;

const CLSID_HTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050f26e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLPhraseElement = &CLSID_HTMLPhraseElement_Value;

const CLSID_HTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050f3f5-98b4-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLSpanElement = &CLSID_HTMLSpanElement_Value;

const CLSID_HTMLTable_Value = @import("../zig.zig").Guid.initString("3050f26b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTable = &CLSID_HTMLTable_Value;

const CLSID_HTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050f26c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTableCol = &CLSID_HTMLTableCol_Value;

const CLSID_HTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050f2e9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTableSection = &CLSID_HTMLTableSection_Value;

const CLSID_HTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050f26d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTableRow = &CLSID_HTMLTableRow_Value;

const CLSID_HTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050f246-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTableCell = &CLSID_HTMLTableCell_Value;

const CLSID_HTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050f28c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLScriptElement = &CLSID_HTMLScriptElement_Value;

const CLSID_HTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050f38b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLNoShowElement = &CLSID_HTMLNoShowElement_Value;

const CLSID_HTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050f24e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLObjectElement = &CLSID_HTMLObjectElement_Value;

const CLSID_HTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050f83e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLParamElement = &CLSID_HTMLParamElement_Value;

const CLSID_HTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050f312-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFrameBase = &CLSID_HTMLFrameBase_Value;

const CLSID_HTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050f314-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFrameElement = &CLSID_HTMLFrameElement_Value;

const CLSID_HTMLIFrame_Value = @import("../zig.zig").Guid.initString("3050f316-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLIFrame = &CLSID_HTMLIFrame_Value;

const CLSID_HTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050f249-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDivPosition = &CLSID_HTMLDivPosition_Value;

const CLSID_HTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050f3e8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFieldSetElement = &CLSID_HTMLFieldSetElement_Value;

const CLSID_HTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050f3e9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLLegendElement = &CLSID_HTMLLegendElement_Value;

const CLSID_HTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050f3e6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLSpanFlow = &CLSID_HTMLSpanFlow_Value;

const CLSID_HTMLFrameSetSite_Value = @import("../zig.zig").Guid.initString("3050f31a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLFrameSetSite = &CLSID_HTMLFrameSetSite_Value;

const CLSID_HTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050f370-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLBGsound = &CLSID_HTMLBGsound_Value;

const CLSID_HTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050f37d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleElement = &CLSID_HTMLStyleElement_Value;

const CLSID_HTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("3050f3d4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStyleFontFace = &CLSID_HTMLStyleFontFace_Value;

const CLSID_XDomainRequest_Value = @import("../zig.zig").Guid.initString("30510455-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_XDomainRequest = &CLSID_XDomainRequest_Value;

const CLSID_XDomainRequestFactory_Value = @import("../zig.zig").Guid.initString("30510457-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_XDomainRequestFactory = &CLSID_XDomainRequestFactory_Value;

const CLSID_HTMLStorage_Value = @import("../zig.zig").Guid.initString("30510475-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLStorage = &CLSID_HTMLStorage_Value;

const CLSID_DOMEvent_Value = @import("../zig.zig").Guid.initString("305104bb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMEvent = &CLSID_DOMEvent_Value;

const CLSID_DOMUIEvent_Value = @import("../zig.zig").Guid.initString("305106cb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMUIEvent = &CLSID_DOMUIEvent_Value;

const CLSID_DOMMouseEvent_Value = @import("../zig.zig").Guid.initString("305106cf-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMouseEvent = &CLSID_DOMMouseEvent_Value;

const CLSID_DOMDragEvent_Value = @import("../zig.zig").Guid.initString("30510762-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMDragEvent = &CLSID_DOMDragEvent_Value;

const CLSID_DOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("305106d1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMouseWheelEvent = &CLSID_DOMMouseWheelEvent_Value;

const CLSID_DOMWheelEvent_Value = @import("../zig.zig").Guid.initString("305106d3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMWheelEvent = &CLSID_DOMWheelEvent_Value;

const CLSID_DOMTextEvent_Value = @import("../zig.zig").Guid.initString("305106d5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMTextEvent = &CLSID_DOMTextEvent_Value;

const CLSID_DOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("305106d7-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMKeyboardEvent = &CLSID_DOMKeyboardEvent_Value;

const CLSID_DOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("305106d9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMCompositionEvent = &CLSID_DOMCompositionEvent_Value;

const CLSID_DOMMutationEvent_Value = @import("../zig.zig").Guid.initString("305106db-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMutationEvent = &CLSID_DOMMutationEvent_Value;

const CLSID_DOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("30510764-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMBeforeUnloadEvent = &CLSID_DOMBeforeUnloadEvent_Value;

const CLSID_DOMFocusEvent_Value = @import("../zig.zig").Guid.initString("305106cd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMFocusEvent = &CLSID_DOMFocusEvent_Value;

const CLSID_DOMCustomEvent_Value = @import("../zig.zig").Guid.initString("305106df-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMCustomEvent = &CLSID_DOMCustomEvent_Value;

const CLSID_CanvasGradient_Value = @import("../zig.zig").Guid.initString("30510715-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CanvasGradient = &CLSID_CanvasGradient_Value;

const CLSID_CanvasPattern_Value = @import("../zig.zig").Guid.initString("30510717-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CanvasPattern = &CLSID_CanvasPattern_Value;

const CLSID_CanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("30510719-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CanvasTextMetrics = &CLSID_CanvasTextMetrics_Value;

const CLSID_CanvasImageData_Value = @import("../zig.zig").Guid.initString("3051071b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CanvasImageData = &CLSID_CanvasImageData_Value;

const CLSID_CanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("30510700-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CanvasRenderingContext2D = &CLSID_CanvasRenderingContext2D_Value;

const CLSID_HTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("305106e5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLCanvasElement = &CLSID_HTMLCanvasElement_Value;

const CLSID_DOMProgressEvent_Value = @import("../zig.zig").Guid.initString("3051071f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMProgressEvent = &CLSID_DOMProgressEvent_Value;

const CLSID_DOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30510721-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMessageEvent = &CLSID_DOMMessageEvent_Value;

const CLSID_DOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("30510766-98b6-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMSiteModeEvent = &CLSID_DOMSiteModeEvent_Value;

const CLSID_DOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30510723-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMStorageEvent = &CLSID_DOMStorageEvent_Value;

const CLSID_XMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("30510831-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_XMLHttpRequestEventTarget = &CLSID_XMLHttpRequestEventTarget_Value;

const CLSID_HTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3051040b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLXMLHttpRequest = &CLSID_HTMLXMLHttpRequest_Value;

const CLSID_HTMLXMLHttpRequestFactory_Value = @import("../zig.zig").Guid.initString("3051040d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLXMLHttpRequestFactory = &CLSID_HTMLXMLHttpRequestFactory_Value;

const CLSID_SVGAngle_Value = @import("../zig.zig").Guid.initString("30510584-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAngle = &CLSID_SVGAngle_Value;

const CLSID_SVGAnimatedAngle_Value = @import("../zig.zig").Guid.initString("305105e4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedAngle = &CLSID_SVGAnimatedAngle_Value;

const CLSID_SVGAnimatedTransformList_Value = @import("../zig.zig").Guid.initString("305105b1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedTransformList = &CLSID_SVGAnimatedTransformList_Value;

const CLSID_SVGAnimatedBoolean_Value = @import("../zig.zig").Guid.initString("3051058b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedBoolean = &CLSID_SVGAnimatedBoolean_Value;

const CLSID_SVGAnimatedEnumeration_Value = @import("../zig.zig").Guid.initString("3051058e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedEnumeration = &CLSID_SVGAnimatedEnumeration_Value;

const CLSID_SVGAnimatedInteger_Value = @import("../zig.zig").Guid.initString("3051058f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedInteger = &CLSID_SVGAnimatedInteger_Value;

const CLSID_SVGAnimatedLength_Value = @import("../zig.zig").Guid.initString("30510581-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedLength = &CLSID_SVGAnimatedLength_Value;

const CLSID_SVGAnimatedLengthList_Value = @import("../zig.zig").Guid.initString("30510582-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedLengthList = &CLSID_SVGAnimatedLengthList_Value;

const CLSID_SVGAnimatedNumber_Value = @import("../zig.zig").Guid.initString("30510588-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedNumber = &CLSID_SVGAnimatedNumber_Value;

const CLSID_SVGAnimatedNumberList_Value = @import("../zig.zig").Guid.initString("3051058a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedNumberList = &CLSID_SVGAnimatedNumberList_Value;

const CLSID_SVGAnimatedRect_Value = @import("../zig.zig").Guid.initString("30510586-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedRect = &CLSID_SVGAnimatedRect_Value;

const CLSID_SVGAnimatedString_Value = @import("../zig.zig").Guid.initString("3051058c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedString = &CLSID_SVGAnimatedString_Value;

const CLSID_SVGClipPathElement_Value = @import("../zig.zig").Guid.initString("305105e6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGClipPathElement = &CLSID_SVGClipPathElement_Value;

const CLSID_SVGElement_Value = @import("../zig.zig").Guid.initString("30510564-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGElement = &CLSID_SVGElement_Value;

const CLSID_SVGLength_Value = @import("../zig.zig").Guid.initString("3051057e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGLength = &CLSID_SVGLength_Value;

const CLSID_SVGLengthList_Value = @import("../zig.zig").Guid.initString("30510580-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGLengthList = &CLSID_SVGLengthList_Value;

const CLSID_SVGMatrix_Value = @import("../zig.zig").Guid.initString("305105ae-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGMatrix = &CLSID_SVGMatrix_Value;

const CLSID_SVGNumber_Value = @import("../zig.zig").Guid.initString("30510587-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGNumber = &CLSID_SVGNumber_Value;

const CLSID_SVGNumberList_Value = @import("../zig.zig").Guid.initString("30510589-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGNumberList = &CLSID_SVGNumberList_Value;

const CLSID_SVGPatternElement_Value = @import("../zig.zig").Guid.initString("305105d4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPatternElement = &CLSID_SVGPatternElement_Value;

const CLSID_SVGPathSeg_Value = @import("../zig.zig").Guid.initString("305105b3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSeg = &CLSID_SVGPathSeg_Value;

const CLSID_SVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("305105bb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegArcAbs = &CLSID_SVGPathSegArcAbs_Value;

const CLSID_SVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("305105bc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegArcRel = &CLSID_SVGPathSegArcRel_Value;

const CLSID_SVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("305105bd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegClosePath = &CLSID_SVGPathSegClosePath_Value;

const CLSID_SVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("305105cc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegMovetoAbs = &CLSID_SVGPathSegMovetoAbs_Value;

const CLSID_SVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("305105cd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegMovetoRel = &CLSID_SVGPathSegMovetoRel_Value;

const CLSID_SVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("305105c6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoAbs = &CLSID_SVGPathSegLinetoAbs_Value;

const CLSID_SVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("305105c9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoRel = &CLSID_SVGPathSegLinetoRel_Value;

const CLSID_SVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("305105be-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoCubicAbs = &CLSID_SVGPathSegCurvetoCubicAbs_Value;

const CLSID_SVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("305105bf-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoCubicRel = &CLSID_SVGPathSegCurvetoCubicRel_Value;

const CLSID_SVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("305105c0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoCubicSmoothAbs = &CLSID_SVGPathSegCurvetoCubicSmoothAbs_Value;

const CLSID_SVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("305105c1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoCubicSmoothRel = &CLSID_SVGPathSegCurvetoCubicSmoothRel_Value;

const CLSID_SVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("305105c2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoQuadraticAbs = &CLSID_SVGPathSegCurvetoQuadraticAbs_Value;

const CLSID_SVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("305105c3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoQuadraticRel = &CLSID_SVGPathSegCurvetoQuadraticRel_Value;

const CLSID_SVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("305105c4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoQuadraticSmoothAbs = &CLSID_SVGPathSegCurvetoQuadraticSmoothAbs_Value;

const CLSID_SVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("305105c5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegCurvetoQuadraticSmoothRel = &CLSID_SVGPathSegCurvetoQuadraticSmoothRel_Value;

const CLSID_SVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("305105c7-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoHorizontalAbs = &CLSID_SVGPathSegLinetoHorizontalAbs_Value;

const CLSID_SVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("305105c8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoHorizontalRel = &CLSID_SVGPathSegLinetoHorizontalRel_Value;

const CLSID_SVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("305105ca-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoVerticalAbs = &CLSID_SVGPathSegLinetoVerticalAbs_Value;

const CLSID_SVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("305105cb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegLinetoVerticalRel = &CLSID_SVGPathSegLinetoVerticalRel_Value;

const CLSID_SVGPathSegList_Value = @import("../zig.zig").Guid.initString("305105b4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathSegList = &CLSID_SVGPathSegList_Value;

const CLSID_SVGPoint_Value = @import("../zig.zig").Guid.initString("305105ba-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPoint = &CLSID_SVGPoint_Value;

const CLSID_SVGPointList_Value = @import("../zig.zig").Guid.initString("305105b9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPointList = &CLSID_SVGPointList_Value;

const CLSID_SVGRect_Value = @import("../zig.zig").Guid.initString("30510583-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGRect = &CLSID_SVGRect_Value;

const CLSID_SVGStringList_Value = @import("../zig.zig").Guid.initString("3051058d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGStringList = &CLSID_SVGStringList_Value;

const CLSID_SVGTransform_Value = @import("../zig.zig").Guid.initString("305105af-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTransform = &CLSID_SVGTransform_Value;

const CLSID_SVGSVGElement_Value = @import("../zig.zig").Guid.initString("30510574-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGSVGElement = &CLSID_SVGSVGElement_Value;

const CLSID_SVGUseElement_Value = @import("../zig.zig").Guid.initString("30510590-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGUseElement = &CLSID_SVGUseElement_Value;

const CLSID_HTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("eb36f845-2395-4719-b85c-d0d80e184bd9");
pub const CLSID_HTMLStyleSheetRulesAppliedCollection = &CLSID_HTMLStyleSheetRulesAppliedCollection_Value;

const CLSID_RulesApplied_Value = @import("../zig.zig").Guid.initString("7c803920-7a53-4d26-98ac-fdd23e6b9e01");
pub const CLSID_RulesApplied = &CLSID_RulesApplied_Value;

const CLSID_RulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("671926ee-c3cf-40af-be8f-1cbaee6486e8");
pub const CLSID_RulesAppliedCollection = &CLSID_RulesAppliedCollection_Value;

const CLSID_HTMLW3CComputedStyle_Value = @import("../zig.zig").Guid.initString("305106c8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLW3CComputedStyle = &CLSID_HTMLW3CComputedStyle_Value;

const CLSID_SVGTransformList_Value = @import("../zig.zig").Guid.initString("305105b0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTransformList = &CLSID_SVGTransformList_Value;

const CLSID_SVGCircleElement_Value = @import("../zig.zig").Guid.initString("30510578-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGCircleElement = &CLSID_SVGCircleElement_Value;

const CLSID_SVGEllipseElement_Value = @import("../zig.zig").Guid.initString("30510579-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGEllipseElement = &CLSID_SVGEllipseElement_Value;

const CLSID_SVGLineElement_Value = @import("../zig.zig").Guid.initString("3051057a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGLineElement = &CLSID_SVGLineElement_Value;

const CLSID_SVGRectElement_Value = @import("../zig.zig").Guid.initString("30510577-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGRectElement = &CLSID_SVGRectElement_Value;

const CLSID_SVGPolygonElement_Value = @import("../zig.zig").Guid.initString("3051057b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPolygonElement = &CLSID_SVGPolygonElement_Value;

const CLSID_SVGPolylineElement_Value = @import("../zig.zig").Guid.initString("3051057c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPolylineElement = &CLSID_SVGPolylineElement_Value;

const CLSID_SVGGElement_Value = @import("../zig.zig").Guid.initString("3051056f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGGElement = &CLSID_SVGGElement_Value;

const CLSID_SVGSymbolElement_Value = @import("../zig.zig").Guid.initString("30510571-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGSymbolElement = &CLSID_SVGSymbolElement_Value;

const CLSID_SVGDefsElement_Value = @import("../zig.zig").Guid.initString("30510570-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGDefsElement = &CLSID_SVGDefsElement_Value;

const CLSID_SVGPathElement_Value = @import("../zig.zig").Guid.initString("305105b2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPathElement = &CLSID_SVGPathElement_Value;

const CLSID_SVGPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305105d0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGPreserveAspectRatio = &CLSID_SVGPreserveAspectRatio_Value;

const CLSID_SVGTextElement_Value = @import("../zig.zig").Guid.initString("305105df-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTextElement = &CLSID_SVGTextElement_Value;

const CLSID_SVGAnimatedPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305105ce-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAnimatedPreserveAspectRatio = &CLSID_SVGAnimatedPreserveAspectRatio_Value;

const CLSID_SVGImageElement_Value = @import("../zig.zig").Guid.initString("305105cf-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGImageElement = &CLSID_SVGImageElement_Value;

const CLSID_SVGStopElement_Value = @import("../zig.zig").Guid.initString("305105d5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGStopElement = &CLSID_SVGStopElement_Value;

const CLSID_SVGGradientElement_Value = @import("../zig.zig").Guid.initString("305105d6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGGradientElement = &CLSID_SVGGradientElement_Value;

const CLSID_SVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("305105d2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGLinearGradientElement = &CLSID_SVGLinearGradientElement_Value;

const CLSID_SVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("305105d3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGRadialGradientElement = &CLSID_SVGRadialGradientElement_Value;

const CLSID_SVGMaskElement_Value = @import("../zig.zig").Guid.initString("305105e7-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGMaskElement = &CLSID_SVGMaskElement_Value;

const CLSID_SVGMarkerElement_Value = @import("../zig.zig").Guid.initString("305105de-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGMarkerElement = &CLSID_SVGMarkerElement_Value;

const CLSID_SVGZoomEvent_Value = @import("../zig.zig").Guid.initString("305105d9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGZoomEvent = &CLSID_SVGZoomEvent_Value;

const CLSID_SVGAElement_Value = @import("../zig.zig").Guid.initString("305105db-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGAElement = &CLSID_SVGAElement_Value;

const CLSID_SVGViewElement_Value = @import("../zig.zig").Guid.initString("305105dc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGViewElement = &CLSID_SVGViewElement_Value;

const CLSID_HTMLMediaError_Value = @import("../zig.zig").Guid.initString("3051070a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMediaError = &CLSID_HTMLMediaError_Value;

const CLSID_HTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("3051070b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLTimeRanges = &CLSID_HTMLTimeRanges_Value;

const CLSID_HTMLMediaElement_Value = @import("../zig.zig").Guid.initString("3051070c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLMediaElement = &CLSID_HTMLMediaElement_Value;

const CLSID_HTMLSourceElement_Value = @import("../zig.zig").Guid.initString("3051070d-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLSourceElement = &CLSID_HTMLSourceElement_Value;

const CLSID_HTMLAudioElement_Value = @import("../zig.zig").Guid.initString("3051070e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAudioElement = &CLSID_HTMLAudioElement_Value;

const CLSID_HTMLAudioElementFactory_Value = @import("../zig.zig").Guid.initString("305107ec-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAudioElementFactory = &CLSID_HTMLAudioElementFactory_Value;

const CLSID_HTMLVideoElement_Value = @import("../zig.zig").Guid.initString("3051070f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLVideoElement = &CLSID_HTMLVideoElement_Value;

const CLSID_SVGSwitchElement_Value = @import("../zig.zig").Guid.initString("305105d8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGSwitchElement = &CLSID_SVGSwitchElement_Value;

const CLSID_SVGDescElement_Value = @import("../zig.zig").Guid.initString("30510572-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGDescElement = &CLSID_SVGDescElement_Value;

const CLSID_SVGTitleElement_Value = @import("../zig.zig").Guid.initString("30510573-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTitleElement = &CLSID_SVGTitleElement_Value;

const CLSID_SVGMetadataElement_Value = @import("../zig.zig").Guid.initString("305105d7-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGMetadataElement = &CLSID_SVGMetadataElement_Value;

const CLSID_SVGElementInstance_Value = @import("../zig.zig").Guid.initString("30510575-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGElementInstance = &CLSID_SVGElementInstance_Value;

const CLSID_SVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("30510576-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGElementInstanceList = &CLSID_SVGElementInstanceList_Value;

const CLSID_DOMException_Value = @import("../zig.zig").Guid.initString("3051072c-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMException = &CLSID_DOMException_Value;

const CLSID_RangeException_Value = @import("../zig.zig").Guid.initString("3051072e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_RangeException = &CLSID_RangeException_Value;

const CLSID_SVGException_Value = @import("../zig.zig").Guid.initString("30510730-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGException = &CLSID_SVGException_Value;

const CLSID_EventException_Value = @import("../zig.zig").Guid.initString("3051073b-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_EventException = &CLSID_EventException_Value;

const CLSID_SVGScriptElement_Value = @import("../zig.zig").Guid.initString("305105e1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGScriptElement = &CLSID_SVGScriptElement_Value;

const CLSID_SVGStyleElement_Value = @import("../zig.zig").Guid.initString("305105d1-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGStyleElement = &CLSID_SVGStyleElement_Value;

const CLSID_SVGTextContentElement_Value = @import("../zig.zig").Guid.initString("305105dd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTextContentElement = &CLSID_SVGTextContentElement_Value;

const CLSID_SVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("305105e0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTextPositioningElement = &CLSID_SVGTextPositioningElement_Value;

const CLSID_DOMDocumentType_Value = @import("../zig.zig").Guid.initString("30510739-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMDocumentType = &CLSID_DOMDocumentType_Value;

const CLSID_NodeIterator_Value = @import("../zig.zig").Guid.initString("30510745-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_NodeIterator = &CLSID_NodeIterator_Value;

const CLSID_TreeWalker_Value = @import("../zig.zig").Guid.initString("30510747-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_TreeWalker = &CLSID_TreeWalker_Value;

const CLSID_DOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("30510743-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMProcessingInstruction = &CLSID_DOMProcessingInstruction_Value;

const CLSID_HTMLPerformance_Value = @import("../zig.zig").Guid.initString("3051074f-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLPerformance = &CLSID_HTMLPerformance_Value;

const CLSID_HTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("30510751-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLPerformanceNavigation = &CLSID_HTMLPerformanceNavigation_Value;

const CLSID_HTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("30510753-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLPerformanceTiming = &CLSID_HTMLPerformanceTiming_Value;

const CLSID_SVGTSpanElement_Value = @import("../zig.zig").Guid.initString("305105e2-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTSpanElement = &CLSID_SVGTSpanElement_Value;

const CLSID_CTemplatePrinter_Value = @import("../zig.zig").Guid.initString("3050f6b3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CTemplatePrinter = &CLSID_CTemplatePrinter_Value;

const CLSID_CPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("63619f54-9d71-4c23-a08d-50d7f18db2e9");
pub const CLSID_CPrintManagerTemplatePrinter = &CLSID_CPrintManagerTemplatePrinter_Value;

const CLSID_SVGTextPathElement_Value = @import("../zig.zig").Guid.initString("305105eb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_SVGTextPathElement = &CLSID_SVGTextPathElement_Value;

const CLSID_XMLSerializer_Value = @import("../zig.zig").Guid.initString("3051077e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_XMLSerializer = &CLSID_XMLSerializer_Value;

const CLSID_DOMParser_Value = @import("../zig.zig").Guid.initString("30510782-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMParser = &CLSID_DOMParser_Value;

const CLSID_HTMLDOMXmlSerializerFactory_Value = @import("../zig.zig").Guid.initString("30510780-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDOMXmlSerializerFactory = &CLSID_HTMLDOMXmlSerializerFactory_Value;

const CLSID_DOMParserFactory_Value = @import("../zig.zig").Guid.initString("30510784-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMParserFactory = &CLSID_DOMParserFactory_Value;

const CLSID_HTMLSemanticElement_Value = @import("../zig.zig").Guid.initString("305107b0-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLSemanticElement = &CLSID_HTMLSemanticElement_Value;

const CLSID_HTMLProgressElement_Value = @import("../zig.zig").Guid.initString("3050f2d5-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLProgressElement = &CLSID_HTMLProgressElement_Value;

const CLSID_DOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305107b6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMSTransitionEvent = &CLSID_DOMMSTransitionEvent_Value;

const CLSID_DOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305107b8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMSAnimationEvent = &CLSID_DOMMSAnimationEvent_Value;

const CLSID_WebGeolocation_Value = @import("../zig.zig").Guid.initString("305107c6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_WebGeolocation = &CLSID_WebGeolocation_Value;

const CLSID_WebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305107c8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_WebGeocoordinates = &CLSID_WebGeocoordinates_Value;

const CLSID_WebGeopositionError_Value = @import("../zig.zig").Guid.initString("305107ca-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_WebGeopositionError = &CLSID_WebGeopositionError_Value;

const CLSID_WebGeoposition_Value = @import("../zig.zig").Guid.initString("305107ce-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_WebGeoposition = &CLSID_WebGeoposition_Value;

const CLSID_CClientCaps_Value = @import("../zig.zig").Guid.initString("7e8bc44e-aeff-11d1-89c2-00c04fb6bfc4");
pub const CLSID_CClientCaps = &CLSID_CClientCaps_Value;

const CLSID_DOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("30510817-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMMSManipulationEvent = &CLSID_DOMMSManipulationEvent_Value;

const CLSID_DOMCloseEvent_Value = @import("../zig.zig").Guid.initString("30510800-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_DOMCloseEvent = &CLSID_DOMCloseEvent_Value;

const CLSID_ApplicationCache_Value = @import("../zig.zig").Guid.initString("30510829-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_ApplicationCache = &CLSID_ApplicationCache_Value;

const CLSID_HtmlDlgSafeHelper_Value = @import("../zig.zig").Guid.initString("3050f819-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HtmlDlgSafeHelper = &CLSID_HtmlDlgSafeHelper_Value;

const CLSID_BlockFormats_Value = @import("../zig.zig").Guid.initString("3050f831-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_BlockFormats = &CLSID_BlockFormats_Value;

const CLSID_FontNames_Value = @import("../zig.zig").Guid.initString("3050f83a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_FontNames = &CLSID_FontNames_Value;

const CLSID_HTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050f6bc-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLNamespace = &CLSID_HTMLNamespace_Value;

const CLSID_HTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050f6b9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLNamespaceCollection = &CLSID_HTMLNamespaceCollection_Value;

const CLSID_ThreadDialogProcParam_Value = @import("../zig.zig").Guid.initString("3050f5eb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_ThreadDialogProcParam = &CLSID_ThreadDialogProcParam_Value;

const CLSID_HTMLDialog_Value = @import("../zig.zig").Guid.initString("3050f28a-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLDialog = &CLSID_HTMLDialog_Value;

const CLSID_HTMLPopup_Value = @import("../zig.zig").Guid.initString("3050f667-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLPopup = &CLSID_HTMLPopup_Value;

const CLSID_HTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050f5cb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLAppBehavior = &CLSID_HTMLAppBehavior_Value;

const CLSID_OldHTMLDocument_Value = @import("../zig.zig").Guid.initString("d48a6ec9-6a4a-11cf-94a7-444553540000");
pub const CLSID_OldHTMLDocument = &CLSID_OldHTMLDocument_Value;

const CLSID_OldHTMLFormElement_Value = @import("../zig.zig").Guid.initString("0d04d285-6bec-11cf-8b97-00aa00476da6");
pub const CLSID_OldHTMLFormElement = &CLSID_OldHTMLFormElement_Value;

const CLSID_HTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2b4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLInputButtonElement = &CLSID_HTMLInputButtonElement_Value;

const CLSID_HTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050f2ab-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLInputTextElement = &CLSID_HTMLInputTextElement_Value;

const CLSID_HTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050f2ae-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLInputFileElement = &CLSID_HTMLInputFileElement_Value;

const CLSID_HTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2be-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLOptionButtonElement = &CLSID_HTMLOptionButtonElement_Value;

const CLSID_HTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050f2c4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_HTMLInputImage = &CLSID_HTMLInputImage_Value;

const IID_IHTMLFiltersCollection_Value = @import("../zig.zig").Guid.initString("3050f3ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFiltersCollection = &IID_IHTMLFiltersCollection_Value;
pub const IHTMLFiltersCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLFiltersCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLFiltersCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFiltersCollection,
            pvarIndex: ?*VARIANT,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFiltersCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFiltersCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_item(self: *const T, pvarIndex: ?*VARIANT, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFiltersCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIE70DispatchEx_Value = @import("../zig.zig").Guid.initString("3051046b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IIE70DispatchEx = &IID_IIE70DispatchEx_Value;
pub const IIE70DispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatchEx.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatchEx.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIE80DispatchEx_Value = @import("../zig.zig").Guid.initString("3051046c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IIE80DispatchEx = &IID_IIE80DispatchEx_Value;
pub const IIE80DispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatchEx.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatchEx.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const htmlDesignMode = enum(i32) {
    Inherit = -2,
    On = -1,
    Off = 0,
    _Max = 2147483647,
};
pub const htmlDesignModeInherit = htmlDesignMode.Inherit;
pub const htmlDesignModeOn = htmlDesignMode.On;
pub const htmlDesignModeOff = htmlDesignMode.Off;
pub const htmlDesignMode_Max = htmlDesignMode._Max;

pub const htmlZOrder = enum(i32) {
    Front = 0,
    Back = 1,
    _Max = 2147483647,
};
pub const htmlZOrderFront = htmlZOrder.Front;
pub const htmlZOrderBack = htmlZOrder.Back;
pub const htmlZOrder_Max = htmlZOrder._Max;

pub const htmlClear = enum(i32) {
    NotSet = 0,
    All = 1,
    Left = 2,
    Right = 3,
    Both = 4,
    None = 5,
    _Max = 2147483647,
};
pub const htmlClearNotSet = htmlClear.NotSet;
pub const htmlClearAll = htmlClear.All;
pub const htmlClearLeft = htmlClear.Left;
pub const htmlClearRight = htmlClear.Right;
pub const htmlClearBoth = htmlClear.Both;
pub const htmlClearNone = htmlClear.None;
pub const htmlClear_Max = htmlClear._Max;

pub const htmlControlAlign = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    TextTop = 4,
    AbsMiddle = 5,
    Baseline = 6,
    AbsBottom = 7,
    Bottom = 8,
    Middle = 9,
    Top = 10,
    _Max = 2147483647,
};
pub const htmlControlAlignNotSet = htmlControlAlign.NotSet;
pub const htmlControlAlignLeft = htmlControlAlign.Left;
pub const htmlControlAlignCenter = htmlControlAlign.Center;
pub const htmlControlAlignRight = htmlControlAlign.Right;
pub const htmlControlAlignTextTop = htmlControlAlign.TextTop;
pub const htmlControlAlignAbsMiddle = htmlControlAlign.AbsMiddle;
pub const htmlControlAlignBaseline = htmlControlAlign.Baseline;
pub const htmlControlAlignAbsBottom = htmlControlAlign.AbsBottom;
pub const htmlControlAlignBottom = htmlControlAlign.Bottom;
pub const htmlControlAlignMiddle = htmlControlAlign.Middle;
pub const htmlControlAlignTop = htmlControlAlign.Top;
pub const htmlControlAlign_Max = htmlControlAlign._Max;

pub const htmlBlockAlign = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    Justify = 4,
    _Max = 2147483647,
};
pub const htmlBlockAlignNotSet = htmlBlockAlign.NotSet;
pub const htmlBlockAlignLeft = htmlBlockAlign.Left;
pub const htmlBlockAlignCenter = htmlBlockAlign.Center;
pub const htmlBlockAlignRight = htmlBlockAlign.Right;
pub const htmlBlockAlignJustify = htmlBlockAlign.Justify;
pub const htmlBlockAlign_Max = htmlBlockAlign._Max;

pub const htmlReadyState = enum(i32) {
    uninitialized = 0,
    loading = 1,
    loaded = 2,
    interactive = 3,
    complete = 4,
    _Max = 2147483647,
};
pub const htmlReadyStateuninitialized = htmlReadyState.uninitialized;
pub const htmlReadyStateloading = htmlReadyState.loading;
pub const htmlReadyStateloaded = htmlReadyState.loaded;
pub const htmlReadyStateinteractive = htmlReadyState.interactive;
pub const htmlReadyStatecomplete = htmlReadyState.complete;
pub const htmlReadyState_Max = htmlReadyState._Max;

pub const htmlLoop = enum(i32) {
    LoopInfinite = -1,
    _Max = 2147483647,
};
pub const htmlLoopLoopInfinite = htmlLoop.LoopInfinite;
pub const htmlLoop_Max = htmlLoop._Max;

pub const mediaType = enum(i32) {
    NotSet = 0,
    All = 511,
    Aural = 1,
    Braille = 2,
    Embossed = 4,
    Handheld = 8,
    Print = 16,
    Projection = 32,
    Screen = 64,
    Tty = 128,
    Tv = 256,
    _Max = 2147483647,
};
pub const mediaTypeNotSet = mediaType.NotSet;
pub const mediaTypeAll = mediaType.All;
pub const mediaTypeAural = mediaType.Aural;
pub const mediaTypeBraille = mediaType.Braille;
pub const mediaTypeEmbossed = mediaType.Embossed;
pub const mediaTypeHandheld = mediaType.Handheld;
pub const mediaTypePrint = mediaType.Print;
pub const mediaTypeProjection = mediaType.Projection;
pub const mediaTypeScreen = mediaType.Screen;
pub const mediaTypeTty = mediaType.Tty;
pub const mediaTypeTv = mediaType.Tv;
pub const mediaType_Max = mediaType._Max;

pub const DomConstructor = enum(i32) {
    Object = 0,
    Attr = 1,
    BehaviorUrnsCollection = 2,
    BookmarkCollection = 3,
    CompatibleInfo = 4,
    CompatibleInfoCollection = 5,
    ControlRangeCollection = 6,
    CSSCurrentStyleDeclaration = 7,
    CSSRuleList = 8,
    CSSRuleStyleDeclaration = 9,
    CSSStyleDeclaration = 10,
    CSSStyleRule = 11,
    CSSStyleSheet = 12,
    DataTransfer = 13,
    DOMImplementation = 14,
    Element = 15,
    Event = 16,
    History = 17,
    HTCElementBehaviorDefaults = 18,
    HTMLAnchorElement = 19,
    HTMLAreaElement = 20,
    HTMLAreasCollection = 21,
    HTMLBaseElement = 22,
    HTMLBaseFontElement = 23,
    HTMLBGSoundElement = 24,
    HTMLBlockElement = 25,
    HTMLBodyElement = 26,
    HTMLBRElement = 27,
    HTMLButtonElement = 28,
    HTMLCollection = 29,
    HTMLCommentElement = 30,
    HTMLDDElement = 31,
    HTMLDivElement = 32,
    HTMLDocument = 33,
    HTMLDListElement = 34,
    HTMLDTElement = 35,
    HTMLEmbedElement = 36,
    HTMLFieldSetElement = 37,
    HTMLFontElement = 38,
    HTMLFormElement = 39,
    HTMLFrameElement = 40,
    HTMLFrameSetElement = 41,
    HTMLGenericElement = 42,
    HTMLHeadElement = 43,
    HTMLHeadingElement = 44,
    HTMLHRElement = 45,
    HTMLHtmlElement = 46,
    HTMLIFrameElement = 47,
    HTMLImageElement = 48,
    HTMLInputElement = 49,
    HTMLIsIndexElement = 50,
    HTMLLabelElement = 51,
    HTMLLegendElement = 52,
    HTMLLIElement = 53,
    HTMLLinkElement = 54,
    HTMLMapElement = 55,
    HTMLMarqueeElement = 56,
    HTMLMetaElement = 57,
    HTMLModelessDialog = 58,
    HTMLNamespaceInfo = 59,
    HTMLNamespaceInfoCollection = 60,
    HTMLNextIdElement = 61,
    HTMLNoShowElement = 62,
    HTMLObjectElement = 63,
    HTMLOListElement = 64,
    HTMLOptionElement = 65,
    HTMLParagraphElement = 66,
    HTMLParamElement = 67,
    HTMLPhraseElement = 68,
    HTMLPluginsCollection = 69,
    HTMLPopup = 70,
    HTMLScriptElement = 71,
    HTMLSelectElement = 72,
    HTMLSpanElement = 73,
    HTMLStyleElement = 74,
    HTMLTableCaptionElement = 75,
    HTMLTableCellElement = 76,
    HTMLTableColElement = 77,
    HTMLTableElement = 78,
    HTMLTableRowElement = 79,
    HTMLTableSectionElement = 80,
    HTMLTextAreaElement = 81,
    HTMLTextElement = 82,
    HTMLTitleElement = 83,
    HTMLUListElement = 84,
    HTMLUnknownElement = 85,
    Image = 86,
    Location = 87,
    NamedNodeMap = 88,
    Navigator = 89,
    NodeList = 90,
    Option = 91,
    Screen = 92,
    Selection = 93,
    StaticNodeList = 94,
    Storage = 95,
    StyleSheetList = 96,
    StyleSheetPage = 97,
    StyleSheetPageList = 98,
    Text = 99,
    TextRange = 100,
    TextRangeCollection = 101,
    TextRectangle = 102,
    TextRectangleList = 103,
    Window = 104,
    XDomainRequest = 105,
    XMLHttpRequest = 106,
    Max = 107,
    _Max = 2147483647,
};
pub const DomConstructorObject = DomConstructor.Object;
pub const DomConstructorAttr = DomConstructor.Attr;
pub const DomConstructorBehaviorUrnsCollection = DomConstructor.BehaviorUrnsCollection;
pub const DomConstructorBookmarkCollection = DomConstructor.BookmarkCollection;
pub const DomConstructorCompatibleInfo = DomConstructor.CompatibleInfo;
pub const DomConstructorCompatibleInfoCollection = DomConstructor.CompatibleInfoCollection;
pub const DomConstructorControlRangeCollection = DomConstructor.ControlRangeCollection;
pub const DomConstructorCSSCurrentStyleDeclaration = DomConstructor.CSSCurrentStyleDeclaration;
pub const DomConstructorCSSRuleList = DomConstructor.CSSRuleList;
pub const DomConstructorCSSRuleStyleDeclaration = DomConstructor.CSSRuleStyleDeclaration;
pub const DomConstructorCSSStyleDeclaration = DomConstructor.CSSStyleDeclaration;
pub const DomConstructorCSSStyleRule = DomConstructor.CSSStyleRule;
pub const DomConstructorCSSStyleSheet = DomConstructor.CSSStyleSheet;
pub const DomConstructorDataTransfer = DomConstructor.DataTransfer;
pub const DomConstructorDOMImplementation = DomConstructor.DOMImplementation;
pub const DomConstructorElement = DomConstructor.Element;
pub const DomConstructorEvent = DomConstructor.Event;
pub const DomConstructorHistory = DomConstructor.History;
pub const DomConstructorHTCElementBehaviorDefaults = DomConstructor.HTCElementBehaviorDefaults;
pub const DomConstructorHTMLAnchorElement = DomConstructor.HTMLAnchorElement;
pub const DomConstructorHTMLAreaElement = DomConstructor.HTMLAreaElement;
pub const DomConstructorHTMLAreasCollection = DomConstructor.HTMLAreasCollection;
pub const DomConstructorHTMLBaseElement = DomConstructor.HTMLBaseElement;
pub const DomConstructorHTMLBaseFontElement = DomConstructor.HTMLBaseFontElement;
pub const DomConstructorHTMLBGSoundElement = DomConstructor.HTMLBGSoundElement;
pub const DomConstructorHTMLBlockElement = DomConstructor.HTMLBlockElement;
pub const DomConstructorHTMLBodyElement = DomConstructor.HTMLBodyElement;
pub const DomConstructorHTMLBRElement = DomConstructor.HTMLBRElement;
pub const DomConstructorHTMLButtonElement = DomConstructor.HTMLButtonElement;
pub const DomConstructorHTMLCollection = DomConstructor.HTMLCollection;
pub const DomConstructorHTMLCommentElement = DomConstructor.HTMLCommentElement;
pub const DomConstructorHTMLDDElement = DomConstructor.HTMLDDElement;
pub const DomConstructorHTMLDivElement = DomConstructor.HTMLDivElement;
pub const DomConstructorHTMLDocument = DomConstructor.HTMLDocument;
pub const DomConstructorHTMLDListElement = DomConstructor.HTMLDListElement;
pub const DomConstructorHTMLDTElement = DomConstructor.HTMLDTElement;
pub const DomConstructorHTMLEmbedElement = DomConstructor.HTMLEmbedElement;
pub const DomConstructorHTMLFieldSetElement = DomConstructor.HTMLFieldSetElement;
pub const DomConstructorHTMLFontElement = DomConstructor.HTMLFontElement;
pub const DomConstructorHTMLFormElement = DomConstructor.HTMLFormElement;
pub const DomConstructorHTMLFrameElement = DomConstructor.HTMLFrameElement;
pub const DomConstructorHTMLFrameSetElement = DomConstructor.HTMLFrameSetElement;
pub const DomConstructorHTMLGenericElement = DomConstructor.HTMLGenericElement;
pub const DomConstructorHTMLHeadElement = DomConstructor.HTMLHeadElement;
pub const DomConstructorHTMLHeadingElement = DomConstructor.HTMLHeadingElement;
pub const DomConstructorHTMLHRElement = DomConstructor.HTMLHRElement;
pub const DomConstructorHTMLHtmlElement = DomConstructor.HTMLHtmlElement;
pub const DomConstructorHTMLIFrameElement = DomConstructor.HTMLIFrameElement;
pub const DomConstructorHTMLImageElement = DomConstructor.HTMLImageElement;
pub const DomConstructorHTMLInputElement = DomConstructor.HTMLInputElement;
pub const DomConstructorHTMLIsIndexElement = DomConstructor.HTMLIsIndexElement;
pub const DomConstructorHTMLLabelElement = DomConstructor.HTMLLabelElement;
pub const DomConstructorHTMLLegendElement = DomConstructor.HTMLLegendElement;
pub const DomConstructorHTMLLIElement = DomConstructor.HTMLLIElement;
pub const DomConstructorHTMLLinkElement = DomConstructor.HTMLLinkElement;
pub const DomConstructorHTMLMapElement = DomConstructor.HTMLMapElement;
pub const DomConstructorHTMLMarqueeElement = DomConstructor.HTMLMarqueeElement;
pub const DomConstructorHTMLMetaElement = DomConstructor.HTMLMetaElement;
pub const DomConstructorHTMLModelessDialog = DomConstructor.HTMLModelessDialog;
pub const DomConstructorHTMLNamespaceInfo = DomConstructor.HTMLNamespaceInfo;
pub const DomConstructorHTMLNamespaceInfoCollection = DomConstructor.HTMLNamespaceInfoCollection;
pub const DomConstructorHTMLNextIdElement = DomConstructor.HTMLNextIdElement;
pub const DomConstructorHTMLNoShowElement = DomConstructor.HTMLNoShowElement;
pub const DomConstructorHTMLObjectElement = DomConstructor.HTMLObjectElement;
pub const DomConstructorHTMLOListElement = DomConstructor.HTMLOListElement;
pub const DomConstructorHTMLOptionElement = DomConstructor.HTMLOptionElement;
pub const DomConstructorHTMLParagraphElement = DomConstructor.HTMLParagraphElement;
pub const DomConstructorHTMLParamElement = DomConstructor.HTMLParamElement;
pub const DomConstructorHTMLPhraseElement = DomConstructor.HTMLPhraseElement;
pub const DomConstructorHTMLPluginsCollection = DomConstructor.HTMLPluginsCollection;
pub const DomConstructorHTMLPopup = DomConstructor.HTMLPopup;
pub const DomConstructorHTMLScriptElement = DomConstructor.HTMLScriptElement;
pub const DomConstructorHTMLSelectElement = DomConstructor.HTMLSelectElement;
pub const DomConstructorHTMLSpanElement = DomConstructor.HTMLSpanElement;
pub const DomConstructorHTMLStyleElement = DomConstructor.HTMLStyleElement;
pub const DomConstructorHTMLTableCaptionElement = DomConstructor.HTMLTableCaptionElement;
pub const DomConstructorHTMLTableCellElement = DomConstructor.HTMLTableCellElement;
pub const DomConstructorHTMLTableColElement = DomConstructor.HTMLTableColElement;
pub const DomConstructorHTMLTableElement = DomConstructor.HTMLTableElement;
pub const DomConstructorHTMLTableRowElement = DomConstructor.HTMLTableRowElement;
pub const DomConstructorHTMLTableSectionElement = DomConstructor.HTMLTableSectionElement;
pub const DomConstructorHTMLTextAreaElement = DomConstructor.HTMLTextAreaElement;
pub const DomConstructorHTMLTextElement = DomConstructor.HTMLTextElement;
pub const DomConstructorHTMLTitleElement = DomConstructor.HTMLTitleElement;
pub const DomConstructorHTMLUListElement = DomConstructor.HTMLUListElement;
pub const DomConstructorHTMLUnknownElement = DomConstructor.HTMLUnknownElement;
pub const DomConstructorImage = DomConstructor.Image;
pub const DomConstructorLocation = DomConstructor.Location;
pub const DomConstructorNamedNodeMap = DomConstructor.NamedNodeMap;
pub const DomConstructorNavigator = DomConstructor.Navigator;
pub const DomConstructorNodeList = DomConstructor.NodeList;
pub const DomConstructorOption = DomConstructor.Option;
pub const DomConstructorScreen = DomConstructor.Screen;
pub const DomConstructorSelection = DomConstructor.Selection;
pub const DomConstructorStaticNodeList = DomConstructor.StaticNodeList;
pub const DomConstructorStorage = DomConstructor.Storage;
pub const DomConstructorStyleSheetList = DomConstructor.StyleSheetList;
pub const DomConstructorStyleSheetPage = DomConstructor.StyleSheetPage;
pub const DomConstructorStyleSheetPageList = DomConstructor.StyleSheetPageList;
pub const DomConstructorText = DomConstructor.Text;
pub const DomConstructorTextRange = DomConstructor.TextRange;
pub const DomConstructorTextRangeCollection = DomConstructor.TextRangeCollection;
pub const DomConstructorTextRectangle = DomConstructor.TextRectangle;
pub const DomConstructorTextRectangleList = DomConstructor.TextRectangleList;
pub const DomConstructorWindow = DomConstructor.Window;
pub const DomConstructorXDomainRequest = DomConstructor.XDomainRequest;
pub const DomConstructorXMLHttpRequest = DomConstructor.XMLHttpRequest;
pub const DomConstructorMax = DomConstructor.Max;
pub const DomConstructor_Max = DomConstructor._Max;

pub const styleTextTransform = enum(i32) {
    NotSet = 0,
    Capitalize = 1,
    Lowercase = 2,
    Uppercase = 3,
    None = 4,
    _Max = 2147483647,
};
pub const styleTextTransformNotSet = styleTextTransform.NotSet;
pub const styleTextTransformCapitalize = styleTextTransform.Capitalize;
pub const styleTextTransformLowercase = styleTextTransform.Lowercase;
pub const styleTextTransformUppercase = styleTextTransform.Uppercase;
pub const styleTextTransformNone = styleTextTransform.None;
pub const styleTextTransform_Max = styleTextTransform._Max;

pub const styleDataRepeat = enum(i32) {
    None = 0,
    Inner = 1,
    _Max = 2147483647,
};
pub const styleDataRepeatNone = styleDataRepeat.None;
pub const styleDataRepeatInner = styleDataRepeat.Inner;
pub const styleDataRepeat_Max = styleDataRepeat._Max;

pub const styleOverflow = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Hidden = 2,
    Visible = 3,
    Scroll = 4,
    _Max = 2147483647,
};
pub const styleOverflowNotSet = styleOverflow.NotSet;
pub const styleOverflowAuto = styleOverflow.Auto;
pub const styleOverflowHidden = styleOverflow.Hidden;
pub const styleOverflowVisible = styleOverflow.Visible;
pub const styleOverflowScroll = styleOverflow.Scroll;
pub const styleOverflow_Max = styleOverflow._Max;

pub const styleMsOverflowStyle = enum(i32) {
    NotSet = 0,
    Auto = 1,
    None = 2,
    Scrollbar = 3,
    MsAutoHidingScrollbar = 4,
    _Max = 2147483647,
};
pub const styleMsOverflowStyleNotSet = styleMsOverflowStyle.NotSet;
pub const styleMsOverflowStyleAuto = styleMsOverflowStyle.Auto;
pub const styleMsOverflowStyleNone = styleMsOverflowStyle.None;
pub const styleMsOverflowStyleScrollbar = styleMsOverflowStyle.Scrollbar;
pub const styleMsOverflowStyleMsAutoHidingScrollbar = styleMsOverflowStyle.MsAutoHidingScrollbar;
pub const styleMsOverflowStyle_Max = styleMsOverflowStyle._Max;

pub const styleTableLayout = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Fixed = 2,
    _Max = 2147483647,
};
pub const styleTableLayoutNotSet = styleTableLayout.NotSet;
pub const styleTableLayoutAuto = styleTableLayout.Auto;
pub const styleTableLayoutFixed = styleTableLayout.Fixed;
pub const styleTableLayout_Max = styleTableLayout._Max;

pub const styleBorderCollapse = enum(i32) {
    NotSet = 0,
    Separate = 1,
    Collapse = 2,
    _Max = 2147483647,
};
pub const styleBorderCollapseNotSet = styleBorderCollapse.NotSet;
pub const styleBorderCollapseSeparate = styleBorderCollapse.Separate;
pub const styleBorderCollapseCollapse = styleBorderCollapse.Collapse;
pub const styleBorderCollapse_Max = styleBorderCollapse._Max;

pub const styleCaptionSide = enum(i32) {
    NotSet = 0,
    Top = 1,
    Bottom = 2,
    Left = 3,
    Right = 4,
    _Max = 2147483647,
};
pub const styleCaptionSideNotSet = styleCaptionSide.NotSet;
pub const styleCaptionSideTop = styleCaptionSide.Top;
pub const styleCaptionSideBottom = styleCaptionSide.Bottom;
pub const styleCaptionSideLeft = styleCaptionSide.Left;
pub const styleCaptionSideRight = styleCaptionSide.Right;
pub const styleCaptionSide_Max = styleCaptionSide._Max;

pub const styleEmptyCells = enum(i32) {
    NotSet = 0,
    Show = 1,
    Hide = 2,
    _Max = 2147483647,
};
pub const styleEmptyCellsNotSet = styleEmptyCells.NotSet;
pub const styleEmptyCellsShow = styleEmptyCells.Show;
pub const styleEmptyCellsHide = styleEmptyCells.Hide;
pub const styleEmptyCells_Max = styleEmptyCells._Max;

pub const styleFontStyle = enum(i32) {
    NotSet = 0,
    Italic = 1,
    Oblique = 2,
    Normal = 3,
    _Max = 2147483647,
};
pub const styleFontStyleNotSet = styleFontStyle.NotSet;
pub const styleFontStyleItalic = styleFontStyle.Italic;
pub const styleFontStyleOblique = styleFontStyle.Oblique;
pub const styleFontStyleNormal = styleFontStyle.Normal;
pub const styleFontStyle_Max = styleFontStyle._Max;

pub const styleFontVariant = enum(i32) {
    NotSet = 0,
    SmallCaps = 1,
    Normal = 2,
    _Max = 2147483647,
};
pub const styleFontVariantNotSet = styleFontVariant.NotSet;
pub const styleFontVariantSmallCaps = styleFontVariant.SmallCaps;
pub const styleFontVariantNormal = styleFontVariant.Normal;
pub const styleFontVariant_Max = styleFontVariant._Max;

pub const styleBackgroundRepeat = enum(i32) {
    Repeat = 0,
    RepeatX = 1,
    RepeatY = 2,
    NoRepeat = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleBackgroundRepeatRepeat = styleBackgroundRepeat.Repeat;
pub const styleBackgroundRepeatRepeatX = styleBackgroundRepeat.RepeatX;
pub const styleBackgroundRepeatRepeatY = styleBackgroundRepeat.RepeatY;
pub const styleBackgroundRepeatNoRepeat = styleBackgroundRepeat.NoRepeat;
pub const styleBackgroundRepeatNotSet = styleBackgroundRepeat.NotSet;
pub const styleBackgroundRepeat_Max = styleBackgroundRepeat._Max;

pub const styleBackgroundAttachment = enum(i32) {
    Fixed = 0,
    Scroll = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleBackgroundAttachmentFixed = styleBackgroundAttachment.Fixed;
pub const styleBackgroundAttachmentScroll = styleBackgroundAttachment.Scroll;
pub const styleBackgroundAttachmentNotSet = styleBackgroundAttachment.NotSet;
pub const styleBackgroundAttachment_Max = styleBackgroundAttachment._Max;

pub const styleBackgroundAttachment3 = enum(i32) {
    Fixed = 0,
    Scroll = 1,
    Local = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleBackgroundAttachment3Fixed = styleBackgroundAttachment3.Fixed;
pub const styleBackgroundAttachment3Scroll = styleBackgroundAttachment3.Scroll;
pub const styleBackgroundAttachment3Local = styleBackgroundAttachment3.Local;
pub const styleBackgroundAttachment3NotSet = styleBackgroundAttachment3.NotSet;
pub const styleBackgroundAttachment3_Max = styleBackgroundAttachment3._Max;

pub const styleBackgroundClip = enum(i32) {
    BorderBox = 0,
    PaddingBox = 1,
    ContentBox = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleBackgroundClipBorderBox = styleBackgroundClip.BorderBox;
pub const styleBackgroundClipPaddingBox = styleBackgroundClip.PaddingBox;
pub const styleBackgroundClipContentBox = styleBackgroundClip.ContentBox;
pub const styleBackgroundClipNotSet = styleBackgroundClip.NotSet;
pub const styleBackgroundClip_Max = styleBackgroundClip._Max;

pub const styleBackgroundOrigin = enum(i32) {
    BorderBox = 0,
    PaddingBox = 1,
    ContentBox = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleBackgroundOriginBorderBox = styleBackgroundOrigin.BorderBox;
pub const styleBackgroundOriginPaddingBox = styleBackgroundOrigin.PaddingBox;
pub const styleBackgroundOriginContentBox = styleBackgroundOrigin.ContentBox;
pub const styleBackgroundOriginNotSet = styleBackgroundOrigin.NotSet;
pub const styleBackgroundOrigin_Max = styleBackgroundOrigin._Max;

pub const styleVerticalAlign = enum(i32) {
    Auto = 0,
    Baseline = 1,
    Sub = 2,
    Super = 3,
    Top = 4,
    TextTop = 5,
    Middle = 6,
    Bottom = 7,
    TextBottom = 8,
    Inherit = 9,
    NotSet = 10,
    _Max = 2147483647,
};
pub const styleVerticalAlignAuto = styleVerticalAlign.Auto;
pub const styleVerticalAlignBaseline = styleVerticalAlign.Baseline;
pub const styleVerticalAlignSub = styleVerticalAlign.Sub;
pub const styleVerticalAlignSuper = styleVerticalAlign.Super;
pub const styleVerticalAlignTop = styleVerticalAlign.Top;
pub const styleVerticalAlignTextTop = styleVerticalAlign.TextTop;
pub const styleVerticalAlignMiddle = styleVerticalAlign.Middle;
pub const styleVerticalAlignBottom = styleVerticalAlign.Bottom;
pub const styleVerticalAlignTextBottom = styleVerticalAlign.TextBottom;
pub const styleVerticalAlignInherit = styleVerticalAlign.Inherit;
pub const styleVerticalAlignNotSet = styleVerticalAlign.NotSet;
pub const styleVerticalAlign_Max = styleVerticalAlign._Max;

pub const styleFontWeight = enum(i32) {
    NotSet = 0,
    @"100" = 1,
    @"200" = 2,
    @"300" = 3,
    @"400" = 4,
    @"500" = 5,
    @"600" = 6,
    @"700" = 7,
    @"800" = 8,
    @"900" = 9,
    Normal = 10,
    Bold = 11,
    Bolder = 12,
    Lighter = 13,
    _Max = 2147483647,
};
pub const styleFontWeightNotSet = styleFontWeight.NotSet;
pub const styleFontWeight100 = styleFontWeight.@"100";
pub const styleFontWeight200 = styleFontWeight.@"200";
pub const styleFontWeight300 = styleFontWeight.@"300";
pub const styleFontWeight400 = styleFontWeight.@"400";
pub const styleFontWeight500 = styleFontWeight.@"500";
pub const styleFontWeight600 = styleFontWeight.@"600";
pub const styleFontWeight700 = styleFontWeight.@"700";
pub const styleFontWeight800 = styleFontWeight.@"800";
pub const styleFontWeight900 = styleFontWeight.@"900";
pub const styleFontWeightNormal = styleFontWeight.Normal;
pub const styleFontWeightBold = styleFontWeight.Bold;
pub const styleFontWeightBolder = styleFontWeight.Bolder;
pub const styleFontWeightLighter = styleFontWeight.Lighter;
pub const styleFontWeight_Max = styleFontWeight._Max;

pub const styleFontSize = enum(i32) {
    XXSmall = 0,
    XSmall = 1,
    Small = 2,
    Medium = 3,
    Large = 4,
    XLarge = 5,
    XXLarge = 6,
    Smaller = 7,
    Larger = 8,
    _Max = 2147483647,
};
pub const styleFontSizeXXSmall = styleFontSize.XXSmall;
pub const styleFontSizeXSmall = styleFontSize.XSmall;
pub const styleFontSizeSmall = styleFontSize.Small;
pub const styleFontSizeMedium = styleFontSize.Medium;
pub const styleFontSizeLarge = styleFontSize.Large;
pub const styleFontSizeXLarge = styleFontSize.XLarge;
pub const styleFontSizeXXLarge = styleFontSize.XXLarge;
pub const styleFontSizeSmaller = styleFontSize.Smaller;
pub const styleFontSizeLarger = styleFontSize.Larger;
pub const styleFontSize_Max = styleFontSize._Max;

pub const styleZIndex = enum(i32) {
    Auto = -2147483647,
    _Max = 2147483647,
};
pub const styleZIndexAuto = styleZIndex.Auto;
pub const styleZIndex_Max = styleZIndex._Max;

pub const styleWidowsOrphans = enum(i32) {
    NotSet = -2147483647,
    _Max = 2147483647,
};
pub const styleWidowsOrphansNotSet = styleWidowsOrphans.NotSet;
pub const styleWidowsOrphans_Max = styleWidowsOrphans._Max;

pub const styleAuto = enum(i32) {
    Auto = 0,
    _Max = 2147483647,
};
pub const styleAutoAuto = styleAuto.Auto;
pub const styleAuto_Max = styleAuto._Max;

pub const styleNone = enum(i32) {
    None = 0,
    _Max = 2147483647,
};
pub const styleNoneNone = styleNone.None;
pub const styleNone_Max = styleNone._Max;

pub const styleNormal = enum(i32) {
    Normal = 0,
    _Max = 2147483647,
};
pub const styleNormalNormal = styleNormal.Normal;
pub const styleNormal_Max = styleNormal._Max;

pub const styleBorderWidth = enum(i32) {
    Thin = 0,
    Medium = 1,
    Thick = 2,
    _Max = 2147483647,
};
pub const styleBorderWidthThin = styleBorderWidth.Thin;
pub const styleBorderWidthMedium = styleBorderWidth.Medium;
pub const styleBorderWidthThick = styleBorderWidth.Thick;
pub const styleBorderWidth_Max = styleBorderWidth._Max;

pub const stylePosition = enum(i32) {
    NotSet = 0,
    static = 1,
    relative = 2,
    absolute = 3,
    fixed = 4,
    MsPage = 5,
    MsDeviceFixed = 6,
    _Max = 2147483647,
};
pub const stylePositionNotSet = stylePosition.NotSet;
pub const stylePositionstatic = stylePosition.static;
pub const stylePositionrelative = stylePosition.relative;
pub const stylePositionabsolute = stylePosition.absolute;
pub const stylePositionfixed = stylePosition.fixed;
pub const stylePositionMsPage = stylePosition.MsPage;
pub const stylePositionMsDeviceFixed = stylePosition.MsDeviceFixed;
pub const stylePosition_Max = stylePosition._Max;

pub const styleBorderStyle = enum(i32) {
    NotSet = 0,
    Dotted = 1,
    Dashed = 2,
    Solid = 3,
    Double = 4,
    Groove = 5,
    Ridge = 6,
    Inset = 7,
    Outset = 8,
    WindowInset = 9,
    None = 10,
    Hidden = 11,
    _Max = 2147483647,
};
pub const styleBorderStyleNotSet = styleBorderStyle.NotSet;
pub const styleBorderStyleDotted = styleBorderStyle.Dotted;
pub const styleBorderStyleDashed = styleBorderStyle.Dashed;
pub const styleBorderStyleSolid = styleBorderStyle.Solid;
pub const styleBorderStyleDouble = styleBorderStyle.Double;
pub const styleBorderStyleGroove = styleBorderStyle.Groove;
pub const styleBorderStyleRidge = styleBorderStyle.Ridge;
pub const styleBorderStyleInset = styleBorderStyle.Inset;
pub const styleBorderStyleOutset = styleBorderStyle.Outset;
pub const styleBorderStyleWindowInset = styleBorderStyle.WindowInset;
pub const styleBorderStyleNone = styleBorderStyle.None;
pub const styleBorderStyleHidden = styleBorderStyle.Hidden;
pub const styleBorderStyle_Max = styleBorderStyle._Max;

pub const styleOutlineStyle = enum(i32) {
    NotSet = 0,
    Dotted = 1,
    Dashed = 2,
    Solid = 3,
    Double = 4,
    Groove = 5,
    Ridge = 6,
    Inset = 7,
    Outset = 8,
    WindowInset = 9,
    None = 10,
    _Max = 2147483647,
};
pub const styleOutlineStyleNotSet = styleOutlineStyle.NotSet;
pub const styleOutlineStyleDotted = styleOutlineStyle.Dotted;
pub const styleOutlineStyleDashed = styleOutlineStyle.Dashed;
pub const styleOutlineStyleSolid = styleOutlineStyle.Solid;
pub const styleOutlineStyleDouble = styleOutlineStyle.Double;
pub const styleOutlineStyleGroove = styleOutlineStyle.Groove;
pub const styleOutlineStyleRidge = styleOutlineStyle.Ridge;
pub const styleOutlineStyleInset = styleOutlineStyle.Inset;
pub const styleOutlineStyleOutset = styleOutlineStyle.Outset;
pub const styleOutlineStyleWindowInset = styleOutlineStyle.WindowInset;
pub const styleOutlineStyleNone = styleOutlineStyle.None;
pub const styleOutlineStyle_Max = styleOutlineStyle._Max;

pub const styleStyleFloat = enum(i32) {
    NotSet = 0,
    Left = 1,
    Right = 2,
    None = 3,
    _Max = 2147483647,
};
pub const styleStyleFloatNotSet = styleStyleFloat.NotSet;
pub const styleStyleFloatLeft = styleStyleFloat.Left;
pub const styleStyleFloatRight = styleStyleFloat.Right;
pub const styleStyleFloatNone = styleStyleFloat.None;
pub const styleStyleFloat_Max = styleStyleFloat._Max;

pub const styleDisplay = enum(i32) {
    NotSet = 0,
    Block = 1,
    Inline = 2,
    ListItem = 3,
    None = 4,
    TableHeaderGroup = 5,
    TableFooterGroup = 6,
    InlineBlock = 7,
    Table = 8,
    InlineTable = 9,
    TableRow = 10,
    TableRowGroup = 11,
    TableColumn = 12,
    TableColumnGroup = 13,
    TableCell = 14,
    TableCaption = 15,
    RunIn = 16,
    Ruby = 17,
    RubyBase = 18,
    RubyText = 19,
    RubyBaseContainer = 20,
    RubyTextContainer = 21,
    MsFlexbox = 22,
    MsInlineFlexbox = 23,
    MsGrid = 24,
    MsInlineGrid = 25,
    Flex = 26,
    InlineFlex = 27,
    WebkitBox = 28,
    WebkitInlineBox = 29,
    _Max = 2147483647,
};
pub const styleDisplayNotSet = styleDisplay.NotSet;
pub const styleDisplayBlock = styleDisplay.Block;
pub const styleDisplayInline = styleDisplay.Inline;
pub const styleDisplayListItem = styleDisplay.ListItem;
pub const styleDisplayNone = styleDisplay.None;
pub const styleDisplayTableHeaderGroup = styleDisplay.TableHeaderGroup;
pub const styleDisplayTableFooterGroup = styleDisplay.TableFooterGroup;
pub const styleDisplayInlineBlock = styleDisplay.InlineBlock;
pub const styleDisplayTable = styleDisplay.Table;
pub const styleDisplayInlineTable = styleDisplay.InlineTable;
pub const styleDisplayTableRow = styleDisplay.TableRow;
pub const styleDisplayTableRowGroup = styleDisplay.TableRowGroup;
pub const styleDisplayTableColumn = styleDisplay.TableColumn;
pub const styleDisplayTableColumnGroup = styleDisplay.TableColumnGroup;
pub const styleDisplayTableCell = styleDisplay.TableCell;
pub const styleDisplayTableCaption = styleDisplay.TableCaption;
pub const styleDisplayRunIn = styleDisplay.RunIn;
pub const styleDisplayRuby = styleDisplay.Ruby;
pub const styleDisplayRubyBase = styleDisplay.RubyBase;
pub const styleDisplayRubyText = styleDisplay.RubyText;
pub const styleDisplayRubyBaseContainer = styleDisplay.RubyBaseContainer;
pub const styleDisplayRubyTextContainer = styleDisplay.RubyTextContainer;
pub const styleDisplayMsFlexbox = styleDisplay.MsFlexbox;
pub const styleDisplayMsInlineFlexbox = styleDisplay.MsInlineFlexbox;
pub const styleDisplayMsGrid = styleDisplay.MsGrid;
pub const styleDisplayMsInlineGrid = styleDisplay.MsInlineGrid;
pub const styleDisplayFlex = styleDisplay.Flex;
pub const styleDisplayInlineFlex = styleDisplay.InlineFlex;
pub const styleDisplayWebkitBox = styleDisplay.WebkitBox;
pub const styleDisplayWebkitInlineBox = styleDisplay.WebkitInlineBox;
pub const styleDisplay_Max = styleDisplay._Max;

pub const styleVisibility = enum(i32) {
    NotSet = 0,
    Inherit = 1,
    Visible = 2,
    Hidden = 3,
    Collapse = 4,
    _Max = 2147483647,
};
pub const styleVisibilityNotSet = styleVisibility.NotSet;
pub const styleVisibilityInherit = styleVisibility.Inherit;
pub const styleVisibilityVisible = styleVisibility.Visible;
pub const styleVisibilityHidden = styleVisibility.Hidden;
pub const styleVisibilityCollapse = styleVisibility.Collapse;
pub const styleVisibility_Max = styleVisibility._Max;

pub const styleListStyleType = enum(i32) {
    NotSet = 0,
    Disc = 1,
    Circle = 2,
    Square = 3,
    Decimal = 4,
    LowerRoman = 5,
    UpperRoman = 6,
    LowerAlpha = 7,
    UpperAlpha = 8,
    None = 9,
    DecimalLeadingZero = 10,
    Georgian = 11,
    Armenian = 12,
    UpperLatin = 13,
    LowerLatin = 14,
    UpperGreek = 15,
    LowerGreek = 16,
    _Max = 2147483647,
};
pub const styleListStyleTypeNotSet = styleListStyleType.NotSet;
pub const styleListStyleTypeDisc = styleListStyleType.Disc;
pub const styleListStyleTypeCircle = styleListStyleType.Circle;
pub const styleListStyleTypeSquare = styleListStyleType.Square;
pub const styleListStyleTypeDecimal = styleListStyleType.Decimal;
pub const styleListStyleTypeLowerRoman = styleListStyleType.LowerRoman;
pub const styleListStyleTypeUpperRoman = styleListStyleType.UpperRoman;
pub const styleListStyleTypeLowerAlpha = styleListStyleType.LowerAlpha;
pub const styleListStyleTypeUpperAlpha = styleListStyleType.UpperAlpha;
pub const styleListStyleTypeNone = styleListStyleType.None;
pub const styleListStyleTypeDecimalLeadingZero = styleListStyleType.DecimalLeadingZero;
pub const styleListStyleTypeGeorgian = styleListStyleType.Georgian;
pub const styleListStyleTypeArmenian = styleListStyleType.Armenian;
pub const styleListStyleTypeUpperLatin = styleListStyleType.UpperLatin;
pub const styleListStyleTypeLowerLatin = styleListStyleType.LowerLatin;
pub const styleListStyleTypeUpperGreek = styleListStyleType.UpperGreek;
pub const styleListStyleTypeLowerGreek = styleListStyleType.LowerGreek;
pub const styleListStyleType_Max = styleListStyleType._Max;

pub const styleListStylePosition = enum(i32) {
    NotSet = 0,
    Inside = 1,
    OutSide = 2,
    _Max = 2147483647,
};
pub const styleListStylePositionNotSet = styleListStylePosition.NotSet;
pub const styleListStylePositionInside = styleListStylePosition.Inside;
pub const styleListStylePositionOutSide = styleListStylePosition.OutSide;
pub const styleListStylePosition_Max = styleListStylePosition._Max;

pub const styleWhiteSpace = enum(i32) {
    NotSet = 0,
    Normal = 1,
    Pre = 2,
    Nowrap = 3,
    Preline = 4,
    Prewrap = 5,
    _Max = 2147483647,
};
pub const styleWhiteSpaceNotSet = styleWhiteSpace.NotSet;
pub const styleWhiteSpaceNormal = styleWhiteSpace.Normal;
pub const styleWhiteSpacePre = styleWhiteSpace.Pre;
pub const styleWhiteSpaceNowrap = styleWhiteSpace.Nowrap;
pub const styleWhiteSpacePreline = styleWhiteSpace.Preline;
pub const styleWhiteSpacePrewrap = styleWhiteSpace.Prewrap;
pub const styleWhiteSpace_Max = styleWhiteSpace._Max;

pub const stylePageBreak = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Always = 2,
    Left = 3,
    Right = 4,
    Avoid = 5,
    _Max = 2147483647,
};
pub const stylePageBreakNotSet = stylePageBreak.NotSet;
pub const stylePageBreakAuto = stylePageBreak.Auto;
pub const stylePageBreakAlways = stylePageBreak.Always;
pub const stylePageBreakLeft = stylePageBreak.Left;
pub const stylePageBreakRight = stylePageBreak.Right;
pub const stylePageBreakAvoid = stylePageBreak.Avoid;
pub const stylePageBreak_Max = stylePageBreak._Max;

pub const stylePageBreakInside = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Avoid = 2,
    _Max = 2147483647,
};
pub const stylePageBreakInsideNotSet = stylePageBreakInside.NotSet;
pub const stylePageBreakInsideAuto = stylePageBreakInside.Auto;
pub const stylePageBreakInsideAvoid = stylePageBreakInside.Avoid;
pub const stylePageBreakInside_Max = stylePageBreakInside._Max;

pub const styleCursor = enum(i32) {
    Auto = 0,
    Crosshair = 1,
    Default = 2,
    Hand = 3,
    Move = 4,
    E_resize = 5,
    Ne_resize = 6,
    Nw_resize = 7,
    N_resize = 8,
    Se_resize = 9,
    Sw_resize = 10,
    S_resize = 11,
    W_resize = 12,
    Text = 13,
    Wait = 14,
    Help = 15,
    Pointer = 16,
    Progress = 17,
    Not_allowed = 18,
    No_drop = 19,
    Vertical_text = 20,
    all_scroll = 21,
    col_resize = 22,
    row_resize = 23,
    None = 24,
    Context_menu = 25,
    Ew_resize = 26,
    Ns_resize = 27,
    Nesw_resize = 28,
    Nwse_resize = 29,
    Cell = 30,
    Copy = 31,
    Alias = 32,
    custom = 33,
    NotSet = 34,
    _Max = 2147483647,
};
pub const styleCursorAuto = styleCursor.Auto;
pub const styleCursorCrosshair = styleCursor.Crosshair;
pub const styleCursorDefault = styleCursor.Default;
pub const styleCursorHand = styleCursor.Hand;
pub const styleCursorMove = styleCursor.Move;
pub const styleCursorE_resize = styleCursor.E_resize;
pub const styleCursorNe_resize = styleCursor.Ne_resize;
pub const styleCursorNw_resize = styleCursor.Nw_resize;
pub const styleCursorN_resize = styleCursor.N_resize;
pub const styleCursorSe_resize = styleCursor.Se_resize;
pub const styleCursorSw_resize = styleCursor.Sw_resize;
pub const styleCursorS_resize = styleCursor.S_resize;
pub const styleCursorW_resize = styleCursor.W_resize;
pub const styleCursorText = styleCursor.Text;
pub const styleCursorWait = styleCursor.Wait;
pub const styleCursorHelp = styleCursor.Help;
pub const styleCursorPointer = styleCursor.Pointer;
pub const styleCursorProgress = styleCursor.Progress;
pub const styleCursorNot_allowed = styleCursor.Not_allowed;
pub const styleCursorNo_drop = styleCursor.No_drop;
pub const styleCursorVertical_text = styleCursor.Vertical_text;
pub const styleCursorall_scroll = styleCursor.all_scroll;
pub const styleCursorcol_resize = styleCursor.col_resize;
pub const styleCursorrow_resize = styleCursor.row_resize;
pub const styleCursorNone = styleCursor.None;
pub const styleCursorContext_menu = styleCursor.Context_menu;
pub const styleCursorEw_resize = styleCursor.Ew_resize;
pub const styleCursorNs_resize = styleCursor.Ns_resize;
pub const styleCursorNesw_resize = styleCursor.Nesw_resize;
pub const styleCursorNwse_resize = styleCursor.Nwse_resize;
pub const styleCursorCell = styleCursor.Cell;
pub const styleCursorCopy = styleCursor.Copy;
pub const styleCursorAlias = styleCursor.Alias;
pub const styleCursorcustom = styleCursor.custom;
pub const styleCursorNotSet = styleCursor.NotSet;
pub const styleCursor_Max = styleCursor._Max;

pub const styleDir = enum(i32) {
    NotSet = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    Inherit = 3,
    _Max = 2147483647,
};
pub const styleDirNotSet = styleDir.NotSet;
pub const styleDirLeftToRight = styleDir.LeftToRight;
pub const styleDirRightToLeft = styleDir.RightToLeft;
pub const styleDirInherit = styleDir.Inherit;
pub const styleDir_Max = styleDir._Max;

pub const styleBidi = enum(i32) {
    NotSet = 0,
    Normal = 1,
    Embed = 2,
    Override = 3,
    Inherit = 4,
    _Max = 2147483647,
};
pub const styleBidiNotSet = styleBidi.NotSet;
pub const styleBidiNormal = styleBidi.Normal;
pub const styleBidiEmbed = styleBidi.Embed;
pub const styleBidiOverride = styleBidi.Override;
pub const styleBidiInherit = styleBidi.Inherit;
pub const styleBidi_Max = styleBidi._Max;

pub const styleImeMode = enum(i32) {
    Auto = 0,
    Active = 1,
    Inactive = 2,
    Disabled = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleImeModeAuto = styleImeMode.Auto;
pub const styleImeModeActive = styleImeMode.Active;
pub const styleImeModeInactive = styleImeMode.Inactive;
pub const styleImeModeDisabled = styleImeMode.Disabled;
pub const styleImeModeNotSet = styleImeMode.NotSet;
pub const styleImeMode_Max = styleImeMode._Max;

pub const styleRubyAlign = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Left = 2,
    Center = 3,
    Right = 4,
    DistributeLetter = 5,
    DistributeSpace = 6,
    LineEdge = 7,
    _Max = 2147483647,
};
pub const styleRubyAlignNotSet = styleRubyAlign.NotSet;
pub const styleRubyAlignAuto = styleRubyAlign.Auto;
pub const styleRubyAlignLeft = styleRubyAlign.Left;
pub const styleRubyAlignCenter = styleRubyAlign.Center;
pub const styleRubyAlignRight = styleRubyAlign.Right;
pub const styleRubyAlignDistributeLetter = styleRubyAlign.DistributeLetter;
pub const styleRubyAlignDistributeSpace = styleRubyAlign.DistributeSpace;
pub const styleRubyAlignLineEdge = styleRubyAlign.LineEdge;
pub const styleRubyAlign_Max = styleRubyAlign._Max;

pub const styleRubyPosition = enum(i32) {
    NotSet = 0,
    Above = 1,
    Inline = 2,
    _Max = 2147483647,
};
pub const styleRubyPositionNotSet = styleRubyPosition.NotSet;
pub const styleRubyPositionAbove = styleRubyPosition.Above;
pub const styleRubyPositionInline = styleRubyPosition.Inline;
pub const styleRubyPosition_Max = styleRubyPosition._Max;

pub const styleRubyOverhang = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Whitespace = 2,
    None = 3,
    _Max = 2147483647,
};
pub const styleRubyOverhangNotSet = styleRubyOverhang.NotSet;
pub const styleRubyOverhangAuto = styleRubyOverhang.Auto;
pub const styleRubyOverhangWhitespace = styleRubyOverhang.Whitespace;
pub const styleRubyOverhangNone = styleRubyOverhang.None;
pub const styleRubyOverhang_Max = styleRubyOverhang._Max;

pub const styleLayoutGridChar = enum(i32) {
    NotSet = 0,
    Auto = 1,
    None = 2,
    _Max = 2147483647,
};
pub const styleLayoutGridCharNotSet = styleLayoutGridChar.NotSet;
pub const styleLayoutGridCharAuto = styleLayoutGridChar.Auto;
pub const styleLayoutGridCharNone = styleLayoutGridChar.None;
pub const styleLayoutGridChar_Max = styleLayoutGridChar._Max;

pub const styleLayoutGridLine = enum(i32) {
    NotSet = 0,
    Auto = 1,
    None = 2,
    _Max = 2147483647,
};
pub const styleLayoutGridLineNotSet = styleLayoutGridLine.NotSet;
pub const styleLayoutGridLineAuto = styleLayoutGridLine.Auto;
pub const styleLayoutGridLineNone = styleLayoutGridLine.None;
pub const styleLayoutGridLine_Max = styleLayoutGridLine._Max;

pub const styleLayoutGridMode = enum(i32) {
    NotSet = 0,
    Char = 1,
    Line = 2,
    Both = 3,
    None = 4,
    _Max = 2147483647,
};
pub const styleLayoutGridModeNotSet = styleLayoutGridMode.NotSet;
pub const styleLayoutGridModeChar = styleLayoutGridMode.Char;
pub const styleLayoutGridModeLine = styleLayoutGridMode.Line;
pub const styleLayoutGridModeBoth = styleLayoutGridMode.Both;
pub const styleLayoutGridModeNone = styleLayoutGridMode.None;
pub const styleLayoutGridMode_Max = styleLayoutGridMode._Max;

pub const styleLayoutGridType = enum(i32) {
    NotSet = 0,
    Loose = 1,
    Strict = 2,
    Fixed = 3,
    _Max = 2147483647,
};
pub const styleLayoutGridTypeNotSet = styleLayoutGridType.NotSet;
pub const styleLayoutGridTypeLoose = styleLayoutGridType.Loose;
pub const styleLayoutGridTypeStrict = styleLayoutGridType.Strict;
pub const styleLayoutGridTypeFixed = styleLayoutGridType.Fixed;
pub const styleLayoutGridType_Max = styleLayoutGridType._Max;

pub const styleLineBreak = enum(i32) {
    NotSet = 0,
    Normal = 1,
    Strict = 2,
    _Max = 2147483647,
};
pub const styleLineBreakNotSet = styleLineBreak.NotSet;
pub const styleLineBreakNormal = styleLineBreak.Normal;
pub const styleLineBreakStrict = styleLineBreak.Strict;
pub const styleLineBreak_Max = styleLineBreak._Max;

pub const styleWordBreak = enum(i32) {
    NotSet = 0,
    Normal = 1,
    BreakAll = 2,
    KeepAll = 3,
    _Max = 2147483647,
};
pub const styleWordBreakNotSet = styleWordBreak.NotSet;
pub const styleWordBreakNormal = styleWordBreak.Normal;
pub const styleWordBreakBreakAll = styleWordBreak.BreakAll;
pub const styleWordBreakKeepAll = styleWordBreak.KeepAll;
pub const styleWordBreak_Max = styleWordBreak._Max;

pub const styleWordWrap = enum(i32) {
    NotSet = 0,
    Off = 1,
    On = 2,
    _Max = 2147483647,
};
pub const styleWordWrapNotSet = styleWordWrap.NotSet;
pub const styleWordWrapOff = styleWordWrap.Off;
pub const styleWordWrapOn = styleWordWrap.On;
pub const styleWordWrap_Max = styleWordWrap._Max;

pub const styleTextJustify = enum(i32) {
    NotSet = 0,
    InterWord = 1,
    Newspaper = 2,
    Distribute = 3,
    DistributeAllLines = 4,
    InterIdeograph = 5,
    InterCluster = 6,
    Kashida = 7,
    Auto = 8,
    _Max = 2147483647,
};
pub const styleTextJustifyNotSet = styleTextJustify.NotSet;
pub const styleTextJustifyInterWord = styleTextJustify.InterWord;
pub const styleTextJustifyNewspaper = styleTextJustify.Newspaper;
pub const styleTextJustifyDistribute = styleTextJustify.Distribute;
pub const styleTextJustifyDistributeAllLines = styleTextJustify.DistributeAllLines;
pub const styleTextJustifyInterIdeograph = styleTextJustify.InterIdeograph;
pub const styleTextJustifyInterCluster = styleTextJustify.InterCluster;
pub const styleTextJustifyKashida = styleTextJustify.Kashida;
pub const styleTextJustifyAuto = styleTextJustify.Auto;
pub const styleTextJustify_Max = styleTextJustify._Max;

pub const styleTextAlignLast = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    Justify = 4,
    Auto = 5,
    _Max = 2147483647,
};
pub const styleTextAlignLastNotSet = styleTextAlignLast.NotSet;
pub const styleTextAlignLastLeft = styleTextAlignLast.Left;
pub const styleTextAlignLastCenter = styleTextAlignLast.Center;
pub const styleTextAlignLastRight = styleTextAlignLast.Right;
pub const styleTextAlignLastJustify = styleTextAlignLast.Justify;
pub const styleTextAlignLastAuto = styleTextAlignLast.Auto;
pub const styleTextAlignLast_Max = styleTextAlignLast._Max;

pub const styleTextJustifyTrim = enum(i32) {
    NotSet = 0,
    None = 1,
    Punctuation = 2,
    PunctAndKana = 3,
    _Max = 2147483647,
};
pub const styleTextJustifyTrimNotSet = styleTextJustifyTrim.NotSet;
pub const styleTextJustifyTrimNone = styleTextJustifyTrim.None;
pub const styleTextJustifyTrimPunctuation = styleTextJustifyTrim.Punctuation;
pub const styleTextJustifyTrimPunctAndKana = styleTextJustifyTrim.PunctAndKana;
pub const styleTextJustifyTrim_Max = styleTextJustifyTrim._Max;

pub const styleAccelerator = enum(i32) {
    False = 0,
    True = 1,
    _Max = 2147483647,
};
pub const styleAcceleratorFalse = styleAccelerator.False;
pub const styleAcceleratorTrue = styleAccelerator.True;
pub const styleAccelerator_Max = styleAccelerator._Max;

pub const styleLayoutFlow = enum(i32) {
    Horizontal = 0,
    VerticalIdeographic = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleLayoutFlowHorizontal = styleLayoutFlow.Horizontal;
pub const styleLayoutFlowVerticalIdeographic = styleLayoutFlow.VerticalIdeographic;
pub const styleLayoutFlowNotSet = styleLayoutFlow.NotSet;
pub const styleLayoutFlow_Max = styleLayoutFlow._Max;

pub const styleBlockProgression = enum(i32) {
    Tb = 0,
    Rl = 1,
    Bt = 2,
    Lr = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleBlockProgressionTb = styleBlockProgression.Tb;
pub const styleBlockProgressionRl = styleBlockProgression.Rl;
pub const styleBlockProgressionBt = styleBlockProgression.Bt;
pub const styleBlockProgressionLr = styleBlockProgression.Lr;
pub const styleBlockProgressionNotSet = styleBlockProgression.NotSet;
pub const styleBlockProgression_Max = styleBlockProgression._Max;

pub const styleWritingMode = enum(i32) {
    Lrtb = 0,
    Tbrl = 1,
    Rltb = 2,
    Btrl = 3,
    NotSet = 4,
    Tblr = 5,
    Btlr = 6,
    Lrbt = 7,
    Rlbt = 8,
    Lr = 9,
    Rl = 10,
    Tb = 11,
    _Max = 2147483647,
};
pub const styleWritingModeLrtb = styleWritingMode.Lrtb;
pub const styleWritingModeTbrl = styleWritingMode.Tbrl;
pub const styleWritingModeRltb = styleWritingMode.Rltb;
pub const styleWritingModeBtrl = styleWritingMode.Btrl;
pub const styleWritingModeNotSet = styleWritingMode.NotSet;
pub const styleWritingModeTblr = styleWritingMode.Tblr;
pub const styleWritingModeBtlr = styleWritingMode.Btlr;
pub const styleWritingModeLrbt = styleWritingMode.Lrbt;
pub const styleWritingModeRlbt = styleWritingMode.Rlbt;
pub const styleWritingModeLr = styleWritingMode.Lr;
pub const styleWritingModeRl = styleWritingMode.Rl;
pub const styleWritingModeTb = styleWritingMode.Tb;
pub const styleWritingMode_Max = styleWritingMode._Max;

pub const styleBool = enum(i32) {
    False = 0,
    True = 1,
    _Max = 2147483647,
};
pub const styleBoolFalse = styleBool.False;
pub const styleBoolTrue = styleBool.True;
pub const styleBool_Max = styleBool._Max;

pub const styleTextUnderlinePosition = enum(i32) {
    Below = 0,
    Above = 1,
    Auto = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleTextUnderlinePositionBelow = styleTextUnderlinePosition.Below;
pub const styleTextUnderlinePositionAbove = styleTextUnderlinePosition.Above;
pub const styleTextUnderlinePositionAuto = styleTextUnderlinePosition.Auto;
pub const styleTextUnderlinePositionNotSet = styleTextUnderlinePosition.NotSet;
pub const styleTextUnderlinePosition_Max = styleTextUnderlinePosition._Max;

pub const styleTextOverflow = enum(i32) {
    Clip = 0,
    Ellipsis = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleTextOverflowClip = styleTextOverflow.Clip;
pub const styleTextOverflowEllipsis = styleTextOverflow.Ellipsis;
pub const styleTextOverflowNotSet = styleTextOverflow.NotSet;
pub const styleTextOverflow_Max = styleTextOverflow._Max;

pub const styleInterpolation = enum(i32) {
    NotSet = 0,
    NN = 1,
    BCH = 2,
    _Max = 2147483647,
};
pub const styleInterpolationNotSet = styleInterpolation.NotSet;
pub const styleInterpolationNN = styleInterpolation.NN;
pub const styleInterpolationBCH = styleInterpolation.BCH;
pub const styleInterpolation_Max = styleInterpolation._Max;

pub const styleBoxSizing = enum(i32) {
    NotSet = 0,
    ContentBox = 1,
    BorderBox = 2,
    _Max = 2147483647,
};
pub const styleBoxSizingNotSet = styleBoxSizing.NotSet;
pub const styleBoxSizingContentBox = styleBoxSizing.ContentBox;
pub const styleBoxSizingBorderBox = styleBoxSizing.BorderBox;
pub const styleBoxSizing_Max = styleBoxSizing._Max;

pub const styleFlex = enum(i32) {
    None = 0,
    NotSet = 1,
    _Max = 2147483647,
};
pub const styleFlexNone = styleFlex.None;
pub const styleFlexNotSet = styleFlex.NotSet;
pub const styleFlex_Max = styleFlex._Max;

pub const styleFlexBasis = enum(i32) {
    Auto = 0,
    NotSet = 1,
    _Max = 2147483647,
};
pub const styleFlexBasisAuto = styleFlexBasis.Auto;
pub const styleFlexBasisNotSet = styleFlexBasis.NotSet;
pub const styleFlexBasis_Max = styleFlexBasis._Max;

pub const styleFlexDirection = enum(i32) {
    Row = 0,
    RowReverse = 1,
    Column = 2,
    ColumnReverse = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleFlexDirectionRow = styleFlexDirection.Row;
pub const styleFlexDirectionRowReverse = styleFlexDirection.RowReverse;
pub const styleFlexDirectionColumn = styleFlexDirection.Column;
pub const styleFlexDirectionColumnReverse = styleFlexDirection.ColumnReverse;
pub const styleFlexDirectionNotSet = styleFlexDirection.NotSet;
pub const styleFlexDirection_Max = styleFlexDirection._Max;

pub const styleWebkitBoxOrient = enum(i32) {
    Horizontal = 0,
    InlineAxis = 1,
    Vertical = 2,
    BlockAxis = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleWebkitBoxOrientHorizontal = styleWebkitBoxOrient.Horizontal;
pub const styleWebkitBoxOrientInlineAxis = styleWebkitBoxOrient.InlineAxis;
pub const styleWebkitBoxOrientVertical = styleWebkitBoxOrient.Vertical;
pub const styleWebkitBoxOrientBlockAxis = styleWebkitBoxOrient.BlockAxis;
pub const styleWebkitBoxOrientNotSet = styleWebkitBoxOrient.NotSet;
pub const styleWebkitBoxOrient_Max = styleWebkitBoxOrient._Max;

pub const styleWebkitBoxDirection = enum(i32) {
    Normal = 0,
    Reverse = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleWebkitBoxDirectionNormal = styleWebkitBoxDirection.Normal;
pub const styleWebkitBoxDirectionReverse = styleWebkitBoxDirection.Reverse;
pub const styleWebkitBoxDirectionNotSet = styleWebkitBoxDirection.NotSet;
pub const styleWebkitBoxDirection_Max = styleWebkitBoxDirection._Max;

pub const styleFlexWrap = enum(i32) {
    Nowrap = 0,
    Wrap = 1,
    WrapReverse = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleFlexWrapNowrap = styleFlexWrap.Nowrap;
pub const styleFlexWrapWrap = styleFlexWrap.Wrap;
pub const styleFlexWrapWrapReverse = styleFlexWrap.WrapReverse;
pub const styleFlexWrapNotSet = styleFlexWrap.NotSet;
pub const styleFlexWrap_Max = styleFlexWrap._Max;

pub const styleAlignItems = enum(i32) {
    FlexStart = 0,
    FlexEnd = 1,
    Center = 2,
    Baseline = 3,
    Stretch = 4,
    NotSet = 5,
    _Max = 2147483647,
};
pub const styleAlignItemsFlexStart = styleAlignItems.FlexStart;
pub const styleAlignItemsFlexEnd = styleAlignItems.FlexEnd;
pub const styleAlignItemsCenter = styleAlignItems.Center;
pub const styleAlignItemsBaseline = styleAlignItems.Baseline;
pub const styleAlignItemsStretch = styleAlignItems.Stretch;
pub const styleAlignItemsNotSet = styleAlignItems.NotSet;
pub const styleAlignItems_Max = styleAlignItems._Max;

pub const styleMsFlexAlign = enum(i32) {
    Start = 0,
    End = 1,
    Center = 2,
    Baseline = 3,
    Stretch = 4,
    NotSet = 5,
    _Max = 2147483647,
};
pub const styleMsFlexAlignStart = styleMsFlexAlign.Start;
pub const styleMsFlexAlignEnd = styleMsFlexAlign.End;
pub const styleMsFlexAlignCenter = styleMsFlexAlign.Center;
pub const styleMsFlexAlignBaseline = styleMsFlexAlign.Baseline;
pub const styleMsFlexAlignStretch = styleMsFlexAlign.Stretch;
pub const styleMsFlexAlignNotSet = styleMsFlexAlign.NotSet;
pub const styleMsFlexAlign_Max = styleMsFlexAlign._Max;

pub const styleMsFlexItemAlign = enum(i32) {
    Start = 0,
    End = 1,
    Center = 2,
    Baseline = 3,
    Stretch = 4,
    Auto = 5,
    NotSet = 6,
    _Max = 2147483647,
};
pub const styleMsFlexItemAlignStart = styleMsFlexItemAlign.Start;
pub const styleMsFlexItemAlignEnd = styleMsFlexItemAlign.End;
pub const styleMsFlexItemAlignCenter = styleMsFlexItemAlign.Center;
pub const styleMsFlexItemAlignBaseline = styleMsFlexItemAlign.Baseline;
pub const styleMsFlexItemAlignStretch = styleMsFlexItemAlign.Stretch;
pub const styleMsFlexItemAlignAuto = styleMsFlexItemAlign.Auto;
pub const styleMsFlexItemAlignNotSet = styleMsFlexItemAlign.NotSet;
pub const styleMsFlexItemAlign_Max = styleMsFlexItemAlign._Max;

pub const styleAlignSelf = enum(i32) {
    FlexStart = 0,
    FlexEnd = 1,
    Center = 2,
    Baseline = 3,
    Stretch = 4,
    Auto = 5,
    NotSet = 6,
    _Max = 2147483647,
};
pub const styleAlignSelfFlexStart = styleAlignSelf.FlexStart;
pub const styleAlignSelfFlexEnd = styleAlignSelf.FlexEnd;
pub const styleAlignSelfCenter = styleAlignSelf.Center;
pub const styleAlignSelfBaseline = styleAlignSelf.Baseline;
pub const styleAlignSelfStretch = styleAlignSelf.Stretch;
pub const styleAlignSelfAuto = styleAlignSelf.Auto;
pub const styleAlignSelfNotSet = styleAlignSelf.NotSet;
pub const styleAlignSelf_Max = styleAlignSelf._Max;

pub const styleJustifyContent = enum(i32) {
    FlexStart = 0,
    FlexEnd = 1,
    Center = 2,
    SpaceBetween = 3,
    SpaceAround = 4,
    NotSet = 5,
    _Max = 2147483647,
};
pub const styleJustifyContentFlexStart = styleJustifyContent.FlexStart;
pub const styleJustifyContentFlexEnd = styleJustifyContent.FlexEnd;
pub const styleJustifyContentCenter = styleJustifyContent.Center;
pub const styleJustifyContentSpaceBetween = styleJustifyContent.SpaceBetween;
pub const styleJustifyContentSpaceAround = styleJustifyContent.SpaceAround;
pub const styleJustifyContentNotSet = styleJustifyContent.NotSet;
pub const styleJustifyContent_Max = styleJustifyContent._Max;

pub const styleMsFlexPack = enum(i32) {
    Start = 0,
    End = 1,
    Center = 2,
    Justify = 3,
    Distribute = 4,
    NotSet = 5,
    _Max = 2147483647,
};
pub const styleMsFlexPackStart = styleMsFlexPack.Start;
pub const styleMsFlexPackEnd = styleMsFlexPack.End;
pub const styleMsFlexPackCenter = styleMsFlexPack.Center;
pub const styleMsFlexPackJustify = styleMsFlexPack.Justify;
pub const styleMsFlexPackDistribute = styleMsFlexPack.Distribute;
pub const styleMsFlexPackNotSet = styleMsFlexPack.NotSet;
pub const styleMsFlexPack_Max = styleMsFlexPack._Max;

pub const styleWebkitBoxPack = enum(i32) {
    Start = 0,
    End = 1,
    Center = 2,
    Justify = 3,
    NotSet = 5,
    _Max = 2147483647,
};
pub const styleWebkitBoxPackStart = styleWebkitBoxPack.Start;
pub const styleWebkitBoxPackEnd = styleWebkitBoxPack.End;
pub const styleWebkitBoxPackCenter = styleWebkitBoxPack.Center;
pub const styleWebkitBoxPackJustify = styleWebkitBoxPack.Justify;
pub const styleWebkitBoxPackNotSet = styleWebkitBoxPack.NotSet;
pub const styleWebkitBoxPack_Max = styleWebkitBoxPack._Max;

pub const styleMsFlexLinePack = enum(i32) {
    Start = 0,
    End = 1,
    Center = 2,
    Justify = 3,
    Distribute = 4,
    Stretch = 5,
    NotSet = 6,
    _Max = 2147483647,
};
pub const styleMsFlexLinePackStart = styleMsFlexLinePack.Start;
pub const styleMsFlexLinePackEnd = styleMsFlexLinePack.End;
pub const styleMsFlexLinePackCenter = styleMsFlexLinePack.Center;
pub const styleMsFlexLinePackJustify = styleMsFlexLinePack.Justify;
pub const styleMsFlexLinePackDistribute = styleMsFlexLinePack.Distribute;
pub const styleMsFlexLinePackStretch = styleMsFlexLinePack.Stretch;
pub const styleMsFlexLinePackNotSet = styleMsFlexLinePack.NotSet;
pub const styleMsFlexLinePack_Max = styleMsFlexLinePack._Max;

pub const styleAlignContent = enum(i32) {
    FlexStart = 0,
    FlexEnd = 1,
    Center = 2,
    SpaceBetween = 3,
    SpaceAround = 4,
    Stretch = 5,
    NotSet = 6,
    _Max = 2147483647,
};
pub const styleAlignContentFlexStart = styleAlignContent.FlexStart;
pub const styleAlignContentFlexEnd = styleAlignContent.FlexEnd;
pub const styleAlignContentCenter = styleAlignContent.Center;
pub const styleAlignContentSpaceBetween = styleAlignContent.SpaceBetween;
pub const styleAlignContentSpaceAround = styleAlignContent.SpaceAround;
pub const styleAlignContentStretch = styleAlignContent.Stretch;
pub const styleAlignContentNotSet = styleAlignContent.NotSet;
pub const styleAlignContent_Max = styleAlignContent._Max;

pub const styleColumnFill = enum(i32) {
    Auto = 0,
    Balance = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleColumnFillAuto = styleColumnFill.Auto;
pub const styleColumnFillBalance = styleColumnFill.Balance;
pub const styleColumnFillNotSet = styleColumnFill.NotSet;
pub const styleColumnFill_Max = styleColumnFill._Max;

pub const styleColumnSpan = enum(i32) {
    None = 0,
    All = 1,
    One = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleColumnSpanNone = styleColumnSpan.None;
pub const styleColumnSpanAll = styleColumnSpan.All;
pub const styleColumnSpanOne = styleColumnSpan.One;
pub const styleColumnSpanNotSet = styleColumnSpan.NotSet;
pub const styleColumnSpan_Max = styleColumnSpan._Max;

pub const styleBreak = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Always = 2,
    Avoid = 3,
    Left = 4,
    Right = 5,
    Page = 6,
    Column = 7,
    AvoidPage = 8,
    AvoidColumn = 9,
    _Max = 2147483647,
};
pub const styleBreakNotSet = styleBreak.NotSet;
pub const styleBreakAuto = styleBreak.Auto;
pub const styleBreakAlways = styleBreak.Always;
pub const styleBreakAvoid = styleBreak.Avoid;
pub const styleBreakLeft = styleBreak.Left;
pub const styleBreakRight = styleBreak.Right;
pub const styleBreakPage = styleBreak.Page;
pub const styleBreakColumn = styleBreak.Column;
pub const styleBreakAvoidPage = styleBreak.AvoidPage;
pub const styleBreakAvoidColumn = styleBreak.AvoidColumn;
pub const styleBreak_Max = styleBreak._Max;

pub const styleBreakInside = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Avoid = 2,
    AvoidPage = 3,
    AvoidColumn = 4,
    _Max = 2147483647,
};
pub const styleBreakInsideNotSet = styleBreakInside.NotSet;
pub const styleBreakInsideAuto = styleBreakInside.Auto;
pub const styleBreakInsideAvoid = styleBreakInside.Avoid;
pub const styleBreakInsideAvoidPage = styleBreakInside.AvoidPage;
pub const styleBreakInsideAvoidColumn = styleBreakInside.AvoidColumn;
pub const styleBreakInside_Max = styleBreakInside._Max;

pub const styleMsScrollChaining = enum(i32) {
    NotSet = 0,
    None = 1,
    Chained = 2,
    _Max = 2147483647,
};
pub const styleMsScrollChainingNotSet = styleMsScrollChaining.NotSet;
pub const styleMsScrollChainingNone = styleMsScrollChaining.None;
pub const styleMsScrollChainingChained = styleMsScrollChaining.Chained;
pub const styleMsScrollChaining_Max = styleMsScrollChaining._Max;

pub const styleMsContentZooming = enum(i32) {
    NotSet = 0,
    None = 1,
    Zoom = 2,
    _Max = 2147483647,
};
pub const styleMsContentZoomingNotSet = styleMsContentZooming.NotSet;
pub const styleMsContentZoomingNone = styleMsContentZooming.None;
pub const styleMsContentZoomingZoom = styleMsContentZooming.Zoom;
pub const styleMsContentZooming_Max = styleMsContentZooming._Max;

pub const styleMsContentZoomSnapType = enum(i32) {
    NotSet = 0,
    None = 1,
    Mandatory = 2,
    Proximity = 3,
    _Max = 2147483647,
};
pub const styleMsContentZoomSnapTypeNotSet = styleMsContentZoomSnapType.NotSet;
pub const styleMsContentZoomSnapTypeNone = styleMsContentZoomSnapType.None;
pub const styleMsContentZoomSnapTypeMandatory = styleMsContentZoomSnapType.Mandatory;
pub const styleMsContentZoomSnapTypeProximity = styleMsContentZoomSnapType.Proximity;
pub const styleMsContentZoomSnapType_Max = styleMsContentZoomSnapType._Max;

pub const styleMsScrollRails = enum(i32) {
    NotSet = 0,
    None = 1,
    Railed = 2,
    _Max = 2147483647,
};
pub const styleMsScrollRailsNotSet = styleMsScrollRails.NotSet;
pub const styleMsScrollRailsNone = styleMsScrollRails.None;
pub const styleMsScrollRailsRailed = styleMsScrollRails.Railed;
pub const styleMsScrollRails_Max = styleMsScrollRails._Max;

pub const styleMsContentZoomChaining = enum(i32) {
    NotSet = 0,
    None = 1,
    Chained = 2,
    _Max = 2147483647,
};
pub const styleMsContentZoomChainingNotSet = styleMsContentZoomChaining.NotSet;
pub const styleMsContentZoomChainingNone = styleMsContentZoomChaining.None;
pub const styleMsContentZoomChainingChained = styleMsContentZoomChaining.Chained;
pub const styleMsContentZoomChaining_Max = styleMsContentZoomChaining._Max;

pub const styleMsScrollSnapType = enum(i32) {
    NotSet = 0,
    None = 1,
    Mandatory = 2,
    Proximity = 3,
    _Max = 2147483647,
};
pub const styleMsScrollSnapTypeNotSet = styleMsScrollSnapType.NotSet;
pub const styleMsScrollSnapTypeNone = styleMsScrollSnapType.None;
pub const styleMsScrollSnapTypeMandatory = styleMsScrollSnapType.Mandatory;
pub const styleMsScrollSnapTypeProximity = styleMsScrollSnapType.Proximity;
pub const styleMsScrollSnapType_Max = styleMsScrollSnapType._Max;

pub const styleGridColumn = enum(i32) {
    NotSet = 0,
    _Max = 2147483647,
};
pub const styleGridColumnNotSet = styleGridColumn.NotSet;
pub const styleGridColumn_Max = styleGridColumn._Max;

pub const styleGridColumnAlign = enum(i32) {
    Center = 0,
    End = 1,
    Start = 2,
    Stretch = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleGridColumnAlignCenter = styleGridColumnAlign.Center;
pub const styleGridColumnAlignEnd = styleGridColumnAlign.End;
pub const styleGridColumnAlignStart = styleGridColumnAlign.Start;
pub const styleGridColumnAlignStretch = styleGridColumnAlign.Stretch;
pub const styleGridColumnAlignNotSet = styleGridColumnAlign.NotSet;
pub const styleGridColumnAlign_Max = styleGridColumnAlign._Max;

pub const styleGridColumnSpan = enum(i32) {
    NotSet = 0,
    _Max = 2147483647,
};
pub const styleGridColumnSpanNotSet = styleGridColumnSpan.NotSet;
pub const styleGridColumnSpan_Max = styleGridColumnSpan._Max;

pub const styleGridRow = enum(i32) {
    NotSet = 0,
    _Max = 2147483647,
};
pub const styleGridRowNotSet = styleGridRow.NotSet;
pub const styleGridRow_Max = styleGridRow._Max;

pub const styleGridRowAlign = enum(i32) {
    Center = 0,
    End = 1,
    Start = 2,
    Stretch = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleGridRowAlignCenter = styleGridRowAlign.Center;
pub const styleGridRowAlignEnd = styleGridRowAlign.End;
pub const styleGridRowAlignStart = styleGridRowAlign.Start;
pub const styleGridRowAlignStretch = styleGridRowAlign.Stretch;
pub const styleGridRowAlignNotSet = styleGridRowAlign.NotSet;
pub const styleGridRowAlign_Max = styleGridRowAlign._Max;

pub const styleGridRowSpan = enum(i32) {
    NotSet = 0,
    _Max = 2147483647,
};
pub const styleGridRowSpanNotSet = styleGridRowSpan.NotSet;
pub const styleGridRowSpan_Max = styleGridRowSpan._Max;

pub const styleWrapThrough = enum(i32) {
    NotSet = 0,
    Wrap = 1,
    None = 2,
    _Max = 2147483647,
};
pub const styleWrapThroughNotSet = styleWrapThrough.NotSet;
pub const styleWrapThroughWrap = styleWrapThrough.Wrap;
pub const styleWrapThroughNone = styleWrapThrough.None;
pub const styleWrapThrough_Max = styleWrapThrough._Max;

pub const styleWrapFlow = enum(i32) {
    NotSet = 0,
    Auto = 1,
    Both = 2,
    Start = 3,
    End = 4,
    Clear = 5,
    Minimum = 6,
    Maximum = 7,
    _Max = 2147483647,
};
pub const styleWrapFlowNotSet = styleWrapFlow.NotSet;
pub const styleWrapFlowAuto = styleWrapFlow.Auto;
pub const styleWrapFlowBoth = styleWrapFlow.Both;
pub const styleWrapFlowStart = styleWrapFlow.Start;
pub const styleWrapFlowEnd = styleWrapFlow.End;
pub const styleWrapFlowClear = styleWrapFlow.Clear;
pub const styleWrapFlowMinimum = styleWrapFlow.Minimum;
pub const styleWrapFlowMaximum = styleWrapFlow.Maximum;
pub const styleWrapFlow_Max = styleWrapFlow._Max;

pub const styleAlignmentBaseline = enum(i32) {
    NotSet = 0,
    AfterEdge = 1,
    Alphabetic = 2,
    Auto = 3,
    Baseline = 4,
    BeforeEdge = 5,
    Central = 6,
    Hanging = 7,
    Mathematical = 8,
    Middle = 9,
    TextAfterEdge = 10,
    TextBeforeEdge = 11,
    Ideographic = 12,
    _Max = 2147483647,
};
pub const styleAlignmentBaselineNotSet = styleAlignmentBaseline.NotSet;
pub const styleAlignmentBaselineAfterEdge = styleAlignmentBaseline.AfterEdge;
pub const styleAlignmentBaselineAlphabetic = styleAlignmentBaseline.Alphabetic;
pub const styleAlignmentBaselineAuto = styleAlignmentBaseline.Auto;
pub const styleAlignmentBaselineBaseline = styleAlignmentBaseline.Baseline;
pub const styleAlignmentBaselineBeforeEdge = styleAlignmentBaseline.BeforeEdge;
pub const styleAlignmentBaselineCentral = styleAlignmentBaseline.Central;
pub const styleAlignmentBaselineHanging = styleAlignmentBaseline.Hanging;
pub const styleAlignmentBaselineMathematical = styleAlignmentBaseline.Mathematical;
pub const styleAlignmentBaselineMiddle = styleAlignmentBaseline.Middle;
pub const styleAlignmentBaselineTextAfterEdge = styleAlignmentBaseline.TextAfterEdge;
pub const styleAlignmentBaselineTextBeforeEdge = styleAlignmentBaseline.TextBeforeEdge;
pub const styleAlignmentBaselineIdeographic = styleAlignmentBaseline.Ideographic;
pub const styleAlignmentBaseline_Max = styleAlignmentBaseline._Max;

pub const styleBaselineShift = enum(i32) {
    Baseline = 0,
    Sub = 1,
    Super = 2,
    _Max = 2147483647,
};
pub const styleBaselineShiftBaseline = styleBaselineShift.Baseline;
pub const styleBaselineShiftSub = styleBaselineShift.Sub;
pub const styleBaselineShiftSuper = styleBaselineShift.Super;
pub const styleBaselineShift_Max = styleBaselineShift._Max;

pub const styleClipRule = enum(i32) {
    NotSet = 0,
    NonZero = 1,
    EvenOdd = 2,
    _Max = 2147483647,
};
pub const styleClipRuleNotSet = styleClipRule.NotSet;
pub const styleClipRuleNonZero = styleClipRule.NonZero;
pub const styleClipRuleEvenOdd = styleClipRule.EvenOdd;
pub const styleClipRule_Max = styleClipRule._Max;

pub const styleDominantBaseline = enum(i32) {
    NotSet = 0,
    Alphabetic = 1,
    Auto = 2,
    Central = 3,
    Hanging = 4,
    Ideographic = 5,
    Mathematical = 6,
    Middle = 7,
    NoChange = 8,
    ResetSize = 9,
    TextAfterEdge = 10,
    TextBeforeEdge = 11,
    UseScript = 12,
    _Max = 2147483647,
};
pub const styleDominantBaselineNotSet = styleDominantBaseline.NotSet;
pub const styleDominantBaselineAlphabetic = styleDominantBaseline.Alphabetic;
pub const styleDominantBaselineAuto = styleDominantBaseline.Auto;
pub const styleDominantBaselineCentral = styleDominantBaseline.Central;
pub const styleDominantBaselineHanging = styleDominantBaseline.Hanging;
pub const styleDominantBaselineIdeographic = styleDominantBaseline.Ideographic;
pub const styleDominantBaselineMathematical = styleDominantBaseline.Mathematical;
pub const styleDominantBaselineMiddle = styleDominantBaseline.Middle;
pub const styleDominantBaselineNoChange = styleDominantBaseline.NoChange;
pub const styleDominantBaselineResetSize = styleDominantBaseline.ResetSize;
pub const styleDominantBaselineTextAfterEdge = styleDominantBaseline.TextAfterEdge;
pub const styleDominantBaselineTextBeforeEdge = styleDominantBaseline.TextBeforeEdge;
pub const styleDominantBaselineUseScript = styleDominantBaseline.UseScript;
pub const styleDominantBaseline_Max = styleDominantBaseline._Max;

pub const styleFillRule = enum(i32) {
    NotSet = 0,
    NonZero = 1,
    EvenOdd = 2,
    _Max = 2147483647,
};
pub const styleFillRuleNotSet = styleFillRule.NotSet;
pub const styleFillRuleNonZero = styleFillRule.NonZero;
pub const styleFillRuleEvenOdd = styleFillRule.EvenOdd;
pub const styleFillRule_Max = styleFillRule._Max;

pub const styleFontStretch = enum(i32) {
    NotSet = 0,
    Wider = 1,
    Narrower = 2,
    UltraCondensed = 3,
    ExtraCondensed = 4,
    Condensed = 5,
    SemiCondensed = 6,
    Normal = 7,
    SemiExpanded = 8,
    Expanded = 9,
    ExtraExpanded = 10,
    UltraExpanded = 11,
    _Max = 2147483647,
};
pub const styleFontStretchNotSet = styleFontStretch.NotSet;
pub const styleFontStretchWider = styleFontStretch.Wider;
pub const styleFontStretchNarrower = styleFontStretch.Narrower;
pub const styleFontStretchUltraCondensed = styleFontStretch.UltraCondensed;
pub const styleFontStretchExtraCondensed = styleFontStretch.ExtraCondensed;
pub const styleFontStretchCondensed = styleFontStretch.Condensed;
pub const styleFontStretchSemiCondensed = styleFontStretch.SemiCondensed;
pub const styleFontStretchNormal = styleFontStretch.Normal;
pub const styleFontStretchSemiExpanded = styleFontStretch.SemiExpanded;
pub const styleFontStretchExpanded = styleFontStretch.Expanded;
pub const styleFontStretchExtraExpanded = styleFontStretch.ExtraExpanded;
pub const styleFontStretchUltraExpanded = styleFontStretch.UltraExpanded;
pub const styleFontStretch_Max = styleFontStretch._Max;

pub const stylePointerEvents = enum(i32) {
    NotSet = 0,
    VisiblePainted = 1,
    VisibleFill = 2,
    VisibleStroke = 3,
    Visible = 4,
    Painted = 5,
    Fill = 6,
    Stroke = 7,
    All = 8,
    None = 9,
    Initial = 10,
    Auto = 11,
    _Max = 2147483647,
};
pub const stylePointerEventsNotSet = stylePointerEvents.NotSet;
pub const stylePointerEventsVisiblePainted = stylePointerEvents.VisiblePainted;
pub const stylePointerEventsVisibleFill = stylePointerEvents.VisibleFill;
pub const stylePointerEventsVisibleStroke = stylePointerEvents.VisibleStroke;
pub const stylePointerEventsVisible = stylePointerEvents.Visible;
pub const stylePointerEventsPainted = stylePointerEvents.Painted;
pub const stylePointerEventsFill = stylePointerEvents.Fill;
pub const stylePointerEventsStroke = stylePointerEvents.Stroke;
pub const stylePointerEventsAll = stylePointerEvents.All;
pub const stylePointerEventsNone = stylePointerEvents.None;
pub const stylePointerEventsInitial = stylePointerEvents.Initial;
pub const stylePointerEventsAuto = stylePointerEvents.Auto;
pub const stylePointerEvents_Max = stylePointerEvents._Max;

pub const styleEnableBackground = enum(i32) {
    NotSet = 0,
    Accumulate = 1,
    New = 2,
    Inherit = 3,
    _Max = 2147483647,
};
pub const styleEnableBackgroundNotSet = styleEnableBackground.NotSet;
pub const styleEnableBackgroundAccumulate = styleEnableBackground.Accumulate;
pub const styleEnableBackgroundNew = styleEnableBackground.New;
pub const styleEnableBackgroundInherit = styleEnableBackground.Inherit;
pub const styleEnableBackground_Max = styleEnableBackground._Max;

pub const styleStrokeLinecap = enum(i32) {
    NotSet = 0,
    Butt = 1,
    Round = 2,
    Square = 3,
    _Max = 2147483647,
};
pub const styleStrokeLinecapNotSet = styleStrokeLinecap.NotSet;
pub const styleStrokeLinecapButt = styleStrokeLinecap.Butt;
pub const styleStrokeLinecapRound = styleStrokeLinecap.Round;
pub const styleStrokeLinecapSquare = styleStrokeLinecap.Square;
pub const styleStrokeLinecap_Max = styleStrokeLinecap._Max;

pub const styleStrokeLinejoin = enum(i32) {
    NotSet = 0,
    Miter = 1,
    Round = 2,
    Bevel = 3,
    _Max = 2147483647,
};
pub const styleStrokeLinejoinNotSet = styleStrokeLinejoin.NotSet;
pub const styleStrokeLinejoinMiter = styleStrokeLinejoin.Miter;
pub const styleStrokeLinejoinRound = styleStrokeLinejoin.Round;
pub const styleStrokeLinejoinBevel = styleStrokeLinejoin.Bevel;
pub const styleStrokeLinejoin_Max = styleStrokeLinejoin._Max;

pub const styleTextAnchor = enum(i32) {
    NotSet = 0,
    Start = 1,
    Middle = 2,
    End = 3,
    _Max = 2147483647,
};
pub const styleTextAnchorNotSet = styleTextAnchor.NotSet;
pub const styleTextAnchorStart = styleTextAnchor.Start;
pub const styleTextAnchorMiddle = styleTextAnchor.Middle;
pub const styleTextAnchorEnd = styleTextAnchor.End;
pub const styleTextAnchor_Max = styleTextAnchor._Max;

pub const styleAttrType = enum(i32) {
    String = 0,
    Color = 1,
    Url = 2,
    Integer = 3,
    Number = 4,
    Length = 5,
    Px = 6,
    Em = 7,
    Ex = 8,
    In = 9,
    Cm = 10,
    Mm = 11,
    Pt = 12,
    Pc = 13,
    Rem = 14,
    Ch = 15,
    Vh = 16,
    Vw = 17,
    Vmin = 18,
    Percentage = 19,
    Angle = 20,
    Deg = 21,
    Rad = 22,
    Grad = 23,
    Time = 24,
    S = 25,
    Ms = 26,
    _Max = 2147483647,
};
pub const styleAttrTypeString = styleAttrType.String;
pub const styleAttrTypeColor = styleAttrType.Color;
pub const styleAttrTypeUrl = styleAttrType.Url;
pub const styleAttrTypeInteger = styleAttrType.Integer;
pub const styleAttrTypeNumber = styleAttrType.Number;
pub const styleAttrTypeLength = styleAttrType.Length;
pub const styleAttrTypePx = styleAttrType.Px;
pub const styleAttrTypeEm = styleAttrType.Em;
pub const styleAttrTypeEx = styleAttrType.Ex;
pub const styleAttrTypeIn = styleAttrType.In;
pub const styleAttrTypeCm = styleAttrType.Cm;
pub const styleAttrTypeMm = styleAttrType.Mm;
pub const styleAttrTypePt = styleAttrType.Pt;
pub const styleAttrTypePc = styleAttrType.Pc;
pub const styleAttrTypeRem = styleAttrType.Rem;
pub const styleAttrTypeCh = styleAttrType.Ch;
pub const styleAttrTypeVh = styleAttrType.Vh;
pub const styleAttrTypeVw = styleAttrType.Vw;
pub const styleAttrTypeVmin = styleAttrType.Vmin;
pub const styleAttrTypePercentage = styleAttrType.Percentage;
pub const styleAttrTypeAngle = styleAttrType.Angle;
pub const styleAttrTypeDeg = styleAttrType.Deg;
pub const styleAttrTypeRad = styleAttrType.Rad;
pub const styleAttrTypeGrad = styleAttrType.Grad;
pub const styleAttrTypeTime = styleAttrType.Time;
pub const styleAttrTypeS = styleAttrType.S;
pub const styleAttrTypeMs = styleAttrType.Ms;
pub const styleAttrType_Max = styleAttrType._Max;

pub const styleInitialColor = enum(i32) {
    NoInitial = 0,
    ColorProperty = 1,
    Transparent = 2,
    Invert = 3,
    _Max = 2147483647,
};
pub const styleInitialColorNoInitial = styleInitialColor.NoInitial;
pub const styleInitialColorColorProperty = styleInitialColor.ColorProperty;
pub const styleInitialColorTransparent = styleInitialColor.Transparent;
pub const styleInitialColorInvert = styleInitialColor.Invert;
pub const styleInitialColor_Max = styleInitialColor._Max;

pub const styleInitialString = enum(i32) {
    NoInitial = 0,
    None = 1,
    Auto = 2,
    Normal = 3,
    _Max = 2147483647,
};
pub const styleInitialStringNoInitial = styleInitialString.NoInitial;
pub const styleInitialStringNone = styleInitialString.None;
pub const styleInitialStringAuto = styleInitialString.Auto;
pub const styleInitialStringNormal = styleInitialString.Normal;
pub const styleInitialString_Max = styleInitialString._Max;

pub const styleTransformOriginX = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    _Max = 2147483647,
};
pub const styleTransformOriginXNotSet = styleTransformOriginX.NotSet;
pub const styleTransformOriginXLeft = styleTransformOriginX.Left;
pub const styleTransformOriginXCenter = styleTransformOriginX.Center;
pub const styleTransformOriginXRight = styleTransformOriginX.Right;
pub const styleTransformOriginX_Max = styleTransformOriginX._Max;

pub const styleTransformOriginY = enum(i32) {
    NotSet = 0,
    Top = 1,
    Center = 2,
    Bottom = 3,
    _Max = 2147483647,
};
pub const styleTransformOriginYNotSet = styleTransformOriginY.NotSet;
pub const styleTransformOriginYTop = styleTransformOriginY.Top;
pub const styleTransformOriginYCenter = styleTransformOriginY.Center;
pub const styleTransformOriginYBottom = styleTransformOriginY.Bottom;
pub const styleTransformOriginY_Max = styleTransformOriginY._Max;

pub const stylePerspectiveOriginX = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    _Max = 2147483647,
};
pub const stylePerspectiveOriginXNotSet = stylePerspectiveOriginX.NotSet;
pub const stylePerspectiveOriginXLeft = stylePerspectiveOriginX.Left;
pub const stylePerspectiveOriginXCenter = stylePerspectiveOriginX.Center;
pub const stylePerspectiveOriginXRight = stylePerspectiveOriginX.Right;
pub const stylePerspectiveOriginX_Max = stylePerspectiveOriginX._Max;

pub const stylePerspectiveOriginY = enum(i32) {
    NotSet = 0,
    Top = 1,
    Center = 2,
    Bottom = 3,
    _Max = 2147483647,
};
pub const stylePerspectiveOriginYNotSet = stylePerspectiveOriginY.NotSet;
pub const stylePerspectiveOriginYTop = stylePerspectiveOriginY.Top;
pub const stylePerspectiveOriginYCenter = stylePerspectiveOriginY.Center;
pub const stylePerspectiveOriginYBottom = stylePerspectiveOriginY.Bottom;
pub const stylePerspectiveOriginY_Max = stylePerspectiveOriginY._Max;

pub const styleTransformStyle = enum(i32) {
    Flat = 0,
    Preserve3D = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleTransformStyleFlat = styleTransformStyle.Flat;
pub const styleTransformStylePreserve3D = styleTransformStyle.Preserve3D;
pub const styleTransformStyleNotSet = styleTransformStyle.NotSet;
pub const styleTransformStyle_Max = styleTransformStyle._Max;

pub const styleBackfaceVisibility = enum(i32) {
    Visible = 0,
    Hidden = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleBackfaceVisibilityVisible = styleBackfaceVisibility.Visible;
pub const styleBackfaceVisibilityHidden = styleBackfaceVisibility.Hidden;
pub const styleBackfaceVisibilityNotSet = styleBackfaceVisibility.NotSet;
pub const styleBackfaceVisibility_Max = styleBackfaceVisibility._Max;

pub const styleTextSizeAdjust = enum(i32) {
    None = 0,
    Auto = 1,
    _Max = 2147483647,
};
pub const styleTextSizeAdjustNone = styleTextSizeAdjust.None;
pub const styleTextSizeAdjustAuto = styleTextSizeAdjust.Auto;
pub const styleTextSizeAdjust_Max = styleTextSizeAdjust._Max;

pub const styleColorInterpolationFilters = enum(i32) {
    Auto = 0,
    SRgb = 1,
    LinearRgb = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleColorInterpolationFiltersAuto = styleColorInterpolationFilters.Auto;
pub const styleColorInterpolationFiltersSRgb = styleColorInterpolationFilters.SRgb;
pub const styleColorInterpolationFiltersLinearRgb = styleColorInterpolationFilters.LinearRgb;
pub const styleColorInterpolationFiltersNotSet = styleColorInterpolationFilters.NotSet;
pub const styleColorInterpolationFilters_Max = styleColorInterpolationFilters._Max;

pub const styleHyphens = enum(i32) {
    None = 0,
    Manual = 1,
    Auto = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleHyphensNone = styleHyphens.None;
pub const styleHyphensManual = styleHyphens.Manual;
pub const styleHyphensAuto = styleHyphens.Auto;
pub const styleHyphensNotSet = styleHyphens.NotSet;
pub const styleHyphens_Max = styleHyphens._Max;

pub const styleHyphenateLimitLines = enum(i32) {
    NoLimit = 0,
    _Max = 2147483647,
};
pub const styleHyphenateLimitLinesNoLimit = styleHyphenateLimitLines.NoLimit;
pub const styleHyphenateLimitLines_Max = styleHyphenateLimitLines._Max;

pub const styleMsAnimationPlayState = enum(i32) {
    Running = 0,
    Paused = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleMsAnimationPlayStateRunning = styleMsAnimationPlayState.Running;
pub const styleMsAnimationPlayStatePaused = styleMsAnimationPlayState.Paused;
pub const styleMsAnimationPlayStateNotSet = styleMsAnimationPlayState.NotSet;
pub const styleMsAnimationPlayState_Max = styleMsAnimationPlayState._Max;

pub const styleMsAnimationDirection = enum(i32) {
    Normal = 0,
    Alternate = 1,
    Reverse = 2,
    AlternateReverse = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleMsAnimationDirectionNormal = styleMsAnimationDirection.Normal;
pub const styleMsAnimationDirectionAlternate = styleMsAnimationDirection.Alternate;
pub const styleMsAnimationDirectionReverse = styleMsAnimationDirection.Reverse;
pub const styleMsAnimationDirectionAlternateReverse = styleMsAnimationDirection.AlternateReverse;
pub const styleMsAnimationDirectionNotSet = styleMsAnimationDirection.NotSet;
pub const styleMsAnimationDirection_Max = styleMsAnimationDirection._Max;

pub const styleMsAnimationFillMode = enum(i32) {
    None = 0,
    Forwards = 1,
    Backwards = 2,
    Both = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleMsAnimationFillModeNone = styleMsAnimationFillMode.None;
pub const styleMsAnimationFillModeForwards = styleMsAnimationFillMode.Forwards;
pub const styleMsAnimationFillModeBackwards = styleMsAnimationFillMode.Backwards;
pub const styleMsAnimationFillModeBoth = styleMsAnimationFillMode.Both;
pub const styleMsAnimationFillModeNotSet = styleMsAnimationFillMode.NotSet;
pub const styleMsAnimationFillMode_Max = styleMsAnimationFillMode._Max;

pub const styleMsHighContrastAdjust = enum(i32) {
    NotSet = 0,
    Auto = 1,
    None = 2,
    _Max = 2147483647,
};
pub const styleMsHighContrastAdjustNotSet = styleMsHighContrastAdjust.NotSet;
pub const styleMsHighContrastAdjustAuto = styleMsHighContrastAdjust.Auto;
pub const styleMsHighContrastAdjustNone = styleMsHighContrastAdjust.None;
pub const styleMsHighContrastAdjust_Max = styleMsHighContrastAdjust._Max;

pub const styleMsUserSelect = enum(i32) {
    Auto = 0,
    Text = 1,
    Element = 2,
    None = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleMsUserSelectAuto = styleMsUserSelect.Auto;
pub const styleMsUserSelectText = styleMsUserSelect.Text;
pub const styleMsUserSelectElement = styleMsUserSelect.Element;
pub const styleMsUserSelectNone = styleMsUserSelect.None;
pub const styleMsUserSelectNotSet = styleMsUserSelect.NotSet;
pub const styleMsUserSelect_Max = styleMsUserSelect._Max;

pub const styleMsTouchAction = enum(i32) {
    NotSet = -1,
    None = 0,
    Auto = 1,
    Manipulation = 2,
    DoubleTapZoom = 4,
    PanX = 8,
    PanY = 16,
    PinchZoom = 32,
    CrossSlideX = 64,
    CrossSlideY = 128,
    _Max = 2147483647,
};
pub const styleMsTouchActionNotSet = styleMsTouchAction.NotSet;
pub const styleMsTouchActionNone = styleMsTouchAction.None;
pub const styleMsTouchActionAuto = styleMsTouchAction.Auto;
pub const styleMsTouchActionManipulation = styleMsTouchAction.Manipulation;
pub const styleMsTouchActionDoubleTapZoom = styleMsTouchAction.DoubleTapZoom;
pub const styleMsTouchActionPanX = styleMsTouchAction.PanX;
pub const styleMsTouchActionPanY = styleMsTouchAction.PanY;
pub const styleMsTouchActionPinchZoom = styleMsTouchAction.PinchZoom;
pub const styleMsTouchActionCrossSlideX = styleMsTouchAction.CrossSlideX;
pub const styleMsTouchActionCrossSlideY = styleMsTouchAction.CrossSlideY;
pub const styleMsTouchAction_Max = styleMsTouchAction._Max;

pub const styleMsTouchSelect = enum(i32) {
    Grippers = 0,
    None = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleMsTouchSelectGrippers = styleMsTouchSelect.Grippers;
pub const styleMsTouchSelectNone = styleMsTouchSelect.None;
pub const styleMsTouchSelectNotSet = styleMsTouchSelect.NotSet;
pub const styleMsTouchSelect_Max = styleMsTouchSelect._Max;

pub const styleMsScrollTranslation = enum(i32) {
    NotSet = 0,
    None = 1,
    VtoH = 2,
    _Max = 2147483647,
};
pub const styleMsScrollTranslationNotSet = styleMsScrollTranslation.NotSet;
pub const styleMsScrollTranslationNone = styleMsScrollTranslation.None;
pub const styleMsScrollTranslationVtoH = styleMsScrollTranslation.VtoH;
pub const styleMsScrollTranslation_Max = styleMsScrollTranslation._Max;

pub const styleBorderImageRepeat = enum(i32) {
    Stretch = 0,
    Repeat = 1,
    Round = 2,
    Space = 3,
    NotSet = 4,
    _Max = 2147483647,
};
pub const styleBorderImageRepeatStretch = styleBorderImageRepeat.Stretch;
pub const styleBorderImageRepeatRepeat = styleBorderImageRepeat.Repeat;
pub const styleBorderImageRepeatRound = styleBorderImageRepeat.Round;
pub const styleBorderImageRepeatSpace = styleBorderImageRepeat.Space;
pub const styleBorderImageRepeatNotSet = styleBorderImageRepeat.NotSet;
pub const styleBorderImageRepeat_Max = styleBorderImageRepeat._Max;

pub const styleBorderImageSliceFill = enum(i32) {
    NotSet = 0,
    Fill = 1,
    _Max = 2147483647,
};
pub const styleBorderImageSliceFillNotSet = styleBorderImageSliceFill.NotSet;
pub const styleBorderImageSliceFillFill = styleBorderImageSliceFill.Fill;
pub const styleBorderImageSliceFill_Max = styleBorderImageSliceFill._Max;

pub const styleMsImeAlign = enum(i32) {
    Auto = 0,
    After = 1,
    NotSet = 2,
    _Max = 2147483647,
};
pub const styleMsImeAlignAuto = styleMsImeAlign.Auto;
pub const styleMsImeAlignAfter = styleMsImeAlign.After;
pub const styleMsImeAlignNotSet = styleMsImeAlign.NotSet;
pub const styleMsImeAlign_Max = styleMsImeAlign._Max;

pub const styleMsTextCombineHorizontal = enum(i32) {
    None = 0,
    All = 1,
    Digits = 2,
    NotSet = 3,
    _Max = 2147483647,
};
pub const styleMsTextCombineHorizontalNone = styleMsTextCombineHorizontal.None;
pub const styleMsTextCombineHorizontalAll = styleMsTextCombineHorizontal.All;
pub const styleMsTextCombineHorizontalDigits = styleMsTextCombineHorizontal.Digits;
pub const styleMsTextCombineHorizontalNotSet = styleMsTextCombineHorizontal.NotSet;
pub const styleMsTextCombineHorizontal_Max = styleMsTextCombineHorizontal._Max;

pub const styleWebkitAppearance = enum(i32) {
    None = 0,
    CapsLockIndicator = 1,
    Button = 2,
    ButtonBevel = 3,
    Caret = 4,
    Checkbox = 5,
    DefaultButton = 6,
    Listbox = 7,
    Listitem = 8,
    MediaFullscreenButton = 9,
    MediaMuteButton = 10,
    MediaPlayButton = 11,
    MediaSeekBackButton = 12,
    MediaSeekForwardButton = 13,
    MediaSlider = 14,
    MediaSliderthumb = 15,
    Menulist = 16,
    MenulistButton = 17,
    MenulistText = 18,
    MenulistTextfield = 19,
    PushButton = 20,
    Radio = 21,
    Searchfield = 22,
    SearchfieldCancelButton = 23,
    SearchfieldDecoration = 24,
    SearchfieldResultsButton = 25,
    SearchfieldResultsDecoration = 26,
    SliderHorizontal = 27,
    SliderVertical = 28,
    SliderthumbHorizontal = 29,
    SliderthumbVertical = 30,
    SquareButton = 31,
    Textarea = 32,
    Textfield = 33,
    NotSet = 34,
    _Max = 2147483647,
};
pub const styleWebkitAppearanceNone = styleWebkitAppearance.None;
pub const styleWebkitAppearanceCapsLockIndicator = styleWebkitAppearance.CapsLockIndicator;
pub const styleWebkitAppearanceButton = styleWebkitAppearance.Button;
pub const styleWebkitAppearanceButtonBevel = styleWebkitAppearance.ButtonBevel;
pub const styleWebkitAppearanceCaret = styleWebkitAppearance.Caret;
pub const styleWebkitAppearanceCheckbox = styleWebkitAppearance.Checkbox;
pub const styleWebkitAppearanceDefaultButton = styleWebkitAppearance.DefaultButton;
pub const styleWebkitAppearanceListbox = styleWebkitAppearance.Listbox;
pub const styleWebkitAppearanceListitem = styleWebkitAppearance.Listitem;
pub const styleWebkitAppearanceMediaFullscreenButton = styleWebkitAppearance.MediaFullscreenButton;
pub const styleWebkitAppearanceMediaMuteButton = styleWebkitAppearance.MediaMuteButton;
pub const styleWebkitAppearanceMediaPlayButton = styleWebkitAppearance.MediaPlayButton;
pub const styleWebkitAppearanceMediaSeekBackButton = styleWebkitAppearance.MediaSeekBackButton;
pub const styleWebkitAppearanceMediaSeekForwardButton = styleWebkitAppearance.MediaSeekForwardButton;
pub const styleWebkitAppearanceMediaSlider = styleWebkitAppearance.MediaSlider;
pub const styleWebkitAppearanceMediaSliderthumb = styleWebkitAppearance.MediaSliderthumb;
pub const styleWebkitAppearanceMenulist = styleWebkitAppearance.Menulist;
pub const styleWebkitAppearanceMenulistButton = styleWebkitAppearance.MenulistButton;
pub const styleWebkitAppearanceMenulistText = styleWebkitAppearance.MenulistText;
pub const styleWebkitAppearanceMenulistTextfield = styleWebkitAppearance.MenulistTextfield;
pub const styleWebkitAppearancePushButton = styleWebkitAppearance.PushButton;
pub const styleWebkitAppearanceRadio = styleWebkitAppearance.Radio;
pub const styleWebkitAppearanceSearchfield = styleWebkitAppearance.Searchfield;
pub const styleWebkitAppearanceSearchfieldCancelButton = styleWebkitAppearance.SearchfieldCancelButton;
pub const styleWebkitAppearanceSearchfieldDecoration = styleWebkitAppearance.SearchfieldDecoration;
pub const styleWebkitAppearanceSearchfieldResultsButton = styleWebkitAppearance.SearchfieldResultsButton;
pub const styleWebkitAppearanceSearchfieldResultsDecoration = styleWebkitAppearance.SearchfieldResultsDecoration;
pub const styleWebkitAppearanceSliderHorizontal = styleWebkitAppearance.SliderHorizontal;
pub const styleWebkitAppearanceSliderVertical = styleWebkitAppearance.SliderVertical;
pub const styleWebkitAppearanceSliderthumbHorizontal = styleWebkitAppearance.SliderthumbHorizontal;
pub const styleWebkitAppearanceSliderthumbVertical = styleWebkitAppearance.SliderthumbVertical;
pub const styleWebkitAppearanceSquareButton = styleWebkitAppearance.SquareButton;
pub const styleWebkitAppearanceTextarea = styleWebkitAppearance.Textarea;
pub const styleWebkitAppearanceTextfield = styleWebkitAppearance.Textfield;
pub const styleWebkitAppearanceNotSet = styleWebkitAppearance.NotSet;
pub const styleWebkitAppearance_Max = styleWebkitAppearance._Max;

pub const styleViewportSize = enum(i32) {
    Auto = 0,
    DeviceWidth = 1,
    DeviceHeight = 2,
    _Max = 2147483647,
};
pub const styleViewportSizeAuto = styleViewportSize.Auto;
pub const styleViewportSizeDeviceWidth = styleViewportSize.DeviceWidth;
pub const styleViewportSizeDeviceHeight = styleViewportSize.DeviceHeight;
pub const styleViewportSize_Max = styleViewportSize._Max;

pub const styleUserZoom = enum(i32) {
    NotSet = 0,
    Zoom = 1,
    Fixed = 2,
    _Max = 2147483647,
};
pub const styleUserZoomNotSet = styleUserZoom.NotSet;
pub const styleUserZoomZoom = styleUserZoom.Zoom;
pub const styleUserZoomFixed = styleUserZoom.Fixed;
pub const styleUserZoom_Max = styleUserZoom._Max;

pub const styleTextLineThroughStyle = enum(i32) {
    Undefined = 0,
    Single = 1,
    Double = 2,
    _Max = 2147483647,
};
pub const styleTextLineThroughStyleUndefined = styleTextLineThroughStyle.Undefined;
pub const styleTextLineThroughStyleSingle = styleTextLineThroughStyle.Single;
pub const styleTextLineThroughStyleDouble = styleTextLineThroughStyle.Double;
pub const styleTextLineThroughStyle_Max = styleTextLineThroughStyle._Max;

pub const styleTextUnderlineStyle = enum(i32) {
    Undefined = 0,
    Single = 1,
    Double = 2,
    Words = 3,
    Dotted = 4,
    Thick = 5,
    Dash = 6,
    DotDash = 7,
    DotDotDash = 8,
    Wave = 9,
    SingleAccounting = 10,
    DoubleAccounting = 11,
    ThickDash = 12,
    _Max = 2147483647,
};
pub const styleTextUnderlineStyleUndefined = styleTextUnderlineStyle.Undefined;
pub const styleTextUnderlineStyleSingle = styleTextUnderlineStyle.Single;
pub const styleTextUnderlineStyleDouble = styleTextUnderlineStyle.Double;
pub const styleTextUnderlineStyleWords = styleTextUnderlineStyle.Words;
pub const styleTextUnderlineStyleDotted = styleTextUnderlineStyle.Dotted;
pub const styleTextUnderlineStyleThick = styleTextUnderlineStyle.Thick;
pub const styleTextUnderlineStyleDash = styleTextUnderlineStyle.Dash;
pub const styleTextUnderlineStyleDotDash = styleTextUnderlineStyle.DotDash;
pub const styleTextUnderlineStyleDotDotDash = styleTextUnderlineStyle.DotDotDash;
pub const styleTextUnderlineStyleWave = styleTextUnderlineStyle.Wave;
pub const styleTextUnderlineStyleSingleAccounting = styleTextUnderlineStyle.SingleAccounting;
pub const styleTextUnderlineStyleDoubleAccounting = styleTextUnderlineStyle.DoubleAccounting;
pub const styleTextUnderlineStyleThickDash = styleTextUnderlineStyle.ThickDash;
pub const styleTextUnderlineStyle_Max = styleTextUnderlineStyle._Max;

pub const styleTextEffect = enum(i32) {
    None = 0,
    Emboss = 1,
    Engrave = 2,
    Outline = 3,
    _Max = 2147483647,
};
pub const styleTextEffectNone = styleTextEffect.None;
pub const styleTextEffectEmboss = styleTextEffect.Emboss;
pub const styleTextEffectEngrave = styleTextEffect.Engrave;
pub const styleTextEffectOutline = styleTextEffect.Outline;
pub const styleTextEffect_Max = styleTextEffect._Max;

pub const styleDefaultTextSelection = enum(i32) {
    False = 0,
    True = 1,
    _Max = 2147483647,
};
pub const styleDefaultTextSelectionFalse = styleDefaultTextSelection.False;
pub const styleDefaultTextSelectionTrue = styleDefaultTextSelection.True;
pub const styleDefaultTextSelection_Max = styleDefaultTextSelection._Max;

pub const styleTextDecoration = enum(i32) {
    None = 0,
    Underline = 1,
    Overline = 2,
    LineThrough = 3,
    Blink = 4,
    _Max = 2147483647,
};
pub const styleTextDecorationNone = styleTextDecoration.None;
pub const styleTextDecorationUnderline = styleTextDecoration.Underline;
pub const styleTextDecorationOverline = styleTextDecoration.Overline;
pub const styleTextDecorationLineThrough = styleTextDecoration.LineThrough;
pub const styleTextDecorationBlink = styleTextDecoration.Blink;
pub const styleTextDecoration_Max = styleTextDecoration._Max;

pub const textDecoration = enum(i32) {
    None = 0,
    Underline = 1,
    Overline = 2,
    LineThrough = 3,
    Blink = 4,
    _Max = 2147483647,
};
pub const textDecorationNone = textDecoration.None;
pub const textDecorationUnderline = textDecoration.Underline;
pub const textDecorationOverline = textDecoration.Overline;
pub const textDecorationLineThrough = textDecoration.LineThrough;
pub const textDecorationBlink = textDecoration.Blink;
pub const textDecoration_Max = textDecoration._Max;

pub const htmlListType = enum(i32) {
    NotSet = 0,
    LargeAlpha = 1,
    SmallAlpha = 2,
    LargeRoman = 3,
    SmallRoman = 4,
    Numbers = 5,
    Disc = 6,
    Circle = 7,
    Square = 8,
    _Max = 2147483647,
};
pub const htmlListTypeNotSet = htmlListType.NotSet;
pub const htmlListTypeLargeAlpha = htmlListType.LargeAlpha;
pub const htmlListTypeSmallAlpha = htmlListType.SmallAlpha;
pub const htmlListTypeLargeRoman = htmlListType.LargeRoman;
pub const htmlListTypeSmallRoman = htmlListType.SmallRoman;
pub const htmlListTypeNumbers = htmlListType.Numbers;
pub const htmlListTypeDisc = htmlListType.Disc;
pub const htmlListTypeCircle = htmlListType.Circle;
pub const htmlListTypeSquare = htmlListType.Square;
pub const htmlListType_Max = htmlListType._Max;

pub const htmlMethod = enum(i32) {
    NotSet = 0,
    Get = 1,
    Post = 2,
    _Max = 2147483647,
};
pub const htmlMethodNotSet = htmlMethod.NotSet;
pub const htmlMethodGet = htmlMethod.Get;
pub const htmlMethodPost = htmlMethod.Post;
pub const htmlMethod_Max = htmlMethod._Max;

pub const htmlWrap = enum(i32) {
    Off = 1,
    Soft = 2,
    Hard = 3,
    _Max = 2147483647,
};
pub const htmlWrapOff = htmlWrap.Off;
pub const htmlWrapSoft = htmlWrap.Soft;
pub const htmlWrapHard = htmlWrap.Hard;
pub const htmlWrap_Max = htmlWrap._Max;

pub const htmlDir = enum(i32) {
    NotSet = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    _Max = 2147483647,
};
pub const htmlDirNotSet = htmlDir.NotSet;
pub const htmlDirLeftToRight = htmlDir.LeftToRight;
pub const htmlDirRightToLeft = htmlDir.RightToLeft;
pub const htmlDir_Max = htmlDir._Max;

pub const htmlEditable = enum(i32) {
    Inherit = 0,
    True = 1,
    False = 2,
    _Max = 2147483647,
};
pub const htmlEditableInherit = htmlEditable.Inherit;
pub const htmlEditableTrue = htmlEditable.True;
pub const htmlEditableFalse = htmlEditable.False;
pub const htmlEditable_Max = htmlEditable._Max;

pub const htmlInput = enum(i32) {
    NotSet = 0,
    Button = 1,
    Checkbox = 2,
    File = 3,
    Hidden = 4,
    Image = 5,
    Password = 6,
    Radio = 7,
    Reset = 8,
    SelectOne = 9,
    SelectMultiple = 10,
    Submit = 11,
    Text = 12,
    Textarea = 13,
    Richtext = 14,
    Range = 15,
    Url = 16,
    Email = 17,
    Number = 18,
    Tel = 19,
    Search = 20,
    _Max = 2147483647,
};
pub const htmlInputNotSet = htmlInput.NotSet;
pub const htmlInputButton = htmlInput.Button;
pub const htmlInputCheckbox = htmlInput.Checkbox;
pub const htmlInputFile = htmlInput.File;
pub const htmlInputHidden = htmlInput.Hidden;
pub const htmlInputImage = htmlInput.Image;
pub const htmlInputPassword = htmlInput.Password;
pub const htmlInputRadio = htmlInput.Radio;
pub const htmlInputReset = htmlInput.Reset;
pub const htmlInputSelectOne = htmlInput.SelectOne;
pub const htmlInputSelectMultiple = htmlInput.SelectMultiple;
pub const htmlInputSubmit = htmlInput.Submit;
pub const htmlInputText = htmlInput.Text;
pub const htmlInputTextarea = htmlInput.Textarea;
pub const htmlInputRichtext = htmlInput.Richtext;
pub const htmlInputRange = htmlInput.Range;
pub const htmlInputUrl = htmlInput.Url;
pub const htmlInputEmail = htmlInput.Email;
pub const htmlInputNumber = htmlInput.Number;
pub const htmlInputTel = htmlInput.Tel;
pub const htmlInputSearch = htmlInput.Search;
pub const htmlInput_Max = htmlInput._Max;

pub const htmlSpellCheck = enum(i32) {
    NotSet = 0,
    True = 1,
    False = 2,
    Default = 3,
    _Max = 2147483647,
};
pub const htmlSpellCheckNotSet = htmlSpellCheck.NotSet;
pub const htmlSpellCheckTrue = htmlSpellCheck.True;
pub const htmlSpellCheckFalse = htmlSpellCheck.False;
pub const htmlSpellCheckDefault = htmlSpellCheck.Default;
pub const htmlSpellCheck_Max = htmlSpellCheck._Max;

pub const htmlEncoding = enum(i32) {
    URL = 0,
    Multipart = 1,
    Text = 2,
    _Max = 2147483647,
};
pub const htmlEncodingURL = htmlEncoding.URL;
pub const htmlEncodingMultipart = htmlEncoding.Multipart;
pub const htmlEncodingText = htmlEncoding.Text;
pub const htmlEncoding_Max = htmlEncoding._Max;

pub const htmlAdjacency = enum(i32) {
    BeforeBegin = 1,
    AfterBegin = 2,
    BeforeEnd = 3,
    AfterEnd = 4,
    _Max = 2147483647,
};
pub const htmlAdjacencyBeforeBegin = htmlAdjacency.BeforeBegin;
pub const htmlAdjacencyAfterBegin = htmlAdjacency.AfterBegin;
pub const htmlAdjacencyBeforeEnd = htmlAdjacency.BeforeEnd;
pub const htmlAdjacencyAfterEnd = htmlAdjacency.AfterEnd;
pub const htmlAdjacency_Max = htmlAdjacency._Max;

pub const htmlTabIndex = enum(i32) {
    NotSet = -32768,
    _Max = 2147483647,
};
pub const htmlTabIndexNotSet = htmlTabIndex.NotSet;
pub const htmlTabIndex_Max = htmlTabIndex._Max;

pub const htmlComponent = enum(i32) {
    Client = 0,
    SbLeft = 1,
    SbPageLeft = 2,
    SbHThumb = 3,
    SbPageRight = 4,
    SbRight = 5,
    SbUp = 6,
    SbPageUp = 7,
    SbVThumb = 8,
    SbPageDown = 9,
    SbDown = 10,
    SbLeft2 = 11,
    SbPageLeft2 = 12,
    SbRight2 = 13,
    SbPageRight2 = 14,
    SbUp2 = 15,
    SbPageUp2 = 16,
    SbDown2 = 17,
    SbPageDown2 = 18,
    SbTop = 19,
    SbBottom = 20,
    Outside = 21,
    GHTopLeft = 22,
    GHLeft = 23,
    GHTop = 24,
    GHBottomLeft = 25,
    GHTopRight = 26,
    GHBottom = 27,
    GHRight = 28,
    GHBottomRight = 29,
    _Max = 2147483647,
};
pub const htmlComponentClient = htmlComponent.Client;
pub const htmlComponentSbLeft = htmlComponent.SbLeft;
pub const htmlComponentSbPageLeft = htmlComponent.SbPageLeft;
pub const htmlComponentSbHThumb = htmlComponent.SbHThumb;
pub const htmlComponentSbPageRight = htmlComponent.SbPageRight;
pub const htmlComponentSbRight = htmlComponent.SbRight;
pub const htmlComponentSbUp = htmlComponent.SbUp;
pub const htmlComponentSbPageUp = htmlComponent.SbPageUp;
pub const htmlComponentSbVThumb = htmlComponent.SbVThumb;
pub const htmlComponentSbPageDown = htmlComponent.SbPageDown;
pub const htmlComponentSbDown = htmlComponent.SbDown;
pub const htmlComponentSbLeft2 = htmlComponent.SbLeft2;
pub const htmlComponentSbPageLeft2 = htmlComponent.SbPageLeft2;
pub const htmlComponentSbRight2 = htmlComponent.SbRight2;
pub const htmlComponentSbPageRight2 = htmlComponent.SbPageRight2;
pub const htmlComponentSbUp2 = htmlComponent.SbUp2;
pub const htmlComponentSbPageUp2 = htmlComponent.SbPageUp2;
pub const htmlComponentSbDown2 = htmlComponent.SbDown2;
pub const htmlComponentSbPageDown2 = htmlComponent.SbPageDown2;
pub const htmlComponentSbTop = htmlComponent.SbTop;
pub const htmlComponentSbBottom = htmlComponent.SbBottom;
pub const htmlComponentOutside = htmlComponent.Outside;
pub const htmlComponentGHTopLeft = htmlComponent.GHTopLeft;
pub const htmlComponentGHLeft = htmlComponent.GHLeft;
pub const htmlComponentGHTop = htmlComponent.GHTop;
pub const htmlComponentGHBottomLeft = htmlComponent.GHBottomLeft;
pub const htmlComponentGHTopRight = htmlComponent.GHTopRight;
pub const htmlComponentGHBottom = htmlComponent.GHBottom;
pub const htmlComponentGHRight = htmlComponent.GHRight;
pub const htmlComponentGHBottomRight = htmlComponent.GHBottomRight;
pub const htmlComponent_Max = htmlComponent._Max;

pub const htmlApplyLocation = enum(i32) {
    Inside = 0,
    Outside = 1,
    _Max = 2147483647,
};
pub const htmlApplyLocationInside = htmlApplyLocation.Inside;
pub const htmlApplyLocationOutside = htmlApplyLocation.Outside;
pub const htmlApplyLocation_Max = htmlApplyLocation._Max;

pub const htmlGlyphMode = enum(i32) {
    None = 0,
    Begin = 1,
    End = 2,
    Both = 3,
    _Max = 2147483647,
};
pub const htmlGlyphModeNone = htmlGlyphMode.None;
pub const htmlGlyphModeBegin = htmlGlyphMode.Begin;
pub const htmlGlyphModeEnd = htmlGlyphMode.End;
pub const htmlGlyphModeBoth = htmlGlyphMode.Both;
pub const htmlGlyphMode_Max = htmlGlyphMode._Max;

pub const htmlDraggable = enum(i32) {
    Auto = 0,
    True = 1,
    False = 2,
    _Max = 2147483647,
};
pub const htmlDraggableAuto = htmlDraggable.Auto;
pub const htmlDraggableTrue = htmlDraggable.True;
pub const htmlDraggableFalse = htmlDraggable.False;
pub const htmlDraggable_Max = htmlDraggable._Max;

pub const htmlUnit = enum(i32) {
    Character = 1,
    Word = 2,
    Sentence = 3,
    TextEdit = 6,
    _Max = 2147483647,
};
pub const htmlUnitCharacter = htmlUnit.Character;
pub const htmlUnitWord = htmlUnit.Word;
pub const htmlUnitSentence = htmlUnit.Sentence;
pub const htmlUnitTextEdit = htmlUnit.TextEdit;
pub const htmlUnit_Max = htmlUnit._Max;

pub const htmlEndPoints = enum(i32) {
    StartToStart = 1,
    StartToEnd = 2,
    EndToStart = 3,
    EndToEnd = 4,
    _Max = 2147483647,
};
pub const htmlEndPointsStartToStart = htmlEndPoints.StartToStart;
pub const htmlEndPointsStartToEnd = htmlEndPoints.StartToEnd;
pub const htmlEndPointsEndToStart = htmlEndPoints.EndToStart;
pub const htmlEndPointsEndToEnd = htmlEndPoints.EndToEnd;
pub const htmlEndPoints_Max = htmlEndPoints._Max;

pub const htmlDirection = enum(i32) {
    Forward = 99999,
    Backward = -99999,
    _Max = 2147483647,
};
pub const htmlDirectionForward = htmlDirection.Forward;
pub const htmlDirectionBackward = htmlDirection.Backward;
pub const htmlDirection_Max = htmlDirection._Max;

pub const htmlStart = enum(i32) {
    fileopen = 0,
    mouseover = 1,
    _Max = 2147483647,
};
pub const htmlStartfileopen = htmlStart.fileopen;
pub const htmlStartmouseover = htmlStart.mouseover;
pub const htmlStart_Max = htmlStart._Max;

pub const bodyScroll = enum(i32) {
    yes = 1,
    no = 2,
    auto = 4,
    default = 3,
    _Max = 2147483647,
};
pub const bodyScrollyes = bodyScroll.yes;
pub const bodyScrollno = bodyScroll.no;
pub const bodyScrollauto = bodyScroll.auto;
pub const bodyScrolldefault = bodyScroll.default;
pub const bodyScroll_Max = bodyScroll._Max;

pub const htmlSelectType = enum(i32) {
    SelectOne = 1,
    SelectMultiple = 2,
    _Max = 2147483647,
};
pub const htmlSelectTypeSelectOne = htmlSelectType.SelectOne;
pub const htmlSelectTypeSelectMultiple = htmlSelectType.SelectMultiple;
pub const htmlSelectType_Max = htmlSelectType._Max;

pub const htmlSelectExFlag = enum(i32) {
    None = 0,
    HideSelectionInDesign = 1,
    _Max = 2147483647,
};
pub const htmlSelectExFlagNone = htmlSelectExFlag.None;
pub const htmlSelectExFlagHideSelectionInDesign = htmlSelectExFlag.HideSelectionInDesign;
pub const htmlSelectExFlag_Max = htmlSelectExFlag._Max;

pub const htmlSelection = enum(i32) {
    None = 0,
    Text = 1,
    Control = 2,
    Table = 3,
    _Max = 2147483647,
};
pub const htmlSelectionNone = htmlSelection.None;
pub const htmlSelectionText = htmlSelection.Text;
pub const htmlSelectionControl = htmlSelection.Control;
pub const htmlSelectionTable = htmlSelection.Table;
pub const htmlSelection_Max = htmlSelection._Max;

pub const htmlMarqueeBehavior = enum(i32) {
    scroll = 1,
    slide = 2,
    alternate = 3,
    _Max = 2147483647,
};
pub const htmlMarqueeBehaviorscroll = htmlMarqueeBehavior.scroll;
pub const htmlMarqueeBehaviorslide = htmlMarqueeBehavior.slide;
pub const htmlMarqueeBehavioralternate = htmlMarqueeBehavior.alternate;
pub const htmlMarqueeBehavior_Max = htmlMarqueeBehavior._Max;

pub const htmlMarqueeDirection = enum(i32) {
    left = 1,
    right = 3,
    up = 5,
    down = 7,
    _Max = 2147483647,
};
pub const htmlMarqueeDirectionleft = htmlMarqueeDirection.left;
pub const htmlMarqueeDirectionright = htmlMarqueeDirection.right;
pub const htmlMarqueeDirectionup = htmlMarqueeDirection.up;
pub const htmlMarqueeDirectiondown = htmlMarqueeDirection.down;
pub const htmlMarqueeDirection_Max = htmlMarqueeDirection._Max;

pub const htmlPersistState = enum(i32) {
    Normal = 0,
    Favorite = 1,
    History = 2,
    Snapshot = 3,
    UserData = 4,
    _Max = 2147483647,
};
pub const htmlPersistStateNormal = htmlPersistState.Normal;
pub const htmlPersistStateFavorite = htmlPersistState.Favorite;
pub const htmlPersistStateHistory = htmlPersistState.History;
pub const htmlPersistStateSnapshot = htmlPersistState.Snapshot;
pub const htmlPersistStateUserData = htmlPersistState.UserData;
pub const htmlPersistState_Max = htmlPersistState._Max;

pub const htmlDropEffect = enum(i32) {
    Copy = 0,
    Link = 1,
    Move = 2,
    None = 3,
    _Max = 2147483647,
};
pub const htmlDropEffectCopy = htmlDropEffect.Copy;
pub const htmlDropEffectLink = htmlDropEffect.Link;
pub const htmlDropEffectMove = htmlDropEffect.Move;
pub const htmlDropEffectNone = htmlDropEffect.None;
pub const htmlDropEffect_Max = htmlDropEffect._Max;

pub const htmlEffectAllowed = enum(i32) {
    Copy = 0,
    Link = 1,
    Move = 2,
    CopyLink = 3,
    CopyMove = 4,
    LinkMove = 5,
    All = 6,
    None = 7,
    Uninitialized = 8,
    _Max = 2147483647,
};
pub const htmlEffectAllowedCopy = htmlEffectAllowed.Copy;
pub const htmlEffectAllowedLink = htmlEffectAllowed.Link;
pub const htmlEffectAllowedMove = htmlEffectAllowed.Move;
pub const htmlEffectAllowedCopyLink = htmlEffectAllowed.CopyLink;
pub const htmlEffectAllowedCopyMove = htmlEffectAllowed.CopyMove;
pub const htmlEffectAllowedLinkMove = htmlEffectAllowed.LinkMove;
pub const htmlEffectAllowedAll = htmlEffectAllowed.All;
pub const htmlEffectAllowedNone = htmlEffectAllowed.None;
pub const htmlEffectAllowedUninitialized = htmlEffectAllowed.Uninitialized;
pub const htmlEffectAllowed_Max = htmlEffectAllowed._Max;

pub const htmlCompatMode = enum(i32) {
    BackCompat = 0,
    CSS1Compat = 1,
    _Max = 2147483647,
};
pub const htmlCompatModeBackCompat = htmlCompatMode.BackCompat;
pub const htmlCompatModeCSS1Compat = htmlCompatMode.CSS1Compat;
pub const htmlCompatMode_Max = htmlCompatMode._Max;

pub const BoolValue = enum(i32) {
    True = 1,
    False = 0,
    BoolValue_Max = 2147483647,
};
pub const True = BoolValue.True;
pub const False = BoolValue.False;
pub const BoolValue_Max = BoolValue.BoolValue_Max;

pub const htmlCaptionAlign = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    Justify = 4,
    Top = 5,
    Bottom = 6,
    _Max = 2147483647,
};
pub const htmlCaptionAlignNotSet = htmlCaptionAlign.NotSet;
pub const htmlCaptionAlignLeft = htmlCaptionAlign.Left;
pub const htmlCaptionAlignCenter = htmlCaptionAlign.Center;
pub const htmlCaptionAlignRight = htmlCaptionAlign.Right;
pub const htmlCaptionAlignJustify = htmlCaptionAlign.Justify;
pub const htmlCaptionAlignTop = htmlCaptionAlign.Top;
pub const htmlCaptionAlignBottom = htmlCaptionAlign.Bottom;
pub const htmlCaptionAlign_Max = htmlCaptionAlign._Max;

pub const htmlCaptionVAlign = enum(i32) {
    NotSet = 0,
    Top = 1,
    Bottom = 2,
    _Max = 2147483647,
};
pub const htmlCaptionVAlignNotSet = htmlCaptionVAlign.NotSet;
pub const htmlCaptionVAlignTop = htmlCaptionVAlign.Top;
pub const htmlCaptionVAlignBottom = htmlCaptionVAlign.Bottom;
pub const htmlCaptionVAlign_Max = htmlCaptionVAlign._Max;

pub const htmlFrame = enum(i32) {
    NotSet = 0,
    void = 1,
    above = 2,
    below = 3,
    hsides = 4,
    lhs = 5,
    rhs = 6,
    vsides = 7,
    box = 8,
    border = 9,
    _Max = 2147483647,
};
pub const htmlFrameNotSet = htmlFrame.NotSet;
pub const htmlFramevoid = htmlFrame.void;
pub const htmlFrameabove = htmlFrame.above;
pub const htmlFramebelow = htmlFrame.below;
pub const htmlFramehsides = htmlFrame.hsides;
pub const htmlFramelhs = htmlFrame.lhs;
pub const htmlFramerhs = htmlFrame.rhs;
pub const htmlFramevsides = htmlFrame.vsides;
pub const htmlFramebox = htmlFrame.box;
pub const htmlFrameborder = htmlFrame.border;
pub const htmlFrame_Max = htmlFrame._Max;

pub const htmlRules = enum(i32) {
    NotSet = 0,
    none = 1,
    groups = 2,
    rows = 3,
    cols = 4,
    all = 5,
    _Max = 2147483647,
};
pub const htmlRulesNotSet = htmlRules.NotSet;
pub const htmlRulesnone = htmlRules.none;
pub const htmlRulesgroups = htmlRules.groups;
pub const htmlRulesrows = htmlRules.rows;
pub const htmlRulescols = htmlRules.cols;
pub const htmlRulesall = htmlRules.all;
pub const htmlRules_Max = htmlRules._Max;

pub const htmlCellAlign = enum(i32) {
    NotSet = 0,
    Left = 1,
    Center = 2,
    Right = 3,
    // Middle = 2, this enum value conflicts with Center
    _Max = 2147483647,
};
pub const htmlCellAlignNotSet = htmlCellAlign.NotSet;
pub const htmlCellAlignLeft = htmlCellAlign.Left;
pub const htmlCellAlignCenter = htmlCellAlign.Center;
pub const htmlCellAlignRight = htmlCellAlign.Right;
pub const htmlCellAlignMiddle = htmlCellAlign.Center;
pub const htmlCellAlign_Max = htmlCellAlign._Max;

pub const htmlCellVAlign = enum(i32) {
    NotSet = 0,
    Top = 1,
    Middle = 2,
    Bottom = 3,
    Baseline = 4,
    // Center = 2, this enum value conflicts with Middle
    _Max = 2147483647,
};
pub const htmlCellVAlignNotSet = htmlCellVAlign.NotSet;
pub const htmlCellVAlignTop = htmlCellVAlign.Top;
pub const htmlCellVAlignMiddle = htmlCellVAlign.Middle;
pub const htmlCellVAlignBottom = htmlCellVAlign.Bottom;
pub const htmlCellVAlignBaseline = htmlCellVAlign.Baseline;
pub const htmlCellVAlignCenter = htmlCellVAlign.Middle;
pub const htmlCellVAlign_Max = htmlCellVAlign._Max;

pub const frameScrolling = enum(i32) {
    yes = 1,
    no = 2,
    auto = 4,
    _Max = 2147483647,
};
pub const frameScrollingyes = frameScrolling.yes;
pub const frameScrollingno = frameScrolling.no;
pub const frameScrollingauto = frameScrolling.auto;
pub const frameScrolling_Max = frameScrolling._Max;

pub const sandboxAllow = enum(i32) {
    Scripts = 0,
    SameOrigin = 1,
    TopNavigation = 2,
    Forms = 3,
    Popups = 4,
    _Max = 2147483647,
};
pub const sandboxAllowScripts = sandboxAllow.Scripts;
pub const sandboxAllowSameOrigin = sandboxAllow.SameOrigin;
pub const sandboxAllowTopNavigation = sandboxAllow.TopNavigation;
pub const sandboxAllowForms = sandboxAllow.Forms;
pub const sandboxAllowPopups = sandboxAllow.Popups;
pub const sandboxAllow_Max = sandboxAllow._Max;

pub const svgAngleType = enum(i32) {
    SVG_ANGLETYPE_UNKNOWN = 0,
    SVG_ANGLETYPE_UNSPECIFIED = 1,
    SVG_ANGLETYPE_DEG = 2,
    SVG_ANGLETYPE_RAD = 3,
    SVG_ANGLETYPE_GRAD = 4,
    svgAngleType_Max = 2147483647,
};
pub const SVG_ANGLETYPE_UNKNOWN = svgAngleType.SVG_ANGLETYPE_UNKNOWN;
pub const SVG_ANGLETYPE_UNSPECIFIED = svgAngleType.SVG_ANGLETYPE_UNSPECIFIED;
pub const SVG_ANGLETYPE_DEG = svgAngleType.SVG_ANGLETYPE_DEG;
pub const SVG_ANGLETYPE_RAD = svgAngleType.SVG_ANGLETYPE_RAD;
pub const SVG_ANGLETYPE_GRAD = svgAngleType.SVG_ANGLETYPE_GRAD;
pub const svgAngleType_Max = svgAngleType.svgAngleType_Max;

pub const svgExternalResourcesRequired = enum(i32) {
    False = 0,
    True = 1,
    _Max = 2147483647,
};
pub const svgExternalResourcesRequiredFalse = svgExternalResourcesRequired.False;
pub const svgExternalResourcesRequiredTrue = svgExternalResourcesRequired.True;
pub const svgExternalResourcesRequired_Max = svgExternalResourcesRequired._Max;

pub const svgFocusable = enum(i32) {
    NotSet = 0,
    Auto = 1,
    True = 2,
    False = 3,
    _Max = 2147483647,
};
pub const svgFocusableNotSet = svgFocusable.NotSet;
pub const svgFocusableAuto = svgFocusable.Auto;
pub const svgFocusableTrue = svgFocusable.True;
pub const svgFocusableFalse = svgFocusable.False;
pub const svgFocusable_Max = svgFocusable._Max;

pub const svgLengthType = enum(i32) {
    SVG_LENGTHTYPE_UNKNOWN = 0,
    SVG_LENGTHTYPE_NUMBER = 1,
    SVG_LENGTHTYPE_PERCENTAGE = 2,
    SVG_LENGTHTYPE_EMS = 3,
    SVG_LENGTHTYPE_EXS = 4,
    SVG_LENGTHTYPE_PX = 5,
    SVG_LENGTHTYPE_CM = 6,
    SVG_LENGTHTYPE_MM = 7,
    SVG_LENGTHTYPE_IN = 8,
    SVG_LENGTHTYPE_PT = 9,
    SVG_LENGTHTYPE_PC = 10,
    svgLengthType_Max = 2147483647,
};
pub const SVG_LENGTHTYPE_UNKNOWN = svgLengthType.SVG_LENGTHTYPE_UNKNOWN;
pub const SVG_LENGTHTYPE_NUMBER = svgLengthType.SVG_LENGTHTYPE_NUMBER;
pub const SVG_LENGTHTYPE_PERCENTAGE = svgLengthType.SVG_LENGTHTYPE_PERCENTAGE;
pub const SVG_LENGTHTYPE_EMS = svgLengthType.SVG_LENGTHTYPE_EMS;
pub const SVG_LENGTHTYPE_EXS = svgLengthType.SVG_LENGTHTYPE_EXS;
pub const SVG_LENGTHTYPE_PX = svgLengthType.SVG_LENGTHTYPE_PX;
pub const SVG_LENGTHTYPE_CM = svgLengthType.SVG_LENGTHTYPE_CM;
pub const SVG_LENGTHTYPE_MM = svgLengthType.SVG_LENGTHTYPE_MM;
pub const SVG_LENGTHTYPE_IN = svgLengthType.SVG_LENGTHTYPE_IN;
pub const SVG_LENGTHTYPE_PT = svgLengthType.SVG_LENGTHTYPE_PT;
pub const SVG_LENGTHTYPE_PC = svgLengthType.SVG_LENGTHTYPE_PC;
pub const svgLengthType_Max = svgLengthType.svgLengthType_Max;

pub const svgPathSegType = enum(i32) {
    PATHSEG_UNKNOWN = 0,
    PATHSEG_CLOSEPATH = 1,
    PATHSEG_MOVETO_ABS = 2,
    PATHSEG_MOVETO_REL = 3,
    PATHSEG_LINETO_ABS = 4,
    PATHSEG_LINETO_REL = 5,
    PATHSEG_CURVETO_CUBIC_ABS = 6,
    PATHSEG_CURVETO_CUBIC_REL = 7,
    PATHSEG_CURVETO_QUADRATIC_ABS = 8,
    PATHSEG_CURVETO_QUADRATIC_REL = 9,
    PATHSEG_ARC_ABS = 10,
    PATHSEG_ARC_REL = 11,
    PATHSEG_LINETO_HORIZONTAL_ABS = 12,
    PATHSEG_LINETO_HORIZONTAL_REL = 13,
    PATHSEG_LINETO_VERTICAL_ABS = 14,
    PATHSEG_LINETO_VERTICAL_REL = 15,
    PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16,
    PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17,
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18,
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19,
    svgPathSegType_Max = 2147483647,
};
pub const PATHSEG_UNKNOWN = svgPathSegType.PATHSEG_UNKNOWN;
pub const PATHSEG_CLOSEPATH = svgPathSegType.PATHSEG_CLOSEPATH;
pub const PATHSEG_MOVETO_ABS = svgPathSegType.PATHSEG_MOVETO_ABS;
pub const PATHSEG_MOVETO_REL = svgPathSegType.PATHSEG_MOVETO_REL;
pub const PATHSEG_LINETO_ABS = svgPathSegType.PATHSEG_LINETO_ABS;
pub const PATHSEG_LINETO_REL = svgPathSegType.PATHSEG_LINETO_REL;
pub const PATHSEG_CURVETO_CUBIC_ABS = svgPathSegType.PATHSEG_CURVETO_CUBIC_ABS;
pub const PATHSEG_CURVETO_CUBIC_REL = svgPathSegType.PATHSEG_CURVETO_CUBIC_REL;
pub const PATHSEG_CURVETO_QUADRATIC_ABS = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_ABS;
pub const PATHSEG_CURVETO_QUADRATIC_REL = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_REL;
pub const PATHSEG_ARC_ABS = svgPathSegType.PATHSEG_ARC_ABS;
pub const PATHSEG_ARC_REL = svgPathSegType.PATHSEG_ARC_REL;
pub const PATHSEG_LINETO_HORIZONTAL_ABS = svgPathSegType.PATHSEG_LINETO_HORIZONTAL_ABS;
pub const PATHSEG_LINETO_HORIZONTAL_REL = svgPathSegType.PATHSEG_LINETO_HORIZONTAL_REL;
pub const PATHSEG_LINETO_VERTICAL_ABS = svgPathSegType.PATHSEG_LINETO_VERTICAL_ABS;
pub const PATHSEG_LINETO_VERTICAL_REL = svgPathSegType.PATHSEG_LINETO_VERTICAL_REL;
pub const PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = svgPathSegType.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
pub const PATHSEG_CURVETO_CUBIC_SMOOTH_REL = svgPathSegType.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
pub const PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
pub const PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
pub const svgPathSegType_Max = svgPathSegType.svgPathSegType_Max;

pub const svgTransformType = enum(i32) {
    SVG_TRANSFORM_UNKNOWN = 0,
    SVG_TRANSFORM_MATRIX = 1,
    SVG_TRANSFORM_TRANSLATE = 2,
    SVG_TRANSFORM_SCALE = 3,
    SVG_TRANSFORM_ROTATE = 4,
    SVG_TRANSFORM_SKEWX = 5,
    SVG_TRANSFORM_SKEWY = 6,
    svgTransformType_Max = 2147483647,
};
pub const SVG_TRANSFORM_UNKNOWN = svgTransformType.SVG_TRANSFORM_UNKNOWN;
pub const SVG_TRANSFORM_MATRIX = svgTransformType.SVG_TRANSFORM_MATRIX;
pub const SVG_TRANSFORM_TRANSLATE = svgTransformType.SVG_TRANSFORM_TRANSLATE;
pub const SVG_TRANSFORM_SCALE = svgTransformType.SVG_TRANSFORM_SCALE;
pub const SVG_TRANSFORM_ROTATE = svgTransformType.SVG_TRANSFORM_ROTATE;
pub const SVG_TRANSFORM_SKEWX = svgTransformType.SVG_TRANSFORM_SKEWX;
pub const SVG_TRANSFORM_SKEWY = svgTransformType.SVG_TRANSFORM_SKEWY;
pub const svgTransformType_Max = svgTransformType.svgTransformType_Max;

pub const svgPreserveAspectRatioAlignType = enum(i32) {
    SVG_PRESERVEASPECTRATIO_UNKNOWN = 0,
    SVG_PRESERVEASPECTRATIO_NONE = 1,
    SVG_PRESERVEASPECTRATIO_XMINYMIN = 2,
    SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3,
    SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4,
    SVG_PRESERVEASPECTRATIO_XMINYMID = 5,
    SVG_PRESERVEASPECTRATIO_XMIDYMID = 6,
    SVG_PRESERVEASPECTRATIO_XMAXYMID = 7,
    SVG_PRESERVEASPECTRATIO_XMINYMAX = 8,
    SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9,
    SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10,
    svgPreserveAspectRatioAlignType_Max = 2147483647,
};
pub const SVG_PRESERVEASPECTRATIO_UNKNOWN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_UNKNOWN;
pub const SVG_PRESERVEASPECTRATIO_NONE = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_NONE;
pub const SVG_PRESERVEASPECTRATIO_XMINYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMINYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMID;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMID;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMID;
pub const SVG_PRESERVEASPECTRATIO_XMINYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMAX;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMAX;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMAX;
pub const svgPreserveAspectRatioAlignType_Max = svgPreserveAspectRatioAlignType.svgPreserveAspectRatioAlignType_Max;

pub const svgPreserveAspectMeetOrSliceType = enum(i32) {
    SVG_MEETORSLICE_UNKNOWN = 0,
    SVG_MEETORSLICE_MEET = 1,
    SVG_MEETORSLICE_SLICE = 2,
    svgPreserveAspectMeetOrSliceType_Max = 2147483647,
};
pub const SVG_MEETORSLICE_UNKNOWN = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_UNKNOWN;
pub const SVG_MEETORSLICE_MEET = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_MEET;
pub const SVG_MEETORSLICE_SLICE = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_SLICE;
pub const svgPreserveAspectMeetOrSliceType_Max = svgPreserveAspectMeetOrSliceType.svgPreserveAspectMeetOrSliceType_Max;

pub const svgUnitTypes = enum(i32) {
    SVG_UNITTYPE_UNKNOWN = 0,
    SVG_UNITTYPE_USERSPACEONUSE = 1,
    SVG_UNITTYPE_OBJECTBOUNDINGBOX = 2,
    svgUnitTypes_Max = 2147483647,
};
pub const SVG_UNITTYPE_UNKNOWN = svgUnitTypes.SVG_UNITTYPE_UNKNOWN;
pub const SVG_UNITTYPE_USERSPACEONUSE = svgUnitTypes.SVG_UNITTYPE_USERSPACEONUSE;
pub const SVG_UNITTYPE_OBJECTBOUNDINGBOX = svgUnitTypes.SVG_UNITTYPE_OBJECTBOUNDINGBOX;
pub const svgUnitTypes_Max = svgUnitTypes.svgUnitTypes_Max;

pub const svgSpreadMethod = enum(i32) {
    SVG_SPREADMETHOD_UNKNOWN = 0,
    SVG_SPREADMETHOD_PAD = 1,
    SVG_SPREADMETHOD_REFLECT = 2,
    SVG_SPREADMETHOD_REPEAT = 3,
    svgSpreadMethod_Max = 2147483647,
};
pub const SVG_SPREADMETHOD_UNKNOWN = svgSpreadMethod.SVG_SPREADMETHOD_UNKNOWN;
pub const SVG_SPREADMETHOD_PAD = svgSpreadMethod.SVG_SPREADMETHOD_PAD;
pub const SVG_SPREADMETHOD_REFLECT = svgSpreadMethod.SVG_SPREADMETHOD_REFLECT;
pub const SVG_SPREADMETHOD_REPEAT = svgSpreadMethod.SVG_SPREADMETHOD_REPEAT;
pub const svgSpreadMethod_Max = svgSpreadMethod.svgSpreadMethod_Max;

pub const svgFeblendMode = enum(i32) {
    SVG_FEBLEND_MODE_UNKNOWN = 0,
    SVG_FEBLEND_MODE_NORMAL = 1,
    SVG_FEBLEND_MODE_MULTIPLY = 2,
    SVG_FEBLEND_MODE_SCREEN = 3,
    SVG_FEBLEND_MODE_DARKEN = 4,
    SVG_FEBLEND_MODE_LIGHTEN = 5,
    svgFeblendMode_Max = 2147483647,
};
pub const SVG_FEBLEND_MODE_UNKNOWN = svgFeblendMode.SVG_FEBLEND_MODE_UNKNOWN;
pub const SVG_FEBLEND_MODE_NORMAL = svgFeblendMode.SVG_FEBLEND_MODE_NORMAL;
pub const SVG_FEBLEND_MODE_MULTIPLY = svgFeblendMode.SVG_FEBLEND_MODE_MULTIPLY;
pub const SVG_FEBLEND_MODE_SCREEN = svgFeblendMode.SVG_FEBLEND_MODE_SCREEN;
pub const SVG_FEBLEND_MODE_DARKEN = svgFeblendMode.SVG_FEBLEND_MODE_DARKEN;
pub const SVG_FEBLEND_MODE_LIGHTEN = svgFeblendMode.SVG_FEBLEND_MODE_LIGHTEN;
pub const svgFeblendMode_Max = svgFeblendMode.svgFeblendMode_Max;

pub const svgFecolormatrixType = enum(i32) {
    SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0,
    SVG_FECOLORMATRIX_TYPE_MATRIX = 1,
    SVG_FECOLORMATRIX_TYPE_SATURATE = 2,
    SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3,
    SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4,
    svgFecolormatrixType_Max = 2147483647,
};
pub const SVG_FECOLORMATRIX_TYPE_UNKNOWN = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_UNKNOWN;
pub const SVG_FECOLORMATRIX_TYPE_MATRIX = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_MATRIX;
pub const SVG_FECOLORMATRIX_TYPE_SATURATE = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_SATURATE;
pub const SVG_FECOLORMATRIX_TYPE_HUEROTATE = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_HUEROTATE;
pub const SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA;
pub const svgFecolormatrixType_Max = svgFecolormatrixType.svgFecolormatrixType_Max;

pub const svgFecomponenttransferType = enum(i32) {
    SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0,
    SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1,
    SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2,
    SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3,
    SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4,
    SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5,
    svgFecomponenttransferType_Max = 2147483647,
};
pub const SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN;
pub const SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY;
pub const SVG_FECOMPONENTTRANSFER_TYPE_TABLE = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_TABLE;
pub const SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE;
pub const SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_LINEAR;
pub const SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_GAMMA;
pub const svgFecomponenttransferType_Max = svgFecomponenttransferType.svgFecomponenttransferType_Max;

pub const svgFecompositeOperator = enum(i32) {
    SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0,
    SVG_FECOMPOSITE_OPERATOR_OVER = 1,
    SVG_FECOMPOSITE_OPERATOR_IN = 2,
    SVG_FECOMPOSITE_OPERATOR_OUT = 3,
    SVG_FECOMPOSITE_OPERATOR_ATOP = 4,
    SVG_FECOMPOSITE_OPERATOR_XOR = 5,
    SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6,
    svgFecompositeOperator_Max = 2147483647,
};
pub const SVG_FECOMPOSITE_OPERATOR_UNKNOWN = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_UNKNOWN;
pub const SVG_FECOMPOSITE_OPERATOR_OVER = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_OVER;
pub const SVG_FECOMPOSITE_OPERATOR_IN = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_IN;
pub const SVG_FECOMPOSITE_OPERATOR_OUT = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_OUT;
pub const SVG_FECOMPOSITE_OPERATOR_ATOP = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_ATOP;
pub const SVG_FECOMPOSITE_OPERATOR_XOR = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_XOR;
pub const SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_ARITHMETIC;
pub const svgFecompositeOperator_Max = svgFecompositeOperator.svgFecompositeOperator_Max;

pub const svgEdgemode = enum(i32) {
    SVG_EDGEMODE_UNKNOWN = 0,
    SVG_EDGEMODE_DUPLICATE = 1,
    SVG_EDGEMODE_WRAP = 2,
    SVG_EDGEMODE_NONE = 3,
    svgEdgemode_Max = 2147483647,
};
pub const SVG_EDGEMODE_UNKNOWN = svgEdgemode.SVG_EDGEMODE_UNKNOWN;
pub const SVG_EDGEMODE_DUPLICATE = svgEdgemode.SVG_EDGEMODE_DUPLICATE;
pub const SVG_EDGEMODE_WRAP = svgEdgemode.SVG_EDGEMODE_WRAP;
pub const SVG_EDGEMODE_NONE = svgEdgemode.SVG_EDGEMODE_NONE;
pub const svgEdgemode_Max = svgEdgemode.svgEdgemode_Max;

pub const svgPreserveAlpha = enum(i32) {
    SVG_PRESERVEALPHA_FALSE = 0,
    SVG_PRESERVEALPHA_TRUE = 1,
    svgPreserveAlpha_Max = 2147483647,
};
pub const SVG_PRESERVEALPHA_FALSE = svgPreserveAlpha.SVG_PRESERVEALPHA_FALSE;
pub const SVG_PRESERVEALPHA_TRUE = svgPreserveAlpha.SVG_PRESERVEALPHA_TRUE;
pub const svgPreserveAlpha_Max = svgPreserveAlpha.svgPreserveAlpha_Max;

pub const svgChannel = enum(i32) {
    SVG_CHANNEL_UNKNOWN = 0,
    SVG_CHANNEL_R = 1,
    SVG_CHANNEL_G = 2,
    SVG_CHANNEL_B = 3,
    SVG_CHANNEL_A = 4,
    svgChannel_Max = 2147483647,
};
pub const SVG_CHANNEL_UNKNOWN = svgChannel.SVG_CHANNEL_UNKNOWN;
pub const SVG_CHANNEL_R = svgChannel.SVG_CHANNEL_R;
pub const SVG_CHANNEL_G = svgChannel.SVG_CHANNEL_G;
pub const SVG_CHANNEL_B = svgChannel.SVG_CHANNEL_B;
pub const SVG_CHANNEL_A = svgChannel.SVG_CHANNEL_A;
pub const svgChannel_Max = svgChannel.svgChannel_Max;

pub const svgMorphologyOperator = enum(i32) {
    SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0,
    SVG_MORPHOLOGY_OPERATOR_ERODE = 1,
    SVG_MORPHOLOGY_OPERATOR_DILATE = 2,
    svgMorphologyOperator_Max = 2147483647,
};
pub const SVG_MORPHOLOGY_OPERATOR_UNKNOWN = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_UNKNOWN;
pub const SVG_MORPHOLOGY_OPERATOR_ERODE = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_ERODE;
pub const SVG_MORPHOLOGY_OPERATOR_DILATE = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_DILATE;
pub const svgMorphologyOperator_Max = svgMorphologyOperator.svgMorphologyOperator_Max;

pub const svgTurbulenceType = enum(i32) {
    SVG_TURBULENCE_TYPE_UNKNOWN = 0,
    SVG_TURBULENCE_TYPE_FACTALNOISE = 1,
    SVG_TURBULENCE_TYPE_TURBULENCE = 2,
    svgTurbulenceType_Max = 2147483647,
};
pub const SVG_TURBULENCE_TYPE_UNKNOWN = svgTurbulenceType.SVG_TURBULENCE_TYPE_UNKNOWN;
pub const SVG_TURBULENCE_TYPE_FACTALNOISE = svgTurbulenceType.SVG_TURBULENCE_TYPE_FACTALNOISE;
pub const SVG_TURBULENCE_TYPE_TURBULENCE = svgTurbulenceType.SVG_TURBULENCE_TYPE_TURBULENCE;
pub const svgTurbulenceType_Max = svgTurbulenceType.svgTurbulenceType_Max;

pub const svgStitchtype = enum(i32) {
    SVG_STITCHTYPE_UNKNOWN = 0,
    SVG_STITCHTYPE_STITCH = 1,
    SVG_STITCHTYPE_NOSTITCH = 2,
    svgStitchtype_Max = 2147483647,
};
pub const SVG_STITCHTYPE_UNKNOWN = svgStitchtype.SVG_STITCHTYPE_UNKNOWN;
pub const SVG_STITCHTYPE_STITCH = svgStitchtype.SVG_STITCHTYPE_STITCH;
pub const SVG_STITCHTYPE_NOSTITCH = svgStitchtype.SVG_STITCHTYPE_NOSTITCH;
pub const svgStitchtype_Max = svgStitchtype.svgStitchtype_Max;

pub const svgMarkerUnits = enum(i32) {
    SVG_MARKERUNITS_UNKNOWN = 0,
    SVG_MARKERUNITS_USERSPACEONUSE = 1,
    SVG_MARKERUNITS_STROKEWIDTH = 2,
    svgMarkerUnits_Max = 2147483647,
};
pub const SVG_MARKERUNITS_UNKNOWN = svgMarkerUnits.SVG_MARKERUNITS_UNKNOWN;
pub const SVG_MARKERUNITS_USERSPACEONUSE = svgMarkerUnits.SVG_MARKERUNITS_USERSPACEONUSE;
pub const SVG_MARKERUNITS_STROKEWIDTH = svgMarkerUnits.SVG_MARKERUNITS_STROKEWIDTH;
pub const svgMarkerUnits_Max = svgMarkerUnits.svgMarkerUnits_Max;

pub const svgMarkerOrient = enum(i32) {
    SVG_MARKER_ORIENT_UNKNOWN = 0,
    SVG_MARKER_ORIENT_AUTO = 1,
    SVG_MARKER_ORIENT_ANGLE = 2,
    svgMarkerOrient_Max = 2147483647,
};
pub const SVG_MARKER_ORIENT_UNKNOWN = svgMarkerOrient.SVG_MARKER_ORIENT_UNKNOWN;
pub const SVG_MARKER_ORIENT_AUTO = svgMarkerOrient.SVG_MARKER_ORIENT_AUTO;
pub const SVG_MARKER_ORIENT_ANGLE = svgMarkerOrient.SVG_MARKER_ORIENT_ANGLE;
pub const svgMarkerOrient_Max = svgMarkerOrient.svgMarkerOrient_Max;

pub const svgMarkerOrientAttribute = enum(i32) {
    Auto = 0,
    _Max = 2147483647,
};
pub const svgMarkerOrientAttributeAuto = svgMarkerOrientAttribute.Auto;
pub const svgMarkerOrientAttribute_Max = svgMarkerOrientAttribute._Max;

pub const htmlMediaNetworkState = enum(i32) {
    Empty = 0,
    Idle = 1,
    Loading = 2,
    NoSource = 3,
    _Max = 2147483647,
};
pub const htmlMediaNetworkStateEmpty = htmlMediaNetworkState.Empty;
pub const htmlMediaNetworkStateIdle = htmlMediaNetworkState.Idle;
pub const htmlMediaNetworkStateLoading = htmlMediaNetworkState.Loading;
pub const htmlMediaNetworkStateNoSource = htmlMediaNetworkState.NoSource;
pub const htmlMediaNetworkState_Max = htmlMediaNetworkState._Max;

pub const htmlMediaReadyState = enum(i32) {
    HaveNothing = 0,
    HaveMetadata = 1,
    HaveCurrentData = 2,
    HaveFutureData = 3,
    HaveEnoughData = 4,
    _Max = 2147483647,
};
pub const htmlMediaReadyStateHaveNothing = htmlMediaReadyState.HaveNothing;
pub const htmlMediaReadyStateHaveMetadata = htmlMediaReadyState.HaveMetadata;
pub const htmlMediaReadyStateHaveCurrentData = htmlMediaReadyState.HaveCurrentData;
pub const htmlMediaReadyStateHaveFutureData = htmlMediaReadyState.HaveFutureData;
pub const htmlMediaReadyStateHaveEnoughData = htmlMediaReadyState.HaveEnoughData;
pub const htmlMediaReadyState_Max = htmlMediaReadyState._Max;

pub const htmlMediaErr = enum(i32) {
    Aborted = 0,
    Network = 1,
    Decode = 2,
    SrcNotSupported = 3,
    _Max = 2147483647,
};
pub const htmlMediaErrAborted = htmlMediaErr.Aborted;
pub const htmlMediaErrNetwork = htmlMediaErr.Network;
pub const htmlMediaErrDecode = htmlMediaErr.Decode;
pub const htmlMediaErrSrcNotSupported = htmlMediaErr.SrcNotSupported;
pub const htmlMediaErr_Max = htmlMediaErr._Max;

pub const lengthAdjust = enum(i32) {
    LENGTHADJUST_UNKNOWN = 0,
    LENGTHADJUST_SPACING = 1,
    LENGTHADJUST_SPACINGANDGLYPHS = 2,
    lengthAdjust_Max = 2147483647,
};
pub const LENGTHADJUST_UNKNOWN = lengthAdjust.LENGTHADJUST_UNKNOWN;
pub const LENGTHADJUST_SPACING = lengthAdjust.LENGTHADJUST_SPACING;
pub const LENGTHADJUST_SPACINGANDGLYPHS = lengthAdjust.LENGTHADJUST_SPACINGANDGLYPHS;
pub const lengthAdjust_Max = lengthAdjust.lengthAdjust_Max;

pub const textpathMethodtype = enum(i32) {
    TEXTPATH_METHODTYPE_UNKNOWN = 0,
    TEXTPATH_METHODTYPE_ALIGN = 1,
    TEXTPATH_METHODTYPE_STRETCH = 2,
    textpathMethodtype_Max = 2147483647,
};
pub const TEXTPATH_METHODTYPE_UNKNOWN = textpathMethodtype.TEXTPATH_METHODTYPE_UNKNOWN;
pub const TEXTPATH_METHODTYPE_ALIGN = textpathMethodtype.TEXTPATH_METHODTYPE_ALIGN;
pub const TEXTPATH_METHODTYPE_STRETCH = textpathMethodtype.TEXTPATH_METHODTYPE_STRETCH;
pub const textpathMethodtype_Max = textpathMethodtype.textpathMethodtype_Max;

pub const textpathSpacingtype = enum(i32) {
    TEXTPATH_SPACINGTYPE_UNKNOWN = 0,
    TEXTPATH_SPACINGTYPE_AUTO = 1,
    TEXTPATH_SPACINGTYPE_EXACT = 2,
    textpathSpacingtype_Max = 2147483647,
};
pub const TEXTPATH_SPACINGTYPE_UNKNOWN = textpathSpacingtype.TEXTPATH_SPACINGTYPE_UNKNOWN;
pub const TEXTPATH_SPACINGTYPE_AUTO = textpathSpacingtype.TEXTPATH_SPACINGTYPE_AUTO;
pub const TEXTPATH_SPACINGTYPE_EXACT = textpathSpacingtype.TEXTPATH_SPACINGTYPE_EXACT;
pub const textpathSpacingtype_Max = textpathSpacingtype.textpathSpacingtype_Max;

pub const ELEMENT_CORNER = enum(i32) {
    NONE = 0,
    TOP = 1,
    LEFT = 2,
    BOTTOM = 3,
    RIGHT = 4,
    TOPLEFT = 5,
    TOPRIGHT = 6,
    BOTTOMLEFT = 7,
    BOTTOMRIGHT = 8,
    Max = 2147483647,
};
pub const ELEMENT_CORNER_NONE = ELEMENT_CORNER.NONE;
pub const ELEMENT_CORNER_TOP = ELEMENT_CORNER.TOP;
pub const ELEMENT_CORNER_LEFT = ELEMENT_CORNER.LEFT;
pub const ELEMENT_CORNER_BOTTOM = ELEMENT_CORNER.BOTTOM;
pub const ELEMENT_CORNER_RIGHT = ELEMENT_CORNER.RIGHT;
pub const ELEMENT_CORNER_TOPLEFT = ELEMENT_CORNER.TOPLEFT;
pub const ELEMENT_CORNER_TOPRIGHT = ELEMENT_CORNER.TOPRIGHT;
pub const ELEMENT_CORNER_BOTTOMLEFT = ELEMENT_CORNER.BOTTOMLEFT;
pub const ELEMENT_CORNER_BOTTOMRIGHT = ELEMENT_CORNER.BOTTOMRIGHT;
pub const ELEMENT_CORNER_Max = ELEMENT_CORNER.Max;

pub const SECUREURLHOSTVALIDATE_FLAGS = enum(i32) {
    UHV_PROMPTBEFORENO = 1,
    UHV_SILENTYES = 2,
    UHV_UNSECURESOURCE = 4,
    ECUREURLHOSTVALIDATE_FLAGS_Max = 2147483647,
};
pub const SUHV_PROMPTBEFORENO = SECUREURLHOSTVALIDATE_FLAGS.UHV_PROMPTBEFORENO;
pub const SUHV_SILENTYES = SECUREURLHOSTVALIDATE_FLAGS.UHV_SILENTYES;
pub const SUHV_UNSECURESOURCE = SECUREURLHOSTVALIDATE_FLAGS.UHV_UNSECURESOURCE;
pub const SECUREURLHOSTVALIDATE_FLAGS_Max = SECUREURLHOSTVALIDATE_FLAGS.ECUREURLHOSTVALIDATE_FLAGS_Max;

pub const POINTER_GRAVITY = enum(i32) {
    Left = 0,
    Right = 1,
    Max = 2147483647,
};
pub const POINTER_GRAVITY_Left = POINTER_GRAVITY.Left;
pub const POINTER_GRAVITY_Right = POINTER_GRAVITY.Right;
pub const POINTER_GRAVITY_Max = POINTER_GRAVITY.Max;

pub const ELEMENT_ADJACENCY = enum(i32) {
    _ADJ_BeforeBegin = 0,
    _ADJ_AfterBegin = 1,
    _ADJ_BeforeEnd = 2,
    _ADJ_AfterEnd = 3,
    ENT_ADJACENCY_Max = 2147483647,
};
pub const ELEM_ADJ_BeforeBegin = ELEMENT_ADJACENCY._ADJ_BeforeBegin;
pub const ELEM_ADJ_AfterBegin = ELEMENT_ADJACENCY._ADJ_AfterBegin;
pub const ELEM_ADJ_BeforeEnd = ELEMENT_ADJACENCY._ADJ_BeforeEnd;
pub const ELEM_ADJ_AfterEnd = ELEMENT_ADJACENCY._ADJ_AfterEnd;
pub const ELEMENT_ADJACENCY_Max = ELEMENT_ADJACENCY.ENT_ADJACENCY_Max;

pub const MARKUP_CONTEXT_TYPE = enum(i32) {
    CONTEXT_TYPE_None = 0,
    CONTEXT_TYPE_Text = 1,
    CONTEXT_TYPE_EnterScope = 2,
    CONTEXT_TYPE_ExitScope = 3,
    CONTEXT_TYPE_NoScope = 4,
    MARKUP_CONTEXT_TYPE_Max = 2147483647,
};
pub const CONTEXT_TYPE_None = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_None;
pub const CONTEXT_TYPE_Text = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_Text;
pub const CONTEXT_TYPE_EnterScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_EnterScope;
pub const CONTEXT_TYPE_ExitScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_ExitScope;
pub const CONTEXT_TYPE_NoScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_NoScope;
pub const MARKUP_CONTEXT_TYPE_Max = MARKUP_CONTEXT_TYPE.MARKUP_CONTEXT_TYPE_Max;

pub const FINDTEXT_FLAGS = enum(i32) {
    BACKWARDS = 1,
    WHOLEWORD = 2,
    MATCHCASE = 4,
    RAW = 131072,
    MATCHREPEATEDWHITESPACE = 262144,
    MATCHDIAC = 536870912,
    MATCHKASHIDA = 1073741824,
    MATCHALEFHAMZA = -2147483648,
    FLAGS_Max = 2147483647,
};
pub const FINDTEXT_BACKWARDS = FINDTEXT_FLAGS.BACKWARDS;
pub const FINDTEXT_WHOLEWORD = FINDTEXT_FLAGS.WHOLEWORD;
pub const FINDTEXT_MATCHCASE = FINDTEXT_FLAGS.MATCHCASE;
pub const FINDTEXT_RAW = FINDTEXT_FLAGS.RAW;
pub const FINDTEXT_MATCHREPEATEDWHITESPACE = FINDTEXT_FLAGS.MATCHREPEATEDWHITESPACE;
pub const FINDTEXT_MATCHDIAC = FINDTEXT_FLAGS.MATCHDIAC;
pub const FINDTEXT_MATCHKASHIDA = FINDTEXT_FLAGS.MATCHKASHIDA;
pub const FINDTEXT_MATCHALEFHAMZA = FINDTEXT_FLAGS.MATCHALEFHAMZA;
pub const FINDTEXT_FLAGS_Max = FINDTEXT_FLAGS.FLAGS_Max;

pub const MOVEUNIT_ACTION = enum(i32) {
    PREVCHAR = 0,
    NEXTCHAR = 1,
    PREVCLUSTERBEGIN = 2,
    NEXTCLUSTERBEGIN = 3,
    PREVCLUSTEREND = 4,
    NEXTCLUSTEREND = 5,
    PREVWORDBEGIN = 6,
    NEXTWORDBEGIN = 7,
    PREVWORDEND = 8,
    NEXTWORDEND = 9,
    PREVPROOFWORD = 10,
    NEXTPROOFWORD = 11,
    NEXTURLBEGIN = 12,
    PREVURLBEGIN = 13,
    NEXTURLEND = 14,
    PREVURLEND = 15,
    PREVSENTENCE = 16,
    NEXTSENTENCE = 17,
    PREVBLOCK = 18,
    NEXTBLOCK = 19,
    ACTION_Max = 2147483647,
};
pub const MOVEUNIT_PREVCHAR = MOVEUNIT_ACTION.PREVCHAR;
pub const MOVEUNIT_NEXTCHAR = MOVEUNIT_ACTION.NEXTCHAR;
pub const MOVEUNIT_PREVCLUSTERBEGIN = MOVEUNIT_ACTION.PREVCLUSTERBEGIN;
pub const MOVEUNIT_NEXTCLUSTERBEGIN = MOVEUNIT_ACTION.NEXTCLUSTERBEGIN;
pub const MOVEUNIT_PREVCLUSTEREND = MOVEUNIT_ACTION.PREVCLUSTEREND;
pub const MOVEUNIT_NEXTCLUSTEREND = MOVEUNIT_ACTION.NEXTCLUSTEREND;
pub const MOVEUNIT_PREVWORDBEGIN = MOVEUNIT_ACTION.PREVWORDBEGIN;
pub const MOVEUNIT_NEXTWORDBEGIN = MOVEUNIT_ACTION.NEXTWORDBEGIN;
pub const MOVEUNIT_PREVWORDEND = MOVEUNIT_ACTION.PREVWORDEND;
pub const MOVEUNIT_NEXTWORDEND = MOVEUNIT_ACTION.NEXTWORDEND;
pub const MOVEUNIT_PREVPROOFWORD = MOVEUNIT_ACTION.PREVPROOFWORD;
pub const MOVEUNIT_NEXTPROOFWORD = MOVEUNIT_ACTION.NEXTPROOFWORD;
pub const MOVEUNIT_NEXTURLBEGIN = MOVEUNIT_ACTION.NEXTURLBEGIN;
pub const MOVEUNIT_PREVURLBEGIN = MOVEUNIT_ACTION.PREVURLBEGIN;
pub const MOVEUNIT_NEXTURLEND = MOVEUNIT_ACTION.NEXTURLEND;
pub const MOVEUNIT_PREVURLEND = MOVEUNIT_ACTION.PREVURLEND;
pub const MOVEUNIT_PREVSENTENCE = MOVEUNIT_ACTION.PREVSENTENCE;
pub const MOVEUNIT_NEXTSENTENCE = MOVEUNIT_ACTION.NEXTSENTENCE;
pub const MOVEUNIT_PREVBLOCK = MOVEUNIT_ACTION.PREVBLOCK;
pub const MOVEUNIT_NEXTBLOCK = MOVEUNIT_ACTION.NEXTBLOCK;
pub const MOVEUNIT_ACTION_Max = MOVEUNIT_ACTION.ACTION_Max;

pub const PARSE_FLAGS = enum(i32) {
    ABSOLUTIFYIE40URLS = 1,
    DISABLEVML = 2,
    FLAGS_Max = 2147483647,
};
pub const PARSE_ABSOLUTIFYIE40URLS = PARSE_FLAGS.ABSOLUTIFYIE40URLS;
pub const PARSE_DISABLEVML = PARSE_FLAGS.DISABLEVML;
pub const PARSE_FLAGS_Max = PARSE_FLAGS.FLAGS_Max;

pub const ELEMENT_TAG_ID = enum(i32) {
    TAGID_NULL = 0,
    TAGID_UNKNOWN = 1,
    TAGID_A = 2,
    TAGID_ACRONYM = 3,
    TAGID_ADDRESS = 4,
    TAGID_APPLET = 5,
    TAGID_AREA = 6,
    TAGID_B = 7,
    TAGID_BASE = 8,
    TAGID_BASEFONT = 9,
    TAGID_BDO = 10,
    TAGID_BGSOUND = 11,
    TAGID_BIG = 12,
    TAGID_BLINK = 13,
    TAGID_BLOCKQUOTE = 14,
    TAGID_BODY = 15,
    TAGID_BR = 16,
    TAGID_BUTTON = 17,
    TAGID_CAPTION = 18,
    TAGID_CENTER = 19,
    TAGID_CITE = 20,
    TAGID_CODE = 21,
    TAGID_COL = 22,
    TAGID_COLGROUP = 23,
    TAGID_COMMENT = 24,
    TAGID_COMMENT_RAW = 25,
    TAGID_DD = 26,
    TAGID_DEL = 27,
    TAGID_DFN = 28,
    TAGID_DIR = 29,
    TAGID_DIV = 30,
    TAGID_DL = 31,
    TAGID_DT = 32,
    TAGID_EM = 33,
    TAGID_EMBED = 34,
    TAGID_FIELDSET = 35,
    TAGID_FONT = 36,
    TAGID_FORM = 37,
    TAGID_FRAME = 38,
    TAGID_FRAMESET = 39,
    TAGID_GENERIC = 40,
    TAGID_H1 = 41,
    TAGID_H2 = 42,
    TAGID_H3 = 43,
    TAGID_H4 = 44,
    TAGID_H5 = 45,
    TAGID_H6 = 46,
    TAGID_HEAD = 47,
    TAGID_HR = 48,
    TAGID_HTML = 49,
    TAGID_I = 50,
    TAGID_IFRAME = 51,
    TAGID_IMG = 52,
    TAGID_INPUT = 53,
    TAGID_INS = 54,
    TAGID_KBD = 55,
    TAGID_LABEL = 56,
    TAGID_LEGEND = 57,
    TAGID_LI = 58,
    TAGID_LINK = 59,
    TAGID_LISTING = 60,
    TAGID_MAP = 61,
    TAGID_MARQUEE = 62,
    TAGID_MENU = 63,
    TAGID_META = 64,
    TAGID_NEXTID = 65,
    TAGID_NOBR = 66,
    TAGID_NOEMBED = 67,
    TAGID_NOFRAMES = 68,
    TAGID_NOSCRIPT = 69,
    TAGID_OBJECT = 70,
    TAGID_OL = 71,
    TAGID_OPTION = 72,
    TAGID_P = 73,
    TAGID_PARAM = 74,
    TAGID_PLAINTEXT = 75,
    TAGID_PRE = 76,
    TAGID_Q = 77,
    TAGID_RP = 78,
    TAGID_RT = 79,
    TAGID_RUBY = 80,
    TAGID_S = 81,
    TAGID_SAMP = 82,
    TAGID_SCRIPT = 83,
    TAGID_SELECT = 84,
    TAGID_SMALL = 85,
    TAGID_SPAN = 86,
    TAGID_STRIKE = 87,
    TAGID_STRONG = 88,
    TAGID_STYLE = 89,
    TAGID_SUB = 90,
    TAGID_SUP = 91,
    TAGID_TABLE = 92,
    TAGID_TBODY = 93,
    TAGID_TC = 94,
    TAGID_TD = 95,
    TAGID_TEXTAREA = 96,
    TAGID_TFOOT = 97,
    TAGID_TH = 98,
    TAGID_THEAD = 99,
    TAGID_TITLE = 100,
    TAGID_TR = 101,
    TAGID_TT = 102,
    TAGID_U = 103,
    TAGID_UL = 104,
    TAGID_VAR = 105,
    TAGID_WBR = 106,
    TAGID_XMP = 107,
    TAGID_ROOT = 108,
    TAGID_OPTGROUP = 109,
    TAGID_ABBR = 110,
    TAGID_SVG_A = 111,
    TAGID_SVG_ALTGLYPH = 112,
    TAGID_SVG_ALTGLYPHDEF = 113,
    TAGID_SVG_ALTGLYPHITEM = 114,
    TAGID_SVG_ANIMATE = 115,
    TAGID_SVG_ANIMATECOLOR = 116,
    TAGID_SVG_ANIMATEMOTION = 117,
    TAGID_SVG_ANIMATETRANSFORM = 118,
    TAGID_SVG_CIRCLE = 119,
    TAGID_SVG_CLIPPATH = 120,
    TAGID_SVG_COLOR_PROFILE = 121,
    TAGID_SVG_CURSOR = 122,
    TAGID_SVG_DEFINITION_SRC = 123,
    TAGID_SVG_DEFS = 124,
    TAGID_SVG_DESC = 125,
    TAGID_SVG_ELLIPSE = 126,
    TAGID_SVG_FEBLEND = 127,
    TAGID_SVG_FECOLORMATRIX = 128,
    TAGID_SVG_FECOMPONENTTRANSFER = 129,
    TAGID_SVG_FECOMPOSITE = 130,
    TAGID_SVG_FECONVOLVEMATRIX = 131,
    TAGID_SVG_FEDIFFUSELIGHTING = 132,
    TAGID_SVG_FEDISPLACEMENTMAP = 133,
    TAGID_SVG_FEDISTANTLIGHT = 134,
    TAGID_SVG_FEFLOOD = 135,
    TAGID_SVG_FEFUNCA = 136,
    TAGID_SVG_FEFUNCB = 137,
    TAGID_SVG_FEFUNCG = 138,
    TAGID_SVG_FEFUNCR = 139,
    TAGID_SVG_FEGAUSSIANBLUR = 140,
    TAGID_SVG_FEIMAGE = 141,
    TAGID_SVG_FEMERGE = 142,
    TAGID_SVG_FEMERGENODE = 143,
    TAGID_SVG_FEMORPHOLOGY = 144,
    TAGID_SVG_FEOFFSET = 145,
    TAGID_SVG_FEPOINTLIGHT = 146,
    TAGID_SVG_FESPECULARLIGHTING = 147,
    TAGID_SVG_FESPOTLIGHT = 148,
    TAGID_SVG_FETILE = 149,
    TAGID_SVG_FETURBULENCE = 150,
    TAGID_SVG_FILTER = 151,
    TAGID_SVG_FONT = 152,
    TAGID_SVG_FONT_FACE = 153,
    TAGID_SVG_FONT_FACE_FORMAT = 154,
    TAGID_SVG_FONT_FACE_NAME = 155,
    TAGID_SVG_FONT_FACE_SRC = 156,
    TAGID_SVG_FONT_FACE_URI = 157,
    TAGID_SVG_FOREIGNOBJECT = 158,
    TAGID_SVG_G = 159,
    TAGID_SVG_GLYPH = 160,
    TAGID_SVG_GLYPHREF = 161,
    TAGID_SVG_HKERN = 162,
    TAGID_SVG_IMAGE = 163,
    TAGID_SVG_LINE = 164,
    TAGID_SVG_LINEARGRADIENT = 165,
    TAGID_SVG_MARKER = 166,
    TAGID_SVG_MASK = 167,
    TAGID_SVG_METADATA = 168,
    TAGID_SVG_MISSING_GLYPH = 169,
    TAGID_SVG_MPATH = 170,
    TAGID_SVG_PATH = 171,
    TAGID_SVG_PATTERN = 172,
    TAGID_SVG_POLYGON = 173,
    TAGID_SVG_POLYLINE = 174,
    TAGID_SVG_RADIALGRADIENT = 175,
    TAGID_SVG_RECT = 176,
    TAGID_SVG_SCRIPT = 177,
    TAGID_SVG_SET = 178,
    TAGID_SVG_STOP = 179,
    TAGID_SVG_STYLE = 180,
    TAGID_SVG_SVG = 181,
    TAGID_SVG_SWITCH = 182,
    TAGID_SVG_SYMBOL = 183,
    TAGID_SVG_TEXT = 184,
    TAGID_SVG_TEXTPATH = 185,
    TAGID_SVG_TITLE = 186,
    TAGID_SVG_TREF = 187,
    TAGID_SVG_TSPAN = 188,
    TAGID_SVG_USE = 189,
    TAGID_SVG_VIEW = 190,
    TAGID_SVG_VKERN = 191,
    TAGID_AUDIO = 192,
    TAGID_SOURCE = 193,
    TAGID_VIDEO = 194,
    TAGID_CANVAS = 195,
    TAGID_DOCTYPE = 196,
    TAGID_KEYGEN = 197,
    TAGID_PROCESSINGINSTRUCTION = 198,
    TAGID_ARTICLE = 199,
    TAGID_ASIDE = 200,
    TAGID_FIGCAPTION = 201,
    TAGID_FIGURE = 202,
    TAGID_FOOTER = 203,
    TAGID_HEADER = 204,
    TAGID_HGROUP = 205,
    TAGID_MARK = 206,
    TAGID_NAV = 207,
    TAGID_SECTION = 208,
    TAGID_PROGRESS = 209,
    TAGID_MATHML_ANNOTATION_XML = 210,
    TAGID_MATHML_MATH = 211,
    TAGID_MATHML_MI = 212,
    TAGID_MATHML_MN = 213,
    TAGID_MATHML_MO = 214,
    TAGID_MATHML_MS = 215,
    TAGID_MATHML_MTEXT = 216,
    TAGID_DATALIST = 217,
    TAGID_TRACK = 218,
    TAGID_ISINDEX = 219,
    TAGID_COMMAND = 220,
    TAGID_DETAILS = 221,
    TAGID_SUMMARY = 222,
    TAGID_X_MS_WEBVIEW = 223,
    TAGID_COUNT = 224,
    TAGID_LAST_PREDEFINED = 10000,
    ELEMENT_TAG_ID_Max = 2147483647,
};
pub const TAGID_NULL = ELEMENT_TAG_ID.TAGID_NULL;
pub const TAGID_UNKNOWN = ELEMENT_TAG_ID.TAGID_UNKNOWN;
pub const TAGID_A = ELEMENT_TAG_ID.TAGID_A;
pub const TAGID_ACRONYM = ELEMENT_TAG_ID.TAGID_ACRONYM;
pub const TAGID_ADDRESS = ELEMENT_TAG_ID.TAGID_ADDRESS;
pub const TAGID_APPLET = ELEMENT_TAG_ID.TAGID_APPLET;
pub const TAGID_AREA = ELEMENT_TAG_ID.TAGID_AREA;
pub const TAGID_B = ELEMENT_TAG_ID.TAGID_B;
pub const TAGID_BASE = ELEMENT_TAG_ID.TAGID_BASE;
pub const TAGID_BASEFONT = ELEMENT_TAG_ID.TAGID_BASEFONT;
pub const TAGID_BDO = ELEMENT_TAG_ID.TAGID_BDO;
pub const TAGID_BGSOUND = ELEMENT_TAG_ID.TAGID_BGSOUND;
pub const TAGID_BIG = ELEMENT_TAG_ID.TAGID_BIG;
pub const TAGID_BLINK = ELEMENT_TAG_ID.TAGID_BLINK;
pub const TAGID_BLOCKQUOTE = ELEMENT_TAG_ID.TAGID_BLOCKQUOTE;
pub const TAGID_BODY = ELEMENT_TAG_ID.TAGID_BODY;
pub const TAGID_BR = ELEMENT_TAG_ID.TAGID_BR;
pub const TAGID_BUTTON = ELEMENT_TAG_ID.TAGID_BUTTON;
pub const TAGID_CAPTION = ELEMENT_TAG_ID.TAGID_CAPTION;
pub const TAGID_CENTER = ELEMENT_TAG_ID.TAGID_CENTER;
pub const TAGID_CITE = ELEMENT_TAG_ID.TAGID_CITE;
pub const TAGID_CODE = ELEMENT_TAG_ID.TAGID_CODE;
pub const TAGID_COL = ELEMENT_TAG_ID.TAGID_COL;
pub const TAGID_COLGROUP = ELEMENT_TAG_ID.TAGID_COLGROUP;
pub const TAGID_COMMENT = ELEMENT_TAG_ID.TAGID_COMMENT;
pub const TAGID_COMMENT_RAW = ELEMENT_TAG_ID.TAGID_COMMENT_RAW;
pub const TAGID_DD = ELEMENT_TAG_ID.TAGID_DD;
pub const TAGID_DEL = ELEMENT_TAG_ID.TAGID_DEL;
pub const TAGID_DFN = ELEMENT_TAG_ID.TAGID_DFN;
pub const TAGID_DIR = ELEMENT_TAG_ID.TAGID_DIR;
pub const TAGID_DIV = ELEMENT_TAG_ID.TAGID_DIV;
pub const TAGID_DL = ELEMENT_TAG_ID.TAGID_DL;
pub const TAGID_DT = ELEMENT_TAG_ID.TAGID_DT;
pub const TAGID_EM = ELEMENT_TAG_ID.TAGID_EM;
pub const TAGID_EMBED = ELEMENT_TAG_ID.TAGID_EMBED;
pub const TAGID_FIELDSET = ELEMENT_TAG_ID.TAGID_FIELDSET;
pub const TAGID_FONT = ELEMENT_TAG_ID.TAGID_FONT;
pub const TAGID_FORM = ELEMENT_TAG_ID.TAGID_FORM;
pub const TAGID_FRAME = ELEMENT_TAG_ID.TAGID_FRAME;
pub const TAGID_FRAMESET = ELEMENT_TAG_ID.TAGID_FRAMESET;
pub const TAGID_GENERIC = ELEMENT_TAG_ID.TAGID_GENERIC;
pub const TAGID_H1 = ELEMENT_TAG_ID.TAGID_H1;
pub const TAGID_H2 = ELEMENT_TAG_ID.TAGID_H2;
pub const TAGID_H3 = ELEMENT_TAG_ID.TAGID_H3;
pub const TAGID_H4 = ELEMENT_TAG_ID.TAGID_H4;
pub const TAGID_H5 = ELEMENT_TAG_ID.TAGID_H5;
pub const TAGID_H6 = ELEMENT_TAG_ID.TAGID_H6;
pub const TAGID_HEAD = ELEMENT_TAG_ID.TAGID_HEAD;
pub const TAGID_HR = ELEMENT_TAG_ID.TAGID_HR;
pub const TAGID_HTML = ELEMENT_TAG_ID.TAGID_HTML;
pub const TAGID_I = ELEMENT_TAG_ID.TAGID_I;
pub const TAGID_IFRAME = ELEMENT_TAG_ID.TAGID_IFRAME;
pub const TAGID_IMG = ELEMENT_TAG_ID.TAGID_IMG;
pub const TAGID_INPUT = ELEMENT_TAG_ID.TAGID_INPUT;
pub const TAGID_INS = ELEMENT_TAG_ID.TAGID_INS;
pub const TAGID_KBD = ELEMENT_TAG_ID.TAGID_KBD;
pub const TAGID_LABEL = ELEMENT_TAG_ID.TAGID_LABEL;
pub const TAGID_LEGEND = ELEMENT_TAG_ID.TAGID_LEGEND;
pub const TAGID_LI = ELEMENT_TAG_ID.TAGID_LI;
pub const TAGID_LINK = ELEMENT_TAG_ID.TAGID_LINK;
pub const TAGID_LISTING = ELEMENT_TAG_ID.TAGID_LISTING;
pub const TAGID_MAP = ELEMENT_TAG_ID.TAGID_MAP;
pub const TAGID_MARQUEE = ELEMENT_TAG_ID.TAGID_MARQUEE;
pub const TAGID_MENU = ELEMENT_TAG_ID.TAGID_MENU;
pub const TAGID_META = ELEMENT_TAG_ID.TAGID_META;
pub const TAGID_NEXTID = ELEMENT_TAG_ID.TAGID_NEXTID;
pub const TAGID_NOBR = ELEMENT_TAG_ID.TAGID_NOBR;
pub const TAGID_NOEMBED = ELEMENT_TAG_ID.TAGID_NOEMBED;
pub const TAGID_NOFRAMES = ELEMENT_TAG_ID.TAGID_NOFRAMES;
pub const TAGID_NOSCRIPT = ELEMENT_TAG_ID.TAGID_NOSCRIPT;
pub const TAGID_OBJECT = ELEMENT_TAG_ID.TAGID_OBJECT;
pub const TAGID_OL = ELEMENT_TAG_ID.TAGID_OL;
pub const TAGID_OPTION = ELEMENT_TAG_ID.TAGID_OPTION;
pub const TAGID_P = ELEMENT_TAG_ID.TAGID_P;
pub const TAGID_PARAM = ELEMENT_TAG_ID.TAGID_PARAM;
pub const TAGID_PLAINTEXT = ELEMENT_TAG_ID.TAGID_PLAINTEXT;
pub const TAGID_PRE = ELEMENT_TAG_ID.TAGID_PRE;
pub const TAGID_Q = ELEMENT_TAG_ID.TAGID_Q;
pub const TAGID_RP = ELEMENT_TAG_ID.TAGID_RP;
pub const TAGID_RT = ELEMENT_TAG_ID.TAGID_RT;
pub const TAGID_RUBY = ELEMENT_TAG_ID.TAGID_RUBY;
pub const TAGID_S = ELEMENT_TAG_ID.TAGID_S;
pub const TAGID_SAMP = ELEMENT_TAG_ID.TAGID_SAMP;
pub const TAGID_SCRIPT = ELEMENT_TAG_ID.TAGID_SCRIPT;
pub const TAGID_SELECT = ELEMENT_TAG_ID.TAGID_SELECT;
pub const TAGID_SMALL = ELEMENT_TAG_ID.TAGID_SMALL;
pub const TAGID_SPAN = ELEMENT_TAG_ID.TAGID_SPAN;
pub const TAGID_STRIKE = ELEMENT_TAG_ID.TAGID_STRIKE;
pub const TAGID_STRONG = ELEMENT_TAG_ID.TAGID_STRONG;
pub const TAGID_STYLE = ELEMENT_TAG_ID.TAGID_STYLE;
pub const TAGID_SUB = ELEMENT_TAG_ID.TAGID_SUB;
pub const TAGID_SUP = ELEMENT_TAG_ID.TAGID_SUP;
pub const TAGID_TABLE = ELEMENT_TAG_ID.TAGID_TABLE;
pub const TAGID_TBODY = ELEMENT_TAG_ID.TAGID_TBODY;
pub const TAGID_TC = ELEMENT_TAG_ID.TAGID_TC;
pub const TAGID_TD = ELEMENT_TAG_ID.TAGID_TD;
pub const TAGID_TEXTAREA = ELEMENT_TAG_ID.TAGID_TEXTAREA;
pub const TAGID_TFOOT = ELEMENT_TAG_ID.TAGID_TFOOT;
pub const TAGID_TH = ELEMENT_TAG_ID.TAGID_TH;
pub const TAGID_THEAD = ELEMENT_TAG_ID.TAGID_THEAD;
pub const TAGID_TITLE = ELEMENT_TAG_ID.TAGID_TITLE;
pub const TAGID_TR = ELEMENT_TAG_ID.TAGID_TR;
pub const TAGID_TT = ELEMENT_TAG_ID.TAGID_TT;
pub const TAGID_U = ELEMENT_TAG_ID.TAGID_U;
pub const TAGID_UL = ELEMENT_TAG_ID.TAGID_UL;
pub const TAGID_VAR = ELEMENT_TAG_ID.TAGID_VAR;
pub const TAGID_WBR = ELEMENT_TAG_ID.TAGID_WBR;
pub const TAGID_XMP = ELEMENT_TAG_ID.TAGID_XMP;
pub const TAGID_ROOT = ELEMENT_TAG_ID.TAGID_ROOT;
pub const TAGID_OPTGROUP = ELEMENT_TAG_ID.TAGID_OPTGROUP;
pub const TAGID_ABBR = ELEMENT_TAG_ID.TAGID_ABBR;
pub const TAGID_SVG_A = ELEMENT_TAG_ID.TAGID_SVG_A;
pub const TAGID_SVG_ALTGLYPH = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPH;
pub const TAGID_SVG_ALTGLYPHDEF = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPHDEF;
pub const TAGID_SVG_ALTGLYPHITEM = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPHITEM;
pub const TAGID_SVG_ANIMATE = ELEMENT_TAG_ID.TAGID_SVG_ANIMATE;
pub const TAGID_SVG_ANIMATECOLOR = ELEMENT_TAG_ID.TAGID_SVG_ANIMATECOLOR;
pub const TAGID_SVG_ANIMATEMOTION = ELEMENT_TAG_ID.TAGID_SVG_ANIMATEMOTION;
pub const TAGID_SVG_ANIMATETRANSFORM = ELEMENT_TAG_ID.TAGID_SVG_ANIMATETRANSFORM;
pub const TAGID_SVG_CIRCLE = ELEMENT_TAG_ID.TAGID_SVG_CIRCLE;
pub const TAGID_SVG_CLIPPATH = ELEMENT_TAG_ID.TAGID_SVG_CLIPPATH;
pub const TAGID_SVG_COLOR_PROFILE = ELEMENT_TAG_ID.TAGID_SVG_COLOR_PROFILE;
pub const TAGID_SVG_CURSOR = ELEMENT_TAG_ID.TAGID_SVG_CURSOR;
pub const TAGID_SVG_DEFINITION_SRC = ELEMENT_TAG_ID.TAGID_SVG_DEFINITION_SRC;
pub const TAGID_SVG_DEFS = ELEMENT_TAG_ID.TAGID_SVG_DEFS;
pub const TAGID_SVG_DESC = ELEMENT_TAG_ID.TAGID_SVG_DESC;
pub const TAGID_SVG_ELLIPSE = ELEMENT_TAG_ID.TAGID_SVG_ELLIPSE;
pub const TAGID_SVG_FEBLEND = ELEMENT_TAG_ID.TAGID_SVG_FEBLEND;
pub const TAGID_SVG_FECOLORMATRIX = ELEMENT_TAG_ID.TAGID_SVG_FECOLORMATRIX;
pub const TAGID_SVG_FECOMPONENTTRANSFER = ELEMENT_TAG_ID.TAGID_SVG_FECOMPONENTTRANSFER;
pub const TAGID_SVG_FECOMPOSITE = ELEMENT_TAG_ID.TAGID_SVG_FECOMPOSITE;
pub const TAGID_SVG_FECONVOLVEMATRIX = ELEMENT_TAG_ID.TAGID_SVG_FECONVOLVEMATRIX;
pub const TAGID_SVG_FEDIFFUSELIGHTING = ELEMENT_TAG_ID.TAGID_SVG_FEDIFFUSELIGHTING;
pub const TAGID_SVG_FEDISPLACEMENTMAP = ELEMENT_TAG_ID.TAGID_SVG_FEDISPLACEMENTMAP;
pub const TAGID_SVG_FEDISTANTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FEDISTANTLIGHT;
pub const TAGID_SVG_FEFLOOD = ELEMENT_TAG_ID.TAGID_SVG_FEFLOOD;
pub const TAGID_SVG_FEFUNCA = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCA;
pub const TAGID_SVG_FEFUNCB = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCB;
pub const TAGID_SVG_FEFUNCG = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCG;
pub const TAGID_SVG_FEFUNCR = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCR;
pub const TAGID_SVG_FEGAUSSIANBLUR = ELEMENT_TAG_ID.TAGID_SVG_FEGAUSSIANBLUR;
pub const TAGID_SVG_FEIMAGE = ELEMENT_TAG_ID.TAGID_SVG_FEIMAGE;
pub const TAGID_SVG_FEMERGE = ELEMENT_TAG_ID.TAGID_SVG_FEMERGE;
pub const TAGID_SVG_FEMERGENODE = ELEMENT_TAG_ID.TAGID_SVG_FEMERGENODE;
pub const TAGID_SVG_FEMORPHOLOGY = ELEMENT_TAG_ID.TAGID_SVG_FEMORPHOLOGY;
pub const TAGID_SVG_FEOFFSET = ELEMENT_TAG_ID.TAGID_SVG_FEOFFSET;
pub const TAGID_SVG_FEPOINTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FEPOINTLIGHT;
pub const TAGID_SVG_FESPECULARLIGHTING = ELEMENT_TAG_ID.TAGID_SVG_FESPECULARLIGHTING;
pub const TAGID_SVG_FESPOTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FESPOTLIGHT;
pub const TAGID_SVG_FETILE = ELEMENT_TAG_ID.TAGID_SVG_FETILE;
pub const TAGID_SVG_FETURBULENCE = ELEMENT_TAG_ID.TAGID_SVG_FETURBULENCE;
pub const TAGID_SVG_FILTER = ELEMENT_TAG_ID.TAGID_SVG_FILTER;
pub const TAGID_SVG_FONT = ELEMENT_TAG_ID.TAGID_SVG_FONT;
pub const TAGID_SVG_FONT_FACE = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE;
pub const TAGID_SVG_FONT_FACE_FORMAT = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_FORMAT;
pub const TAGID_SVG_FONT_FACE_NAME = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_NAME;
pub const TAGID_SVG_FONT_FACE_SRC = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_SRC;
pub const TAGID_SVG_FONT_FACE_URI = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_URI;
pub const TAGID_SVG_FOREIGNOBJECT = ELEMENT_TAG_ID.TAGID_SVG_FOREIGNOBJECT;
pub const TAGID_SVG_G = ELEMENT_TAG_ID.TAGID_SVG_G;
pub const TAGID_SVG_GLYPH = ELEMENT_TAG_ID.TAGID_SVG_GLYPH;
pub const TAGID_SVG_GLYPHREF = ELEMENT_TAG_ID.TAGID_SVG_GLYPHREF;
pub const TAGID_SVG_HKERN = ELEMENT_TAG_ID.TAGID_SVG_HKERN;
pub const TAGID_SVG_IMAGE = ELEMENT_TAG_ID.TAGID_SVG_IMAGE;
pub const TAGID_SVG_LINE = ELEMENT_TAG_ID.TAGID_SVG_LINE;
pub const TAGID_SVG_LINEARGRADIENT = ELEMENT_TAG_ID.TAGID_SVG_LINEARGRADIENT;
pub const TAGID_SVG_MARKER = ELEMENT_TAG_ID.TAGID_SVG_MARKER;
pub const TAGID_SVG_MASK = ELEMENT_TAG_ID.TAGID_SVG_MASK;
pub const TAGID_SVG_METADATA = ELEMENT_TAG_ID.TAGID_SVG_METADATA;
pub const TAGID_SVG_MISSING_GLYPH = ELEMENT_TAG_ID.TAGID_SVG_MISSING_GLYPH;
pub const TAGID_SVG_MPATH = ELEMENT_TAG_ID.TAGID_SVG_MPATH;
pub const TAGID_SVG_PATH = ELEMENT_TAG_ID.TAGID_SVG_PATH;
pub const TAGID_SVG_PATTERN = ELEMENT_TAG_ID.TAGID_SVG_PATTERN;
pub const TAGID_SVG_POLYGON = ELEMENT_TAG_ID.TAGID_SVG_POLYGON;
pub const TAGID_SVG_POLYLINE = ELEMENT_TAG_ID.TAGID_SVG_POLYLINE;
pub const TAGID_SVG_RADIALGRADIENT = ELEMENT_TAG_ID.TAGID_SVG_RADIALGRADIENT;
pub const TAGID_SVG_RECT = ELEMENT_TAG_ID.TAGID_SVG_RECT;
pub const TAGID_SVG_SCRIPT = ELEMENT_TAG_ID.TAGID_SVG_SCRIPT;
pub const TAGID_SVG_SET = ELEMENT_TAG_ID.TAGID_SVG_SET;
pub const TAGID_SVG_STOP = ELEMENT_TAG_ID.TAGID_SVG_STOP;
pub const TAGID_SVG_STYLE = ELEMENT_TAG_ID.TAGID_SVG_STYLE;
pub const TAGID_SVG_SVG = ELEMENT_TAG_ID.TAGID_SVG_SVG;
pub const TAGID_SVG_SWITCH = ELEMENT_TAG_ID.TAGID_SVG_SWITCH;
pub const TAGID_SVG_SYMBOL = ELEMENT_TAG_ID.TAGID_SVG_SYMBOL;
pub const TAGID_SVG_TEXT = ELEMENT_TAG_ID.TAGID_SVG_TEXT;
pub const TAGID_SVG_TEXTPATH = ELEMENT_TAG_ID.TAGID_SVG_TEXTPATH;
pub const TAGID_SVG_TITLE = ELEMENT_TAG_ID.TAGID_SVG_TITLE;
pub const TAGID_SVG_TREF = ELEMENT_TAG_ID.TAGID_SVG_TREF;
pub const TAGID_SVG_TSPAN = ELEMENT_TAG_ID.TAGID_SVG_TSPAN;
pub const TAGID_SVG_USE = ELEMENT_TAG_ID.TAGID_SVG_USE;
pub const TAGID_SVG_VIEW = ELEMENT_TAG_ID.TAGID_SVG_VIEW;
pub const TAGID_SVG_VKERN = ELEMENT_TAG_ID.TAGID_SVG_VKERN;
pub const TAGID_AUDIO = ELEMENT_TAG_ID.TAGID_AUDIO;
pub const TAGID_SOURCE = ELEMENT_TAG_ID.TAGID_SOURCE;
pub const TAGID_VIDEO = ELEMENT_TAG_ID.TAGID_VIDEO;
pub const TAGID_CANVAS = ELEMENT_TAG_ID.TAGID_CANVAS;
pub const TAGID_DOCTYPE = ELEMENT_TAG_ID.TAGID_DOCTYPE;
pub const TAGID_KEYGEN = ELEMENT_TAG_ID.TAGID_KEYGEN;
pub const TAGID_PROCESSINGINSTRUCTION = ELEMENT_TAG_ID.TAGID_PROCESSINGINSTRUCTION;
pub const TAGID_ARTICLE = ELEMENT_TAG_ID.TAGID_ARTICLE;
pub const TAGID_ASIDE = ELEMENT_TAG_ID.TAGID_ASIDE;
pub const TAGID_FIGCAPTION = ELEMENT_TAG_ID.TAGID_FIGCAPTION;
pub const TAGID_FIGURE = ELEMENT_TAG_ID.TAGID_FIGURE;
pub const TAGID_FOOTER = ELEMENT_TAG_ID.TAGID_FOOTER;
pub const TAGID_HEADER = ELEMENT_TAG_ID.TAGID_HEADER;
pub const TAGID_HGROUP = ELEMENT_TAG_ID.TAGID_HGROUP;
pub const TAGID_MARK = ELEMENT_TAG_ID.TAGID_MARK;
pub const TAGID_NAV = ELEMENT_TAG_ID.TAGID_NAV;
pub const TAGID_SECTION = ELEMENT_TAG_ID.TAGID_SECTION;
pub const TAGID_PROGRESS = ELEMENT_TAG_ID.TAGID_PROGRESS;
pub const TAGID_MATHML_ANNOTATION_XML = ELEMENT_TAG_ID.TAGID_MATHML_ANNOTATION_XML;
pub const TAGID_MATHML_MATH = ELEMENT_TAG_ID.TAGID_MATHML_MATH;
pub const TAGID_MATHML_MI = ELEMENT_TAG_ID.TAGID_MATHML_MI;
pub const TAGID_MATHML_MN = ELEMENT_TAG_ID.TAGID_MATHML_MN;
pub const TAGID_MATHML_MO = ELEMENT_TAG_ID.TAGID_MATHML_MO;
pub const TAGID_MATHML_MS = ELEMENT_TAG_ID.TAGID_MATHML_MS;
pub const TAGID_MATHML_MTEXT = ELEMENT_TAG_ID.TAGID_MATHML_MTEXT;
pub const TAGID_DATALIST = ELEMENT_TAG_ID.TAGID_DATALIST;
pub const TAGID_TRACK = ELEMENT_TAG_ID.TAGID_TRACK;
pub const TAGID_ISINDEX = ELEMENT_TAG_ID.TAGID_ISINDEX;
pub const TAGID_COMMAND = ELEMENT_TAG_ID.TAGID_COMMAND;
pub const TAGID_DETAILS = ELEMENT_TAG_ID.TAGID_DETAILS;
pub const TAGID_SUMMARY = ELEMENT_TAG_ID.TAGID_SUMMARY;
pub const TAGID_X_MS_WEBVIEW = ELEMENT_TAG_ID.TAGID_X_MS_WEBVIEW;
pub const TAGID_COUNT = ELEMENT_TAG_ID.TAGID_COUNT;
pub const TAGID_LAST_PREDEFINED = ELEMENT_TAG_ID.TAGID_LAST_PREDEFINED;
pub const ELEMENT_TAG_ID_Max = ELEMENT_TAG_ID.ELEMENT_TAG_ID_Max;

pub const SELECTION_TYPE = enum(i32) {
    None = 0,
    Caret = 1,
    Text = 2,
    Control = 3,
    Max = 2147483647,
};
pub const SELECTION_TYPE_None = SELECTION_TYPE.None;
pub const SELECTION_TYPE_Caret = SELECTION_TYPE.Caret;
pub const SELECTION_TYPE_Text = SELECTION_TYPE.Text;
pub const SELECTION_TYPE_Control = SELECTION_TYPE.Control;
pub const SELECTION_TYPE_Max = SELECTION_TYPE.Max;

pub const SAVE_SEGMENTS_FLAGS = enum(i32) {
    NoIE4SelectionCompat = 1,
    FLAGS_Max = 2147483647,
};
pub const SAVE_SEGMENTS_NoIE4SelectionCompat = SAVE_SEGMENTS_FLAGS.NoIE4SelectionCompat;
pub const SAVE_SEGMENTS_FLAGS_Max = SAVE_SEGMENTS_FLAGS.FLAGS_Max;

pub const CARET_DIRECTION = enum(i32) {
    INDETERMINATE = 0,
    SAME = 1,
    BACKWARD = 2,
    FORWARD = 3,
    Max = 2147483647,
};
pub const CARET_DIRECTION_INDETERMINATE = CARET_DIRECTION.INDETERMINATE;
pub const CARET_DIRECTION_SAME = CARET_DIRECTION.SAME;
pub const CARET_DIRECTION_BACKWARD = CARET_DIRECTION.BACKWARD;
pub const CARET_DIRECTION_FORWARD = CARET_DIRECTION.FORWARD;
pub const CARET_DIRECTION_Max = CARET_DIRECTION.Max;

pub const LINE_DIRECTION = enum(i32) {
    RightToLeft = 1,
    LeftToRight = 2,
    Max = 2147483647,
};
pub const LINE_DIRECTION_RightToLeft = LINE_DIRECTION.RightToLeft;
pub const LINE_DIRECTION_LeftToRight = LINE_DIRECTION.LeftToRight;
pub const LINE_DIRECTION_Max = LINE_DIRECTION.Max;

pub const HT_OPTIONS = enum(i32) {
    _AllowAfterEOL = 1,
    IONS_Max = 2147483647,
};
pub const HT_OPT_AllowAfterEOL = HT_OPTIONS._AllowAfterEOL;
pub const HT_OPTIONS_Max = HT_OPTIONS.IONS_Max;

pub const HT_RESULTS = enum(i32) {
    Glyph = 1,
    Max = 2147483647,
};
pub const HT_RESULTS_Glyph = HT_RESULTS.Glyph;
pub const HT_RESULTS_Max = HT_RESULTS.Max;

pub const DISPLAY_MOVEUNIT = enum(i32) {
    PreviousLine = 1,
    NextLine = 2,
    CurrentLineStart = 3,
    CurrentLineEnd = 4,
    TopOfWindow = 5,
    BottomOfWindow = 6,
    Max = 2147483647,
};
pub const DISPLAY_MOVEUNIT_PreviousLine = DISPLAY_MOVEUNIT.PreviousLine;
pub const DISPLAY_MOVEUNIT_NextLine = DISPLAY_MOVEUNIT.NextLine;
pub const DISPLAY_MOVEUNIT_CurrentLineStart = DISPLAY_MOVEUNIT.CurrentLineStart;
pub const DISPLAY_MOVEUNIT_CurrentLineEnd = DISPLAY_MOVEUNIT.CurrentLineEnd;
pub const DISPLAY_MOVEUNIT_TopOfWindow = DISPLAY_MOVEUNIT.TopOfWindow;
pub const DISPLAY_MOVEUNIT_BottomOfWindow = DISPLAY_MOVEUNIT.BottomOfWindow;
pub const DISPLAY_MOVEUNIT_Max = DISPLAY_MOVEUNIT.Max;

pub const DISPLAY_GRAVITY = enum(i32) {
    PreviousLine = 1,
    NextLine = 2,
    Max = 2147483647,
};
pub const DISPLAY_GRAVITY_PreviousLine = DISPLAY_GRAVITY.PreviousLine;
pub const DISPLAY_GRAVITY_NextLine = DISPLAY_GRAVITY.NextLine;
pub const DISPLAY_GRAVITY_Max = DISPLAY_GRAVITY.Max;

pub const DISPLAY_BREAK = enum(i32) {
    None = 0,
    Block = 1,
    Break = 2,
    Max = 2147483647,
};
pub const DISPLAY_BREAK_None = DISPLAY_BREAK.None;
pub const DISPLAY_BREAK_Block = DISPLAY_BREAK.Block;
pub const DISPLAY_BREAK_Break = DISPLAY_BREAK.Break;
pub const DISPLAY_BREAK_Max = DISPLAY_BREAK.Max;

pub const COORD_SYSTEM = enum(i32) {
    GLOBAL = 0,
    PARENT = 1,
    CONTAINER = 2,
    CONTENT = 3,
    FRAME = 4,
    CLIENT = 5,
    Max = 2147483647,
};
pub const COORD_SYSTEM_GLOBAL = COORD_SYSTEM.GLOBAL;
pub const COORD_SYSTEM_PARENT = COORD_SYSTEM.PARENT;
pub const COORD_SYSTEM_CONTAINER = COORD_SYSTEM.CONTAINER;
pub const COORD_SYSTEM_CONTENT = COORD_SYSTEM.CONTENT;
pub const COORD_SYSTEM_FRAME = COORD_SYSTEM.FRAME;
pub const COORD_SYSTEM_CLIENT = COORD_SYSTEM.CLIENT;
pub const COORD_SYSTEM_Max = COORD_SYSTEM.Max;

pub const DEV_CONSOLE_MESSAGE_LEVEL = enum(i32) {
    CML_INFORMATIONAL = 0,
    CML_WARNING = 1,
    CML_ERROR = 2,
    EV_CONSOLE_MESSAGE_LEVEL_Max = 2147483647,
};
pub const DCML_INFORMATIONAL = DEV_CONSOLE_MESSAGE_LEVEL.CML_INFORMATIONAL;
pub const DCML_WARNING = DEV_CONSOLE_MESSAGE_LEVEL.CML_WARNING;
pub const DCML_ERROR = DEV_CONSOLE_MESSAGE_LEVEL.CML_ERROR;
pub const DEV_CONSOLE_MESSAGE_LEVEL_Max = DEV_CONSOLE_MESSAGE_LEVEL.EV_CONSOLE_MESSAGE_LEVEL_Max;

pub const DOM_EVENT_PHASE = enum(i32) {
    EP_CAPTURING_PHASE = 1,
    EP_AT_TARGET = 2,
    EP_BUBBLING_PHASE = 3,
    OM_EVENT_PHASE_Max = 2147483647,
};
pub const DEP_CAPTURING_PHASE = DOM_EVENT_PHASE.EP_CAPTURING_PHASE;
pub const DEP_AT_TARGET = DOM_EVENT_PHASE.EP_AT_TARGET;
pub const DEP_BUBBLING_PHASE = DOM_EVENT_PHASE.EP_BUBBLING_PHASE;
pub const DOM_EVENT_PHASE_Max = DOM_EVENT_PHASE.OM_EVENT_PHASE_Max;

pub const SCRIPT_TIMER_TYPE = enum(i32) {
    TT_TIMEOUT = 0,
    TT_INTERVAL = 1,
    TT_IMMEDIATE = 2,
    TT_ANIMATION_FRAME = 3,
    CRIPT_TIMER_TYPE_Max = 2147483647,
};
pub const STT_TIMEOUT = SCRIPT_TIMER_TYPE.TT_TIMEOUT;
pub const STT_INTERVAL = SCRIPT_TIMER_TYPE.TT_INTERVAL;
pub const STT_IMMEDIATE = SCRIPT_TIMER_TYPE.TT_IMMEDIATE;
pub const STT_ANIMATION_FRAME = SCRIPT_TIMER_TYPE.TT_ANIMATION_FRAME;
pub const SCRIPT_TIMER_TYPE_Max = SCRIPT_TIMER_TYPE.CRIPT_TIMER_TYPE_Max;

pub const HTML_PAINTER = enum(i32) {
    PAINTER_OPAQUE = 1,
    PAINTER_TRANSPARENT = 2,
    PAINTER_ALPHA = 4,
    PAINTER_COMPLEX = 8,
    PAINTER_OVERLAY = 16,
    PAINTER_HITTEST = 32,
    PAINTER_SURFACE = 256,
    PAINTER_3DSURFACE = 512,
    PAINTER_NOBAND = 1024,
    PAINTER_NODC = 4096,
    PAINTER_NOPHYSICALCLIP = 8192,
    PAINTER_NOSAVEDC = 16384,
    PAINTER_SUPPORTS_XFORM = 32768,
    PAINTER_EXPAND = 65536,
    PAINTER_NOSCROLLBITS = 131072,
    _PAINTER_Max = 2147483647,
};
pub const HTMLPAINTER_OPAQUE = HTML_PAINTER.PAINTER_OPAQUE;
pub const HTMLPAINTER_TRANSPARENT = HTML_PAINTER.PAINTER_TRANSPARENT;
pub const HTMLPAINTER_ALPHA = HTML_PAINTER.PAINTER_ALPHA;
pub const HTMLPAINTER_COMPLEX = HTML_PAINTER.PAINTER_COMPLEX;
pub const HTMLPAINTER_OVERLAY = HTML_PAINTER.PAINTER_OVERLAY;
pub const HTMLPAINTER_HITTEST = HTML_PAINTER.PAINTER_HITTEST;
pub const HTMLPAINTER_SURFACE = HTML_PAINTER.PAINTER_SURFACE;
pub const HTMLPAINTER_3DSURFACE = HTML_PAINTER.PAINTER_3DSURFACE;
pub const HTMLPAINTER_NOBAND = HTML_PAINTER.PAINTER_NOBAND;
pub const HTMLPAINTER_NODC = HTML_PAINTER.PAINTER_NODC;
pub const HTMLPAINTER_NOPHYSICALCLIP = HTML_PAINTER.PAINTER_NOPHYSICALCLIP;
pub const HTMLPAINTER_NOSAVEDC = HTML_PAINTER.PAINTER_NOSAVEDC;
pub const HTMLPAINTER_SUPPORTS_XFORM = HTML_PAINTER.PAINTER_SUPPORTS_XFORM;
pub const HTMLPAINTER_EXPAND = HTML_PAINTER.PAINTER_EXPAND;
pub const HTMLPAINTER_NOSCROLLBITS = HTML_PAINTER.PAINTER_NOSCROLLBITS;
pub const HTML_PAINTER_Max = HTML_PAINTER._PAINTER_Max;

pub const HTML_PAINT_ZORDER = enum(i32) {
    PAINT_ZORDER_NONE = 0,
    PAINT_ZORDER_REPLACE_ALL = 1,
    PAINT_ZORDER_REPLACE_CONTENT = 2,
    PAINT_ZORDER_REPLACE_BACKGROUND = 3,
    PAINT_ZORDER_BELOW_CONTENT = 4,
    PAINT_ZORDER_BELOW_FLOW = 5,
    PAINT_ZORDER_ABOVE_FLOW = 6,
    PAINT_ZORDER_ABOVE_CONTENT = 7,
    PAINT_ZORDER_WINDOW_TOP = 8,
    _PAINT_ZORDER_Max = 2147483647,
};
pub const HTMLPAINT_ZORDER_NONE = HTML_PAINT_ZORDER.PAINT_ZORDER_NONE;
pub const HTMLPAINT_ZORDER_REPLACE_ALL = HTML_PAINT_ZORDER.PAINT_ZORDER_REPLACE_ALL;
pub const HTMLPAINT_ZORDER_REPLACE_CONTENT = HTML_PAINT_ZORDER.PAINT_ZORDER_REPLACE_CONTENT;
pub const HTMLPAINT_ZORDER_REPLACE_BACKGROUND = HTML_PAINT_ZORDER.PAINT_ZORDER_REPLACE_BACKGROUND;
pub const HTMLPAINT_ZORDER_BELOW_CONTENT = HTML_PAINT_ZORDER.PAINT_ZORDER_BELOW_CONTENT;
pub const HTMLPAINT_ZORDER_BELOW_FLOW = HTML_PAINT_ZORDER.PAINT_ZORDER_BELOW_FLOW;
pub const HTMLPAINT_ZORDER_ABOVE_FLOW = HTML_PAINT_ZORDER.PAINT_ZORDER_ABOVE_FLOW;
pub const HTMLPAINT_ZORDER_ABOVE_CONTENT = HTML_PAINT_ZORDER.PAINT_ZORDER_ABOVE_CONTENT;
pub const HTMLPAINT_ZORDER_WINDOW_TOP = HTML_PAINT_ZORDER.PAINT_ZORDER_WINDOW_TOP;
pub const HTML_PAINT_ZORDER_Max = HTML_PAINT_ZORDER._PAINT_ZORDER_Max;

pub const HTML_PAINT_DRAW_FLAGS = enum(i32) {
    PAINT_DRAW_UPDATEREGION = 1,
    PAINT_DRAW_USE_XFORM = 2,
    _PAINT_DRAW_FLAGS_Max = 2147483647,
};
pub const HTMLPAINT_DRAW_UPDATEREGION = HTML_PAINT_DRAW_FLAGS.PAINT_DRAW_UPDATEREGION;
pub const HTMLPAINT_DRAW_USE_XFORM = HTML_PAINT_DRAW_FLAGS.PAINT_DRAW_USE_XFORM;
pub const HTML_PAINT_DRAW_FLAGS_Max = HTML_PAINT_DRAW_FLAGS._PAINT_DRAW_FLAGS_Max;

pub const HTML_PAINT_EVENT_FLAGS = enum(i32) {
    PAINT_EVENT_TARGET = 1,
    PAINT_EVENT_SETCURSOR = 2,
    _PAINT_EVENT_FLAGS_Max = 2147483647,
};
pub const HTMLPAINT_EVENT_TARGET = HTML_PAINT_EVENT_FLAGS.PAINT_EVENT_TARGET;
pub const HTMLPAINT_EVENT_SETCURSOR = HTML_PAINT_EVENT_FLAGS.PAINT_EVENT_SETCURSOR;
pub const HTML_PAINT_EVENT_FLAGS_Max = HTML_PAINT_EVENT_FLAGS._PAINT_EVENT_FLAGS_Max;

pub const HTML_PAINT_DRAW_INFO_FLAGS = enum(i32) {
    PAINT_DRAWINFO_VIEWPORT = 1,
    PAINT_DRAWINFO_UPDATEREGION = 2,
    PAINT_DRAWINFO_XFORM = 4,
    _PAINT_DRAW_INFO_FLAGS_Max = 2147483647,
};
pub const HTMLPAINT_DRAWINFO_VIEWPORT = HTML_PAINT_DRAW_INFO_FLAGS.PAINT_DRAWINFO_VIEWPORT;
pub const HTMLPAINT_DRAWINFO_UPDATEREGION = HTML_PAINT_DRAW_INFO_FLAGS.PAINT_DRAWINFO_UPDATEREGION;
pub const HTMLPAINT_DRAWINFO_XFORM = HTML_PAINT_DRAW_INFO_FLAGS.PAINT_DRAWINFO_XFORM;
pub const HTML_PAINT_DRAW_INFO_FLAGS_Max = HTML_PAINT_DRAW_INFO_FLAGS._PAINT_DRAW_INFO_FLAGS_Max;

pub const HTML_PAINTER_INFO = extern struct {
    lFlags: i32,
    lZOrder: i32,
    iidDrawObject: Guid,
    rcExpand: RECT,
};

pub const HTML_PAINT_XFORM = extern struct {
    eM11: f32,
    eM12: f32,
    eM21: f32,
    eM22: f32,
    eDx: f32,
    eDy: f32,
};

pub const HTML_PAINT_DRAW_INFO = extern struct {
    rcViewport: RECT,
    hrgnUpdate: ?HRGN,
    xform: HTML_PAINT_XFORM,
};

pub const HTMLDlgFlag = enum(i32) {
    No = 0,
    // Off = 0, this enum value conflicts with No
    // @"0" = 0, this enum value conflicts with No
    Yes = 1,
    // On = 1, this enum value conflicts with Yes
    // @"1" = 1, this enum value conflicts with Yes
    NotSet = -1,
    _Max = 2147483647,
};
pub const HTMLDlgFlagNo = HTMLDlgFlag.No;
pub const HTMLDlgFlagOff = HTMLDlgFlag.No;
pub const HTMLDlgFlag0 = HTMLDlgFlag.No;
pub const HTMLDlgFlagYes = HTMLDlgFlag.Yes;
pub const HTMLDlgFlagOn = HTMLDlgFlag.Yes;
pub const HTMLDlgFlag1 = HTMLDlgFlag.Yes;
pub const HTMLDlgFlagNotSet = HTMLDlgFlag.NotSet;
pub const HTMLDlgFlag_Max = HTMLDlgFlag._Max;

pub const HTMLDlgBorder = enum(i32) {
    Thin = 0,
    Thick = 262144,
    _Max = 2147483647,
};
pub const HTMLDlgBorderThin = HTMLDlgBorder.Thin;
pub const HTMLDlgBorderThick = HTMLDlgBorder.Thick;
pub const HTMLDlgBorder_Max = HTMLDlgBorder._Max;

pub const HTMLDlgEdge = enum(i32) {
    Sunken = 0,
    Raised = 16,
    _Max = 2147483647,
};
pub const HTMLDlgEdgeSunken = HTMLDlgEdge.Sunken;
pub const HTMLDlgEdgeRaised = HTMLDlgEdge.Raised;
pub const HTMLDlgEdge_Max = HTMLDlgEdge._Max;

pub const HTMLDlgCenter = enum(i32) {
    No = 0,
    // Off = 0, this enum value conflicts with No
    // @"0" = 0, this enum value conflicts with No
    Yes = 1,
    // On = 1, this enum value conflicts with Yes
    // @"1" = 1, this enum value conflicts with Yes
    // Parent = 1, this enum value conflicts with Yes
    Desktop = 2,
    _Max = 2147483647,
};
pub const HTMLDlgCenterNo = HTMLDlgCenter.No;
pub const HTMLDlgCenterOff = HTMLDlgCenter.No;
pub const HTMLDlgCenter0 = HTMLDlgCenter.No;
pub const HTMLDlgCenterYes = HTMLDlgCenter.Yes;
pub const HTMLDlgCenterOn = HTMLDlgCenter.Yes;
pub const HTMLDlgCenter1 = HTMLDlgCenter.Yes;
pub const HTMLDlgCenterParent = HTMLDlgCenter.Yes;
pub const HTMLDlgCenterDesktop = HTMLDlgCenter.Desktop;
pub const HTMLDlgCenter_Max = HTMLDlgCenter._Max;

pub const HTMLAppFlag = enum(i32) {
    No = 0,
    // Off = 0, this enum value conflicts with No
    // @"0" = 0, this enum value conflicts with No
    Yes = 1,
    // On = 1, this enum value conflicts with Yes
    // @"1" = 1, this enum value conflicts with Yes
    _Max = 2147483647,
};
pub const HTMLAppFlagNo = HTMLAppFlag.No;
pub const HTMLAppFlagOff = HTMLAppFlag.No;
pub const HTMLAppFlag0 = HTMLAppFlag.No;
pub const HTMLAppFlagYes = HTMLAppFlag.Yes;
pub const HTMLAppFlagOn = HTMLAppFlag.Yes;
pub const HTMLAppFlag1 = HTMLAppFlag.Yes;
pub const HTMLAppFlag_Max = HTMLAppFlag._Max;

pub const HTMLMinimizeFlag = enum(i32) {
    No = 0,
    Yes = 131072,
    _Max = 2147483647,
};
pub const HTMLMinimizeFlagNo = HTMLMinimizeFlag.No;
pub const HTMLMinimizeFlagYes = HTMLMinimizeFlag.Yes;
pub const HTMLMinimizeFlag_Max = HTMLMinimizeFlag._Max;

pub const HTMLMaximizeFlag = enum(i32) {
    No = 0,
    Yes = 65536,
    _Max = 2147483647,
};
pub const HTMLMaximizeFlagNo = HTMLMaximizeFlag.No;
pub const HTMLMaximizeFlagYes = HTMLMaximizeFlag.Yes;
pub const HTMLMaximizeFlag_Max = HTMLMaximizeFlag._Max;

pub const HTMLCaptionFlag = enum(i32) {
    No = 0,
    Yes = 12582912,
    _Max = 2147483647,
};
pub const HTMLCaptionFlagNo = HTMLCaptionFlag.No;
pub const HTMLCaptionFlagYes = HTMLCaptionFlag.Yes;
pub const HTMLCaptionFlag_Max = HTMLCaptionFlag._Max;

pub const HTMLSysMenuFlag = enum(i32) {
    No = 0,
    Yes = 524288,
    _Max = 2147483647,
};
pub const HTMLSysMenuFlagNo = HTMLSysMenuFlag.No;
pub const HTMLSysMenuFlagYes = HTMLSysMenuFlag.Yes;
pub const HTMLSysMenuFlag_Max = HTMLSysMenuFlag._Max;

pub const HTMLBorder = enum(i32) {
    None = 0,
    Thick = 262144,
    Dialog = 4194304,
    Thin = 8388608,
    _Max = 2147483647,
};
pub const HTMLBorderNone = HTMLBorder.None;
pub const HTMLBorderThick = HTMLBorder.Thick;
pub const HTMLBorderDialog = HTMLBorder.Dialog;
pub const HTMLBorderThin = HTMLBorder.Thin;
pub const HTMLBorder_Max = HTMLBorder._Max;

pub const HTMLBorderStyle = enum(i32) {
    Normal = 0,
    Raised = 256,
    Sunken = 512,
    combined = 768,
    Static = 131072,
    _Max = 2147483647,
};
pub const HTMLBorderStyleNormal = HTMLBorderStyle.Normal;
pub const HTMLBorderStyleRaised = HTMLBorderStyle.Raised;
pub const HTMLBorderStyleSunken = HTMLBorderStyle.Sunken;
pub const HTMLBorderStylecombined = HTMLBorderStyle.combined;
pub const HTMLBorderStyleStatic = HTMLBorderStyle.Static;
pub const HTMLBorderStyle_Max = HTMLBorderStyle._Max;

pub const HTMLWindowState = enum(i32) {
    Normal = 1,
    Maximize = 3,
    Minimize = 6,
    _Max = 2147483647,
};
pub const HTMLWindowStateNormal = HTMLWindowState.Normal;
pub const HTMLWindowStateMaximize = HTMLWindowState.Maximize;
pub const HTMLWindowStateMinimize = HTMLWindowState.Minimize;
pub const HTMLWindowState_Max = HTMLWindowState._Max;

pub const BEHAVIOR_EVENT = enum(i32) {
    EVENT_FIRST = 0,
    // EVENT_CONTENTREADY = 0, this enum value conflicts with EVENT_FIRST
    EVENT_DOCUMENTREADY = 1,
    EVENT_APPLYSTYLE = 2,
    EVENT_DOCUMENTCONTEXTCHANGE = 3,
    EVENT_CONTENTSAVE = 4,
    // EVENT_LAST = 4, this enum value conflicts with EVENT_CONTENTSAVE
    _EVENT_Max = 2147483647,
};
pub const BEHAVIOREVENT_FIRST = BEHAVIOR_EVENT.EVENT_FIRST;
pub const BEHAVIOREVENT_CONTENTREADY = BEHAVIOR_EVENT.EVENT_FIRST;
pub const BEHAVIOREVENT_DOCUMENTREADY = BEHAVIOR_EVENT.EVENT_DOCUMENTREADY;
pub const BEHAVIOREVENT_APPLYSTYLE = BEHAVIOR_EVENT.EVENT_APPLYSTYLE;
pub const BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE = BEHAVIOR_EVENT.EVENT_DOCUMENTCONTEXTCHANGE;
pub const BEHAVIOREVENT_CONTENTSAVE = BEHAVIOR_EVENT.EVENT_CONTENTSAVE;
pub const BEHAVIOREVENT_LAST = BEHAVIOR_EVENT.EVENT_CONTENTSAVE;
pub const BEHAVIOR_EVENT_Max = BEHAVIOR_EVENT._EVENT_Max;

pub const BEHAVIOR_EVENT_FLAGS = enum(i32) {
    EVENTFLAGS_BUBBLE = 1,
    EVENTFLAGS_STANDARDADDITIVE = 2,
    _EVENT_FLAGS_Max = 2147483647,
};
pub const BEHAVIOREVENTFLAGS_BUBBLE = BEHAVIOR_EVENT_FLAGS.EVENTFLAGS_BUBBLE;
pub const BEHAVIOREVENTFLAGS_STANDARDADDITIVE = BEHAVIOR_EVENT_FLAGS.EVENTFLAGS_STANDARDADDITIVE;
pub const BEHAVIOR_EVENT_FLAGS_Max = BEHAVIOR_EVENT_FLAGS._EVENT_FLAGS_Max;

pub const BEHAVIOR_RENDER_INFO = enum(i32) {
    RENDERINFO_BEFOREBACKGROUND = 1,
    RENDERINFO_AFTERBACKGROUND = 2,
    RENDERINFO_BEFORECONTENT = 4,
    RENDERINFO_AFTERCONTENT = 8,
    RENDERINFO_AFTERFOREGROUND = 32,
    RENDERINFO_ABOVECONTENT = 40,
    RENDERINFO_ALLLAYERS = 255,
    RENDERINFO_DISABLEBACKGROUND = 256,
    RENDERINFO_DISABLENEGATIVEZ = 512,
    RENDERINFO_DISABLECONTENT = 1024,
    RENDERINFO_DISABLEPOSITIVEZ = 2048,
    RENDERINFO_DISABLEALLLAYERS = 3840,
    RENDERINFO_HITTESTING = 4096,
    RENDERINFO_SURFACE = 1048576,
    RENDERINFO_3DSURFACE = 2097152,
    _RENDER_INFO_Max = 2147483647,
};
pub const BEHAVIORRENDERINFO_BEFOREBACKGROUND = BEHAVIOR_RENDER_INFO.RENDERINFO_BEFOREBACKGROUND;
pub const BEHAVIORRENDERINFO_AFTERBACKGROUND = BEHAVIOR_RENDER_INFO.RENDERINFO_AFTERBACKGROUND;
pub const BEHAVIORRENDERINFO_BEFORECONTENT = BEHAVIOR_RENDER_INFO.RENDERINFO_BEFORECONTENT;
pub const BEHAVIORRENDERINFO_AFTERCONTENT = BEHAVIOR_RENDER_INFO.RENDERINFO_AFTERCONTENT;
pub const BEHAVIORRENDERINFO_AFTERFOREGROUND = BEHAVIOR_RENDER_INFO.RENDERINFO_AFTERFOREGROUND;
pub const BEHAVIORRENDERINFO_ABOVECONTENT = BEHAVIOR_RENDER_INFO.RENDERINFO_ABOVECONTENT;
pub const BEHAVIORRENDERINFO_ALLLAYERS = BEHAVIOR_RENDER_INFO.RENDERINFO_ALLLAYERS;
pub const BEHAVIORRENDERINFO_DISABLEBACKGROUND = BEHAVIOR_RENDER_INFO.RENDERINFO_DISABLEBACKGROUND;
pub const BEHAVIORRENDERINFO_DISABLENEGATIVEZ = BEHAVIOR_RENDER_INFO.RENDERINFO_DISABLENEGATIVEZ;
pub const BEHAVIORRENDERINFO_DISABLECONTENT = BEHAVIOR_RENDER_INFO.RENDERINFO_DISABLECONTENT;
pub const BEHAVIORRENDERINFO_DISABLEPOSITIVEZ = BEHAVIOR_RENDER_INFO.RENDERINFO_DISABLEPOSITIVEZ;
pub const BEHAVIORRENDERINFO_DISABLEALLLAYERS = BEHAVIOR_RENDER_INFO.RENDERINFO_DISABLEALLLAYERS;
pub const BEHAVIORRENDERINFO_HITTESTING = BEHAVIOR_RENDER_INFO.RENDERINFO_HITTESTING;
pub const BEHAVIORRENDERINFO_SURFACE = BEHAVIOR_RENDER_INFO.RENDERINFO_SURFACE;
pub const BEHAVIORRENDERINFO_3DSURFACE = BEHAVIOR_RENDER_INFO.RENDERINFO_3DSURFACE;
pub const BEHAVIOR_RENDER_INFO_Max = BEHAVIOR_RENDER_INFO._RENDER_INFO_Max;

pub const BEHAVIOR_RELATION = enum(i32) {
    FIRSTRELATION = 0,
    // SAMEELEMENT = 0, this enum value conflicts with FIRSTRELATION
    PARENT = 1,
    CHILD = 2,
    SIBLING = 3,
    // LASTRELATION = 3, this enum value conflicts with SIBLING
    RELATION_Max = 2147483647,
};
pub const BEHAVIOR_FIRSTRELATION = BEHAVIOR_RELATION.FIRSTRELATION;
pub const BEHAVIOR_SAMEELEMENT = BEHAVIOR_RELATION.FIRSTRELATION;
pub const BEHAVIOR_PARENT = BEHAVIOR_RELATION.PARENT;
pub const BEHAVIOR_CHILD = BEHAVIOR_RELATION.CHILD;
pub const BEHAVIOR_SIBLING = BEHAVIOR_RELATION.SIBLING;
pub const BEHAVIOR_LASTRELATION = BEHAVIOR_RELATION.SIBLING;
pub const BEHAVIOR_RELATION_Max = BEHAVIOR_RELATION.RELATION_Max;

pub const BEHAVIOR_LAYOUT_INFO = enum(i32) {
    LAYOUTINFO_FULLDELEGATION = 1,
    LAYOUTINFO_MODIFYNATURAL = 2,
    LAYOUTINFO_MAPSIZE = 4,
    _LAYOUT_INFO_Max = 2147483647,
};
pub const BEHAVIORLAYOUTINFO_FULLDELEGATION = BEHAVIOR_LAYOUT_INFO.LAYOUTINFO_FULLDELEGATION;
pub const BEHAVIORLAYOUTINFO_MODIFYNATURAL = BEHAVIOR_LAYOUT_INFO.LAYOUTINFO_MODIFYNATURAL;
pub const BEHAVIORLAYOUTINFO_MAPSIZE = BEHAVIOR_LAYOUT_INFO.LAYOUTINFO_MAPSIZE;
pub const BEHAVIOR_LAYOUT_INFO_Max = BEHAVIOR_LAYOUT_INFO._LAYOUT_INFO_Max;

pub const BEHAVIOR_LAYOUT_MODE = enum(i32) {
    LAYOUTMODE_NATURAL = 1,
    LAYOUTMODE_MINWIDTH = 2,
    LAYOUTMODE_MAXWIDTH = 4,
    LAYOUTMODE_MEDIA_RESOLUTION = 16384,
    LAYOUTMODE_FINAL_PERCENT = 32768,
    _LAYOUT_MODE_Max = 2147483647,
};
pub const BEHAVIORLAYOUTMODE_NATURAL = BEHAVIOR_LAYOUT_MODE.LAYOUTMODE_NATURAL;
pub const BEHAVIORLAYOUTMODE_MINWIDTH = BEHAVIOR_LAYOUT_MODE.LAYOUTMODE_MINWIDTH;
pub const BEHAVIORLAYOUTMODE_MAXWIDTH = BEHAVIOR_LAYOUT_MODE.LAYOUTMODE_MAXWIDTH;
pub const BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION = BEHAVIOR_LAYOUT_MODE.LAYOUTMODE_MEDIA_RESOLUTION;
pub const BEHAVIORLAYOUTMODE_FINAL_PERCENT = BEHAVIOR_LAYOUT_MODE.LAYOUTMODE_FINAL_PERCENT;
pub const BEHAVIOR_LAYOUT_MODE_Max = BEHAVIOR_LAYOUT_MODE._LAYOUT_MODE_Max;

pub const ELEMENTDESCRIPTOR_FLAGS = enum(i32) {
    FLAGS_LITERAL = 1,
    FLAGS_NESTED_LITERAL = 2,
    _FLAGS_Max = 2147483647,
};
pub const ELEMENTDESCRIPTORFLAGS_LITERAL = ELEMENTDESCRIPTOR_FLAGS.FLAGS_LITERAL;
pub const ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL = ELEMENTDESCRIPTOR_FLAGS.FLAGS_NESTED_LITERAL;
pub const ELEMENTDESCRIPTOR_FLAGS_Max = ELEMENTDESCRIPTOR_FLAGS._FLAGS_Max;

pub const ELEMENTNAMESPACE_FLAGS = enum(i32) {
    FLAGS_ALLOWANYTAG = 1,
    FLAGS_QUERYFORUNKNOWNTAGS = 2,
    _FLAGS_Max = 2147483647,
};
pub const ELEMENTNAMESPACEFLAGS_ALLOWANYTAG = ELEMENTNAMESPACE_FLAGS.FLAGS_ALLOWANYTAG;
pub const ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS = ELEMENTNAMESPACE_FLAGS.FLAGS_QUERYFORUNKNOWNTAGS;
pub const ELEMENTNAMESPACE_FLAGS_Max = ELEMENTNAMESPACE_FLAGS._FLAGS_Max;

pub const VIEW_OBJECT_ALPHA_MODE = enum(i32) {
    IGNORE = 0,
    PREMULTIPLIED = 1,
    Max = 2147483647,
};
pub const VIEW_OBJECT_ALPHA_MODE_IGNORE = VIEW_OBJECT_ALPHA_MODE.IGNORE;
pub const VIEW_OBJECT_ALPHA_MODE_PREMULTIPLIED = VIEW_OBJECT_ALPHA_MODE.PREMULTIPLIED;
pub const VIEW_OBJECT_ALPHA_MODE_Max = VIEW_OBJECT_ALPHA_MODE.Max;

pub const VIEW_OBJECT_COMPOSITION_MODE = enum(i32) {
    LEGACY = 0,
    SURFACEPRESENTER = 1,
    Max = 2147483647,
};
pub const VIEW_OBJECT_COMPOSITION_MODE_LEGACY = VIEW_OBJECT_COMPOSITION_MODE.LEGACY;
pub const VIEW_OBJECT_COMPOSITION_MODE_SURFACEPRESENTER = VIEW_OBJECT_COMPOSITION_MODE.SURFACEPRESENTER;
pub const VIEW_OBJECT_COMPOSITION_MODE_Max = VIEW_OBJECT_COMPOSITION_MODE.Max;

const IID_IHTMLEventObj_Value = @import("../zig.zig").Guid.initString("3050f32d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj = &IID_IHTMLEventObj_Value;
pub const IHTMLEventObj = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcElement: fn(
            self: *const IHTMLEventObj,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altKey: fn(
            self: *const IHTMLEventObj,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ctrlKey: fn(
            self: *const IHTMLEventObj,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shiftKey: fn(
            self: *const IHTMLEventObj,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_returnValue: fn(
            self: *const IHTMLEventObj,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_returnValue: fn(
            self: *const IHTMLEventObj,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cancelBubble: fn(
            self: *const IHTMLEventObj,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cancelBubble: fn(
            self: *const IHTMLEventObj,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fromElement: fn(
            self: *const IHTMLEventObj,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_toElement: fn(
            self: *const IHTMLEventObj,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_keyCode: fn(
            self: *const IHTMLEventObj,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_keyCode: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_button: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLEventObj,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_qualifier: fn(
            self: *const IHTMLEventObj,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_reason: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientX: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientY: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetX: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetY: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenX: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenY: fn(
            self: *const IHTMLEventObj,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcFilter: fn(
            self: *const IHTMLEventObj,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_srcElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_srcElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_altKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_altKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_ctrlKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_shiftKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_shiftKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_returnValue(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_returnValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_returnValue(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_cancelBubble(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_cancelBubble(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_cancelBubble(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_cancelBubble(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_fromElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_fromElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_toElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_toElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_keyCode(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_keyCode(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_keyCode(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_keyCode(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_button(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_button(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_type(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_qualifier(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_qualifier(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_reason(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_reason(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_x(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_x(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_y(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_y(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_clientX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_clientX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_clientY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_clientY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_offsetX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_offsetX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_offsetY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_offsetY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_screenX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_screenY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_srcFilter(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_srcFilter(@ptrCast(*const IHTMLEventObj, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSite_Value = @import("../zig.zig").Guid.initString("3050f427-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSite = &IID_IElementBehaviorSite_Value;
pub const IElementBehaviorSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElement: fn(
            self: *const IElementBehaviorSite,
            ppElement: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotification: fn(
            self: *const IElementBehaviorSite,
            lEvent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSite_GetElement(self: *const T, ppElement: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSite.VTable, self.vtable).GetElement(@ptrCast(*const IElementBehaviorSite, self), ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSite_RegisterNotification(self: *const T, lEvent: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSite.VTable, self.vtable).RegisterNotification(@ptrCast(*const IElementBehaviorSite, self), lEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehavior_Value = @import("../zig.zig").Guid.initString("3050f425-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehavior = &IID_IElementBehavior_Value;
pub const IElementBehavior = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IElementBehavior,
            pBehaviorSite: ?*IElementBehaviorSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IElementBehavior,
            lEvent: i32,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Init(self: *const T, pBehaviorSite: ?*IElementBehaviorSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Init(@ptrCast(*const IElementBehavior, self), pBehaviorSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Notify(self: *const T, lEvent: i32, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Notify(@ptrCast(*const IElementBehavior, self), lEvent, pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Detach(@ptrCast(*const IElementBehavior, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorFactory_Value = @import("../zig.zig").Guid.initString("3050f429-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorFactory = &IID_IElementBehaviorFactory_Value;
pub const IElementBehaviorFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindBehavior: fn(
            self: *const IElementBehaviorFactory,
            bstrBehavior: ?BSTR,
            bstrBehaviorUrl: ?BSTR,
            pSite: ?*IElementBehaviorSite,
            ppBehavior: ?*?*IElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorFactory_FindBehavior(self: *const T, bstrBehavior: ?BSTR, bstrBehaviorUrl: ?BSTR, pSite: ?*IElementBehaviorSite, ppBehavior: ?*?*IElementBehavior) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorFactory.VTable, self.vtable).FindBehavior(@ptrCast(*const IElementBehaviorFactory, self), bstrBehavior, bstrBehaviorUrl, pSite, ppBehavior);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteOM_Value = @import("../zig.zig").Guid.initString("3050f489-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteOM = &IID_IElementBehaviorSiteOM_Value;
pub const IElementBehaviorSiteOM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterEvent: fn(
            self: *const IElementBehaviorSiteOM,
            pchEvent: ?PWSTR,
            lFlags: i32,
            plCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCookie: fn(
            self: *const IElementBehaviorSiteOM,
            pchEvent: ?PWSTR,
            plCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireEvent: fn(
            self: *const IElementBehaviorSiteOM,
            lCookie: i32,
            pEventObject: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEventObject: fn(
            self: *const IElementBehaviorSiteOM,
            ppEventObject: ?*?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterName: fn(
            self: *const IElementBehaviorSiteOM,
            pchName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterUrn: fn(
            self: *const IElementBehaviorSiteOM,
            pchUrn: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterEvent(self: *const T, pchEvent: ?PWSTR, lFlags: i32, plCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterEvent(@ptrCast(*const IElementBehaviorSiteOM, self), pchEvent, lFlags, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_GetEventCookie(self: *const T, pchEvent: ?PWSTR, plCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).GetEventCookie(@ptrCast(*const IElementBehaviorSiteOM, self), pchEvent, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_FireEvent(self: *const T, lCookie: i32, pEventObject: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).FireEvent(@ptrCast(*const IElementBehaviorSiteOM, self), lCookie, pEventObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_CreateEventObject(self: *const T, ppEventObject: ?*?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).CreateEventObject(@ptrCast(*const IElementBehaviorSiteOM, self), ppEventObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterName(self: *const T, pchName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterName(@ptrCast(*const IElementBehaviorSiteOM, self), pchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterUrn(self: *const T, pchUrn: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterUrn(@ptrCast(*const IElementBehaviorSiteOM, self), pchUrn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorRender_Value = @import("../zig.zig").Guid.initString("3050f4aa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorRender = &IID_IElementBehaviorRender_Value;
pub const IElementBehaviorRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: fn(
            self: *const IElementBehaviorRender,
            hdc: ?HDC,
            lLayer: i32,
            pRect: ?*RECT,
            pReserved: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderInfo: fn(
            self: *const IElementBehaviorRender,
            plRenderInfo: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HitTestPoint: fn(
            self: *const IElementBehaviorRender,
            pPoint: ?*POINT,
            pReserved: ?*IUnknown,
            pbHit: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_Draw(self: *const T, hdc: ?HDC, lLayer: i32, pRect: ?*RECT, pReserved: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).Draw(@ptrCast(*const IElementBehaviorRender, self), hdc, lLayer, pRect, pReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_GetRenderInfo(self: *const T, plRenderInfo: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).GetRenderInfo(@ptrCast(*const IElementBehaviorRender, self), plRenderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_HitTestPoint(self: *const T, pPoint: ?*POINT, pReserved: ?*IUnknown, pbHit: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).HitTestPoint(@ptrCast(*const IElementBehaviorRender, self), pPoint, pReserved, pbHit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteRender_Value = @import("../zig.zig").Guid.initString("3050f4a7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteRender = &IID_IElementBehaviorSiteRender_Value;
pub const IElementBehaviorSiteRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invalidate: fn(
            self: *const IElementBehaviorSiteRender,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRenderInfo: fn(
            self: *const IElementBehaviorSiteRender,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateStyle: fn(
            self: *const IElementBehaviorSiteRender,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_Invalidate(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).Invalidate(@ptrCast(*const IElementBehaviorSiteRender, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_InvalidateRenderInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).InvalidateRenderInfo(@ptrCast(*const IElementBehaviorSiteRender, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_InvalidateStyle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).InvalidateStyle(@ptrCast(*const IElementBehaviorSiteRender, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMEvent_Value = @import("../zig.zig").Guid.initString("305104ba-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMEvent = &IID_IDOMEvent_Value;
pub const IDOMEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bubbles: fn(
            self: *const IDOMEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cancelable: fn(
            self: *const IDOMEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentTarget: fn(
            self: *const IDOMEvent,
            p: ?*?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultPrevented: fn(
            self: *const IDOMEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eventPhase: fn(
            self: *const IDOMEvent,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IDOMEvent,
            p: ?*?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timeStamp: fn(
            self: *const IDOMEvent,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IDOMEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initEvent: fn(
            self: *const IDOMEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        preventDefault: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopPropagation: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopImmediatePropagation: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isTrusted: fn(
            self: *const IDOMEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cancelBubble: fn(
            self: *const IDOMEvent,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cancelBubble: fn(
            self: *const IDOMEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcElement: fn(
            self: *const IDOMEvent,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_bubbles(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_bubbles(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_cancelable(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_cancelable(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_currentTarget(self: *const T, p: ?*?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_currentTarget(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_defaultPrevented(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_defaultPrevented(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_eventPhase(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_eventPhase(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_target(self: *const T, p: ?*?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_target(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_timeStamp(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_timeStamp(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_type(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_initEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).initEvent(@ptrCast(*const IDOMEvent, self), eventType, canBubble, cancelable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_preventDefault(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).preventDefault(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_stopPropagation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).stopPropagation(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_stopImmediatePropagation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).stopImmediatePropagation(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_isTrusted(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_isTrusted(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_put_cancelBubble(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).put_cancelBubble(@ptrCast(*const IDOMEvent, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_cancelBubble(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_cancelBubble(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_srcElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_srcElement(@ptrCast(*const IDOMEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMConstructor_Value = @import("../zig.zig").Guid.initString("3051049b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMConstructor = &IID_IHTMLDOMConstructor_Value;
pub const IHTMLDOMConstructor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_constructor: fn(
            self: *const IHTMLDOMConstructor,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupGetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: ?BSTR,
            ppDispHandler: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupSetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: ?BSTR,
            ppDispHandler: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineGetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: ?BSTR,
            pdispHandler: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineSetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: ?BSTR,
            pdispHandler: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_get_constructor(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).get_constructor(@ptrCast(*const IHTMLDOMConstructor, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_LookupGetter(self: *const T, propname: ?BSTR, ppDispHandler: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).LookupGetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_LookupSetter(self: *const T, propname: ?BSTR, ppDispHandler: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).LookupSetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_DefineGetter(self: *const T, propname: ?BSTR, pdispHandler: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).DefineGetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, pdispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_DefineSetter(self: *const T, propname: ?BSTR, pdispHandler: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).DefineSetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, pdispHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050f357-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRule = &IID_IHTMLStyleSheetRule_Value;
pub const IHTMLStyleSheetRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectorText: fn(
            self: *const IHTMLStyleSheetRule,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectorText: fn(
            self: *const IHTMLStyleSheetRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLStyleSheetRule,
            p: ?*?*IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readOnly: fn(
            self: *const IHTMLStyleSheetRule,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_put_selectorText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_selectorText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_style(self: *const T, p: ?*?*IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_readOnly(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("30510740-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSStyleDeclaration = &IID_IHTMLCSSStyleDeclaration_Value;
pub const IHTMLCSSStyleDeclaration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPropertyValue: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: ?BSTR,
            pbstrPropertyValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPropertyPriority: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: ?BSTR,
            pbstrPropertyPriority: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeProperty: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: ?BSTR,
            pbstrPropertyValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setProperty: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: ?BSTR,
            pvarPropertyValue: ?*VARIANT,
            pvarPropertyPriority: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLCSSStyleDeclaration,
            index: i32,
            pbstrPropertyName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontFamily: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontFamily: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontVariant: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontVariant: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontWeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontWeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_font: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_font: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_letterSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_letterSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecoration: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecoration: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_verticalAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_verticalAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textIndent: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textIndent: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_margin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_margin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_padding: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_padding: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_styleFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clear: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_display: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_display: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_visibility: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_visibility: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStylePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStylePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_whiteSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whiteSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_top: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_left: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_left: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zIndex: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zIndex: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssText: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssText: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cursor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cursor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_filter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tableLayout: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tableLayout: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderCollapse: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderCollapse: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_direction: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_behavior: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behavior: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_position: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unicodeBidi: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unicodeBidi: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_right: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_right: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_imeMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyOverhang: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyOverhang: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridChar: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridChar: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridLine: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridLine: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGrid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGrid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAutospace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAutospace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustify: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustify: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustifyTrim: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustifyTrim: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashida: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashida: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accelerator: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accelerator: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutFlow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutFlow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zoom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordWrap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordWrap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textUnderlinePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textUnderlinePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarBaseColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarBaseColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarFaceColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarFaceColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarArrowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarArrowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarTrackColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarTrackColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_writingMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_writingMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlignLast: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlignLast: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashidaSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashidaSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textOverflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textOverflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msInterpolationMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msInterpolationMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_content: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_content: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_captionSide: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_captionSide: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterIncrement: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterIncrement: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterReset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterReset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_boxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_orphans: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orphans: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_widows: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_widows: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakInside: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakInside: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_emptyCells: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_emptyCells: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msBlockProgression: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msBlockProgression: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_quotes: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_quotes: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alignmentBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alignmentBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baselineShift: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baselineShift: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dominantBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dominantBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontStretch: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontStretch: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_opacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_opacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clipPath: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipPath: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clipRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fill: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fill: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fillOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fillOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fillRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fillRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_kerning: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_kerning: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marker: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marker: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_markerEnd: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerEnd: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_markerMid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerMid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_markerStart: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerStart: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_mask: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mask: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pointerEvents: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pointerEvents: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stopOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stopOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stroke: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stroke: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeDasharray: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeDasharray: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeDashoffset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeDashoffset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeLinecap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeLinecap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeLinejoin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeLinejoin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeMiterlimit: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeMiterlimit: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAnchor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAnchor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_glyphOrientationHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_glyphOrientationHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_glyphOrientationVertical: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_glyphOrientationVertical: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clipTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clipRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clipLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_boxShadow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boxShadow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_parentRule(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_parentRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_getPropertyValue(self: *const T, bstrPropertyName: ?BSTR, pbstrPropertyValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).getPropertyValue(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_getPropertyPriority(self: *const T, bstrPropertyName: ?BSTR, pbstrPropertyPriority: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).getPropertyPriority(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_removeProperty(self: *const T, bstrPropertyName: ?BSTR, pbstrPropertyValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).removeProperty(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_setProperty(self: *const T, bstrPropertyName: ?BSTR, pvarPropertyValue: ?*VARIANT, pvarPropertyPriority: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).setProperty(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pvarPropertyValue, pvarPropertyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_item(self: *const T, index: i32, pbstrPropertyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).item(@ptrCast(*const IHTMLCSSStyleDeclaration, self), index, pbstrPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontFamily(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontFamily(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontVariant(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontVariant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontWeight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontWeight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontSize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_font(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_font(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_font(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_font(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_color(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_color(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_background(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_background(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundAttachment(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundAttachment(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPositionX(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPositionY(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_letterSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textDecoration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textDecoration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_verticalAlign(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textTransform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textIndent(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_lineHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_margin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_margin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_padding(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_padding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_border(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_border(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_border(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_border(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTop(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTop(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottom(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottom(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeft(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeft(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderColor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderColor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderWidth(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_width(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_height(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_styleFloat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_styleFloat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clear(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_display(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_display(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_display(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_display(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_visibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_visibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyleType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyleType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStylePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStylePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyleImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyleImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_whiteSpace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_whiteSpace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_top(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_top(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_top(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_left(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_left(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_left(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_zIndex(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakBefore(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakBefore(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakAfter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakAfter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cssText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cssText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cursor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cursor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clip(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clip(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_filter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_filter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_tableLayout(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_tableLayout(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderCollapse(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderCollapse(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_direction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_direction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_behavior(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_behavior(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_position(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_position(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_position(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_unicodeBidi(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_unicodeBidi(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_bottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_right(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_right(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_right(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_imeMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_imeMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyOverhang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyOverhang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridChar(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridLine(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGrid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGrid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAutospace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAutospace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_lineBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_lineBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textJustify(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textJustify(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textJustifyTrim(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textJustifyTrim(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textKashida(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflowX(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflowX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflowY(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflowY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_accelerator(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_accelerator(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_zoom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordWrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textUnderlinePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textUnderlinePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarBaseColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarFaceColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbar3dLightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarHighlightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarDarkShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarArrowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarTrackColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_writingMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_writingMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAlignLast(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAlignLast(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textKashidaSpace(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textOverflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textOverflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_minHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msInterpolationMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msInterpolationMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_maxHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_minWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_maxWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_content(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_content(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_content(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_content(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_captionSide(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_captionSide(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_counterIncrement(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_counterIncrement(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_counterReset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_counterReset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_boxSizing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_boxSizing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderSpacing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderSpacing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_orphans(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_widows(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakInside(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakInside(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_emptyCells(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_emptyCells(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msBlockProgression(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msBlockProgression(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_quotes(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_quotes(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_alignmentBaseline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_alignmentBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_alignmentBaseline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_alignmentBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_baselineShift(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_baselineShift(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_baselineShift(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_baselineShift(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_dominantBaseline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_dominantBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_dominantBaseline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_dominantBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontSizeAdjust(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontStretch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontStretch(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontStretch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontStretch(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_opacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_opacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_opacity(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_opacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipPath(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipPath(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipPath(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipPath(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipRule(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipRule(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fill(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fill(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fill(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fill(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fillOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fillOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fillOpacity(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fillOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fillRule(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fillRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fillRule(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fillRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_kerning(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_kerning(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_kerning(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_kerning(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marker(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marker(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marker(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marker(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerEnd(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerEnd(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerEnd(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerEnd(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerMid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerMid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerMid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerMid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerStart(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerStart(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerStart(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerStart(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_mask(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_mask(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_mask(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_mask(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pointerEvents(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pointerEvents(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pointerEvents(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pointerEvents(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stopColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stopOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stopOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stopOpacity(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stopOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stroke(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stroke(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stroke(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stroke(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeDasharray(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeDasharray(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeDasharray(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeDasharray(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeDashoffset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeDashoffset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeDashoffset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeDashoffset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeLinecap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeLinecap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeLinecap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeLinecap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeLinejoin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeLinejoin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeLinejoin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeLinejoin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeMiterlimit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeMiterlimit(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeMiterlimit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeMiterlimit(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeOpacity(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAnchor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAnchor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAnchor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAnchor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_glyphOrientationHorizontal(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_glyphOrientationHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_glyphOrientationHorizontal(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_glyphOrientationHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_glyphOrientationVertical(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_glyphOrientationVertical(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_glyphOrientationVertical(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_glyphOrientationVertical(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRadius(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRadius(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopLeftRadius(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopLeftRadius(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopRightRadius(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopRightRadius(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomRightRadius(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomRightRadius(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomLeftRadius(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomLeftRadius(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cssFloat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cssFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cssFloat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cssFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundClip(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundClip(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundSize(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_boxShadow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_boxShadow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_boxShadow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_boxShadow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msTransform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msTransformOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msTransformOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration2_Value = @import("../zig.zig").Guid.initString("305107d1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSStyleDeclaration2 = &IID_IHTMLCSSStyleDeclaration2_Value;
pub const IHTMLCSSStyleDeclaration2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZooming: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZooming: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollRails: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollRails: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomSnap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomSnap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomSnapPoints: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomSnapPoints: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomLimitMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomLimitMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msContentZoomLimitMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msContentZoomLimitMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollSnapX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollSnapX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollSnapY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollSnapY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollSnapPointsX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollSnapPointsX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollSnapPointsY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollSnapPointsY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridColumn: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridColumn: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridColumnAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridColumnAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridColumns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridColumns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridColumnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridColumnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridRow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridRow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridRowAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridRowAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridRows: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridRows: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msGridRowSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msGridRowSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msWrapThrough: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msWrapThrough: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msWrapMargin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msWrapMargin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msWrapFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msWrapFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_colorInterpolationFilters: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_colorInterpolationFilters: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnGap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnGap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnFill: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnFill: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnRule: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnRule: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnRuleColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnRuleColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnRuleStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnRuleStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_columnRuleWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnRuleWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_breakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_breakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_breakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_breakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_breakInside: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_breakInside: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_floodColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_floodColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_floodOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_floodOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lightingColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lightingColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollLimitXMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollLimitXMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollLimitYMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollLimitYMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollLimitXMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollLimitXMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollLimitYMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollLimitYMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textShadow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textShadow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlowFrom: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlowFrom: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlowInto: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlowInto: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msHyphens: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msHyphens: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msHyphenateLimitZone: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msHyphenateLimitZone: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msHyphenateLimitChars: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msHyphenateLimitChars: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msHyphenateLimitLines: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msHyphenateLimitLines: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msHighContrastAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msHighContrastAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableBackground: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableBackground: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msOverflowStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msOverflowStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPerspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPerspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPerspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPerspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTransition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTransition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTouchAction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTouchAction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msScrollTranslation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msScrollTranslation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlex: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlex: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexPositive: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexPositive: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexNegative: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexNegative: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexPreferredSize: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexPreferredSize: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexItemAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexItemAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexPack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexPack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexLinePack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexLinePack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msFlexOrder: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFlexOrder: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTouchSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTouchSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transform: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transform: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_perspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_perspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_perspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_perspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_transition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollChaining(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollChaining(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZooming(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZooming(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZooming(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZooming(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnapType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnapType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollRails(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollRails(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollRails(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollRails(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomChaining(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomChaining(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimit(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimit(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnapPoints(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnapPoints(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnapPoints(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnapPoints(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimitMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimitMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimitMin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimitMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimitMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimitMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimitMax(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimitMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapX(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapY(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapPointsX(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapPointsX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapPointsX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapPointsX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapPointsY(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapPointsY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapPointsY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapPointsY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumn(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumn(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumn(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumn(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumnAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumnAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumnAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumnAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumns(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumns(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumnSpan(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumnSpan(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRow(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRow(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRowAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRowAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRowAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRowAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRows(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRows(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRows(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRows(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRowSpan(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRowSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRowSpan(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRowSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapThrough(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapThrough(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapThrough(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapThrough(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapMargin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapMargin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapMargin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationName(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationPlayState(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationPlayState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationIterationCount(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationIterationCount(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationFillMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationFillMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_colorInterpolationFilters(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_colorInterpolationFilters(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_colorInterpolationFilters(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_colorInterpolationFilters(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnCount(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnCount(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnGap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnGap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnGap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnGap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnFill(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnFill(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnFill(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnFill(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnSpan(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnSpan(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columns(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columns(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRule(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRule(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRule(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRule(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakBefore(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakBefore(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakAfter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakAfter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakInside(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakInside(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakInside(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakInside(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_floodColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_floodColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_floodColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_floodColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_floodOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_floodOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_floodOpacity(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_floodOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_lightingColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_lightingColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_lightingColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_lightingColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitXMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitXMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitXMin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitXMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitYMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitYMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitYMin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitYMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitXMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitXMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitXMax(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitXMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitYMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitYMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitYMax(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitYMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimit(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimit(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_textShadow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_textShadow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_textShadow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_textShadow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlowFrom(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlowFrom(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlowFrom(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlowFrom(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlowInto(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlowInto(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlowInto(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlowInto(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphens(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphens(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphens(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphens(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitZone(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitZone(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitZone(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitZone(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitChars(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitChars(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitChars(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitChars(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitLines(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitLines(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitLines(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitLines(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHighContrastAdjust(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHighContrastAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHighContrastAdjust(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHighContrastAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_enableBackground(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_enableBackground(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_enableBackground(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_enableBackground(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFontFeatureSettings(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFontFeatureSettings(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msUserSelect(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msUserSelect(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msOverflowStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msOverflowStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msOverflowStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msOverflowStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransformStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransformStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msBackfaceVisibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msBackfaceVisibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msPerspective(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msPerspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msPerspective(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msPerspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msPerspectiveOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msPerspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msPerspectiveOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msPerspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionProperty(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionProperty(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTouchAction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTouchAction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTouchAction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTouchAction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollTranslation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollTranslation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollTranslation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollTranslation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlex(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlex(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlex(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlex(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPositive(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPositive(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPositive(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPositive(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexNegative(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexNegative(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexNegative(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexNegative(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPreferredSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPreferredSize(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPreferredSize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPreferredSize(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexWrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexItemAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexItemAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexItemAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexItemAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPack(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPack(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexLinePack(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexLinePack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexLinePack(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexLinePack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexOrder(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexOrder(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexOrder(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexOrder(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTouchSelect(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTouchSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTouchSelect(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTouchSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transform(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transform(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transformOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transformOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transformStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transformStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_backfaceVisibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_backfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_backfaceVisibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_backfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_perspective(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_perspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_perspective(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_perspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_perspectiveOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_perspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_perspectiveOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_perspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionProperty(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionProperty(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_fontFeatureSettings(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_fontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_fontFeatureSettings(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_fontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationName(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationPlayState(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationPlayState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationIterationCount(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationIterationCount(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationFillMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationFillMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration3_Value = @import("../zig.zig").Guid.initString("3051085c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSStyleDeclaration3 = &IID_IHTMLCSSStyleDeclaration3_Value;
pub const IHTMLCSSStyleDeclaration3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flex: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flex: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexGrow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexGrow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexShrink: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexShrink: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_flexBasis: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_flexBasis: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_justifyContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_justifyContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alignItems: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alignItems: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alignSelf: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alignSelf: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alignContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alignContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImage: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImage: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msImeAlign: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msImeAlign: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTextCombineHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTextCombineHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_touchAction: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_touchAction: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flex(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flex(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flex(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flex(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexWrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexGrow(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexGrow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexGrow(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexGrow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexShrink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexShrink(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexShrink(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexShrink(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexBasis(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexBasis(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexBasis(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexBasis(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_justifyContent(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_justifyContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_justifyContent(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_justifyContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignItems(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignItems(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignItems(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignItems(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignSelf(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignSelf(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignSelf(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignSelf(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignContent(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignContent(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImage(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImage(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageSource(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageSource(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageSlice(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageSlice(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageWidth(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageOutset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageOutset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_msImeAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_msImeAlign(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_msImeAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_msImeAlign(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_msTextCombineHorizontal(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_msTextCombineHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_msTextCombineHorizontal(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_msTextCombineHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_touchAction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_touchAction(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_touchAction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_touchAction(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration4_Value = @import("../zig.zig").Guid.initString("d6100f3b-27c8-4132-afea-f0e4b1e00060");
pub const IID_IHTMLCSSStyleDeclaration4 = &IID_IHTMLCSSStyleDeclaration4_Value;
pub const IHTMLCSSStyleDeclaration4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAppearance: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAppearance: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxAlign: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxAlign: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxOrdinalGroup: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxOrdinalGroup: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxPack: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxPack: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxFlex: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxFlex: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxOrient: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxOrient: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransform: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransform: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBackground: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBackground: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBorderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBorderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitBoxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitBoxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_webkitAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_webkitAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAppearance(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAppearance(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAppearance(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAppearance(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitUserSelect(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitUserSelect(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxAlign(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxAlign(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxOrdinalGroup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxOrdinalGroup(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxOrdinalGroup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxOrdinalGroup(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxPack(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxPack(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxPack(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxPack(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxFlex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxFlex(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxFlex(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxFlex(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxOrient(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxOrient(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxOrient(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxOrient(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransform(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransform(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundSize(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackfaceVisibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackfaceVisibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationName(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationIterationCount(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationIterationCount(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDirection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationPlayState(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationPlayState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionProperty(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionProperty(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionDuration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionDuration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionTimingFunction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionTimingFunction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionDelay(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionDelay(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundAttachment(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundAttachment(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundClip(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundClip(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPositionX(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPositionY(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackground(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackground(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackground(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackground(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransformOrigin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransformOrigin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_msTextSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_msTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_msTextSizeAdjust(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_msTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTextSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTextSizeAdjust(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageSource(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageSource(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageSlice(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageSlice(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageWidth(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageOutset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageOutset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxSizing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxSizing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationFillMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationFillMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleEnabled_Value = @import("../zig.zig").Guid.initString("305104c2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleEnabled = &IID_IHTMLStyleEnabled_Value;
pub const IHTMLStyleEnabled = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        msGetPropertyEnabled: fn(
            self: *const IHTMLStyleEnabled,
            name: ?BSTR,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msPutPropertyEnabled: fn(
            self: *const IHTMLStyleEnabled,
            name: ?BSTR,
            b: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleEnabled_msGetPropertyEnabled(self: *const T, name: ?BSTR, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleEnabled.VTable, self.vtable).msGetPropertyEnabled(@ptrCast(*const IHTMLStyleEnabled, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleEnabled_msPutPropertyEnabled(self: *const T, name: ?BSTR, b: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleEnabled.VTable, self.vtable).msPutPropertyEnabled(@ptrCast(*const IHTMLStyleEnabled, self), name, b);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("3059009a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSStyleDeclaration = &IID_DispHTMLCSSStyleDeclaration_Value;
pub const DispHTMLCSSStyleDeclaration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle_Value = @import("../zig.zig").Guid.initString("3050f25e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle = &IID_IHTMLStyle_Value;
pub const IHTMLStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontFamily: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontFamily: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontVariant: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontVariant: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontWeight: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontWeight: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontSize: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSize: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_font: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_font: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundColor: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundImage: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundImage: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundRepeat: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundRepeat: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundAttachment: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundAttachment: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPosition: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPosition: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionX: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionX: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionY: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionY: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordSpacing: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordSpacing: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_letterSpacing: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_letterSpacing: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecoration: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecoration: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationNone: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationNone: fn(
            self: *const IHTMLStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationUnderline: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationUnderline: fn(
            self: *const IHTMLStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationOverline: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationOverline: fn(
            self: *const IHTMLStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationLineThrough: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationLineThrough: fn(
            self: *const IHTMLStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationBlink: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationBlink: fn(
            self: *const IHTMLStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_verticalAlign: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_verticalAlign: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textTransform: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textTransform: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlign: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlign: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textIndent: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textIndent: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineHeight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineHeight: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginTop: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginTop: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginRight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginRight: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginBottom: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginBottom: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginLeft: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginLeft: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_margin: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_margin: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingTop: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingTop: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingRight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingRight: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingBottom: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingBottom: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingLeft: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingLeft: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_padding: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_padding: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTop: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTop: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRight: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRight: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottom: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottom: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeft: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeft: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopColor: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightColor: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomColor: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftColor: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderWidth: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderWidth: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopWidth: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightWidth: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomWidth: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftWidth: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_styleFloat: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleFloat: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clear: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_display: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_display: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_visibility: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_visibility: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleType: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleType: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStylePosition: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStylePosition: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleImage: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleImage: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyle: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyle: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_whiteSpace: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whiteSpace: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_top: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_left: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_left: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zIndex: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zIndex: fn(
            self: *const IHTMLStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflow: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflow: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakBefore: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakBefore: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakAfter: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakAfter: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssText: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssText: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelTop: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelTop: fn(
            self: *const IHTMLStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelLeft: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelLeft: fn(
            self: *const IHTMLStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelWidth: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelWidth: fn(
            self: *const IHTMLStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelHeight: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelHeight: fn(
            self: *const IHTMLStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posTop: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posTop: fn(
            self: *const IHTMLStyle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posLeft: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posLeft: fn(
            self: *const IHTMLStyle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posWidth: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posWidth: fn(
            self: *const IHTMLStyle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posHeight: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posHeight: fn(
            self: *const IHTMLStyle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cursor: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cursor: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clip: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clip: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_filter: fn(
            self: *const IHTMLStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IHTMLStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: ?BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: ?BSTR,
            lFlags: i32,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: ?BSTR,
            lFlags: i32,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLStyle,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontFamily(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontFamily(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontVariant(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontVariant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontWeight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontWeight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontSize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_font(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_font(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_font(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_font(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_color(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_background(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_background(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundAttachment(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundAttachment(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPositionX(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPositionY(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_wordSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_letterSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecoration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecoration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationNone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationNone(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationNone(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationNone(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationUnderline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationUnderline(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationUnderline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationUnderline(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationOverline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationOverline(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationOverline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationOverline(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationLineThrough(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationLineThrough(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationLineThrough(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationLineThrough(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationBlink(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationBlink(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationBlink(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationBlink(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_verticalAlign(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textTransform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textIndent(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_lineHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_margin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_margin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_padding(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_padding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_border(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_border(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_border(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_border(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTop(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTop(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottom(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottom(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeft(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeft(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderColor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderColor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderWidth(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_width(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_height(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_styleFloat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_styleFloat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_clear(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_display(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_display(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_display(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_visibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_visibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyleType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyleType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStylePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStylePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyleImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyleImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_whiteSpace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_whiteSpace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_top(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_top(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_left(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_left(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_zIndex(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_overflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_overflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pageBreakBefore(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pageBreakBefore(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pageBreakAfter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pageBreakAfter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_cssText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_cssText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelWidth(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelHeight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posTop(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posTop(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posLeft(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posLeft(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posWidth(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posWidth(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posHeight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posHeight(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_cursor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_cursor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_clip(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_clip(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_filter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_filter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_setAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_getAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_removeAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).toString(@ptrCast(*const IHTMLStyle, self), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle2_Value = @import("../zig.zig").Guid.initString("3050f4a2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle2 = &IID_IHTMLStyle2_Value;
pub const IHTMLStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tableLayout: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tableLayout: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderCollapse: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderCollapse: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_direction: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_behavior: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behavior: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setExpression: fn(
            self: *const IHTMLStyle2,
            propname: ?BSTR,
            expression: ?BSTR,
            language: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExpression: fn(
            self: *const IHTMLStyle2,
            propname: ?BSTR,
            expression: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeExpression: fn(
            self: *const IHTMLStyle2,
            propname: ?BSTR,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_position: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unicodeBidi: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unicodeBidi: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bottom: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottom: fn(
            self: *const IHTMLStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_right: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_right: fn(
            self: *const IHTMLStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelBottom: fn(
            self: *const IHTMLStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelBottom: fn(
            self: *const IHTMLStyle2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelRight: fn(
            self: *const IHTMLStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelRight: fn(
            self: *const IHTMLStyle2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posBottom: fn(
            self: *const IHTMLStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posBottom: fn(
            self: *const IHTMLStyle2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posRight: fn(
            self: *const IHTMLStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posRight: fn(
            self: *const IHTMLStyle2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_imeMode: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeMode: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyAlign: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyAlign: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyPosition: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyPosition: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyOverhang: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyOverhang: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridChar: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridChar: fn(
            self: *const IHTMLStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridLine: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridLine: fn(
            self: *const IHTMLStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridMode: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridMode: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridType: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridType: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGrid: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGrid: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordBreak: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordBreak: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineBreak: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineBreak: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustify: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustify: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustifyTrim: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustifyTrim: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashida: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashida: fn(
            self: *const IHTMLStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAutospace: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAutospace: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowX: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowX: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowY: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowY: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accelerator: fn(
            self: *const IHTMLStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accelerator: fn(
            self: *const IHTMLStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_tableLayout(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_tableLayout(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_borderCollapse(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_borderCollapse(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_direction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_direction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_behavior(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_behavior(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_setExpression(self: *const T, propname: ?BSTR, expression: ?BSTR, language: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).setExpression(@ptrCast(*const IHTMLStyle2, self), propname, expression, language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_getExpression(self: *const T, propname: ?BSTR, expression: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).getExpression(@ptrCast(*const IHTMLStyle2, self), propname, expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_removeExpression(self: *const T, propname: ?BSTR, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).removeExpression(@ptrCast(*const IHTMLStyle2, self), propname, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_position(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_position(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_position(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_unicodeBidi(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_unicodeBidi(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_bottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_right(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_right(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_right(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_pixelBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_pixelBottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_pixelBottom(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_pixelBottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_pixelRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_pixelRight(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_pixelRight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_pixelRight(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_posBottom(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_posBottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_posBottom(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_posBottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_posRight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_posRight(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_posRight(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_posRight(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_imeMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_imeMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyOverhang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyOverhang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridChar(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridLine(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGrid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGrid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_wordBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_wordBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_lineBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_lineBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textJustify(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textJustify(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textJustifyTrim(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textJustifyTrim(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textKashida(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textAutospace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textAutospace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_overflowX(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_overflowX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_overflowY(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_overflowY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_accelerator(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_accelerator(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle3_Value = @import("../zig.zig").Guid.initString("3050f656-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle3 = &IID_IHTMLStyle3_Value;
pub const IHTMLStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutFlow: fn(
            self: *const IHTMLStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutFlow: fn(
            self: *const IHTMLStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zoom: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoom: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordWrap: fn(
            self: *const IHTMLStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordWrap: fn(
            self: *const IHTMLStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textUnderlinePosition: fn(
            self: *const IHTMLStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textUnderlinePosition: fn(
            self: *const IHTMLStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarBaseColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarBaseColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarFaceColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarFaceColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarShadowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarShadowColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarArrowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarArrowColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarTrackColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarTrackColor: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_writingMode: fn(
            self: *const IHTMLStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_writingMode: fn(
            self: *const IHTMLStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlignLast: fn(
            self: *const IHTMLStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlignLast: fn(
            self: *const IHTMLStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashidaSpace: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashidaSpace: fn(
            self: *const IHTMLStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_layoutFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_layoutFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_zoom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_wordWrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_wordWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textUnderlinePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textUnderlinePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarBaseColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarFaceColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbar3dLightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarHighlightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarDarkShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarArrowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarTrackColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_writingMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_writingMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textAlignLast(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textAlignLast(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textKashidaSpace(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle4_Value = @import("../zig.zig").Guid.initString("3050f816-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle4 = &IID_IHTMLStyle4_Value;
pub const IHTMLStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textOverflow: fn(
            self: *const IHTMLStyle4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textOverflow: fn(
            self: *const IHTMLStyle4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minHeight: fn(
            self: *const IHTMLStyle4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minHeight: fn(
            self: *const IHTMLStyle4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_put_textOverflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_get_textOverflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_get_minHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle5_Value = @import("../zig.zig").Guid.initString("3050f33a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle5 = &IID_IHTMLStyle5_Value;
pub const IHTMLStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msInterpolationMode: fn(
            self: *const IHTMLStyle5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msInterpolationMode: fn(
            self: *const IHTMLStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxHeight: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxHeight: fn(
            self: *const IHTMLStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minWidth: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minWidth: fn(
            self: *const IHTMLStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxWidth: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxWidth: fn(
            self: *const IHTMLStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_msInterpolationMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_msInterpolationMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_maxHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_minWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_maxWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle6_Value = @import("../zig.zig").Guid.initString("30510480-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyle6 = &IID_IHTMLStyle6_Value;
pub const IHTMLStyle6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_content: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_content: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_captionSide: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_captionSide: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterIncrement: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterIncrement: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterReset: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterReset: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outline: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outline: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineWidth: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineWidth: fn(
            self: *const IHTMLStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineStyle: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineStyle: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineColor: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineColor: fn(
            self: *const IHTMLStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_boxSizing: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boxSizing: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderSpacing: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderSpacing: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_orphans: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orphans: fn(
            self: *const IHTMLStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_widows: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_widows: fn(
            self: *const IHTMLStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakInside: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakInside: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_emptyCells: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_emptyCells: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msBlockProgression: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msBlockProgression: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_quotes: fn(
            self: *const IHTMLStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_quotes: fn(
            self: *const IHTMLStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_content(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_content(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_content(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_content(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_captionSide(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_captionSide(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_counterIncrement(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_counterIncrement(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_counterReset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_counterReset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_boxSizing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_boxSizing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_borderSpacing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_borderSpacing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_orphans(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_widows(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_pageBreakInside(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_pageBreakInside(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_emptyCells(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_emptyCells(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_msBlockProgression(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_msBlockProgression(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_quotes(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_quotes(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLStyle6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050f3cf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle = &IID_IHTMLRuleStyle_Value;
pub const IHTMLRuleStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontFamily: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontFamily: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontVariant: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontVariant: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontWeight: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontWeight: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontSize: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSize: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_font: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_font: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundImage: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundImage: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundRepeat: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundRepeat: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundAttachment: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundAttachment: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPosition: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPosition: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionX: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionX: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_backgroundPositionY: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionY: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordSpacing: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordSpacing: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_letterSpacing: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_letterSpacing: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecoration: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecoration: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationNone: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationNone: fn(
            self: *const IHTMLRuleStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationUnderline: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationUnderline: fn(
            self: *const IHTMLRuleStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationOverline: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationOverline: fn(
            self: *const IHTMLRuleStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationLineThrough: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationLineThrough: fn(
            self: *const IHTMLRuleStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationBlink: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationBlink: fn(
            self: *const IHTMLRuleStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_verticalAlign: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_verticalAlign: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textTransform: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textTransform: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlign: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlign: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textIndent: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textIndent: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineHeight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineHeight: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginTop: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginTop: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginRight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginRight: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginBottom: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginBottom: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginLeft: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginLeft: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_margin: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_margin: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingTop: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingTop: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingRight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingRight: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingBottom: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingBottom: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_paddingLeft: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingLeft: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_padding: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_padding: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTop: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTop: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRight: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRight: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottom: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottom: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeft: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeft: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftColor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderWidth: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderWidth: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopWidth: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightWidth: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomWidth: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftWidth: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderTopStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderRightStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderBottomStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderLeftStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_styleFloat: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleFloat: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clear: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_display: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_display: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_visibility: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_visibility: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleType: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleType: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStylePosition: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStylePosition: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyleImage: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleImage: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_listStyle: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyle: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_whiteSpace: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whiteSpace: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_top: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_left: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_left: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zIndex: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zIndex: fn(
            self: *const IHTMLRuleStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflow: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflow: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakBefore: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakBefore: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakAfter: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakAfter: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssText: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssText: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cursor: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cursor: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clip: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clip: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_filter: fn(
            self: *const IHTMLRuleStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IHTMLRuleStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: ?BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: ?BSTR,
            lFlags: i32,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: ?BSTR,
            lFlags: i32,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontFamily(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontFamily(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontVariant(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontVariant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontWeight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontWeight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontSize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_font(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_font(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_font(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_font(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_color(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_background(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_background(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundRepeat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundAttachment(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundAttachment(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPositionX(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPositionY(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_wordSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_letterSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecoration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecoration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationNone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationNone(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationNone(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationNone(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationUnderline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationUnderline(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationUnderline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationUnderline(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationOverline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationOverline(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationOverline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationOverline(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationLineThrough(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationLineThrough(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationLineThrough(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationLineThrough(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationBlink(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationBlink(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationBlink(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationBlink(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_verticalAlign(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textTransform(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textIndent(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_lineHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_margin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_margin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_padding(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_padding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_border(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_border(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_border(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_border(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTop(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTop(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRight(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRight(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottom(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottom(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeft(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeft(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderColor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderColor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderWidth(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_width(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_height(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_styleFloat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_styleFloat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_clear(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_display(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_display(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_display(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_visibility(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_visibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyleType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyleType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStylePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStylePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyleImage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyleImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_whiteSpace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_whiteSpace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_top(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_top(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_left(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_left(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_zIndex(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_overflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_overflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_pageBreakBefore(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_pageBreakBefore(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_pageBreakAfter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_pageBreakAfter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_cssText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_cssText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_cursor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_cursor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_clip(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_clip(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_filter(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_filter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_setAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_getAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_removeAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, lFlags, pfSuccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle2_Value = @import("../zig.zig").Guid.initString("3050f4ac-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle2 = &IID_IHTMLRuleStyle2_Value;
pub const IHTMLRuleStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tableLayout: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tableLayout: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderCollapse: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderCollapse: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_direction: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_behavior: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behavior: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_position: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unicodeBidi: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unicodeBidi: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bottom: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottom: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_right: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_right: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelBottom: fn(
            self: *const IHTMLRuleStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelBottom: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelRight: fn(
            self: *const IHTMLRuleStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelRight: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posBottom: fn(
            self: *const IHTMLRuleStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posBottom: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_posRight: fn(
            self: *const IHTMLRuleStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_posRight: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_imeMode: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeMode: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyAlign: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyAlign: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyPosition: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyPosition: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rubyOverhang: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyOverhang: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridChar: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridChar: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridLine: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridLine: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridMode: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridMode: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGridType: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridType: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutGrid: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGrid: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAutospace: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAutospace: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordBreak: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordBreak: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineBreak: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineBreak: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustify: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustify: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textJustifyTrim: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustifyTrim: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashida: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashida: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowX: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowX: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_overflowY: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowY: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accelerator: fn(
            self: *const IHTMLRuleStyle2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accelerator: fn(
            self: *const IHTMLRuleStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_tableLayout(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_tableLayout(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_borderCollapse(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_borderCollapse(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_direction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_direction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_behavior(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_behavior(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_position(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_position(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_position(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_unicodeBidi(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_unicodeBidi(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_bottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_right(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_right(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_right(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_pixelBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_pixelBottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_pixelBottom(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_pixelBottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_pixelRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_pixelRight(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_pixelRight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_pixelRight(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_posBottom(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_posBottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_posBottom(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_posBottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_posRight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_posRight(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_posRight(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_posRight(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_imeMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_imeMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyPosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyOverhang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyOverhang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridChar(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridLine(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGrid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGrid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textAutospace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textAutospace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_wordBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_wordBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_lineBreak(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_lineBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textJustify(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textJustify(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textJustifyTrim(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textJustifyTrim(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textKashida(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_overflowX(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_overflowX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_overflowY(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_overflowY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_accelerator(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_accelerator(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle3_Value = @import("../zig.zig").Guid.initString("3050f657-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle3 = &IID_IHTMLRuleStyle3_Value;
pub const IHTMLRuleStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_layoutFlow: fn(
            self: *const IHTMLRuleStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutFlow: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_zoom: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoom: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wordWrap: fn(
            self: *const IHTMLRuleStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordWrap: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textUnderlinePosition: fn(
            self: *const IHTMLRuleStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textUnderlinePosition: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarBaseColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarBaseColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarFaceColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarFaceColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarArrowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarArrowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbarTrackColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarTrackColor: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_writingMode: fn(
            self: *const IHTMLRuleStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_writingMode: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlignLast: fn(
            self: *const IHTMLRuleStyle3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlignLast: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textKashidaSpace: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashidaSpace: fn(
            self: *const IHTMLRuleStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_layoutFlow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_layoutFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_zoom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_wordWrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_wordWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textUnderlinePosition(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textUnderlinePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarBaseColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarFaceColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbar3dLightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarHighlightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarDarkShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarArrowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarTrackColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_writingMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_writingMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textAlignLast(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textAlignLast(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textKashidaSpace(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle4_Value = @import("../zig.zig").Guid.initString("3050f817-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle4 = &IID_IHTMLRuleStyle4_Value;
pub const IHTMLRuleStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textOverflow: fn(
            self: *const IHTMLRuleStyle4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textOverflow: fn(
            self: *const IHTMLRuleStyle4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minHeight: fn(
            self: *const IHTMLRuleStyle4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minHeight: fn(
            self: *const IHTMLRuleStyle4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_put_textOverflow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLRuleStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_get_textOverflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLRuleStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLRuleStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_get_minHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLRuleStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle5_Value = @import("../zig.zig").Guid.initString("3050f335-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle5 = &IID_IHTMLRuleStyle5_Value;
pub const IHTMLRuleStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msInterpolationMode: fn(
            self: *const IHTMLRuleStyle5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msInterpolationMode: fn(
            self: *const IHTMLRuleStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxHeight: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxHeight: fn(
            self: *const IHTMLRuleStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minWidth: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minWidth: fn(
            self: *const IHTMLRuleStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxWidth: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxWidth: fn(
            self: *const IHTMLRuleStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_msInterpolationMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_msInterpolationMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_maxHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_minWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_maxWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle6_Value = @import("../zig.zig").Guid.initString("30510471-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRuleStyle6 = &IID_IHTMLRuleStyle6_Value;
pub const IHTMLRuleStyle6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_content: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_content: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_captionSide: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_captionSide: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterIncrement: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterIncrement: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_counterReset: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_counterReset: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outline: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outline: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineWidth: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineWidth: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineStyle: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineStyle: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outlineColor: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineColor: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_boxSizing: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boxSizing: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderSpacing: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderSpacing: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_orphans: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orphans: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_widows: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_widows: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageBreakInside: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakInside: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_emptyCells: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_emptyCells: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msBlockProgression: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msBlockProgression: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_quotes: fn(
            self: *const IHTMLRuleStyle6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_quotes: fn(
            self: *const IHTMLRuleStyle6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_content(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_content(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_content(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_content(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_captionSide(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_captionSide(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_counterIncrement(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_counterIncrement(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_counterReset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_counterReset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_boxSizing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_boxSizing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_borderSpacing(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_borderSpacing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_orphans(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_widows(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_pageBreakInside(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_pageBreakInside(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_emptyCells(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_emptyCells(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_msBlockProgression(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_msBlockProgression(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_quotes(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_quotes(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyle_Value = @import("../zig.zig").Guid.initString("3050f55a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyle = &IID_DispHTMLStyle_Value;
pub const DispHTMLStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050f55c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLRuleStyle = &IID_DispHTMLRuleStyle_Value;
pub const DispHTMLRuleStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050f2e5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRulesCollection = &IID_IHTMLStyleSheetRulesCollection_Value;
pub const IHTMLStyleSheetRulesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStyleSheetRulesCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetRulesCollection,
            index: i32,
            ppHTMLStyleSheetRule: ?*?*IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection_item(self: *const T, index: i32, ppHTMLStyleSheetRule: ?*?*IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesCollection, self), index, ppHTMLStyleSheetRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050f2e3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheet = &IID_IHTMLStyleSheet_Value;
pub const IHTMLStyleSheet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_title: fn(
            self: *const IHTMLStyleSheet,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_title: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentStyleSheet: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_owningElement: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLStyleSheet,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLStyleSheet,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readOnly: fn(
            self: *const IHTMLStyleSheet,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imports: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?*IHTMLStyleSheetsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLStyleSheet,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_id: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addImport: fn(
            self: *const IHTMLStyleSheet,
            bstrURL: ?BSTR,
            lIndex: i32,
            plIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addRule: fn(
            self: *const IHTMLStyleSheet,
            bstrSelector: ?BSTR,
            bstrStyle: ?BSTR,
            lIndex: i32,
            plNewIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeImport: fn(
            self: *const IHTMLStyleSheet,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeRule: fn(
            self: *const IHTMLStyleSheet,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLStyleSheet,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssText: fn(
            self: *const IHTMLStyleSheet,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssText: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rules: fn(
            self: *const IHTMLStyleSheet,
            p: ?*?*IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_title(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_title(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_title(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_title(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_parentStyleSheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_parentStyleSheet(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_owningElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_owningElement(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_readOnly(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_imports(self: *const T, p: ?*?*IHTMLStyleSheetsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_imports(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_href(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_id(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_id(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_addImport(self: *const T, bstrURL: ?BSTR, lIndex: i32, plIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).addImport(@ptrCast(*const IHTMLStyleSheet, self), bstrURL, lIndex, plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_addRule(self: *const T, bstrSelector: ?BSTR, bstrStyle: ?BSTR, lIndex: i32, plNewIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).addRule(@ptrCast(*const IHTMLStyleSheet, self), bstrSelector, bstrStyle, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_removeImport(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).removeImport(@ptrCast(*const IHTMLStyleSheet, self), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_removeRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).removeRule(@ptrCast(*const IHTMLStyleSheet, self), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_media(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_cssText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_cssText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_rules(self: *const T, p: ?*?*IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_rules(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSRule_Value = @import("../zig.zig").Guid.initString("305106e9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSRule = &IID_IHTMLCSSRule_Value;
pub const IHTMLCSSRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLCSSRule,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cssText: fn(
            self: *const IHTMLCSSRule,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssText: fn(
            self: *const IHTMLCSSRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentRule: fn(
            self: *const IHTMLCSSRule,
            p: ?*?*IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentStyleSheet: fn(
            self: *const IHTMLCSSRule,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_type(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_type(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_put_cssText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLCSSRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_cssText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_parentRule(self: *const T, p: ?*?*IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_parentRule(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_parentStyleSheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_parentStyleSheet(@ptrCast(*const IHTMLCSSRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("305106ea-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSImportRule = &IID_IHTMLCSSImportRule_Value;
pub const IHTMLCSSImportRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLCSSImportRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLCSSImportRule,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLCSSImportRule,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleSheet: fn(
            self: *const IHTMLCSSImportRule,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_href(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_put_media(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).put_media(@ptrCast(*const IHTMLCSSImportRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_media(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_media(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_styleSheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("305106eb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSMediaRule = &IID_IHTMLCSSMediaRule_Value;
pub const IHTMLCSSMediaRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLCSSMediaRule,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLCSSMediaRule,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssRules: fn(
            self: *const IHTMLCSSMediaRule,
            p: ?*?*IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRule: fn(
            self: *const IHTMLCSSMediaRule,
            bstrRule: ?BSTR,
            lIndex: i32,
            plNewIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLCSSMediaRule,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_put_media(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).put_media(@ptrCast(*const IHTMLCSSMediaRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_get_media(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).get_media(@ptrCast(*const IHTMLCSSMediaRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_get_cssRules(self: *const T, p: ?*?*IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLCSSMediaRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_insertRule(self: *const T, bstrRule: ?BSTR, lIndex: i32, plNewIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).insertRule(@ptrCast(*const IHTMLCSSMediaRule, self), bstrRule, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_deleteRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLCSSMediaRule, self), lIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30510731-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSMediaList = &IID_IHTMLCSSMediaList_Value;
pub const IHTMLCSSMediaList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_mediaText: fn(
            self: *const IHTMLCSSMediaList,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mediaText: fn(
            self: *const IHTMLCSSMediaList,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLCSSMediaList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLCSSMediaList,
            index: i32,
            pbstrMedium: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendMedium: fn(
            self: *const IHTMLCSSMediaList,
            bstrMedium: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteMedium: fn(
            self: *const IHTMLCSSMediaList,
            bstrMedium: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_put_mediaText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).put_mediaText(@ptrCast(*const IHTMLCSSMediaList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_get_mediaText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).get_mediaText(@ptrCast(*const IHTMLCSSMediaList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCSSMediaList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_item(self: *const T, index: i32, pbstrMedium: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).item(@ptrCast(*const IHTMLCSSMediaList, self), index, pbstrMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_appendMedium(self: *const T, bstrMedium: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).appendMedium(@ptrCast(*const IHTMLCSSMediaList, self), bstrMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_deleteMedium(self: *const T, bstrMedium: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).deleteMedium(@ptrCast(*const IHTMLCSSMediaList, self), bstrMedium);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("305106ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCSSNamespaceRule = &IID_IHTMLCSSNamespaceRule_Value;
pub const IHTMLCSSNamespaceRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: fn(
            self: *const IHTMLCSSNamespaceRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prefix: fn(
            self: *const IHTMLCSSNamespaceRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSNamespaceRule_get_namespaceURI(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSNamespaceRule.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IHTMLCSSNamespaceRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSNamespaceRule_get_prefix(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSNamespaceRule.VTable, self.vtable).get_prefix(@ptrCast(*const IHTMLCSSNamespaceRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("3051080c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMSCSSKeyframeRule = &IID_IHTMLMSCSSKeyframeRule_Value;
pub const IHTMLMSCSSKeyframeRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_keyText: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_keyText: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            p: ?*?*IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_put_keyText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).put_keyText(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_get_keyText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).get_keyText(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_get_style(self: *const T, p: ?*?*IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).get_style(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("3051080d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMSCSSKeyframesRule = &IID_IHTMLMSCSSKeyframesRule_Value;
pub const IHTMLMSCSSKeyframesRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssRules: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            p: ?*?*IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrRule: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrKey: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        findRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrKey: ?BSTR,
            ppMSKeyframeRule: ?*?*IHTMLMSCSSKeyframeRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_get_cssRules(self: *const T, p: ?*?*IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_appendRule(self: *const T, bstrRule: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).appendRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_deleteRule(self: *const T, bstrKey: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_findRule(self: *const T, bstrKey: ?BSTR, ppMSKeyframeRule: ?*?*IHTMLMSCSSKeyframeRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).findRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrKey, ppMSKeyframeRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSRule_Value = @import("../zig.zig").Guid.initString("3059007d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSRule = &IID_DispHTMLCSSRule_Value;
pub const DispHTMLCSSRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("3059007e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSImportRule = &IID_DispHTMLCSSImportRule_Value;
pub const DispHTMLCSSImportRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("3059007f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSMediaRule = &IID_DispHTMLCSSMediaRule_Value;
pub const DispHTMLCSSMediaRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30590097-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSMediaList = &IID_DispHTMLCSSMediaList_Value;
pub const DispHTMLCSSMediaList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("30590080-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCSSNamespaceRule = &IID_DispHTMLCSSNamespaceRule_Value;
pub const DispHTMLCSSNamespaceRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("305900de-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMSCSSKeyframeRule = &IID_DispHTMLMSCSSKeyframeRule_Value;
pub const DispHTMLMSCSSKeyframeRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("305900df-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMSCSSKeyframesRule = &IID_DispHTMLMSCSSKeyframesRule_Value;
pub const DispHTMLMSCSSKeyframesRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050f6ae-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRenderStyle = &IID_IHTMLRenderStyle_Value;
pub const IHTMLRenderStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textLineThroughStyle: fn(
            self: *const IHTMLRenderStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textLineThroughStyle: fn(
            self: *const IHTMLRenderStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textUnderlineStyle: fn(
            self: *const IHTMLRenderStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textUnderlineStyle: fn(
            self: *const IHTMLRenderStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textEffect: fn(
            self: *const IHTMLRenderStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textEffect: fn(
            self: *const IHTMLRenderStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textColor: fn(
            self: *const IHTMLRenderStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textBackgroundColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textBackgroundColor: fn(
            self: *const IHTMLRenderStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecorationColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecorationColor: fn(
            self: *const IHTMLRenderStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_renderingPriority: fn(
            self: *const IHTMLRenderStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_renderingPriority: fn(
            self: *const IHTMLRenderStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultTextSelection: fn(
            self: *const IHTMLRenderStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultTextSelection: fn(
            self: *const IHTMLRenderStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textDecoration: fn(
            self: *const IHTMLRenderStyle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecoration: fn(
            self: *const IHTMLRenderStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textLineThroughStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textLineThroughStyle(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textLineThroughStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textLineThroughStyle(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textUnderlineStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textUnderlineStyle(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textUnderlineStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textUnderlineStyle(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textEffect(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textEffect(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textEffect(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textEffect(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textBackgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textBackgroundColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textBackgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textBackgroundColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textDecorationColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textDecorationColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textDecorationColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textDecorationColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_renderingPriority(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_renderingPriority(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_renderingPriority(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_renderingPriority(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_defaultTextSelection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_defaultTextSelection(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_defaultTextSelection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_defaultTextSelection(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textDecoration(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textDecoration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050f58b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLRenderStyle = &IID_DispHTMLRenderStyle_Value;
pub const DispHTMLRenderStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050f3db-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCurrentStyle = &IID_IHTMLCurrentStyle_Value;
pub const IHTMLCurrentStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleFloat: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontFamily: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontVariant: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontWeight: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSize: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundImage: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionX: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundPositionY: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundRepeat: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderTopWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderRightWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderBottomWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderLeftWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_left: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingTop: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingRight: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paddingBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDecoration: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_display: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_visibility: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zIndex: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_letterSpacing: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineHeight: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textIndent: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_verticalAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundAttachment: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginTop: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginRight: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleType: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStylePosition: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_listStyleImage: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipTop: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipRight: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflow: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakBefore: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakAfter: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cursor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tableLayout: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderCollapse: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behavior: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLCurrentStyle,
            strAttributeName: ?BSTR,
            lFlags: i32,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unicodeBidi: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_right: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottom: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeMode: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyPosition: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rubyOverhang: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAutospace: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineBreak: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordBreak: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustify: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textJustifyTrim: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashida: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_blockDirection: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridChar: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridLine: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridMode: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutGridType: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_padding: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_margin: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accelerator: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowX: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overflowY: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textTransform: fn(
            self: *const IHTMLCurrentStyle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_position(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_styleFloat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontFamily(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontVariant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontWeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontSize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundPositionX(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundPositionY(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundRepeat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_left(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_top(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textDecoration(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_display(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_visibility(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_zIndex(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_letterSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_lineHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textIndent(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_verticalAlign(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundAttachment(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStyleType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStylePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStyleImage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipRight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipBottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_pageBreakBefore(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_pageBreakAfter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_cursor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_tableLayout(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderCollapse(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_direction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_behavior(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_getAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLCurrentStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_unicodeBidi(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_right(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_right(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_bottom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_imeMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyPosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyOverhang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textAutospace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_lineBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_wordBreak(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textJustify(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textJustifyTrim(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textKashida(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_blockDirection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_blockDirection(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridChar(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridLine(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderColor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderWidth(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_padding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_margin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_accelerator(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflowX(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflowY(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textTransform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle2_Value = @import("../zig.zig").Guid.initString("3050f658-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCurrentStyle2 = &IID_IHTMLCurrentStyle2_Value;
pub const IHTMLCurrentStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layoutFlow: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordWrap: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textUnderlinePosition: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hasLayout: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarBaseColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarFaceColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarShadowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarArrowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbarTrackColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_writingMode: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoom: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlignLast: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textKashidaSpace: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isBlock: fn(
            self: *const IHTMLCurrentStyle2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_layoutFlow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_wordWrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textUnderlinePosition(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_hasLayout(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_hasLayout(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarBaseColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarFaceColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbar3dLightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarHighlightColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarDarkShadowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarArrowColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarTrackColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_writingMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_zoom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_filter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textAlignLast(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textKashidaSpace(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_isBlock(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_isBlock(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle3_Value = @import("../zig.zig").Guid.initString("3050f818-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCurrentStyle3 = &IID_IHTMLCurrentStyle3_Value;
pub const IHTMLCurrentStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textOverflow: fn(
            self: *const IHTMLCurrentStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minHeight: fn(
            self: *const IHTMLCurrentStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wordSpacing: fn(
            self: *const IHTMLCurrentStyle3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whiteSpace: fn(
            self: *const IHTMLCurrentStyle3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_textOverflow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_minHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_wordSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_whiteSpace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle4_Value = @import("../zig.zig").Guid.initString("3050f33b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCurrentStyle4 = &IID_IHTMLCurrentStyle4_Value;
pub const IHTMLCurrentStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msInterpolationMode: fn(
            self: *const IHTMLCurrentStyle4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxHeight: fn(
            self: *const IHTMLCurrentStyle4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minWidth: fn(
            self: *const IHTMLCurrentStyle4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxWidth: fn(
            self: *const IHTMLCurrentStyle4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_msInterpolationMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_maxHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_minWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_maxWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle5_Value = @import("../zig.zig").Guid.initString("30510481-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCurrentStyle5 = &IID_IHTMLCurrentStyle5_Value;
pub const IHTMLCurrentStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_captionSide: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outline: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineWidth: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineStyle: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outlineColor: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boxSizing: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderSpacing: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orphans: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_widows: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageBreakInside: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_emptyCells: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msBlockProgression: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_quotes: fn(
            self: *const IHTMLCurrentStyle5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_captionSide(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_boxSizing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_borderSpacing(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_orphans(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_widows(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_pageBreakInside(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_emptyCells(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_msBlockProgression(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_quotes(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050f557-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCurrentStyle = &IID_DispHTMLCurrentStyle_Value;
pub const DispHTMLCurrentStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement_Value = @import("../zig.zig").Guid.initString("3050f1ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement = &IID_IHTMLElement_Value;
pub const IHTMLElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: ?BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: ?BSTR,
            lFlags: i32,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: ?BSTR,
            lFlags: i32,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_className: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_className: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_id: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_id: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentElement: fn(
            self: *const IHTMLElement,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLElement,
            p: ?*?*IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhelp: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhelp: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onclick: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onclick: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondblclick: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondblclick: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeydown: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeydown: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeyup: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeyup: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeypress: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeypress: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseout: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseout: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseover: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseover: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousemove: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousemove: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousedown: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousedown: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseup: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseup: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTMLElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_title: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_title: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_language: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_language: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselectstart: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselectstart: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLElement,
            varargStart: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        contains: fn(
            self: *const IHTMLElement,
            pChild: ?*IHTMLElement,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sourceIndex: fn(
            self: *const IHTMLElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_recordNumber: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lang: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lang: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetLeft: fn(
            self: *const IHTMLElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetTop: fn(
            self: *const IHTMLElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetWidth: fn(
            self: *const IHTMLElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetHeight: fn(
            self: *const IHTMLElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetParent: fn(
            self: *const IHTMLElement,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_innerHTML: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_innerHTML: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_innerText: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_innerText: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outerHTML: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outerHTML: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_outerText: fn(
            self: *const IHTMLElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outerText: fn(
            self: *const IHTMLElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentHTML: fn(
            self: *const IHTMLElement,
            where: ?BSTR,
            html: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentText: fn(
            self: *const IHTMLElement,
            where: ?BSTR,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentTextEdit: fn(
            self: *const IHTMLElement,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isTextEdit: fn(
            self: *const IHTMLElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        click: fn(
            self: *const IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filters: fn(
            self: *const IHTMLElement,
            p: ?*?*IHTMLFiltersCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragstart: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragstart: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLElement,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeupdate: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onafterupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onafterupdate: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerrorupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerrorupdate: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowexit: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowexit: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowenter: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowenter: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondatasetchanged: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondatasetchanged: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondataavailable: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondataavailable: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondatasetcomplete: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondatasetcomplete: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfilterchange: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfilterchange: fn(
            self: *const IHTMLElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_children: fn(
            self: *const IHTMLElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_all: fn(
            self: *const IHTMLElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_setAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_getAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_removeAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_className(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_className(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_className(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_className(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_id(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_id(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_id(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_id(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_tagName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_tagName(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_parentElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_parentElement(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_style(self: *const T, p: ?*?*IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_style(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onhelp(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondblclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeydown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeyup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeypress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmousemove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmousedown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_document(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_document(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_title(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_title(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_title(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_title(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_language(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_language(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_language(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_language(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onselectstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onselectstart(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onselectstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onselectstart(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_scrollIntoView(self: *const T, varargStart: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLElement, self), varargStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_contains(self: *const T, pChild: ?*IHTMLElement, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).contains(@ptrCast(*const IHTMLElement, self), pChild, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_sourceIndex(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_sourceIndex(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_recordNumber(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_recordNumber(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_lang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_lang(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_lang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_lang(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetLeft(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetTop(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetWidth(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetHeight(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetParent(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetParent(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_innerHTML(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_innerHTML(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_innerHTML(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_innerHTML(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_innerText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_innerText(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_innerText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_innerText(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_outerHTML(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_outerHTML(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_outerHTML(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_outerHTML(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_outerText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_outerText(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_outerText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_outerText(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_insertAdjacentHTML(self: *const T, where: ?BSTR, html: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).insertAdjacentHTML(@ptrCast(*const IHTMLElement, self), where, html);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_insertAdjacentText(self: *const T, where: ?BSTR, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).insertAdjacentText(@ptrCast(*const IHTMLElement, self), where, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_parentTextEdit(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_parentTextEdit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_isTextEdit(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_isTextEdit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_click(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).click(@ptrCast(*const IHTMLElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_filters(self: *const T, p: ?*?*IHTMLFiltersCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_filters(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondragstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).toString(@ptrCast(*const IHTMLElement, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onbeforeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onbeforeupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onbeforeupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onbeforeupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onafterupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onafterupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onafterupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onafterupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onerrorupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onerrorupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onerrorupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onerrorupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onrowexit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onrowexit(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onrowexit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onrowexit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onrowenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onrowenter(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onrowenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onrowenter(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondatasetchanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondatasetchanged(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondatasetchanged(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondatasetchanged(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondataavailable(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondataavailable(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondataavailable(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondatasetcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondatasetcomplete(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondatasetcomplete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondatasetcomplete(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onfilterchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onfilterchange(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onfilterchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onfilterchange(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_children(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_children(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_all(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_all(@ptrCast(*const IHTMLElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRect_Value = @import("../zig.zig").Guid.initString("3050f4a3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRect = &IID_IHTMLRect_Value;
pub const IHTMLRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_left: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_left: fn(
            self: *const IHTMLRect,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_top: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLRect,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_right: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_right: fn(
            self: *const IHTMLRect,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bottom: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottom: fn(
            self: *const IHTMLRect,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_left(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_left(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_left(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_left(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_top(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_top(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_top(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_top(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_right(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_right(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_right(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_right(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_bottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_bottom(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRect2_Value = @import("../zig.zig").Guid.initString("3051076c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRect2 = &IID_IHTMLRect2_Value;
pub const IHTMLRect2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLRect2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLRect2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect2_get_width(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLRect2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect2_get_height(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLRect2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRectCollection_Value = @import("../zig.zig").Guid.initString("3050f4a4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLRectCollection = &IID_IHTMLRectCollection_Value;
pub const IHTMLRectCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLRectCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLRectCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLRectCollection,
            pvarIndex: ?*VARIANT,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLRectCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLRectCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_item(self: *const T, pvarIndex: ?*VARIANT, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLRectCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050f21f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementCollection = &IID_IHTMLElementCollection_Value;
pub const IHTMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        toString: fn(
            self: *const IHTMLElementCollection,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: fn(
            self: *const IHTMLElementCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLElementCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLElementCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLElementCollection,
            name: VARIANT,
            index: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLElementCollection,
            tagName: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).toString(@ptrCast(*const IHTMLElementCollection, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).put_length(@ptrCast(*const IHTMLElementCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLElementCollection, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_tags(self: *const T, tagName: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).tags(@ptrCast(*const IHTMLElementCollection, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement2_Value = @import("../zig.zig").Guid.initString("3050f434-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement2 = &IID_IHTMLElement2_Value;
pub const IHTMLElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scopeName: fn(
            self: *const IHTMLElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setCapture: fn(
            self: *const IHTMLElement2,
            containerCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        releaseCapture: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onlosecapture: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onlosecapture: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        componentFromPoint: fn(
            self: *const IHTMLElement2,
            x: i32,
            y: i32,
            component: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doScroll: fn(
            self: *const IHTMLElement2,
            component: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onscroll: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onscroll: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrag: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrag: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragend: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragend: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragenter: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragenter: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragover: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragover: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragleave: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragleave: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrop: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrop: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforecut: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforecut: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncut: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncut: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforecopy: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforecopy: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncopy: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncopy: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforepaste: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforepaste: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpaste: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpaste: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentStyle: fn(
            self: *const IHTMLElement2,
            p: ?*?*IHTMLCurrentStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpropertychange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpropertychange: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getClientRects: fn(
            self: *const IHTMLElement2,
            pRectCol: ?*?*IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLElement2,
            pRect: ?*?*IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setExpression: fn(
            self: *const IHTMLElement2,
            propname: ?BSTR,
            expression: ?BSTR,
            language: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExpression: fn(
            self: *const IHTMLElement2,
            propname: ?BSTR,
            expression: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeExpression: fn(
            self: *const IHTMLElement2,
            propname: ?BSTR,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tabIndex: fn(
            self: *const IHTMLElement2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tabIndex: fn(
            self: *const IHTMLElement2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accessKey: fn(
            self: *const IHTMLElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accessKey: fn(
            self: *const IHTMLElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onresize: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onresize: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addFilter: fn(
            self: *const IHTMLElement2,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeFilter: fn(
            self: *const IHTMLElement2,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientHeight: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientWidth: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientTop: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientLeft: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLElement2,
            event: ?BSTR,
            pDisp: ?*IDispatch,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLElement2,
            event: ?BSTR,
            pDisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowsdelete: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowsdelete: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowsinserted: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowsinserted: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncellchange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncellchange: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dir: fn(
            self: *const IHTMLElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dir: fn(
            self: *const IHTMLElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createControlRange: fn(
            self: *const IHTMLElement2,
            range: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollHeight: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollWidth: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollTop: fn(
            self: *const IHTMLElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollTop: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollLeft: fn(
            self: *const IHTMLElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollLeft: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearAttributes: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        mergeAttributes: fn(
            self: *const IHTMLElement2,
            mergeThis: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncontextmenu: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncontextmenu: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentElement: fn(
            self: *const IHTMLElement2,
            where: ?BSTR,
            insertedElement: ?*IHTMLElement,
            inserted: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        applyElement: fn(
            self: *const IHTMLElement2,
            apply: ?*IHTMLElement,
            where: ?BSTR,
            applied: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAdjacentText: fn(
            self: *const IHTMLElement2,
            where: ?BSTR,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceAdjacentText: fn(
            self: *const IHTMLElement2,
            where: ?BSTR,
            newText: ?BSTR,
            oldText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_canHaveChildren: fn(
            self: *const IHTMLElement2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addBehavior: fn(
            self: *const IHTMLElement2,
            bstrUrl: ?BSTR,
            pvarFactory: ?*VARIANT,
            pCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeBehavior: fn(
            self: *const IHTMLElement2,
            cookie: i32,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_runtimeStyle: fn(
            self: *const IHTMLElement2,
            p: ?*?*IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behaviorUrns: fn(
            self: *const IHTMLElement2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tagUrn: fn(
            self: *const IHTMLElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagUrn: fn(
            self: *const IHTMLElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeeditfocus: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeeditfocus: fn(
            self: *const IHTMLElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyStateValue: fn(
            self: *const IHTMLElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IHTMLElement2,
            v: ?BSTR,
            pelColl: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scopeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scopeName(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_setCapture(self: *const T, containerCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).setCapture(@ptrCast(*const IHTMLElement2, self), containerCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_releaseCapture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).releaseCapture(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onlosecapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onlosecapture(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onlosecapture(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onlosecapture(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_componentFromPoint(self: *const T, x: i32, y: i32, component: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).componentFromPoint(@ptrCast(*const IHTMLElement2, self), x, y, component);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_doScroll(self: *const T, component: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).doScroll(@ptrCast(*const IHTMLElement2, self), component);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onscroll(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondrag(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragleave(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondrop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforecut(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforecut(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforecut(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforecut(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncut(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncut(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncut(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncut(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforecopy(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforecopy(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforecopy(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforecopy(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncopy(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncopy(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncopy(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncopy(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforepaste(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforepaste(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforepaste(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforepaste(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onpaste(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onpaste(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onpaste(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onpaste(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_currentStyle(self: *const T, p: ?*?*IHTMLCurrentStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_currentStyle(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onpropertychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onpropertychange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onpropertychange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onpropertychange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getClientRects(self: *const T, pRectCol: ?*?*IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLElement2, self), pRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getBoundingClientRect(self: *const T, pRect: ?*?*IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLElement2, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_setExpression(self: *const T, propname: ?BSTR, expression: ?BSTR, language: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).setExpression(@ptrCast(*const IHTMLElement2, self), propname, expression, language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getExpression(self: *const T, propname: ?BSTR, expression: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getExpression(@ptrCast(*const IHTMLElement2, self), propname, expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeExpression(self: *const T, propname: ?BSTR, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeExpression(@ptrCast(*const IHTMLElement2, self), propname, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_tabIndex(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).focus(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_accessKey(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_accessKey(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onresize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).blur(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_addFilter(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).addFilter(@ptrCast(*const IHTMLElement2, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeFilter(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeFilter(@ptrCast(*const IHTMLElement2, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_attachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLElement2, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_detachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLElement2, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_readyState(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onrowsdelete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onrowsdelete(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onrowsdelete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onrowsdelete(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onrowsinserted(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onrowsinserted(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onrowsinserted(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onrowsinserted(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncellchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncellchange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncellchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncellchange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_dir(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_dir(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_createControlRange(self: *const T, range: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).createControlRange(@ptrCast(*const IHTMLElement2, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollHeight(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollWidth(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_scrollTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_scrollTop(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollTop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_scrollLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_scrollLeft(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollLeft(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_clearAttributes(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).clearAttributes(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_mergeAttributes(self: *const T, mergeThis: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).mergeAttributes(@ptrCast(*const IHTMLElement2, self), mergeThis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncontextmenu(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_insertAdjacentElement(self: *const T, where: ?BSTR, insertedElement: ?*IHTMLElement, inserted: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).insertAdjacentElement(@ptrCast(*const IHTMLElement2, self), where, insertedElement, inserted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_applyElement(self: *const T, apply: ?*IHTMLElement, where: ?BSTR, applied: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).applyElement(@ptrCast(*const IHTMLElement2, self), apply, where, applied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getAdjacentText(self: *const T, where: ?BSTR, text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getAdjacentText(@ptrCast(*const IHTMLElement2, self), where, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_replaceAdjacentText(self: *const T, where: ?BSTR, newText: ?BSTR, oldText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).replaceAdjacentText(@ptrCast(*const IHTMLElement2, self), where, newText, oldText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_canHaveChildren(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_canHaveChildren(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_addBehavior(self: *const T, bstrUrl: ?BSTR, pvarFactory: ?*VARIANT, pCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).addBehavior(@ptrCast(*const IHTMLElement2, self), bstrUrl, pvarFactory, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeBehavior(self: *const T, cookie: i32, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeBehavior(@ptrCast(*const IHTMLElement2, self), cookie, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_runtimeStyle(self: *const T, p: ?*?*IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_runtimeStyle(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_behaviorUrns(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_behaviorUrns(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_tagUrn(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_tagUrn(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_tagUrn(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_tagUrn(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforeeditfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforeeditfocus(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforeeditfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforeeditfocus(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_readyStateValue(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_readyStateValue(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getElementsByTagName(self: *const T, v: ?BSTR, pelColl: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IHTMLElement2, self), v, pelColl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection3_Value = @import("../zig.zig").Guid.initString("30510469-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAttributeCollection3 = &IID_IHTMLAttributeCollection3_Value;
pub const IHTMLAttributeCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            pNodeIn: ?*IHTMLDOMAttribute,
            ppNodeOut: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection3,
            index: i32,
            ppNodeOut: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLAttributeCollection3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_getNamedItem(self: *const T, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_setNamedItem(self: *const T, pNodeIn: ?*IHTMLDOMAttribute, ppNodeOut: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_removeNamedItem(self: *const T, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_item(self: *const T, index: i32, ppNodeOut: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection3, self), index, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMDocumentType_Value = @import("../zig.zig").Guid.initString("30510738-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMDocumentType = &IID_IDOMDocumentType_Value;
pub const IDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IDOMDocumentType,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entities: fn(
            self: *const IDOMDocumentType,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notations: fn(
            self: *const IDOMDocumentType,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: fn(
            self: *const IDOMDocumentType,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: fn(
            self: *const IDOMDocumentType,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_internalSubset: fn(
            self: *const IDOMDocumentType,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_name(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_entities(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_entities(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_notations(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_notations(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_publicId(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_publicId(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_systemId(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_systemId(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_internalSubset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_internalSubset(@ptrCast(*const IDOMDocumentType, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument7_Value = @import("../zig.zig").Guid.initString("305104b8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument7 = &IID_IHTMLDocument7_Value;
pub const IHTMLDocument7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultView: fn(
            self: *const IHTMLDocument7,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCDATASection: fn(
            self: *const IHTMLDocument7,
            text: ?BSTR,
            newCDATASectionNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSelection: fn(
            self: *const IHTMLDocument7,
            ppIHTMLSelection: ?*?*IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagNameNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: ?*VARIANT,
            bstrLocalName: ?BSTR,
            pelColl: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElementNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: ?*VARIANT,
            bstrTag: ?BSTR,
            newElem: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttributeNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: ?*VARIANT,
            bstrAttrName: ?BSTR,
            ppAttribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsthumbnailclick: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsthumbnailclick: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_characterSet: fn(
            self: *const IHTMLDocument7,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IHTMLDocument7,
            bstrTag: ?BSTR,
            newElem: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IHTMLDocument7,
            bstrAttrName: ?BSTR,
            ppAttribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByClassName: fn(
            self: *const IHTMLDocument7,
            v: ?BSTR,
            pel: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createProcessingInstruction: fn(
            self: *const IHTMLDocument7,
            bstrTarget: ?BSTR,
            bstrData: ?BSTR,
            newProcessingInstruction: ?*?*IDOMProcessingInstruction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        adoptNode: fn(
            self: *const IHTMLDocument7,
            pNodeSource: ?*IHTMLDOMNode,
            ppNodeDest: ?*?*IHTMLDOMNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmssitemodejumplistitemremoved: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmssitemodejumplistitemremoved: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_all: fn(
            self: *const IHTMLDocument7,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inputEncoding: fn(
            self: *const IHTMLDocument7,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmlEncoding: fn(
            self: *const IHTMLDocument7,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmlStandalone: fn(
            self: *const IHTMLDocument7,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmlStandalone: fn(
            self: *const IHTMLDocument7,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmlVersion: fn(
            self: *const IHTMLDocument7,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmlVersion: fn(
            self: *const IHTMLDocument7,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDocument7,
            pfHasAttributes: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplay: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplay: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplaythrough: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplaythrough: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrag: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrag: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragend: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragend: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragenter: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragenter: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragleave: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragleave: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragover: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragover: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrop: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrop: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondurationchange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondurationchange: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onemptied: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onemptied: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onended: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onended: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oninput: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oninput: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadeddata: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadeddata: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadedmetadata: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadedmetadata: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadstart: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadstart: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpause: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpause: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplay: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplay: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplaying: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplaying: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onprogress: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onprogress: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onratechange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onratechange: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreset: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreset: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onscroll: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onscroll: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeked: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeked: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeking: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeking: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstalled: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstalled: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsubmit: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsubmit: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsuspend: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsuspend: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontimeupdate: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ontimeupdate: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onvolumechange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onvolumechange: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onwaiting: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onwaiting: fn(
            self: *const IHTMLDocument7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        importNode: fn(
            self: *const IHTMLDocument7,
            pNodeSource: ?*IHTMLDOMNode,
            fDeep: i16,
            ppNodeDest: ?*?*IHTMLDOMNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentWindow: fn(
            self: *const IHTMLDocument7,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_body: fn(
            self: *const IHTMLDocument7,
            v: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_body: fn(
            self: *const IHTMLDocument7,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_head: fn(
            self: *const IHTMLDocument7,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_defaultView(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_defaultView(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createCDATASection(self: *const T, text: ?BSTR, newCDATASectionNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createCDATASection(@ptrCast(*const IHTMLDocument7, self), text, newCDATASectionNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getSelection(self: *const T, ppIHTMLSelection: ?*?*IHTMLSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getSelection(@ptrCast(*const IHTMLDocument7, self), ppIHTMLSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getElementsByTagNameNS(self: *const T, pvarNS: ?*VARIANT, bstrLocalName: ?BSTR, pelColl: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getElementsByTagNameNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrLocalName, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createElementNS(self: *const T, pvarNS: ?*VARIANT, bstrTag: ?BSTR, newElem: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createElementNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createAttributeNS(self: *const T, pvarNS: ?*VARIANT, bstrAttrName: ?BSTR, ppAttribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createAttributeNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrAttrName, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onmsthumbnailclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onmsthumbnailclick(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onmsthumbnailclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onmsthumbnailclick(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_characterSet(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_characterSet(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createElement(self: *const T, bstrTag: ?BSTR, newElem: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createElement(@ptrCast(*const IHTMLDocument7, self), bstrTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createAttribute(self: *const T, bstrAttrName: ?BSTR, ppAttribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createAttribute(@ptrCast(*const IHTMLDocument7, self), bstrAttrName, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getElementsByClassName(self: *const T, v: ?BSTR, pel: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getElementsByClassName(@ptrCast(*const IHTMLDocument7, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createProcessingInstruction(self: *const T, bstrTarget: ?BSTR, bstrData: ?BSTR, newProcessingInstruction: ?*?*IDOMProcessingInstruction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createProcessingInstruction(@ptrCast(*const IHTMLDocument7, self), bstrTarget, bstrData, newProcessingInstruction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_adoptNode(self: *const T, pNodeSource: ?*IHTMLDOMNode, ppNodeDest: ?*?*IHTMLDOMNode3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).adoptNode(@ptrCast(*const IHTMLDocument7, self), pNodeSource, ppNodeDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onmssitemodejumplistitemremoved(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onmssitemodejumplistitemremoved(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onmssitemodejumplistitemremoved(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onmssitemodejumplistitemremoved(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_all(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_all(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_inputEncoding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_inputEncoding(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlEncoding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlEncoding(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_xmlStandalone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_xmlStandalone(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlStandalone(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlStandalone(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_xmlVersion(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_xmlVersion(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlVersion(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlVersion(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_hasAttributes(self: *const T, pfHasAttributes: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDocument7, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oncanplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oncanplaythrough(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondrag(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragleave(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondrop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondurationchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onemptied(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onended(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oninput(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadeddata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadedmetadata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onpause(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onplaying(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onprogress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onratechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onreset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onscroll(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onseeked(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onseeking(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onstalled(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onsubmit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onsuspend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ontimeupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onvolumechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onwaiting(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDocument7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_importNode(self: *const T, pNodeSource: ?*IHTMLDOMNode, fDeep: i16, ppNodeDest: ?*?*IHTMLDOMNode3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).importNode(@ptrCast(*const IHTMLDocument7, self), pNodeSource, fDeep, ppNodeDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_parentWindow(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_parentWindow(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_putref_body(self: *const T, v: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).putref_body(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_body(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_body(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_head(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_head(@ptrCast(*const IHTMLDocument7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode_Value = @import("../zig.zig").Guid.initString("3050f5da-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMNode = &IID_IHTMLDOMNode_Value;
pub const IHTMLDOMNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeType: fn(
            self: *const IHTMLDOMNode,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentNode: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMNode,
            fChildren: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMNode,
            newChild: ?*IHTMLDOMNode,
            refChild: VARIANT,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMNode,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMNode,
            newChild: ?*IHTMLDOMNode,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IHTMLDOMNode,
            fDeep: i16,
            clonedNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNode: fn(
            self: *const IHTMLDOMNode,
            fDeep: i16,
            removed: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        swapNode: fn(
            self: *const IHTMLDOMNode,
            otherNode: ?*IHTMLDOMNode,
            swappedNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceNode: fn(
            self: *const IHTMLDOMNode,
            replacement: ?*IHTMLDOMNode,
            replaced: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMNode,
            newChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: fn(
            self: *const IHTMLDOMNode,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: fn(
            self: *const IHTMLDOMNode,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: fn(
            self: *const IHTMLDOMNode,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousSibling: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextSibling: fn(
            self: *const IHTMLDOMNode,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeType(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeType(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_parentNode(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_parentNode(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_hasChildNodes(self: *const T, fChildren: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMNode, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_childNodes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_attributes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_insertBefore(self: *const T, newChild: ?*IHTMLDOMNode, refChild: VARIANT, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMNode, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_removeChild(self: *const T, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMNode, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_replaceChild(self: *const T, newChild: ?*IHTMLDOMNode, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMNode, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_cloneNode(self: *const T, fDeep: i16, clonedNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).cloneNode(@ptrCast(*const IHTMLDOMNode, self), fDeep, clonedNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_removeNode(self: *const T, fDeep: i16, removed: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).removeNode(@ptrCast(*const IHTMLDOMNode, self), fDeep, removed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_swapNode(self: *const T, otherNode: ?*IHTMLDOMNode, swappedNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).swapNode(@ptrCast(*const IHTMLDOMNode, self), otherNode, swappedNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_replaceNode(self: *const T, replacement: ?*IHTMLDOMNode, replaced: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).replaceNode(@ptrCast(*const IHTMLDOMNode, self), replacement, replaced);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_appendChild(self: *const T, newChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMNode, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMNode, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_firstChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_lastChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_previousSibling(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_previousSibling(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nextSibling(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nextSibling(@ptrCast(*const IHTMLDOMNode, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode2_Value = @import("../zig.zig").Guid.initString("3050f80b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMNode2 = &IID_IHTMLDOMNode2_Value;
pub const IHTMLDOMNode2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerDocument: fn(
            self: *const IHTMLDOMNode2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode2_get_ownerDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode2.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IHTMLDOMNode2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode3_Value = @import("../zig.zig").Guid.initString("305106e0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMNode3 = &IID_IHTMLDOMNode3_Value;
pub const IHTMLDOMNode3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_prefix: fn(
            self: *const IHTMLDOMNode3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prefix: fn(
            self: *const IHTMLDOMNode3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_localName: fn(
            self: *const IHTMLDOMNode3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: fn(
            self: *const IHTMLDOMNode3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textContent: fn(
            self: *const IHTMLDOMNode3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textContent: fn(
            self: *const IHTMLDOMNode3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isEqualNode: fn(
            self: *const IHTMLDOMNode3,
            otherNode: ?*IHTMLDOMNode3,
            isEqual: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lookupNamespaceURI: fn(
            self: *const IHTMLDOMNode3,
            pvarPrefix: ?*VARIANT,
            pvarNamespaceURI: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lookupPrefix: fn(
            self: *const IHTMLDOMNode3,
            pvarNamespaceURI: ?*VARIANT,
            pvarPrefix: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isDefaultNamespace: fn(
            self: *const IHTMLDOMNode3,
            pvarNamespace: ?*VARIANT,
            pfDefaultNamespace: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMNode3,
            newChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMNode3,
            newChild: ?*IHTMLDOMNode,
            refChild: VARIANT,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMNode3,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMNode3,
            newChild: ?*IHTMLDOMNode,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isSameNode: fn(
            self: *const IHTMLDOMNode3,
            otherNode: ?*IHTMLDOMNode3,
            isSame: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareDocumentPosition: fn(
            self: *const IHTMLDOMNode3,
            otherNode: ?*IHTMLDOMNode,
            flags: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isSupported: fn(
            self: *const IHTMLDOMNode3,
            feature: ?BSTR,
            version: VARIANT,
            pfisSupported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_put_prefix(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).put_prefix(@ptrCast(*const IHTMLDOMNode3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_prefix(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_prefix(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_localName(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_localName(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_namespaceURI(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_put_textContent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).put_textContent(@ptrCast(*const IHTMLDOMNode3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_textContent(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_textContent(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isEqualNode(self: *const T, otherNode: ?*IHTMLDOMNode3, isEqual: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isEqualNode(@ptrCast(*const IHTMLDOMNode3, self), otherNode, isEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_lookupNamespaceURI(self: *const T, pvarPrefix: ?*VARIANT, pvarNamespaceURI: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).lookupNamespaceURI(@ptrCast(*const IHTMLDOMNode3, self), pvarPrefix, pvarNamespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_lookupPrefix(self: *const T, pvarNamespaceURI: ?*VARIANT, pvarPrefix: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).lookupPrefix(@ptrCast(*const IHTMLDOMNode3, self), pvarNamespaceURI, pvarPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isDefaultNamespace(self: *const T, pvarNamespace: ?*VARIANT, pfDefaultNamespace: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isDefaultNamespace(@ptrCast(*const IHTMLDOMNode3, self), pvarNamespace, pfDefaultNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_appendChild(self: *const T, newChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMNode3, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_insertBefore(self: *const T, newChild: ?*IHTMLDOMNode, refChild: VARIANT, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMNode3, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_removeChild(self: *const T, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMNode3, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_replaceChild(self: *const T, newChild: ?*IHTMLDOMNode, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMNode3, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isSameNode(self: *const T, otherNode: ?*IHTMLDOMNode3, isSame: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isSameNode(@ptrCast(*const IHTMLDOMNode3, self), otherNode, isSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_compareDocumentPosition(self: *const T, otherNode: ?*IHTMLDOMNode, flags: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).compareDocumentPosition(@ptrCast(*const IHTMLDOMNode3, self), otherNode, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isSupported(self: *const T, feature: ?BSTR, version: VARIANT, pfisSupported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isSupported(@ptrCast(*const IHTMLDOMNode3, self), feature, version, pfisSupported);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050f4b0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMAttribute = &IID_IHTMLDOMAttribute_Value;
pub const IHTMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: fn(
            self: *const IHTMLDOMAttribute,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_specified: fn(
            self: *const IHTMLDOMAttribute,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_nodeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_nodeValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_specified(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute2_Value = @import("../zig.zig").Guid.initString("3050f810-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMAttribute2 = &IID_IHTMLDOMAttribute2_Value;
pub const IHTMLDOMAttribute2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLDOMAttribute2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expando: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeType: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentNode: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousSibling: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextSibling: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerDocument: fn(
            self: *const IHTMLDOMAttribute2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: ?*IHTMLDOMNode,
            refChild: VARIANT,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: ?*IHTMLDOMNode,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMAttribute2,
            oldChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: ?*IHTMLDOMNode,
            node: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMAttribute2,
            fChildren: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IHTMLDOMAttribute2,
            fDeep: i16,
            clonedNode: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_expando(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_expando(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_nodeType(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_nodeType(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_parentNode(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_parentNode(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_childNodes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_firstChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_lastChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_previousSibling(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_previousSibling(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_nextSibling(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_nextSibling(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_attributes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_ownerDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_insertBefore(self: *const T, newChild: ?*IHTMLDOMNode, refChild: VARIANT, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_replaceChild(self: *const T, newChild: ?*IHTMLDOMNode, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_removeChild(self: *const T, oldChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMAttribute2, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_appendChild(self: *const T, newChild: ?*IHTMLDOMNode, node: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_hasChildNodes(self: *const T, fChildren: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMAttribute2, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_cloneNode(self: *const T, fDeep: i16, clonedNode: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).cloneNode(@ptrCast(*const IHTMLDOMAttribute2, self), fDeep, clonedNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute3_Value = @import("../zig.zig").Guid.initString("30510468-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMAttribute3 = &IID_IHTMLDOMAttribute3_Value;
pub const IHTMLDOMAttribute3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLDOMAttribute3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLDOMAttribute3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_specified: fn(
            self: *const IHTMLDOMAttribute3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerElement: fn(
            self: *const IHTMLDOMAttribute3,
            p: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_nodeValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_specified(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_ownerElement(self: *const T, p: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_ownerElement(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute4_Value = @import("../zig.zig").Guid.initString("305106f9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMAttribute4 = &IID_IHTMLDOMAttribute4_Value;
pub const IHTMLDOMAttribute4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLDOMAttribute4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDOMAttribute4,
            pfHasAttributes: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMAttribute4,
            fChildren: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDOMAttribute4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_specified: fn(
            self: *const IHTMLDOMAttribute4,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_nodeValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_nodeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_name(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_firstChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_lastChild(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_childNodes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_hasAttributes(self: *const T, pfHasAttributes: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDOMAttribute4, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_hasChildNodes(self: *const T, fChildren: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMAttribute4, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDOMAttribute4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_specified(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050f4b1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMTextNode = &IID_IHTMLDOMTextNode_Value;
pub const IHTMLDOMTextNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IHTMLDOMTextNode,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLDOMTextNode,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDOMTextNode,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLDOMTextNode,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        splitText: fn(
            self: *const IHTMLDOMTextNode,
            offset: i32,
            pRetNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).put_data(@ptrCast(*const IHTMLDOMTextNode, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).get_data(@ptrCast(*const IHTMLDOMTextNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).toString(@ptrCast(*const IHTMLDOMTextNode, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDOMTextNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_splitText(self: *const T, offset: i32, pRetNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).splitText(@ptrCast(*const IHTMLDOMTextNode, self), offset, pRetNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode2_Value = @import("../zig.zig").Guid.initString("3050f809-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMTextNode2 = &IID_IHTMLDOMTextNode2_Value;
pub const IHTMLDOMTextNode2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
            pbstrsubString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IHTMLDOMTextNode2,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).substringData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_appendData(self: *const T, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).appendData(@ptrCast(*const IHTMLDOMTextNode2, self), bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_insertData(self: *const T, offset: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).insertData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode3_Value = @import("../zig.zig").Guid.initString("3051073e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMTextNode3 = &IID_IHTMLDOMTextNode3_Value;
pub const IHTMLDOMTextNode3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
            pbstrsubString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        splitText: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            pRetNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wholeText: fn(
            self: *const IHTMLDOMTextNode3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceWholeText: fn(
            self: *const IHTMLDOMTextNode3,
            bstrText: ?BSTR,
            ppRetNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDOMTextNode3,
            pfHasAttributes: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDOMTextNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).substringData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_insertData(self: *const T, offset: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).insertData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_splitText(self: *const T, offset: i32, pRetNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).splitText(@ptrCast(*const IHTMLDOMTextNode3, self), offset, pRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_get_wholeText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).get_wholeText(@ptrCast(*const IHTMLDOMTextNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_replaceWholeText(self: *const T, bstrText: ?BSTR, ppRetNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).replaceWholeText(@ptrCast(*const IHTMLDOMTextNode3, self), bstrText, ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_hasAttributes(self: *const T, pfHasAttributes: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDOMTextNode3, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDOMTextNode3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050f80d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMImplementation = &IID_IHTMLDOMImplementation_Value;
pub const IHTMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        hasFeature: fn(
            self: *const IHTMLDOMImplementation,
            bstrfeature: ?BSTR,
            version: VARIANT,
            pfHasFeature: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation_hasFeature(self: *const T, bstrfeature: ?BSTR, version: VARIANT, pfHasFeature: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation.VTable, self.vtable).hasFeature(@ptrCast(*const IHTMLDOMImplementation, self), bstrfeature, version, pfHasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMImplementation2_Value = @import("../zig.zig").Guid.initString("3051073c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMImplementation2 = &IID_IHTMLDOMImplementation2_Value;
pub const IHTMLDOMImplementation2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createDocumentType: fn(
            self: *const IHTMLDOMImplementation2,
            bstrQualifiedName: ?BSTR,
            pvarPublicId: ?*VARIANT,
            pvarSystemId: ?*VARIANT,
            newDocumentType: ?*?*IDOMDocumentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocument: fn(
            self: *const IHTMLDOMImplementation2,
            pvarNS: ?*VARIANT,
            pvarTagName: ?*VARIANT,
            pDocumentType: ?*IDOMDocumentType,
            ppnewDocument: ?*?*IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createHTMLDocument: fn(
            self: *const IHTMLDOMImplementation2,
            bstrTitle: ?BSTR,
            ppnewDocument: ?*?*IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasFeature: fn(
            self: *const IHTMLDOMImplementation2,
            bstrfeature: ?BSTR,
            version: VARIANT,
            pfHasFeature: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createDocumentType(self: *const T, bstrQualifiedName: ?BSTR, pvarPublicId: ?*VARIANT, pvarSystemId: ?*VARIANT, newDocumentType: ?*?*IDOMDocumentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createDocumentType(@ptrCast(*const IHTMLDOMImplementation2, self), bstrQualifiedName, pvarPublicId, pvarSystemId, newDocumentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createDocument(self: *const T, pvarNS: ?*VARIANT, pvarTagName: ?*VARIANT, pDocumentType: ?*IDOMDocumentType, ppnewDocument: ?*?*IHTMLDocument7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createDocument(@ptrCast(*const IHTMLDOMImplementation2, self), pvarNS, pvarTagName, pDocumentType, ppnewDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createHTMLDocument(self: *const T, bstrTitle: ?BSTR, ppnewDocument: ?*?*IHTMLDocument7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createHTMLDocument(@ptrCast(*const IHTMLDOMImplementation2, self), bstrTitle, ppnewDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_hasFeature(self: *const T, bstrfeature: ?BSTR, version: VARIANT, pfHasFeature: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).hasFeature(@ptrCast(*const IHTMLDOMImplementation2, self), bstrfeature, version, pfHasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050f564-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDOMAttribute = &IID_DispHTMLDOMAttribute_Value;
pub const DispHTMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050f565-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDOMTextNode = &IID_DispHTMLDOMTextNode_Value;
pub const DispHTMLDOMTextNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050f58f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDOMImplementation = &IID_DispHTMLDOMImplementation_Value;
pub const DispHTMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050f4c3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAttributeCollection = &IID_IHTMLAttributeCollection_Value;
pub const IHTMLAttributeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLAttributeCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLAttributeCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection,
            name: ?*VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLAttributeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_item(self: *const T, name: ?*VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection2_Value = @import("../zig.zig").Guid.initString("3050f80a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAttributeCollection2 = &IID_IHTMLAttributeCollection2_Value;
pub const IHTMLAttributeCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            bstrName: ?BSTR,
            newretNode: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            ppNode: ?*IHTMLDOMAttribute,
            newretNode: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            bstrName: ?BSTR,
            newretNode: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_getNamedItem(self: *const T, bstrName: ?BSTR, newretNode: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), bstrName, newretNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_setNamedItem(self: *const T, ppNode: ?*IHTMLDOMAttribute, newretNode: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), ppNode, newretNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_removeNamedItem(self: *const T, bstrName: ?BSTR, newretNode: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), bstrName, newretNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection4_Value = @import("../zig.zig").Guid.initString("305106fa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAttributeCollection4 = &IID_IHTMLAttributeCollection4_Value;
pub const IHTMLAttributeCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pvarNS: ?*VARIANT,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pNodeIn: ?*IHTMLDOMAttribute2,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pvarNS: ?*VARIANT,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            pNodeIn: ?*IHTMLDOMAttribute2,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            bstrName: ?BSTR,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection4,
            index: i32,
            ppNodeOut: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLAttributeCollection4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_getNamedItemNS(self: *const T, pvarNS: ?*VARIANT, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).getNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pvarNS, bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_setNamedItemNS(self: *const T, pNodeIn: ?*IHTMLDOMAttribute2, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).setNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_removeNamedItemNS(self: *const T, pvarNS: ?*VARIANT, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).removeNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pvarNS, bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_getNamedItem(self: *const T, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_setNamedItem(self: *const T, pNodeIn: ?*IHTMLDOMAttribute2, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_removeNamedItem(self: *const T, bstrName: ?BSTR, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_item(self: *const T, index: i32, ppNodeOut: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection4, self), index, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050f5ab-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMChildrenCollection = &IID_IHTMLDOMChildrenCollection_Value;
pub const IHTMLDOMChildrenCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLDOMChildrenCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLDOMChildrenCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLDOMChildrenCollection,
            index: i32,
            ppItem: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDOMChildrenCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLDOMChildrenCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_item(self: *const T, index: i32, ppItem: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLDOMChildrenCollection, self), index, ppItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMChildrenCollection2_Value = @import("../zig.zig").Guid.initString("30510791-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMChildrenCollection2 = &IID_IHTMLDOMChildrenCollection2_Value;
pub const IHTMLDOMChildrenCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLDOMChildrenCollection2,
            index: i32,
            ppItem: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection2_item(self: *const T, index: i32, ppItem: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLDOMChildrenCollection2, self), index, ppItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050f56c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAttributeCollection = &IID_DispHTMLAttributeCollection_Value;
pub const DispHTMLAttributeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispStaticNodeList_Value = @import("../zig.zig").Guid.initString("3050f59b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispStaticNodeList = &IID_DispStaticNodeList_Value;
pub const DispStaticNodeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050f577-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMChildrenCollection = &IID_DispDOMChildrenCollection_Value;
pub const DispDOMChildrenCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents4_Value = @import("../zig.zig").Guid.initString("3051075e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLElementEvents4 = &IID_HTMLElementEvents4_Value;
pub const HTMLElementEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents3_Value = @import("../zig.zig").Guid.initString("3050f59f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLElementEvents3 = &IID_HTMLElementEvents3_Value;
pub const HTMLElementEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f60f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLElementEvents2 = &IID_HTMLElementEvents2_Value;
pub const HTMLElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents_Value = @import("../zig.zig").Guid.initString("3050f33c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLElementEvents = &IID_HTMLElementEvents_Value;
pub const HTMLElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("305104be-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IRulesAppliedCollection = &IID_IRulesAppliedCollection_Value;
pub const IRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IRulesAppliedCollection,
            index: i32,
            ppRulesApplied: ?*?*IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IRulesAppliedCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_element: fn(
            self: *const IRulesAppliedCollection,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedFrom: fn(
            self: *const IRulesAppliedCollection,
            name: ?BSTR,
            ppRulesApplied: ?*?*IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_propertyCount: fn(
            self: *const IRulesAppliedCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        property: fn(
            self: *const IRulesAppliedCollection,
            index: i32,
            pbstrProperty: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedTrace: fn(
            self: *const IRulesAppliedCollection,
            name: ?BSTR,
            index: i32,
            ppRulesApplied: ?*?*IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedTraceLength: fn(
            self: *const IRulesAppliedCollection,
            name: ?BSTR,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_item(self: *const T, index: i32, ppRulesApplied: ?*?*IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).item(@ptrCast(*const IRulesAppliedCollection, self), index, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_length(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_element(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_element(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedFrom(self: *const T, name: ?BSTR, ppRulesApplied: ?*?*IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedFrom(@ptrCast(*const IRulesAppliedCollection, self), name, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_propertyCount(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_propertyCount(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_property(self: *const T, index: i32, pbstrProperty: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).property(@ptrCast(*const IRulesAppliedCollection, self), index, pbstrProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedTrace(self: *const T, name: ?BSTR, index: i32, ppRulesApplied: ?*?*IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedTrace(@ptrCast(*const IRulesAppliedCollection, self), name, index, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedTraceLength(self: *const T, name: ?BSTR, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedTraceLength(@ptrCast(*const IRulesAppliedCollection, self), name, pLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement3_Value = @import("../zig.zig").Guid.initString("3050f673-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement3 = &IID_IHTMLElement3_Value;
pub const IHTMLElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        mergeAttributes: fn(
            self: *const IHTMLElement3,
            mergeThis: ?*IHTMLElement,
            pvarFlags: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isMultiLine: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_canHaveHTML: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onlayoutcomplete: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onlayoutcomplete: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpage: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpage: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_inflateBlock: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inflateBlock: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforedeactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforedeactivate: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setActive: fn(
            self: *const IHTMLElement3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contentEditable: fn(
            self: *const IHTMLElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentEditable: fn(
            self: *const IHTMLElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isContentEditable: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hideFocus: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hideFocus: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isDisabled: fn(
            self: *const IHTMLElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmove: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmove: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncontrolselect: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncontrolselect: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fireEvent: fn(
            self: *const IHTMLElement3,
            bstrEventName: ?BSTR,
            pvarEventObject: ?*VARIANT,
            pfCancelled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onresizestart: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onresizestart: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onresizeend: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onresizeend: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmovestart: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmovestart: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmoveend: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmoveend: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseenter: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseenter: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseleave: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseleave: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onactivate: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondeactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondeactivate: fn(
            self: *const IHTMLElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dragDrop: fn(
            self: *const IHTMLElement3,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_glyphMode: fn(
            self: *const IHTMLElement3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_mergeAttributes(self: *const T, mergeThis: ?*IHTMLElement, pvarFlags: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).mergeAttributes(@ptrCast(*const IHTMLElement3, self), mergeThis, pvarFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isMultiLine(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isMultiLine(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_canHaveHTML(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_canHaveHTML(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onlayoutcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onlayoutcomplete(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onlayoutcomplete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onlayoutcomplete(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onpage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onpage(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onpage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onpage(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_inflateBlock(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_inflateBlock(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_inflateBlock(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_inflateBlock(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onbeforedeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onbeforedeactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onbeforedeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onbeforedeactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_setActive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).setActive(@ptrCast(*const IHTMLElement3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_contentEditable(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_contentEditable(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_contentEditable(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_contentEditable(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isContentEditable(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isContentEditable(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_hideFocus(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_hideFocus(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_hideFocus(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_hideFocus(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isDisabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isDisabled(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmove(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmove(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_oncontrolselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_oncontrolselect(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_oncontrolselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_oncontrolselect(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_fireEvent(self: *const T, bstrEventName: ?BSTR, pvarEventObject: ?*VARIANT, pfCancelled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).fireEvent(@ptrCast(*const IHTMLElement3, self), bstrEventName, pvarEventObject, pfCancelled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onresizestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onresizestart(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onresizestart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onresizestart(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onresizeend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onresizeend(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onresizeend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onresizeend(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmovestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmovestart(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmovestart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmovestart(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmoveend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmoveend(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmoveend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmoveend(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmouseenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmouseenter(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmouseenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmouseenter(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmouseleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmouseleave(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmouseleave(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmouseleave(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_ondeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_ondeactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_ondeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_ondeactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_dragDrop(self: *const T, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).dragDrop(@ptrCast(*const IHTMLElement3, self), pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_glyphMode(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_glyphMode(@ptrCast(*const IHTMLElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement4_Value = @import("../zig.zig").Guid.initString("3050f80f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement4 = &IID_IHTMLElement4_Value;
pub const IHTMLElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousewheel: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousewheel: fn(
            self: *const IHTMLElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLElement4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IHTMLElement4,
            bstrname: ?BSTR,
            ppAttribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement4,
            pattr: ?*IHTMLDOMAttribute,
            ppretAttribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement4,
            pattr: ?*IHTMLDOMAttribute,
            ppretAttribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeactivate: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeactivate: fn(
            self: *const IHTMLElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusin: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusin: fn(
            self: *const IHTMLElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusout: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusout: fn(
            self: *const IHTMLElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onmousewheel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).normalize(@ptrCast(*const IHTMLElement4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_getAttributeNode(self: *const T, bstrname: ?BSTR, ppAttribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement4, self), bstrname, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_setAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute, ppretAttribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement4, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_removeAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute, ppretAttribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement4, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onbeforeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onbeforeactivate(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onbeforeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onbeforeactivate(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onfocusin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onfocusout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementSelector_Value = @import("../zig.zig").Guid.initString("30510463-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementSelector = &IID_IElementSelector_Value;
pub const IElementSelector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        querySelector: fn(
            self: *const IElementSelector,
            v: ?BSTR,
            pel: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        querySelectorAll: fn(
            self: *const IElementSelector,
            v: ?BSTR,
            pel: ?*?*IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSelector_querySelector(self: *const T, v: ?BSTR, pel: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSelector.VTable, self.vtable).querySelector(@ptrCast(*const IElementSelector, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSelector_querySelectorAll(self: *const T, v: ?BSTR, pel: ?*?*IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSelector.VTable, self.vtable).querySelectorAll(@ptrCast(*const IElementSelector, self), v, pel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementRender_Value = @import("../zig.zig").Guid.initString("3050f669-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementRender = &IID_IHTMLElementRender_Value;
pub const IHTMLElementRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DrawToDC: fn(
            self: *const IHTMLElementRender,
            hDC: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPrinter: fn(
            self: *const IHTMLElementRender,
            bstrPrinterName: ?BSTR,
            hDC: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementRender_DrawToDC(self: *const T, hDC: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementRender.VTable, self.vtable).DrawToDC(@ptrCast(*const IHTMLElementRender, self), hDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementRender_SetDocumentPrinter(self: *const T, bstrPrinterName: ?BSTR, hDC: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementRender.VTable, self.vtable).SetDocumentPrinter(@ptrCast(*const IHTMLElementRender, self), bstrPrinterName, hDC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUniqueName_Value = @import("../zig.zig").Guid.initString("3050f4d0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLUniqueName = &IID_IHTMLUniqueName_Value;
pub const IHTMLUniqueName = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uniqueNumber: fn(
            self: *const IHTMLUniqueName,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uniqueID: fn(
            self: *const IHTMLUniqueName,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUniqueName_get_uniqueNumber(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUniqueName.VTable, self.vtable).get_uniqueNumber(@ptrCast(*const IHTMLUniqueName, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUniqueName_get_uniqueID(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUniqueName.VTable, self.vtable).get_uniqueID(@ptrCast(*const IHTMLUniqueName, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement5_Value = @import("../zig.zig").Guid.initString("3051045d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement5 = &IID_IHTMLElement5_Value;
pub const IHTMLElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getAttributeNode: fn(
            self: *const IHTMLElement5,
            bstrname: ?BSTR,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement5,
            pattr: ?*IHTMLDOMAttribute2,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement5,
            pattr: ?*IHTMLDOMAttribute2,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttribute: fn(
            self: *const IHTMLElement5,
            name: ?BSTR,
            pfHasAttribute: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_role: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_role: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaBusy: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaBusy: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaChecked: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaChecked: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaDisabled: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaDisabled: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaExpanded: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaExpanded: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaHaspopup: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaHaspopup: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaHidden: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaHidden: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaInvalid: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaInvalid: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaMultiselectable: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaMultiselectable: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaPressed: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaPressed: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaReadonly: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaReadonly: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaRequired: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaRequired: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaSecret: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaSecret: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaSelected: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaSelected: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: ?BSTR,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: ?BSTR,
            AttributeValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: ?BSTR,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const IHTMLElement5,
            p: ?*?*IHTMLAttributeCollection3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaValuenow: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaValuenow: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaPosinset: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaPosinset: fn(
            self: *const IHTMLElement5,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaSetsize: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaSetsize: fn(
            self: *const IHTMLElement5,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaLevel: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaLevel: fn(
            self: *const IHTMLElement5,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaValuemin: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaValuemin: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaValuemax: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaValuemax: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaControls: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaControls: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaDescribedby: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaDescribedby: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaFlowto: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaFlowto: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaLabelledby: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaLabelledby: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaActivedescendant: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaActivedescendant: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaOwns: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaOwns: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLElement5,
            pfHasAttributes: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaLive: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaLive: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ariaRelevant: fn(
            self: *const IHTMLElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ariaRelevant: fn(
            self: *const IHTMLElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_getAttributeNode(self: *const T, bstrname: ?BSTR, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement5, self), bstrname, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_setAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute2, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement5, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_removeAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute2, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement5, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_hasAttribute(self: *const T, name: ?BSTR, pfHasAttribute: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).hasAttribute(@ptrCast(*const IHTMLElement5, self), name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_role(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_role(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_role(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_role(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaBusy(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaBusy(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaBusy(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaBusy(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaChecked(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaChecked(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaChecked(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaChecked(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaDisabled(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaDisabled(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaDisabled(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaDisabled(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaExpanded(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaExpanded(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaExpanded(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaExpanded(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaHaspopup(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaHaspopup(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaHaspopup(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaHaspopup(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaHidden(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaHidden(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaHidden(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaHidden(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaInvalid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaInvalid(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaInvalid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaInvalid(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaMultiselectable(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaMultiselectable(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaMultiselectable(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaMultiselectable(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaPressed(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaPressed(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaPressed(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaPressed(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaReadonly(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaReadonly(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaReadonly(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaReadonly(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaRequired(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaRequired(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaRequired(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaRequired(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSecret(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSecret(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSecret(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSecret(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSelected(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSelected(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSelected(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSelected(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_getAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_setAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_removeAttribute(self: *const T, strAttributeName: ?BSTR, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_attributes(self: *const T, p: ?*?*IHTMLAttributeCollection3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuenow(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuenow(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuenow(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuenow(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaPosinset(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaPosinset(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaPosinset(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaPosinset(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSetsize(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSetsize(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSetsize(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSetsize(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLevel(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLevel(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLevel(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLevel(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuemin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuemin(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuemin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuemin(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuemax(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuemax(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuemax(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuemax(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaControls(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaControls(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaControls(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaControls(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaDescribedby(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaDescribedby(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaDescribedby(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaDescribedby(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaFlowto(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaFlowto(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaFlowto(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaFlowto(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLabelledby(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLabelledby(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLabelledby(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLabelledby(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaActivedescendant(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaActivedescendant(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaActivedescendant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaActivedescendant(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaOwns(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaOwns(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaOwns(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaOwns(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_hasAttributes(self: *const T, pfHasAttributes: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLElement5, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLive(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLive(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLive(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLive(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaRelevant(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaRelevant(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaRelevant(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaRelevant(@ptrCast(*const IHTMLElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement6_Value = @import("../zig.zig").Guid.initString("305106f8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement6 = &IID_IHTMLElement6_Value;
pub const IHTMLElement6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: ?*VARIANT,
            strAttributeName: ?BSTR,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: ?*VARIANT,
            strAttributeName: ?BSTR,
            pvarAttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: ?*VARIANT,
            strAttributeName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNodeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: ?*VARIANT,
            bstrname: ?BSTR,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNodeNS: fn(
            self: *const IHTMLElement6,
            pattr: ?*IHTMLDOMAttribute2,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: ?*VARIANT,
            name: ?BSTR,
            pfHasAttribute: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: ?BSTR,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: ?BSTR,
            pvarAttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IHTMLElement6,
            strAttributeName: ?BSTR,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement6,
            pattr: ?*IHTMLDOMAttribute2,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement6,
            pattr: ?*IHTMLDOMAttribute2,
            ppretAttribute: ?*?*IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttribute: fn(
            self: *const IHTMLElement6,
            name: ?BSTR,
            pfHasAttribute: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagNameNS: fn(
            self: *const IHTMLElement6,
            varNS: ?*VARIANT,
            bstrLocalName: ?BSTR,
            pelColl: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: fn(
            self: *const IHTMLElement6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: fn(
            self: *const IHTMLElement6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByClassName: fn(
            self: *const IHTMLElement6,
            v: ?BSTR,
            pel: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msMatchesSelector: fn(
            self: *const IHTMLElement6,
            v: ?BSTR,
            pfMatches: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplay: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplay: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplaythrough: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplaythrough: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondurationchange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondurationchange: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onemptied: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onemptied: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onended: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onended: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oninput: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oninput: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadeddata: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadeddata: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadedmetadata: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadedmetadata: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadstart: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadstart: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpause: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpause: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplay: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplay: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplaying: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplaying: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onprogress: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onprogress: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onratechange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onratechange: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreset: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreset: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeked: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeked: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeking: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeking: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstalled: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstalled: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsubmit: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsubmit: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsuspend: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsuspend: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontimeupdate: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ontimeupdate: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onvolumechange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onvolumechange: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onwaiting: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onwaiting: fn(
            self: *const IHTMLElement6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLElement6,
            pfHasAttributes: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNS(self: *const T, pvarNS: ?*VARIANT, strAttributeName: ?BSTR, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNS(self: *const T, pvarNS: ?*VARIANT, strAttributeName: ?BSTR, pvarAttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName, pvarAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttributeNS(self: *const T, pvarNS: ?*VARIANT, strAttributeName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNodeNS(self: *const T, pvarNS: ?*VARIANT, bstrname: ?BSTR, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNodeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, bstrname, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNodeNS(self: *const T, pattr: ?*IHTMLDOMAttribute2, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNodeNS(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttributeNS(self: *const T, pvarNS: ?*VARIANT, name: ?BSTR, pfHasAttribute: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttribute(self: *const T, strAttributeName: ?BSTR, pvarAttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName, pvarAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttribute(self: *const T, strAttributeName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNode(self: *const T, strAttributeName: ?BSTR, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement6, self), strAttributeName, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute2, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttributeNode(self: *const T, pattr: ?*IHTMLDOMAttribute2, ppretAttribute: ?*?*IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttribute(self: *const T, name: ?BSTR, pfHasAttribute: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttribute(@ptrCast(*const IHTMLElement6, self), name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getElementsByTagNameNS(self: *const T, varNS: ?*VARIANT, bstrLocalName: ?BSTR, pelColl: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getElementsByTagNameNS(@ptrCast(*const IHTMLElement6, self), varNS, bstrLocalName, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_tagName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_tagName(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_nodeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getElementsByClassName(self: *const T, v: ?BSTR, pel: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getElementsByClassName(@ptrCast(*const IHTMLElement6, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_msMatchesSelector(self: *const T, v: ?BSTR, pfMatches: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).msMatchesSelector(@ptrCast(*const IHTMLElement6, self), v, pfMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oncanplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oncanplaythrough(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_ondurationchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onemptied(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onended(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oninput(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadeddata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadedmetadata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onpause(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onplaying(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onprogress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onratechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onreset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onseeked(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onseeking(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onstalled(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onsubmit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onsuspend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_ontimeupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onvolumechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onwaiting(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttributes(self: *const T, pfHasAttributes: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLElement6, self), pfHasAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement7_Value = @import("../zig.zig").Guid.initString("305107aa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElement7 = &IID_IHTMLElement7_Value;
pub const IHTMLElement7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerdown: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerdown: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointermove: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointermove: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerup: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerup: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerover: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerover: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerout: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerout: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointercancel: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointercancel: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerhover: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerhover: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmslostpointercapture: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmslostpointercapture: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgotpointercapture: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgotpointercapture: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturestart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturestart: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturechange: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturechange: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgestureend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgestureend: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturehold: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturehold: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturetap: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturetap: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsinertiastart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsinertiastart: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSetPointerCapture: fn(
            self: *const IHTMLElement7,
            pointerId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msReleasePointerCapture: fn(
            self: *const IHTMLElement7,
            pointerId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmstransitionstart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmstransitionstart: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmstransitionend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmstransitionend: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsanimationstart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsanimationstart: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsanimationend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsanimationend: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsanimationiteration: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsanimationiteration: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oninvalid: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oninvalid: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmsAcceleratorKey: fn(
            self: *const IHTMLElement7,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmsAcceleratorKey: fn(
            self: *const IHTMLElement7,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_spellcheck: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_spellcheck: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsmanipulationstatechanged: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsmanipulationstatechanged: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncuechange: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncuechange: fn(
            self: *const IHTMLElement7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerdown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointermove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointercancel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerhover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmslostpointercapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmslostpointercapture(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmslostpointercapture(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmslostpointercapture(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgotpointercapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgotpointercapture(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgotpointercapture(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgotpointercapture(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturestart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgestureend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturehold(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturetap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturedoubletap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsinertiastart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_msSetPointerCapture(self: *const T, pointerId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).msSetPointerCapture(@ptrCast(*const IHTMLElement7, self), pointerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_msReleasePointerCapture(self: *const T, pointerId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).msReleasePointerCapture(@ptrCast(*const IHTMLElement7, self), pointerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmstransitionstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmstransitionstart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmstransitionstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmstransitionstart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmstransitionend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmstransitionend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmstransitionend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmstransitionend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationstart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationstart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationiteration(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationiteration(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationiteration(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationiteration(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_oninvalid(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_oninvalid(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_oninvalid(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_oninvalid(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_xmsAcceleratorKey(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_xmsAcceleratorKey(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_xmsAcceleratorKey(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_xmsAcceleratorKey(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_spellcheck(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_spellcheck(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_spellcheck(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_spellcheck(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsmanipulationstatechanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsmanipulationstatechanged(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsmanipulationstatechanged(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsmanipulationstatechanged(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_oncuechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_oncuechange(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_oncuechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_oncuechange(@ptrCast(*const IHTMLElement7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementAppliedStyles_Value = @import("../zig.zig").Guid.initString("305104bd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementAppliedStyles = &IID_IHTMLElementAppliedStyles_Value;
pub const IHTMLElementAppliedStyles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        msGetRulesApplied: fn(
            self: *const IHTMLElementAppliedStyles,
            ppRulesAppliedCollection: ?*?*IRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msGetRulesAppliedWithAncestor: fn(
            self: *const IHTMLElementAppliedStyles,
            varContext: VARIANT,
            ppRulesAppliedCollection: ?*?*IRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementAppliedStyles_msGetRulesApplied(self: *const T, ppRulesAppliedCollection: ?*?*IRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementAppliedStyles.VTable, self.vtable).msGetRulesApplied(@ptrCast(*const IHTMLElementAppliedStyles, self), ppRulesAppliedCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementAppliedStyles_msGetRulesAppliedWithAncestor(self: *const T, varContext: VARIANT, ppRulesAppliedCollection: ?*?*IRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementAppliedStyles.VTable, self.vtable).msGetRulesAppliedWithAncestor(@ptrCast(*const IHTMLElementAppliedStyles, self), varContext, ppRulesAppliedCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementTraversal_Value = @import("../zig.zig").Guid.initString("30510736-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementTraversal = &IID_IElementTraversal_Value;
pub const IElementTraversal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstElementChild: fn(
            self: *const IElementTraversal,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastElementChild: fn(
            self: *const IElementTraversal,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousElementSibling: fn(
            self: *const IElementTraversal,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextElementSibling: fn(
            self: *const IElementTraversal,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childElementCount: fn(
            self: *const IElementTraversal,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_firstElementChild(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_firstElementChild(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_lastElementChild(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_lastElementChild(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_previousElementSibling(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_previousElementSibling(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_nextElementSibling(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_nextElementSibling(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_childElementCount(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_childElementCount(@ptrCast(*const IElementTraversal, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDatabinding_Value = @import("../zig.zig").Guid.initString("3050f3f2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDatabinding = &IID_IHTMLDatabinding_Value;
pub const IHTMLDatabinding = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataFld: fn(
            self: *const IHTMLDatabinding,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataFld: fn(
            self: *const IHTMLDatabinding,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataSrc: fn(
            self: *const IHTMLDatabinding,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataSrc: fn(
            self: *const IHTMLDatabinding,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataFormatAs: fn(
            self: *const IHTMLDatabinding,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataFormatAs: fn(
            self: *const IHTMLDatabinding,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataFld(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataFld(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataFld(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataFld(@ptrCast(*const IHTMLDatabinding, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataSrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataSrc(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataSrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataSrc(@ptrCast(*const IHTMLDatabinding, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataFormatAs(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataFormatAs(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataFormatAs(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataFormatAs(@ptrCast(*const IHTMLDatabinding, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument_Value = @import("../zig.zig").Guid.initString("626fc520-a41e-11cf-a731-00a0c9082637");
pub const IID_IHTMLDocument = &IID_IHTMLDocument_Value;
pub const IHTMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Script: fn(
            self: *const IHTMLDocument,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument_get_Script(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument.VTable, self.vtable).get_Script(@ptrCast(*const IHTMLDocument, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementDefaults_Value = @import("../zig.zig").Guid.initString("3050f6c9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementDefaults = &IID_IHTMLElementDefaults_Value;
pub const IHTMLElementDefaults = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLElementDefaults,
            p: ?*?*IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tabStop: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tabStop: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_viewInheritStyle: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewInheritStyle: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_viewMasterTab: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewMasterTab: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollSegmentX: fn(
            self: *const IHTMLElementDefaults,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollSegmentX: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollSegmentY: fn(
            self: *const IHTMLElementDefaults,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollSegmentY: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_isMultiLine: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isMultiLine: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contentEditable: fn(
            self: *const IHTMLElementDefaults,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentEditable: fn(
            self: *const IHTMLElementDefaults,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_canHaveHTML: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_canHaveHTML: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewLink: fn(
            self: *const IHTMLElementDefaults,
            v: ?*IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewLink: fn(
            self: *const IHTMLElementDefaults,
            p: ?*?*IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frozen: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frozen: fn(
            self: *const IHTMLElementDefaults,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_style(self: *const T, p: ?*?*IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_style(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_tabStop(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_tabStop(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_tabStop(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_tabStop(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_viewInheritStyle(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_viewInheritStyle(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewInheritStyle(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewInheritStyle(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_viewMasterTab(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_viewMasterTab(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewMasterTab(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewMasterTab(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_scrollSegmentX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_scrollSegmentX(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_scrollSegmentX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_scrollSegmentX(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_scrollSegmentY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_scrollSegmentY(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_scrollSegmentY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_scrollSegmentY(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_isMultiLine(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_isMultiLine(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_isMultiLine(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_isMultiLine(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_contentEditable(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_contentEditable(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_contentEditable(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_contentEditable(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_canHaveHTML(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_canHaveHTML(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_canHaveHTML(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_canHaveHTML(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_putref_viewLink(self: *const T, v: ?*IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).putref_viewLink(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewLink(self: *const T, p: ?*?*IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewLink(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_frozen(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_frozen(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_frozen(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_frozen(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDefaults_Value = @import("../zig.zig").Guid.initString("3050f58c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDefaults = &IID_DispHTMLDefaults_Value;
pub const DispHTMLDefaults = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050f4fd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCDefaultDispatch = &IID_IHTCDefaultDispatch_Value;
pub const IHTCDefaultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_element: fn(
            self: *const IHTCDefaultDispatch,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEventObject: fn(
            self: *const IHTCDefaultDispatch,
            eventObj: ?*?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaults: fn(
            self: *const IHTCDefaultDispatch,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTCDefaultDispatch,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_element(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_element(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_createEventObject(self: *const T, eventObj: ?*?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).createEventObject(@ptrCast(*const IHTCDefaultDispatch, self), eventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_defaults(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_defaults(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_document(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_document(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050f5df-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCPropertyBehavior = &IID_IHTCPropertyBehavior_Value;
pub const IHTCPropertyBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireChange: fn(
            self: *const IHTCPropertyBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTCPropertyBehavior,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTCPropertyBehavior,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_fireChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).fireChange(@ptrCast(*const IHTCPropertyBehavior, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_put_value(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).put_value(@ptrCast(*const IHTCPropertyBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_get_value(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).get_value(@ptrCast(*const IHTCPropertyBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050f631-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCMethodBehavior = &IID_IHTCMethodBehavior_Value;
pub const IHTCMethodBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050f4ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCEventBehavior = &IID_IHTCEventBehavior_Value;
pub const IHTCEventBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fire: fn(
            self: *const IHTCEventBehavior,
            pvar: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCEventBehavior_fire(self: *const T, pvar: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCEventBehavior.VTable, self.vtable).fire(@ptrCast(*const IHTCEventBehavior, self), pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050f5f4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCAttachBehavior = &IID_IHTCAttachBehavior_Value;
pub const IHTCAttachBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireEvent: fn(
            self: *const IHTCAttachBehavior,
            evt: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTCAttachBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior_fireEvent(self: *const T, evt: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior.VTable, self.vtable).fireEvent(@ptrCast(*const IHTCAttachBehavior, self), evt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior_detachEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior.VTable, self.vtable).detachEvent(@ptrCast(*const IHTCAttachBehavior, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCAttachBehavior2_Value = @import("../zig.zig").Guid.initString("3050f7eb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCAttachBehavior2 = &IID_IHTCAttachBehavior2_Value;
pub const IHTCAttachBehavior2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireEvent: fn(
            self: *const IHTCAttachBehavior2,
            evt: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior2_fireEvent(self: *const T, evt: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior2.VTable, self.vtable).fireEvent(@ptrCast(*const IHTCAttachBehavior2, self), evt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050f5dc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTCDescBehavior = &IID_IHTCDescBehavior_Value;
pub const IHTCDescBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_urn: fn(
            self: *const IHTCDescBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTCDescBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDescBehavior_get_urn(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDescBehavior.VTable, self.vtable).get_urn(@ptrCast(*const IHTCDescBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDescBehavior_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDescBehavior.VTable, self.vtable).get_name(@ptrCast(*const IHTCDescBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050f573-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCDefaultDispatch = &IID_DispHTCDefaultDispatch_Value;
pub const DispHTCDefaultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050f57f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCPropertyBehavior = &IID_DispHTCPropertyBehavior_Value;
pub const DispHTCPropertyBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050f587-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCMethodBehavior = &IID_DispHTCMethodBehavior_Value;
pub const DispHTCMethodBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050f574-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCEventBehavior = &IID_DispHTCEventBehavior_Value;
pub const DispHTCEventBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050f583-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCAttachBehavior = &IID_DispHTCAttachBehavior_Value;
pub const DispHTCAttachBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050f57e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTCDescBehavior = &IID_DispHTCDescBehavior_Value;
pub const DispHTCDescBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050f5e2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLUrnCollection = &IID_IHTMLUrnCollection_Value;
pub const IHTMLUrnCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLUrnCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLUrnCollection,
            index: i32,
            ppUrn: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUrnCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUrnCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLUrnCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUrnCollection_item(self: *const T, index: i32, ppUrn: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUrnCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLUrnCollection, self), index, ppUrn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050f551-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLUrnCollection = &IID_DispHTMLUrnCollection_Value;
pub const DispHTMLUrnCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050f4b7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLGenericElement = &IID_IHTMLGenericElement_Value;
pub const IHTMLGenericElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_recordset: fn(
            self: *const IHTMLGenericElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedRecordset: fn(
            self: *const IHTMLGenericElement,
            dataMember: ?BSTR,
            hierarchy: ?*VARIANT,
            ppRecordset: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLGenericElement_get_recordset(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLGenericElement.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLGenericElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLGenericElement_namedRecordset(self: *const T, dataMember: ?BSTR, hierarchy: ?*VARIANT, ppRecordset: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLGenericElement.VTable, self.vtable).namedRecordset(@ptrCast(*const IHTMLGenericElement, self), dataMember, hierarchy, ppRecordset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050f563-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLGenericElement = &IID_DispHTMLGenericElement_Value;
pub const DispHTMLGenericElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRuleApplied_Value = @import("../zig.zig").Guid.initString("305104c1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRuleApplied = &IID_IHTMLStyleSheetRuleApplied_Value;
pub const IHTMLStyleSheetRuleApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msSpecificity: fn(
            self: *const IHTMLStyleSheetRuleApplied,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msGetSpecificity: fn(
            self: *const IHTMLStyleSheetRuleApplied,
            index: i32,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRuleApplied_get_msSpecificity(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRuleApplied.VTable, self.vtable).get_msSpecificity(@ptrCast(*const IHTMLStyleSheetRuleApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRuleApplied_msGetSpecificity(self: *const T, index: i32, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRuleApplied.VTable, self.vtable).msGetSpecificity(@ptrCast(*const IHTMLStyleSheetRuleApplied, self), index, p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRule2_Value = @import("../zig.zig").Guid.initString("305106fd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRule2 = &IID_IHTMLStyleSheetRule2_Value;
pub const IHTMLStyleSheetRule2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectorText: fn(
            self: *const IHTMLStyleSheetRule2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectorText: fn(
            self: *const IHTMLStyleSheetRule2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule2_put_selectorText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule2.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetRule2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule2_get_selectorText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule2.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetRule2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesCollection2_Value = @import("../zig.zig").Guid.initString("305106e8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRulesCollection2 = &IID_IHTMLStyleSheetRulesCollection2_Value;
pub const IHTMLStyleSheetRulesCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStyleSheetRulesCollection2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetRulesCollection2,
            index: i32,
            ppHTMLCSSRule: ?*?*IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection2_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesCollection2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection2_item(self: *const T, index: i32, ppHTMLCSSRule: ?*?*IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesCollection2, self), index, ppHTMLCSSRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050f50e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetRule = &IID_DispHTMLStyleSheetRule_Value;
pub const DispHTMLStyleSheetRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050f52f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetRulesCollection = &IID_DispHTMLStyleSheetRulesCollection_Value;
pub const DispHTMLStyleSheetRulesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050f7ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetPage = &IID_IHTMLStyleSheetPage_Value;
pub const IHTMLStyleSheetPage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selector: fn(
            self: *const IHTMLStyleSheetPage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pseudoClass: fn(
            self: *const IHTMLStyleSheetPage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage_get_selector(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage.VTable, self.vtable).get_selector(@ptrCast(*const IHTMLStyleSheetPage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage_get_pseudoClass(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage.VTable, self.vtable).get_pseudoClass(@ptrCast(*const IHTMLStyleSheetPage, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPage2_Value = @import("../zig.zig").Guid.initString("305106ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetPage2 = &IID_IHTMLStyleSheetPage2_Value;
pub const IHTMLStyleSheetPage2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectorText: fn(
            self: *const IHTMLStyleSheetPage2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectorText: fn(
            self: *const IHTMLStyleSheetPage2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLStyleSheetPage2,
            p: ?*?*IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_put_selectorText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetPage2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_get_selectorText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetPage2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_get_style(self: *const T, p: ?*?*IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleSheetPage2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050f7f0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetPagesCollection = &IID_IHTMLStyleSheetPagesCollection_Value;
pub const IHTMLStyleSheetPagesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStyleSheetPagesCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetPagesCollection,
            index: i32,
            ppHTMLStyleSheetPage: ?*?*IHTMLStyleSheetPage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPagesCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPagesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetPagesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPagesCollection_item(self: *const T, index: i32, ppHTMLStyleSheetPage: ?*?*IHTMLStyleSheetPage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPagesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetPagesCollection, self), index, ppHTMLStyleSheetPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050f540-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetPage = &IID_DispHTMLStyleSheetPage_Value;
pub const DispHTMLStyleSheetPage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050f543-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetPagesCollection = &IID_DispHTMLStyleSheetPagesCollection_Value;
pub const DispHTMLStyleSheetPagesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050f37e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetsCollection = &IID_IHTMLStyleSheetsCollection_Value;
pub const IHTMLStyleSheetsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStyleSheetsCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLStyleSheetsCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetsCollection,
            pvarIndex: ?*VARIANT,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLStyleSheetsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_item(self: *const T, pvarIndex: ?*VARIANT, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetsCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet2_Value = @import("../zig.zig").Guid.initString("3050f3d1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheet2 = &IID_IHTMLStyleSheet2_Value;
pub const IHTMLStyleSheet2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pages: fn(
            self: *const IHTMLStyleSheet2,
            p: ?*?*IHTMLStyleSheetPagesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addPageRule: fn(
            self: *const IHTMLStyleSheet2,
            bstrSelector: ?BSTR,
            bstrStyle: ?BSTR,
            lIndex: i32,
            plNewIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet2_get_pages(self: *const T, p: ?*?*IHTMLStyleSheetPagesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet2.VTable, self.vtable).get_pages(@ptrCast(*const IHTMLStyleSheet2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet2_addPageRule(self: *const T, bstrSelector: ?BSTR, bstrStyle: ?BSTR, lIndex: i32, plNewIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet2.VTable, self.vtable).addPageRule(@ptrCast(*const IHTMLStyleSheet2, self), bstrSelector, bstrStyle, lIndex, plNewIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet3_Value = @import("../zig.zig").Guid.initString("30510496-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheet3 = &IID_IHTMLStyleSheet3_Value;
pub const IHTMLStyleSheet3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLStyleSheet3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLStyleSheet3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAlternate: fn(
            self: *const IHTMLStyleSheet3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isPrefAlternate: fn(
            self: *const IHTMLStyleSheet3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).put_href(@ptrCast(*const IHTMLStyleSheet3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_isAlternate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_isAlternate(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_isPrefAlternate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_isPrefAlternate(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet4_Value = @import("../zig.zig").Guid.initString("305106f4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheet4 = &IID_IHTMLStyleSheet4_Value;
pub const IHTMLStyleSheet4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_title: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerNode: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerRule: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*?*IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cssRules: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*?*IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLStyleSheet4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRule: fn(
            self: *const IHTMLStyleSheet4,
            bstrRule: ?BSTR,
            lIndex: i32,
            plNewIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLStyleSheet4,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_href(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_title(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_title(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_ownerNode(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_ownerNode(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_ownerRule(self: *const T, p: ?*?*IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_ownerRule(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_cssRules(self: *const T, p: ?*?*IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_media(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_insertRule(self: *const T, bstrRule: ?BSTR, lIndex: i32, plNewIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).insertRule(@ptrCast(*const IHTMLStyleSheet4, self), bstrRule, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_deleteRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLStyleSheet4, self), lIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050f58d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheet = &IID_DispHTMLStyleSheet_Value;
pub const DispHTMLStyleSheet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetsCollection2_Value = @import("../zig.zig").Guid.initString("305106e7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetsCollection2 = &IID_IHTMLStyleSheetsCollection2_Value;
pub const IHTMLStyleSheetsCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLStyleSheetsCollection2,
            index: i32,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection2_item(self: *const T, index: i32, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetsCollection2, self), index, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050f547-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetsCollection = &IID_DispHTMLStyleSheetsCollection_Value;
pub const DispHTMLStyleSheetsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLinkElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f61d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLLinkElementEvents2 = &IID_HTMLLinkElementEvents2_Value;
pub const HTMLLinkElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLinkElementEvents_Value = @import("../zig.zig").Guid.initString("3050f3cc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLLinkElementEvents = &IID_HTMLLinkElementEvents_Value;
pub const HTMLLinkElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050f205-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLinkElement = &IID_IHTMLLinkElement_Value;
pub const IHTMLLinkElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLLinkElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rel: fn(
            self: *const IHTMLLinkElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rel: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rev: fn(
            self: *const IHTMLLinkElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rev: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLLinkElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLLinkElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLLinkElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLLinkElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleSheet: fn(
            self: *const IHTMLLinkElement,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLLinkElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLLinkElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLLinkElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLLinkElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_rel(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_rel(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_rel(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_rel(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_rev(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_rev(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_rev(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_rev(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_styleSheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLLinkElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement2_Value = @import("../zig.zig").Guid.initString("3050f4e5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLinkElement2 = &IID_IHTMLLinkElement2_Value;
pub const IHTMLLinkElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_target: fn(
            self: *const IHTMLLinkElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IHTMLLinkElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement2_put_target(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement2.VTable, self.vtable).put_target(@ptrCast(*const IHTMLLinkElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement2_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement2.VTable, self.vtable).get_target(@ptrCast(*const IHTMLLinkElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement3_Value = @import("../zig.zig").Guid.initString("3050f81e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLinkElement3 = &IID_IHTMLLinkElement3_Value;
pub const IHTMLLinkElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IHTMLLinkElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IHTMLLinkElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hreflang: fn(
            self: *const IHTMLLinkElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hreflang: fn(
            self: *const IHTMLLinkElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_put_charset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLLinkElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLLinkElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_put_hreflang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).put_hreflang(@ptrCast(*const IHTMLLinkElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_get_hreflang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).get_hreflang(@ptrCast(*const IHTMLLinkElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement4_Value = @import("../zig.zig").Guid.initString("3051043a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLinkElement4 = &IID_IHTMLLinkElement4_Value;
pub const IHTMLLinkElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLLinkElement4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLLinkElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement4_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement4.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLinkElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement4_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement4.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLinkElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement5_Value = @import("../zig.zig").Guid.initString("30510726-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLinkElement5 = &IID_IHTMLLinkElement5_Value;
pub const IHTMLLinkElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sheet: fn(
            self: *const IHTMLLinkElement5,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement5_get_sheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement5.VTable, self.vtable).get_sheet(@ptrCast(*const IHTMLLinkElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050f524-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLLinkElement = &IID_DispHTMLLinkElement_Value;
pub const DispHTMLLinkElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTxtRange_Value = @import("../zig.zig").Guid.initString("3050f220-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTxtRange = &IID_IHTMLTxtRange_Value;
pub const IHTMLTxtRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_htmlText: fn(
            self: *const IHTMLTxtRange,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLTxtRange,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLTxtRange,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parentElement: fn(
            self: *const IHTMLTxtRange,
            parent: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        duplicate: fn(
            self: *const IHTMLTxtRange,
            Duplicate: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        inRange: fn(
            self: *const IHTMLTxtRange,
            Range: ?*IHTMLTxtRange,
            InRange: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isEqual: fn(
            self: *const IHTMLTxtRange,
            Range: ?*IHTMLTxtRange,
            IsEqual: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLTxtRange,
            fStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLTxtRange,
            Start: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        expand: fn(
            self: *const IHTMLTxtRange,
            Unit: ?BSTR,
            Success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        move: fn(
            self: *const IHTMLTxtRange,
            Unit: ?BSTR,
            Count: i32,
            ActualCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveStart: fn(
            self: *const IHTMLTxtRange,
            Unit: ?BSTR,
            Count: i32,
            ActualCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveEnd: fn(
            self: *const IHTMLTxtRange,
            Unit: ?BSTR,
            Count: i32,
            ActualCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pasteHTML: fn(
            self: *const IHTMLTxtRange,
            html: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToElementText: fn(
            self: *const IHTMLTxtRange,
            element: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndPoint: fn(
            self: *const IHTMLTxtRange,
            how: ?BSTR,
            SourceRange: ?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareEndPoints: fn(
            self: *const IHTMLTxtRange,
            how: ?BSTR,
            SourceRange: ?*IHTMLTxtRange,
            ret: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        findText: fn(
            self: *const IHTMLTxtRange,
            String: ?BSTR,
            count: i32,
            Flags: i32,
            Success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToPoint: fn(
            self: *const IHTMLTxtRange,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBookmark: fn(
            self: *const IHTMLTxtRange,
            Boolmark: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToBookmark: fn(
            self: *const IHTMLTxtRange,
            Bookmark: ?BSTR,
            Success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pcmdText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pcmdValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLTxtRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_get_htmlText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).get_htmlText(@ptrCast(*const IHTMLTxtRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_put_text(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).put_text(@ptrCast(*const IHTMLTxtRange, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).get_text(@ptrCast(*const IHTMLTxtRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_parentElement(self: *const T, parent: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).parentElement(@ptrCast(*const IHTMLTxtRange, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_duplicate(self: *const T, Duplicate: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).duplicate(@ptrCast(*const IHTMLTxtRange, self), Duplicate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_inRange(self: *const T, Range: ?*IHTMLTxtRange, InRange: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).inRange(@ptrCast(*const IHTMLTxtRange, self), Range, InRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_isEqual(self: *const T, Range: ?*IHTMLTxtRange, IsEqual: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).isEqual(@ptrCast(*const IHTMLTxtRange, self), Range, IsEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_scrollIntoView(self: *const T, fStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLTxtRange, self), fStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_collapse(self: *const T, Start: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).collapse(@ptrCast(*const IHTMLTxtRange, self), Start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_expand(self: *const T, Unit: ?BSTR, Success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).expand(@ptrCast(*const IHTMLTxtRange, self), Unit, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_move(self: *const T, Unit: ?BSTR, Count: i32, ActualCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).move(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveStart(self: *const T, Unit: ?BSTR, Count: i32, ActualCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveStart(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveEnd(self: *const T, Unit: ?BSTR, Count: i32, ActualCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveEnd(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).select(@ptrCast(*const IHTMLTxtRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_pasteHTML(self: *const T, html: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).pasteHTML(@ptrCast(*const IHTMLTxtRange, self), html);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToElementText(self: *const T, element: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToElementText(@ptrCast(*const IHTMLTxtRange, self), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_setEndPoint(self: *const T, how: ?BSTR, SourceRange: ?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).setEndPoint(@ptrCast(*const IHTMLTxtRange, self), how, SourceRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_compareEndPoints(self: *const T, how: ?BSTR, SourceRange: ?*IHTMLTxtRange, ret: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).compareEndPoints(@ptrCast(*const IHTMLTxtRange, self), how, SourceRange, ret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_findText(self: *const T, String: ?BSTR, count: i32, Flags: i32, Success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).findText(@ptrCast(*const IHTMLTxtRange, self), String, count, Flags, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToPoint(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToPoint(@ptrCast(*const IHTMLTxtRange, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_getBookmark(self: *const T, Boolmark: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).getBookmark(@ptrCast(*const IHTMLTxtRange, self), Boolmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToBookmark(self: *const T, Bookmark: ?BSTR, Success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToBookmark(@ptrCast(*const IHTMLTxtRange, self), Bookmark, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandSupported(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandEnabled(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandState(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandIndeterm(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandText(self: *const T, cmdID: ?BSTR, pcmdText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLTxtRange, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandValue(self: *const T, cmdID: ?BSTR, pcmdValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLTxtRange, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_execCommand(self: *const T, cmdID: ?BSTR, showUI: i16, value: VARIANT, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLTxtRange, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_execCommandShowHelp(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextRangeMetrics_Value = @import("../zig.zig").Guid.initString("3050f40b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextRangeMetrics = &IID_IHTMLTextRangeMetrics_Value;
pub const IHTMLTextRangeMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetTop: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetLeft: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boundingTop: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boundingLeft: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boundingWidth: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boundingHeight: fn(
            self: *const IHTMLTextRangeMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_offsetTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_offsetTop(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_offsetLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_offsetLeft(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingTop(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingLeft(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingWidth(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingHeight(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextRangeMetrics2_Value = @import("../zig.zig").Guid.initString("3050f4a6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextRangeMetrics2 = &IID_IHTMLTextRangeMetrics2_Value;
pub const IHTMLTextRangeMetrics2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getClientRects: fn(
            self: *const IHTMLTextRangeMetrics2,
            pRectCol: ?*?*IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLTextRangeMetrics2,
            pRect: ?*?*IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics2_getClientRects(self: *const T, pRectCol: ?*?*IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics2.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLTextRangeMetrics2, self), pRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics2_getBoundingClientRect(self: *const T, pRect: ?*?*IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics2.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLTextRangeMetrics2, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTxtRangeCollection_Value = @import("../zig.zig").Guid.initString("3050f7ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTxtRangeCollection = &IID_IHTMLTxtRangeCollection_Value;
pub const IHTMLTxtRangeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLTxtRangeCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLTxtRangeCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLTxtRangeCollection,
            pvarIndex: ?*VARIANT,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLTxtRangeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLTxtRangeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_item(self: *const T, pvarIndex: ?*VARIANT, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLTxtRangeCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMRange_Value = @import("../zig.zig").Guid.initString("305104ae-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMRange = &IID_IHTMLDOMRange_Value;
pub const IHTMLDOMRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startContainer: fn(
            self: *const IHTMLDOMRange,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startOffset: fn(
            self: *const IHTMLDOMRange,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_endContainer: fn(
            self: *const IHTMLDOMRange,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_endOffset: fn(
            self: *const IHTMLDOMRange,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_collapsed: fn(
            self: *const IHTMLDOMRange,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_commonAncestorContainer: fn(
            self: *const IHTMLDOMRange,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStart: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
            offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEnd: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
            offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStartBefore: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStartAfter: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndBefore: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndAfter: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLDOMRange,
            toStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNode: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNodeContents: fn(
            self: *const IHTMLDOMRange,
            refNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareBoundaryPoints: fn(
            self: *const IHTMLDOMRange,
            how: i16,
            sourceRange: ?*IDispatch,
            compareResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteContents: fn(
            self: *const IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        extractContents: fn(
            self: *const IHTMLDOMRange,
            ppDocumentFragment: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneContents: fn(
            self: *const IHTMLDOMRange,
            ppDocumentFragment: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertNode: fn(
            self: *const IHTMLDOMRange,
            newNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        surroundContents: fn(
            self: *const IHTMLDOMRange,
            newParent: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneRange: fn(
            self: *const IHTMLDOMRange,
            ppClonedRange: ?*?*IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDOMRange,
            pRangeString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detach: fn(
            self: *const IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getClientRects: fn(
            self: *const IHTMLDOMRange,
            ppRectCol: ?*?*IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLDOMRange,
            ppRect: ?*?*IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_startContainer(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_startContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_startOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_startOffset(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_endContainer(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_endContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_endOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_endOffset(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_collapsed(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_collapsed(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_commonAncestorContainer(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_commonAncestorContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStart(self: *const T, refNode: ?*IDispatch, offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStart(@ptrCast(*const IHTMLDOMRange, self), refNode, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEnd(self: *const T, refNode: ?*IDispatch, offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEnd(@ptrCast(*const IHTMLDOMRange, self), refNode, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStartBefore(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStartBefore(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStartAfter(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStartAfter(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEndBefore(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEndBefore(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEndAfter(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEndAfter(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_collapse(self: *const T, toStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).collapse(@ptrCast(*const IHTMLDOMRange, self), toStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_selectNode(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).selectNode(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_selectNodeContents(self: *const T, refNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).selectNodeContents(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_compareBoundaryPoints(self: *const T, how: i16, sourceRange: ?*IDispatch, compareResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).compareBoundaryPoints(@ptrCast(*const IHTMLDOMRange, self), how, sourceRange, compareResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_deleteContents(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).deleteContents(@ptrCast(*const IHTMLDOMRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_extractContents(self: *const T, ppDocumentFragment: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).extractContents(@ptrCast(*const IHTMLDOMRange, self), ppDocumentFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_cloneContents(self: *const T, ppDocumentFragment: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).cloneContents(@ptrCast(*const IHTMLDOMRange, self), ppDocumentFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_insertNode(self: *const T, newNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).insertNode(@ptrCast(*const IHTMLDOMRange, self), newNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_surroundContents(self: *const T, newParent: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).surroundContents(@ptrCast(*const IHTMLDOMRange, self), newParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_cloneRange(self: *const T, ppClonedRange: ?*?*IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).cloneRange(@ptrCast(*const IHTMLDOMRange, self), ppClonedRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_toString(self: *const T, pRangeString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).toString(@ptrCast(*const IHTMLDOMRange, self), pRangeString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).detach(@ptrCast(*const IHTMLDOMRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_getClientRects(self: *const T, ppRectCol: ?*?*IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLDOMRange, self), ppRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_getBoundingClientRect(self: *const T, ppRect: ?*?*IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLDOMRange, self), ppRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMRange_Value = @import("../zig.zig").Guid.initString("3050f5a3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDOMRange = &IID_DispHTMLDOMRange_Value;
pub const DispHTMLDOMRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFormElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f614-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLFormElementEvents2 = &IID_HTMLFormElementEvents2_Value;
pub const HTMLFormElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFormElementEvents_Value = @import("../zig.zig").Guid.initString("3050f364-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLFormElementEvents = &IID_HTMLFormElementEvents_Value;
pub const HTMLFormElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050f1f7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFormElement = &IID_IHTMLFormElement_Value;
pub const IHTMLFormElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_action: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_action: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dir: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dir: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_encoding: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_encoding: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_method: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_method: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_elements: fn(
            self: *const IHTMLFormElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_target: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLFormElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLFormElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsubmit: fn(
            self: *const IHTMLFormElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsubmit: fn(
            self: *const IHTMLFormElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreset: fn(
            self: *const IHTMLFormElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreset: fn(
            self: *const IHTMLFormElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        submit: fn(
            self: *const IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: fn(
            self: *const IHTMLFormElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLFormElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLFormElement,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFormElement,
            name: VARIANT,
            index: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLFormElement,
            tagName: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_action(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_action(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_action(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_action(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_dir(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_dir(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_encoding(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_encoding(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_encoding(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_encoding(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_method(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_method(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_method(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_method(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_elements(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_elements(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_target(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_onsubmit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_onreset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_submit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).submit(@ptrCast(*const IHTMLFormElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).reset(@ptrCast(*const IHTMLFormElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_length(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).item(@ptrCast(*const IHTMLFormElement, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_tags(self: *const T, tagName: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).tags(@ptrCast(*const IHTMLFormElement, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement2_Value = @import("../zig.zig").Guid.initString("3050f4f6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFormElement2 = &IID_IHTMLFormElement2_Value;
pub const IHTMLFormElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_acceptCharset: fn(
            self: *const IHTMLFormElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_acceptCharset: fn(
            self: *const IHTMLFormElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        urns: fn(
            self: *const IHTMLFormElement2,
            urn: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_put_acceptCharset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).put_acceptCharset(@ptrCast(*const IHTMLFormElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_get_acceptCharset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).get_acceptCharset(@ptrCast(*const IHTMLFormElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_urns(self: *const T, urn: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).urns(@ptrCast(*const IHTMLFormElement2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement3_Value = @import("../zig.zig").Guid.initString("3050f836-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFormElement3 = &IID_IHTMLFormElement3_Value;
pub const IHTMLFormElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLFormElement3,
            name: ?BSTR,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement3_namedItem(self: *const T, name: ?BSTR, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLFormElement3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSubmitData_Value = @import("../zig.zig").Guid.initString("3050f645-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSubmitData = &IID_IHTMLSubmitData_Value;
pub const IHTMLSubmitData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        appendNameValuePair: fn(
            self: *const IHTMLSubmitData,
            name: ?BSTR,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendNameFilePair: fn(
            self: *const IHTMLSubmitData,
            name: ?BSTR,
            filename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItemSeparator: fn(
            self: *const IHTMLSubmitData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendNameValuePair(self: *const T, name: ?BSTR, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendNameValuePair(@ptrCast(*const IHTMLSubmitData, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendNameFilePair(self: *const T, name: ?BSTR, filename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendNameFilePair(@ptrCast(*const IHTMLSubmitData, self), name, filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendItemSeparator(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendItemSeparator(@ptrCast(*const IHTMLSubmitData, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement4_Value = @import("../zig.zig").Guid.initString("3051042c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFormElement4 = &IID_IHTMLFormElement4_Value;
pub const IHTMLFormElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_action: fn(
            self: *const IHTMLFormElement4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_action: fn(
            self: *const IHTMLFormElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement4_put_action(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement4.VTable, self.vtable).put_action(@ptrCast(*const IHTMLFormElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement4_get_action(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement4.VTable, self.vtable).get_action(@ptrCast(*const IHTMLFormElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050f510-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFormElement = &IID_DispHTMLFormElement_Value;
pub const DispHTMLFormElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLControlElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f612-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLControlElementEvents2 = &IID_HTMLControlElementEvents2_Value;
pub const HTMLControlElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLControlElementEvents_Value = @import("../zig.zig").Guid.initString("3050f4ea-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLControlElementEvents = &IID_HTMLControlElementEvents_Value;
pub const HTMLControlElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlElement_Value = @import("../zig.zig").Guid.initString("3050f4e9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLControlElement = &IID_IHTMLControlElement_Value;
pub const IHTMLControlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tabIndex: fn(
            self: *const IHTMLControlElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tabIndex: fn(
            self: *const IHTMLControlElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accessKey: fn(
            self: *const IHTMLControlElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accessKey: fn(
            self: *const IHTMLControlElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLControlElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLControlElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onresize: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onresize: fn(
            self: *const IHTMLControlElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addFilter: fn(
            self: *const IHTMLControlElement,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeFilter: fn(
            self: *const IHTMLControlElement,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientHeight: fn(
            self: *const IHTMLControlElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientWidth: fn(
            self: *const IHTMLControlElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientTop: fn(
            self: *const IHTMLControlElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientLeft: fn(
            self: *const IHTMLControlElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_tabIndex(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLControlElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_accessKey(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_accessKey(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onresize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLControlElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_addFilter(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).addFilter(@ptrCast(*const IHTMLControlElement, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_removeFilter(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).removeFilter(@ptrCast(*const IHTMLControlElement, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLControlElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050f218-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextElement = &IID_IHTMLTextElement_Value;
pub const IHTMLTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050f537-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTextElement = &IID_DispHTMLTextElement_Value;
pub const DispHTMLTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTextContainerEvents2_Value = @import("../zig.zig").Guid.initString("3050f624-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLTextContainerEvents2 = &IID_HTMLTextContainerEvents2_Value;
pub const HTMLTextContainerEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTextContainerEvents_Value = @import("../zig.zig").Guid.initString("1ff6aa72-5842-11cf-a707-00aa00c0098d");
pub const IID_HTMLTextContainerEvents = &IID_HTMLTextContainerEvents_Value;
pub const HTMLTextContainerEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextContainer_Value = @import("../zig.zig").Guid.initString("3050f230-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextContainer = &IID_IHTMLTextContainer_Value;
pub const IHTMLTextContainer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createControlRange: fn(
            self: *const IHTMLTextContainer,
            range: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollHeight: fn(
            self: *const IHTMLTextContainer,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollWidth: fn(
            self: *const IHTMLTextContainer,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollTop: fn(
            self: *const IHTMLTextContainer,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollTop: fn(
            self: *const IHTMLTextContainer,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollLeft: fn(
            self: *const IHTMLTextContainer,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollLeft: fn(
            self: *const IHTMLTextContainer,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onscroll: fn(
            self: *const IHTMLTextContainer,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onscroll: fn(
            self: *const IHTMLTextContainer,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_createControlRange(self: *const T, range: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).createControlRange(@ptrCast(*const IHTMLTextContainer, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollHeight(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollWidth(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_scrollTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_scrollTop(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollTop(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_scrollLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_scrollLeft(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollLeft(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_onscroll(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLTextContainer, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlRange_Value = @import("../zig.zig").Guid.initString("3050f29c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLControlRange = &IID_IHTMLControlRange_Value;
pub const IHTMLControlRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        select: fn(
            self: *const IHTMLControlRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLControlRange,
            item: ?*IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLControlRange,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLControlRange,
            index: i32,
            pdisp: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLControlRange,
            varargStart: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pcmdText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pcmdValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLControlRange,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        commonParentElement: fn(
            self: *const IHTMLControlRange,
            parent: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLControlRange,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).select(@ptrCast(*const IHTMLControlRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_add(self: *const T, item: ?*IHTMLControlElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).add(@ptrCast(*const IHTMLControlRange, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).remove(@ptrCast(*const IHTMLControlRange, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_item(self: *const T, index: i32, pdisp: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).item(@ptrCast(*const IHTMLControlRange, self), index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_scrollIntoView(self: *const T, varargStart: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLControlRange, self), varargStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandSupported(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandEnabled(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandState(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandIndeterm(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandText(self: *const T, cmdID: ?BSTR, pcmdText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLControlRange, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandValue(self: *const T, cmdID: ?BSTR, pcmdValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLControlRange, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_execCommand(self: *const T, cmdID: ?BSTR, showUI: i16, value: VARIANT, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLControlRange, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_execCommandShowHelp(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_commonParentElement(self: *const T, parent: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).commonParentElement(@ptrCast(*const IHTMLControlRange, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).get_length(@ptrCast(*const IHTMLControlRange, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlRange2_Value = @import("../zig.zig").Guid.initString("3050f65e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLControlRange2 = &IID_IHTMLControlRange2_Value;
pub const IHTMLControlRange2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addElement: fn(
            self: *const IHTMLControlRange2,
            item: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange2_addElement(self: *const T, item: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange2.VTable, self.vtable).addElement(@ptrCast(*const IHTMLControlRange2, self), item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLImgEvents2_Value = @import("../zig.zig").Guid.initString("3050f616-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLImgEvents2 = &IID_HTMLImgEvents2_Value;
pub const HTMLImgEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLImgEvents_Value = @import("../zig.zig").Guid.initString("3050f25b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLImgEvents = &IID_HTMLImgEvents_Value;
pub const HTMLImgEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement_Value = @import("../zig.zig").Guid.initString("3050f240-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLImgElement = &IID_IHTMLImgElement_Value;
pub const IHTMLImgElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_isMap: fn(
            self: *const IHTMLImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isMap: fn(
            self: *const IHTMLImgElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_useMap: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_useMap: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileCreatedDate: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocol: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nameProp: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLImgElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLImgElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLImgElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lowsrc: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lowsrc: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vrml: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vrml: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dynsrc: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dynsrc: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_complete: fn(
            self: *const IHTMLImgElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLImgElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLImgElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLImgElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLImgElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLImgElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLImgElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_start: fn(
            self: *const IHTMLImgElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_start: fn(
            self: *const IHTMLImgElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_isMap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_isMap(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_isMap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_isMap(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_useMap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_useMap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_mimeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileSize(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileCreatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileCreatedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileModifiedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileUpdatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_protocol(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_nameProp(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_lowsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_lowsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_vrml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_vrml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_dynsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_dynsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_complete(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_loop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_start(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_start(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLImgElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement2_Value = @import("../zig.zig").Guid.initString("3050f826-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLImgElement2 = &IID_IHTMLImgElement2_Value;
pub const IHTMLImgElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_longDesc: fn(
            self: *const IHTMLImgElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longDesc: fn(
            self: *const IHTMLImgElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement2_put_longDesc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement2.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLImgElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement2_get_longDesc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement2.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLImgElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement3_Value = @import("../zig.zig").Guid.initString("30510434-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLImgElement3 = &IID_IHTMLImgElement3_Value;
pub const IHTMLImgElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_longDesc: fn(
            self: *const IHTMLImgElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longDesc: fn(
            self: *const IHTMLImgElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vrml: fn(
            self: *const IHTMLImgElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vrml: fn(
            self: *const IHTMLImgElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lowsrc: fn(
            self: *const IHTMLImgElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lowsrc: fn(
            self: *const IHTMLImgElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dynsrc: fn(
            self: *const IHTMLImgElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dynsrc: fn(
            self: *const IHTMLImgElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_longDesc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_longDesc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_vrml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_vrml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_lowsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_lowsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_dynsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_dynsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement4_Value = @import("../zig.zig").Guid.initString("305107f6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLImgElement4 = &IID_IHTMLImgElement4_Value;
pub const IHTMLImgElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_naturalWidth: fn(
            self: *const IHTMLImgElement4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_naturalHeight: fn(
            self: *const IHTMLImgElement4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement4_get_naturalWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement4.VTable, self.vtable).get_naturalWidth(@ptrCast(*const IHTMLImgElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement4_get_naturalHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement4.VTable, self.vtable).get_naturalHeight(@ptrCast(*const IHTMLImgElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSImgElement_Value = @import("../zig.zig").Guid.initString("30510793-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMSImgElement = &IID_IHTMLMSImgElement_Value;
pub const IHTMLMSImgElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPlayToDisabled: fn(
            self: *const IHTMLMSImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPlayToDisabled: fn(
            self: *const IHTMLMSImgElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPlayToPrimary: fn(
            self: *const IHTMLMSImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPlayToPrimary: fn(
            self: *const IHTMLMSImgElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_put_msPlayToDisabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).put_msPlayToDisabled(@ptrCast(*const IHTMLMSImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_get_msPlayToDisabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).get_msPlayToDisabled(@ptrCast(*const IHTMLMSImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_put_msPlayToPrimary(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).put_msPlayToPrimary(@ptrCast(*const IHTMLMSImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_get_msPlayToPrimary(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).get_msPlayToPrimary(@ptrCast(*const IHTMLMSImgElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImageElementFactory_Value = @import("../zig.zig").Guid.initString("3050f38e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLImageElementFactory = &IID_IHTMLImageElementFactory_Value;
pub const IHTMLImageElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLImageElementFactory,
            width: VARIANT,
            height: VARIANT,
            __MIDL__IHTMLImageElementFactory0000: ?*?*IHTMLImgElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImageElementFactory_create(self: *const T, width: VARIANT, height: VARIANT, __MIDL__IHTMLImageElementFactory0000: ?*?*IHTMLImgElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImageElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLImageElementFactory, self), width, height, __MIDL__IHTMLImageElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLImg_Value = @import("../zig.zig").Guid.initString("3050f51c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLImg = &IID_DispHTMLImg_Value;
pub const DispHTMLImg = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement_Value = @import("../zig.zig").Guid.initString("3050f1d8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBodyElement = &IID_IHTMLBodyElement_Value;
pub const IHTMLBodyElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLBodyElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLBodyElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgProperties: fn(
            self: *const IHTMLBodyElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgProperties: fn(
            self: *const IHTMLBodyElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_leftMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_leftMargin: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_topMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_topMargin: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rightMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rightMargin: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bottomMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bottomMargin: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noWrap: fn(
            self: *const IHTMLBodyElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noWrap: fn(
            self: *const IHTMLBodyElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_link: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_link: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vLink: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vLink: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_aLink: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_aLink: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onunload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onunload: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scroll: fn(
            self: *const IHTMLBodyElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scroll: fn(
            self: *const IHTMLBodyElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeunload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeunload: fn(
            self: *const IHTMLBodyElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLBodyElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_background(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_background(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bgProperties(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bgProperties(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bgProperties(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bgProperties(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_leftMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_leftMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_leftMargin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_leftMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_topMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_topMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_topMargin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_topMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_rightMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_rightMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_rightMargin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_rightMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bottomMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bottomMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bottomMargin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bottomMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_noWrap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_text(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_text(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_link(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_link(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_link(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_link(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_vLink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_vLink(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_vLink(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_vLink(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_aLink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_aLink(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_aLink(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_aLink(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_scroll(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_scroll(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_scroll(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_scroll(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onbeforeunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLBodyElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement2_Value = @import("../zig.zig").Guid.initString("3050f5c5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBodyElement2 = &IID_IHTMLBodyElement2_Value;
pub const IHTMLBodyElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeprint: fn(
            self: *const IHTMLBodyElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeprint: fn(
            self: *const IHTMLBodyElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onafterprint: fn(
            self: *const IHTMLBodyElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onafterprint: fn(
            self: *const IHTMLBodyElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLBodyElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_get_onbeforeprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLBodyElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLBodyElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_get_onafterprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLBodyElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement3_Value = @import("../zig.zig").Guid.initString("30510422-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBodyElement3 = &IID_IHTMLBodyElement3_Value;
pub const IHTMLBodyElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLBodyElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLBodyElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ononline: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ononline: fn(
            self: *const IHTMLBodyElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onoffline: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onoffline: fn(
            self: *const IHTMLBodyElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhashchange: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhashchange: fn(
            self: *const IHTMLBodyElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_background(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_background(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_ononline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_onoffline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_onhashchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement4_Value = @import("../zig.zig").Guid.initString("30510795-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBodyElement4 = &IID_IHTMLBodyElement4_Value;
pub const IHTMLBodyElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmessage: fn(
            self: *const IHTMLBodyElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmessage: fn(
            self: *const IHTMLBodyElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstorage: fn(
            self: *const IHTMLBodyElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstorage: fn(
            self: *const IHTMLBodyElement4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLBodyElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_get_onmessage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLBodyElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLBodyElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_get_onstorage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLBodyElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement5_Value = @import("../zig.zig").Guid.initString("30510822-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBodyElement5 = &IID_IHTMLBodyElement5_Value;
pub const IHTMLBodyElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpopstate: fn(
            self: *const IHTMLBodyElement5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpopstate: fn(
            self: *const IHTMLBodyElement5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement5_put_onpopstate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement5.VTable, self.vtable).put_onpopstate(@ptrCast(*const IHTMLBodyElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement5_get_onpopstate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement5.VTable, self.vtable).get_onpopstate(@ptrCast(*const IHTMLBodyElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBody_Value = @import("../zig.zig").Guid.initString("3050f507-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBody = &IID_DispHTMLBody_Value;
pub const DispHTMLBody = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050f1d9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFontElement = &IID_IHTMLFontElement_Value;
pub const IHTMLFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLFontElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_face: fn(
            self: *const IHTMLFontElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_face: fn(
            self: *const IHTMLFontElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLFontElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_face(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_face(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_face(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_face(@ptrCast(*const IHTMLFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_size(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_size(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLFontElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050f512-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFontElement = &IID_DispHTMLFontElement_Value;
pub const DispHTMLFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAnchorEvents2_Value = @import("../zig.zig").Guid.initString("3050f610-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLAnchorEvents2 = &IID_HTMLAnchorEvents2_Value;
pub const HTMLAnchorEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAnchorEvents_Value = @import("../zig.zig").Guid.initString("3050f29d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLAnchorEvents = &IID_HTMLAnchorEvents_Value;
pub const HTMLAnchorEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050f1da-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAnchorElement = &IID_IHTMLAnchorElement_Value;
pub const IHTMLAnchorElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_target: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rel: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rel: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rev: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rev: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_urn: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_urn: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Methods: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Methods: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_host: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_host: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hostname: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hostname: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pathname: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathname: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_port: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_port: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_protocol: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocol: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_search: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_search: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hash: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hash: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLAnchorElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLAnchorElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLAnchorElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLAnchorElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accessKey: fn(
            self: *const IHTMLAnchorElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accessKey: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocolLong: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nameProp: fn(
            self: *const IHTMLAnchorElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tabIndex: fn(
            self: *const IHTMLAnchorElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tabIndex: fn(
            self: *const IHTMLAnchorElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLAnchorElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLAnchorElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_target(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_rel(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_rel(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_rel(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_rel(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_rev(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_rev(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_rev(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_rev(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_urn(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_urn(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_urn(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_urn(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_Methods(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_Methods(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_Methods(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_Methods(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_host(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_host(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_host(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_host(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_hostname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_hostname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_pathname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_pathname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_port(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_port(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_port(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_port(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_protocol(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_protocol(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_search(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_search(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_search(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_search(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_hash(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_hash(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_accessKey(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_accessKey(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_protocolLong(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_protocolLong(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_mimeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_nameProp(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_tabIndex(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLAnchorElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLAnchorElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement2_Value = @import("../zig.zig").Guid.initString("3050f825-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAnchorElement2 = &IID_IHTMLAnchorElement2_Value;
pub const IHTMLAnchorElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IHTMLAnchorElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IHTMLAnchorElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_coords: fn(
            self: *const IHTMLAnchorElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_coords: fn(
            self: *const IHTMLAnchorElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hreflang: fn(
            self: *const IHTMLAnchorElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hreflang: fn(
            self: *const IHTMLAnchorElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shape: fn(
            self: *const IHTMLAnchorElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shape: fn(
            self: *const IHTMLAnchorElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLAnchorElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLAnchorElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_charset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_coords(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_coords(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_hreflang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_hreflang(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_hreflang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_hreflang(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_shape(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_shape(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement3_Value = @import("../zig.zig").Guid.initString("3051041d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAnchorElement3 = &IID_IHTMLAnchorElement3_Value;
pub const IHTMLAnchorElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shape: fn(
            self: *const IHTMLAnchorElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shape: fn(
            self: *const IHTMLAnchorElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_coords: fn(
            self: *const IHTMLAnchorElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_coords: fn(
            self: *const IHTMLAnchorElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLAnchorElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLAnchorElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_shape(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_shape(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_coords(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_coords(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050f502-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAnchorElement = &IID_DispHTMLAnchorElement_Value;
pub const DispHTMLAnchorElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLabelEvents2_Value = @import("../zig.zig").Guid.initString("3050f61c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLLabelEvents2 = &IID_HTMLLabelEvents2_Value;
pub const HTMLLabelEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLabelEvents_Value = @import("../zig.zig").Guid.initString("3050f329-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLLabelEvents = &IID_HTMLLabelEvents_Value;
pub const HTMLLabelEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050f32a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLabelElement = &IID_IHTMLLabelElement_Value;
pub const IHTMLLabelElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_htmlFor: fn(
            self: *const IHTMLLabelElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_htmlFor: fn(
            self: *const IHTMLLabelElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accessKey: fn(
            self: *const IHTMLLabelElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accessKey: fn(
            self: *const IHTMLLabelElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_put_htmlFor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).put_htmlFor(@ptrCast(*const IHTMLLabelElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_get_htmlFor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).get_htmlFor(@ptrCast(*const IHTMLLabelElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_put_accessKey(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLLabelElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_get_accessKey(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLLabelElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLabelElement2_Value = @import("../zig.zig").Guid.initString("3050f832-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLabelElement2 = &IID_IHTMLLabelElement2_Value;
pub const IHTMLLabelElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLLabelElement2,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement2_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLLabelElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050f522-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLLabelElement = &IID_DispHTMLLabelElement_Value;
pub const DispHTMLLabelElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLListElement_Value = @import("../zig.zig").Guid.initString("3050f20e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLListElement = &IID_IHTMLListElement_Value;
pub const IHTMLListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLListElement2_Value = @import("../zig.zig").Guid.initString("3050f822-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLListElement2 = &IID_IHTMLListElement2_Value;
pub const IHTMLListElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_compact: fn(
            self: *const IHTMLListElement2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compact: fn(
            self: *const IHTMLListElement2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLListElement2_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLListElement2.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLListElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLListElement2_get_compact(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLListElement2.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLListElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLListElement_Value = @import("../zig.zig").Guid.initString("3050f525-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLListElement = &IID_DispHTMLListElement_Value;
pub const DispHTMLListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050f1dd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLUListElement = &IID_IHTMLUListElement_Value;
pub const IHTMLUListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_compact: fn(
            self: *const IHTMLUListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compact: fn(
            self: *const IHTMLUListElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLUListElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLUListElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLUListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_get_compact(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLUListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLUListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLUListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050f538-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLUListElement = &IID_DispHTMLUListElement_Value;
pub const DispHTMLUListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050f1de-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOListElement = &IID_IHTMLOListElement_Value;
pub const IHTMLOListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_compact: fn(
            self: *const IHTMLOListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compact: fn(
            self: *const IHTMLOListElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_start: fn(
            self: *const IHTMLOListElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_start: fn(
            self: *const IHTMLOListElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLOListElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLOListElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_compact(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLOListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_start(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_start(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLOListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLOListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050f52a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLOListElement = &IID_DispHTMLOListElement_Value;
pub const DispHTMLOListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050f1e0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLIElement = &IID_IHTMLLIElement_Value;
pub const IHTMLLIElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLLIElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLLIElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLLIElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLLIElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLLIElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLLIElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_put_value(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLLIElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_get_value(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLLIElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050f523-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLLIElement = &IID_DispHTMLLIElement_Value;
pub const DispHTMLLIElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050f208-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBlockElement = &IID_IHTMLBlockElement_Value;
pub const IHTMLBlockElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clear: fn(
            self: *const IHTMLBlockElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLBlockElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement_put_clear(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLBlockElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLBlockElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement2_Value = @import("../zig.zig").Guid.initString("3050f823-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBlockElement2 = &IID_IHTMLBlockElement2_Value;
pub const IHTMLBlockElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cite: fn(
            self: *const IHTMLBlockElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cite: fn(
            self: *const IHTMLBlockElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLBlockElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLBlockElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_put_cite(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLBlockElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_get_cite(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLBlockElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_put_width(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLBlockElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_get_width(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLBlockElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement3_Value = @import("../zig.zig").Guid.initString("30510494-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBlockElement3 = &IID_IHTMLBlockElement3_Value;
pub const IHTMLBlockElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cite: fn(
            self: *const IHTMLBlockElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cite: fn(
            self: *const IHTMLBlockElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement3_put_cite(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement3.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLBlockElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement3_get_cite(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement3.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLBlockElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050f506-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBlockElement = &IID_DispHTMLBlockElement_Value;
pub const DispHTMLBlockElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050f200-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDivElement = &IID_IHTMLDivElement_Value;
pub const IHTMLDivElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLDivElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLDivElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noWrap: fn(
            self: *const IHTMLDivElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noWrap: fn(
            self: *const IHTMLDivElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLDivElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLDivElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDivElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_get_noWrap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDivElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050f50c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDivElement = &IID_DispHTMLDivElement_Value;
pub const DispHTMLDivElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050f1f2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDDElement = &IID_IHTMLDDElement_Value;
pub const IHTMLDDElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noWrap: fn(
            self: *const IHTMLDDElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noWrap: fn(
            self: *const IHTMLDDElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDDElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDDElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDDElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDDElement_get_noWrap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDDElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDDElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050f50b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDDElement = &IID_DispHTMLDDElement_Value;
pub const DispHTMLDDElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050f1f3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDTElement = &IID_IHTMLDTElement_Value;
pub const IHTMLDTElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noWrap: fn(
            self: *const IHTMLDTElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noWrap: fn(
            self: *const IHTMLDTElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDTElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDTElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDTElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDTElement_get_noWrap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDTElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDTElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050f50d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDTElement = &IID_DispHTMLDTElement_Value;
pub const DispHTMLDTElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050f1f0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBRElement = &IID_IHTMLBRElement_Value;
pub const IHTMLBRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clear: fn(
            self: *const IHTMLBRElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clear: fn(
            self: *const IHTMLBRElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBRElement_put_clear(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBRElement.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLBRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBRElement_get_clear(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBRElement.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLBRElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050f53a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBRElement = &IID_DispHTMLBRElement_Value;
pub const DispHTMLBRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050f1f1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDListElement = &IID_IHTMLDListElement_Value;
pub const IHTMLDListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_compact: fn(
            self: *const IHTMLDListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compact: fn(
            self: *const IHTMLDListElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLDListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDListElement_get_compact(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLDListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050f53b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDListElement = &IID_DispHTMLDListElement_Value;
pub const DispHTMLDListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050f1f4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLHRElement = &IID_IHTMLHRElement_Value;
pub const IHTMLHRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLHRElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLHRElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLHRElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noShade: fn(
            self: *const IHTMLHRElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noShade: fn(
            self: *const IHTMLHRElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLHRElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLHRElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_noShade(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_noShade(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_noShade(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_noShade(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_size(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_size(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLHRElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050f53d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLHRElement = &IID_DispHTMLHRElement_Value;
pub const DispHTMLHRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050f1f5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLParaElement = &IID_IHTMLParaElement_Value;
pub const IHTMLParaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLParaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLParaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParaElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParaElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLParaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParaElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParaElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLParaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050f52c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLParaElement = &IID_DispHTMLParaElement_Value;
pub const DispHTMLParaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection2_Value = @import("../zig.zig").Guid.initString("3050f5ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementCollection2 = &IID_IHTMLElementCollection2_Value;
pub const IHTMLElementCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLElementCollection2,
            urn: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection2_urns(self: *const T, urn: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection2.VTable, self.vtable).urns(@ptrCast(*const IHTMLElementCollection2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection3_Value = @import("../zig.zig").Guid.initString("3050f835-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementCollection3 = &IID_IHTMLElementCollection3_Value;
pub const IHTMLElementCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLElementCollection3,
            name: ?BSTR,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection3_namedItem(self: *const T, name: ?BSTR, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLElementCollection3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection4_Value = @import("../zig.zig").Guid.initString("30510425-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLElementCollection4 = &IID_IHTMLElementCollection4_Value;
pub const IHTMLElementCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLElementCollection4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLElementCollection4,
            index: i32,
            pNode: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedItem: fn(
            self: *const IHTMLElementCollection4,
            name: ?BSTR,
            pNode: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLElementCollection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_item(self: *const T, index: i32, pNode: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLElementCollection4, self), index, pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_namedItem(self: *const T, name: ?BSTR, pNode: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLElementCollection4, self), name, pNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050f56b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLElementCollection = &IID_DispHTMLElementCollection_Value;
pub const DispHTMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050f1f6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLHeaderElement = &IID_IHTMLHeaderElement_Value;
pub const IHTMLHeaderElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLHeaderElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLHeaderElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeaderElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeaderElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLHeaderElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeaderElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeaderElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLHeaderElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050f515-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLHeaderElement = &IID_DispHTMLHeaderElement_Value;
pub const DispHTMLHeaderElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLSelectElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f622-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLSelectElementEvents2 = &IID_HTMLSelectElementEvents2_Value;
pub const HTMLSelectElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLSelectElementEvents_Value = @import("../zig.zig").Guid.initString("3050f302-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLSelectElementEvents = &IID_HTMLSelectElementEvents_Value;
pub const HTMLSelectElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050f211-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionElement = &IID_IHTMLOptionElement_Value;
pub const IHTMLOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selected: fn(
            self: *const IHTMLOptionElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selected: fn(
            self: *const IHTMLOptionElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLOptionElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLOptionElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultSelected: fn(
            self: *const IHTMLOptionElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultSelected: fn(
            self: *const IHTMLOptionElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_index: fn(
            self: *const IHTMLOptionElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_index: fn(
            self: *const IHTMLOptionElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLOptionElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLOptionElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLOptionElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_selected(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_selected(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_selected(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_selected(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_defaultSelected(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_defaultSelected(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_defaultSelected(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_defaultSelected(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_index(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_index(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_index(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_index(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_text(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLOptionElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElementEx_Value = @import("../zig.zig").Guid.initString("3050f2d1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElementEx = &IID_IHTMLSelectElementEx_Value;
pub const IHTMLSelectElementEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDropdown: fn(
            self: *const IHTMLSelectElementEx,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelectExFlags: fn(
            self: *const IHTMLSelectElementEx,
            lFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectExFlags: fn(
            self: *const IHTMLSelectElementEx,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropdownOpen: fn(
            self: *const IHTMLSelectElementEx,
            pfOpen: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_ShowDropdown(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).ShowDropdown(@ptrCast(*const IHTMLSelectElementEx, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_SetSelectExFlags(self: *const T, lFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).SetSelectExFlags(@ptrCast(*const IHTMLSelectElementEx, self), lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_GetSelectExFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).GetSelectExFlags(@ptrCast(*const IHTMLSelectElementEx, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_GetDropdownOpen(self: *const T, pfOpen: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).GetDropdownOpen(@ptrCast(*const IHTMLSelectElementEx, self), pfOpen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050f244-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElement = &IID_IHTMLSelectElement_Value;
pub const IHTMLSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLSelectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_multiple: fn(
            self: *const IHTMLSelectElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_multiple: fn(
            self: *const IHTMLSelectElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLSelectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLSelectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_options: fn(
            self: *const IHTMLSelectElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLSelectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLSelectElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectedIndex: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectedIndex: fn(
            self: *const IHTMLSelectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLSelectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLSelectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLSelectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLSelectElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLSelectElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLSelectElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLSelectElement,
            element: ?*IHTMLElement,
            before: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLSelectElement,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLSelectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLSelectElement,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLSelectElement,
            name: VARIANT,
            index: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLSelectElement,
            tagName: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_size(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_multiple(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_multiple(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_multiple(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_multiple(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_options(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_options(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_selectedIndex(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_selectedIndex(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_selectedIndex(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_selectedIndex(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_add(self: *const T, element: ?*IHTMLElement, before: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement, self), element, before);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).remove(@ptrCast(*const IHTMLSelectElement, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_length(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_length(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).item(@ptrCast(*const IHTMLSelectElement, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_tags(self: *const T, tagName: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).tags(@ptrCast(*const IHTMLSelectElement, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement2_Value = @import("../zig.zig").Guid.initString("3050f5ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElement2 = &IID_IHTMLSelectElement2_Value;
pub const IHTMLSelectElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLSelectElement2,
            urn: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement2_urns(self: *const T, urn: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement2.VTable, self.vtable).urns(@ptrCast(*const IHTMLSelectElement2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement4_Value = @import("../zig.zig").Guid.initString("3050f838-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElement4 = &IID_IHTMLSelectElement4_Value;
pub const IHTMLSelectElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLSelectElement4,
            name: ?BSTR,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement4_namedItem(self: *const T, name: ?BSTR, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLSelectElement4, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement5_Value = @import("../zig.zig").Guid.initString("3051049d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElement5 = &IID_IHTMLSelectElement5_Value;
pub const IHTMLSelectElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: fn(
            self: *const IHTMLSelectElement5,
            pElem: ?*IHTMLOptionElement,
            pvarBefore: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement5_add(self: *const T, pElem: ?*IHTMLOptionElement, pvarBefore: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement5.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement5, self), pElem, pvarBefore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement6_Value = @import("../zig.zig").Guid.initString("30510760-98b6-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectElement6 = &IID_IHTMLSelectElement6_Value;
pub const IHTMLSelectElement6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: fn(
            self: *const IHTMLSelectElement6,
            pElem: ?*IHTMLOptionElement,
            pvarBefore: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLSelectElement6,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLSelectElement6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_add(self: *const T, pElem: ?*IHTMLOptionElement, pvarBefore: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement6, self), pElem, pvarBefore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).put_value(@ptrCast(*const IHTMLSelectElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).get_value(@ptrCast(*const IHTMLSelectElement6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050f531-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLSelectElement = &IID_DispHTMLSelectElement_Value;
pub const DispHTMLSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWndSelectElement_Value = @import("../zig.zig").Guid.initString("3050f597-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLWndSelectElement = &IID_DispHTMLWndSelectElement_Value;
pub const DispHTMLWndSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectionObject_Value = @import("../zig.zig").Guid.initString("3050f25a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectionObject = &IID_IHTMLSelectionObject_Value;
pub const IHTMLSelectionObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRange: fn(
            self: *const IHTMLSelectionObject,
            range: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        empty: fn(
            self: *const IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLSelectionObject,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_createRange(self: *const T, range: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).createRange(@ptrCast(*const IHTMLSelectionObject, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_empty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).empty(@ptrCast(*const IHTMLSelectionObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).clear(@ptrCast(*const IHTMLSelectionObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSelectionObject, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectionObject2_Value = @import("../zig.zig").Guid.initString("3050f7ec-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelectionObject2 = &IID_IHTMLSelectionObject2_Value;
pub const IHTMLSelectionObject2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRangeCollection: fn(
            self: *const IHTMLSelectionObject2,
            rangeCollection: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_typeDetail: fn(
            self: *const IHTMLSelectionObject2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject2_createRangeCollection(self: *const T, rangeCollection: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject2.VTable, self.vtable).createRangeCollection(@ptrCast(*const IHTMLSelectionObject2, self), rangeCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject2_get_typeDetail(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject2.VTable, self.vtable).get_typeDetail(@ptrCast(*const IHTMLSelectionObject2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelection_Value = @import("../zig.zig").Guid.initString("305104b6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSelection = &IID_IHTMLSelection_Value;
pub const IHTMLSelection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anchorNode: fn(
            self: *const IHTMLSelection,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anchorOffset: fn(
            self: *const IHTMLSelection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_focusNode: fn(
            self: *const IHTMLSelection,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_focusOffset: fn(
            self: *const IHTMLSelection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isCollapsed: fn(
            self: *const IHTMLSelection,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLSelection,
            parentNode: ?*IDispatch,
            offfset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapseToStart: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapseToEnd: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectAllChildren: fn(
            self: *const IHTMLSelection,
            parentNode: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteFromDocument: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rangeCount: fn(
            self: *const IHTMLSelection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRangeAt: fn(
            self: *const IHTMLSelection,
            index: i32,
            ppRange: ?*?*IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addRange: fn(
            self: *const IHTMLSelection,
            range: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeRange: fn(
            self: *const IHTMLSelection,
            range: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAllRanges: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLSelection,
            pSelectionString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_anchorNode(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_anchorNode(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_anchorOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_anchorOffset(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_focusNode(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_focusNode(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_focusOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_focusOffset(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_isCollapsed(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_isCollapsed(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapse(self: *const T, parentNode: ?*IDispatch, offfset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapse(@ptrCast(*const IHTMLSelection, self), parentNode, offfset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapseToStart(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapseToStart(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapseToEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapseToEnd(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_selectAllChildren(self: *const T, parentNode: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).selectAllChildren(@ptrCast(*const IHTMLSelection, self), parentNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_deleteFromDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).deleteFromDocument(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_rangeCount(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_rangeCount(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_getRangeAt(self: *const T, index: i32, ppRange: ?*?*IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).getRangeAt(@ptrCast(*const IHTMLSelection, self), index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_addRange(self: *const T, range: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).addRange(@ptrCast(*const IHTMLSelection, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_removeRange(self: *const T, range: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).removeRange(@ptrCast(*const IHTMLSelection, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_removeAllRanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).removeAllRanges(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_toString(self: *const T, pSelectionString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).toString(@ptrCast(*const IHTMLSelection, self), pSelectionString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement3_Value = @import("../zig.zig").Guid.initString("3050f820-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionElement3 = &IID_IHTMLOptionElement3_Value;
pub const IHTMLOptionElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_label: fn(
            self: *const IHTMLOptionElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_label: fn(
            self: *const IHTMLOptionElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement3_put_label(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement3.VTable, self.vtable).put_label(@ptrCast(*const IHTMLOptionElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement3_get_label(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement3.VTable, self.vtable).get_label(@ptrCast(*const IHTMLOptionElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement4_Value = @import("../zig.zig").Guid.initString("305107b4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionElement4 = &IID_IHTMLOptionElement4_Value;
pub const IHTMLOptionElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLOptionElement4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLOptionElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement4_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement4.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement4_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement4.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElementFactory_Value = @import("../zig.zig").Guid.initString("3050f38c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionElementFactory = &IID_IHTMLOptionElementFactory_Value;
pub const IHTMLOptionElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLOptionElementFactory,
            text: VARIANT,
            value: VARIANT,
            defaultselected: VARIANT,
            selected: VARIANT,
            __MIDL__IHTMLOptionElementFactory0000: ?*?*IHTMLOptionElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElementFactory_create(self: *const T, text: VARIANT, value: VARIANT, defaultselected: VARIANT, selected: VARIANT, __MIDL__IHTMLOptionElementFactory0000: ?*?*IHTMLOptionElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLOptionElementFactory, self), text, value, defaultselected, selected, __MIDL__IHTMLOptionElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050f52b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLOptionElement = &IID_DispHTMLOptionElement_Value;
pub const DispHTMLOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWndOptionElement_Value = @import("../zig.zig").Guid.initString("3050f598-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLWndOptionElement = &IID_DispHTMLWndOptionElement_Value;
pub const DispHTMLWndOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLButtonElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f617-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLButtonElementEvents2 = &IID_HTMLButtonElementEvents2_Value;
pub const HTMLButtonElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLButtonElementEvents_Value = @import("../zig.zig").Guid.initString("3050f2b3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLButtonElementEvents = &IID_HTMLButtonElementEvents_Value;
pub const HTMLButtonElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputTextElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f618-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputTextElementEvents2 = &IID_HTMLInputTextElementEvents2_Value;
pub const HTMLInputTextElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLOptionButtonElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f619-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLOptionButtonElementEvents2 = &IID_HTMLOptionButtonElementEvents2_Value;
pub const HTMLOptionButtonElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputFileElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f61a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputFileElementEvents2 = &IID_HTMLInputFileElementEvents2_Value;
pub const HTMLInputFileElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputImageEvents2_Value = @import("../zig.zig").Guid.initString("3050f61b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputImageEvents2 = &IID_HTMLInputImageEvents2_Value;
pub const HTMLInputImageEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputTextElementEvents_Value = @import("../zig.zig").Guid.initString("3050f2a7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputTextElementEvents = &IID_HTMLInputTextElementEvents_Value;
pub const HTMLInputTextElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLOptionButtonElementEvents_Value = @import("../zig.zig").Guid.initString("3050f2bd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLOptionButtonElementEvents = &IID_HTMLOptionButtonElementEvents_Value;
pub const HTMLOptionButtonElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputFileElementEvents_Value = @import("../zig.zig").Guid.initString("3050f2af-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputFileElementEvents = &IID_HTMLInputFileElementEvents_Value;
pub const HTMLInputFileElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputImageEvents_Value = @import("../zig.zig").Guid.initString("3050f2c3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLInputImageEvents = &IID_HTMLInputImageEvents_Value;
pub const HTMLInputImageEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050f5d2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputElement = &IID_IHTMLInputElement_Value;
pub const IHTMLInputElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLInputElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxLength: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxLength: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultValue: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_readOnly: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readOnly: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_indeterminate: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_indeterminate: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultChecked: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultChecked: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_checked: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_checked: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lowsrc: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lowsrc: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vrml: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vrml: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dynsrc: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dynsrc: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_complete: fn(
            self: *const IHTMLInputElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLInputElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLInputElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_start: fn(
            self: *const IHTMLInputElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_start: fn(
            self: *const IHTMLInputElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_status(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_status(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_size(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_maxLength(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_defaultValue(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_defaultValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_readOnly(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputElement, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_indeterminate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_indeterminate(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_indeterminate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_indeterminate(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_defaultChecked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_defaultChecked(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_defaultChecked(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_defaultChecked(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_checked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_checked(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_checked(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_checked(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_lowsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_lowsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_vrml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_vrml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_dynsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_dynsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_complete(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_loop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_start(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_start(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLInputElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement2_Value = @import("../zig.zig").Guid.initString("3050f821-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputElement2 = &IID_IHTMLInputElement2_Value;
pub const IHTMLInputElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accept: fn(
            self: *const IHTMLInputElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accept: fn(
            self: *const IHTMLInputElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_useMap: fn(
            self: *const IHTMLInputElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_useMap: fn(
            self: *const IHTMLInputElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_put_accept(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).put_accept(@ptrCast(*const IHTMLInputElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_get_accept(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).get_accept(@ptrCast(*const IHTMLInputElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_put_useMap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLInputElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_get_useMap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLInputElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement3_Value = @import("../zig.zig").Guid.initString("30510435-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputElement3 = &IID_IHTMLInputElement3_Value;
pub const IHTMLInputElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLInputElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLInputElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lowsrc: fn(
            self: *const IHTMLInputElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lowsrc: fn(
            self: *const IHTMLInputElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vrml: fn(
            self: *const IHTMLInputElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vrml: fn(
            self: *const IHTMLInputElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dynsrc: fn(
            self: *const IHTMLInputElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dynsrc: fn(
            self: *const IHTMLInputElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_lowsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_lowsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_vrml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_vrml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_dynsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_dynsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2b2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputButtonElement = &IID_IHTMLInputButtonElement_Value;
pub const IHTMLInputButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLInputButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLInputButtonElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputButtonElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputButtonElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputHiddenElement_Value = @import("../zig.zig").Guid.initString("3050f2a4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputHiddenElement = &IID_IHTMLInputHiddenElement_Value;
pub const IHTMLInputHiddenElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputHiddenElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputHiddenElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLInputHiddenElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputHiddenElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLInputHiddenElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputHiddenElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputHiddenElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050f2a6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputTextElement = &IID_IHTMLInputTextElement_Value;
pub const IHTMLInputTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputTextElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputTextElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputTextElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputTextElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputTextElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLInputTextElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputTextElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputTextElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLInputTextElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultValue: fn(
            self: *const IHTMLInputTextElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: fn(
            self: *const IHTMLInputTextElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLInputTextElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLInputTextElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxLength: fn(
            self: *const IHTMLInputTextElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxLength: fn(
            self: *const IHTMLInputTextElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputTextElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLInputTextElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLInputTextElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_readOnly: fn(
            self: *const IHTMLInputTextElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readOnly: fn(
            self: *const IHTMLInputTextElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputTextElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_defaultValue(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_defaultValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_size(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_maxLength(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputTextElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_readOnly(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputTextElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputTextElement2_Value = @import("../zig.zig").Guid.initString("3050f2d2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputTextElement2 = &IID_IHTMLInputTextElement2_Value;
pub const IHTMLInputTextElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectionStart: fn(
            self: *const IHTMLInputTextElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectionStart: fn(
            self: *const IHTMLInputTextElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectionEnd: fn(
            self: *const IHTMLInputTextElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectionEnd: fn(
            self: *const IHTMLInputTextElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSelectionRange: fn(
            self: *const IHTMLInputTextElement2,
            start: i32,
            end: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_put_selectionStart(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).put_selectionStart(@ptrCast(*const IHTMLInputTextElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_get_selectionStart(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).get_selectionStart(@ptrCast(*const IHTMLInputTextElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_put_selectionEnd(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).put_selectionEnd(@ptrCast(*const IHTMLInputTextElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_get_selectionEnd(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).get_selectionEnd(@ptrCast(*const IHTMLInputTextElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_setSelectionRange(self: *const T, start: i32, end: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).setSelectionRange(@ptrCast(*const IHTMLInputTextElement2, self), start, end);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050f2ad-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputFileElement = &IID_IHTMLInputFileElement_Value;
pub const IHTMLInputFileElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputFileElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputFileElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputFileElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLInputFileElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputFileElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputFileElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLInputFileElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLInputFileElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLInputFileElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxLength: fn(
            self: *const IHTMLInputFileElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxLength: fn(
            self: *const IHTMLInputFileElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputFileElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLInputFileElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLInputFileElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputFileElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputFileElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_size(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_maxLength(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputFileElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2bc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionButtonElement = &IID_IHTMLOptionButtonElement_Value;
pub const IHTMLOptionButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLOptionButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLOptionButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_checked: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_checked: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultChecked: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultChecked: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLOptionButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_indeterminate: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_indeterminate: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLOptionButtonElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_checked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_checked(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_checked(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_checked(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_defaultChecked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_defaultChecked(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_defaultChecked(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_defaultChecked(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_status(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_status(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_indeterminate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_indeterminate(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_indeterminate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_indeterminate(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050f2c2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputImage = &IID_IHTMLInputImage_Value;
pub const IHTMLInputImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputImage,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputImage,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLInputImage,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLInputImage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLInputImage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lowsrc: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lowsrc: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vrml: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vrml: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dynsrc: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dynsrc: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_complete: fn(
            self: *const IHTMLInputImage,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLInputImage,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLInputImage,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLInputImage,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLInputImage,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLInputImage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLInputImage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_start: fn(
            self: *const IHTMLInputImage,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_start: fn(
            self: *const IHTMLInputImage,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_border(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_border(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_lowsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_lowsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_vrml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_vrml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_dynsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_dynsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_complete(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_loop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_align(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_align(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_width(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_width(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_height(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_height(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_start(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_start(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_start(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_start(@ptrCast(*const IHTMLInputImage, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputRangeElement_Value = @import("../zig.zig").Guid.initString("3050f2d4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLInputRangeElement = &IID_IHTMLInputRangeElement_Value;
pub const IHTMLInputRangeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLInputRangeElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_min: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_min: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_max: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_max: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_step: fn(
            self: *const IHTMLInputRangeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_step: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueAsNumber: fn(
            self: *const IHTMLInputRangeElement,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueAsNumber: fn(
            self: *const IHTMLInputRangeElement,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stepUp: fn(
            self: *const IHTMLInputRangeElement,
            n: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stepDown: fn(
            self: *const IHTMLInputRangeElement,
            n: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_min(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_min(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_min(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_min(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_max(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_max(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_max(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_max(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_step(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_step(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_step(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_step(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_valueAsNumber(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_valueAsNumber(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_valueAsNumber(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_valueAsNumber(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_stepUp(self: *const T, n: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).stepUp(@ptrCast(*const IHTMLInputRangeElement, self), n);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_stepDown(self: *const T, n: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).stepDown(@ptrCast(*const IHTMLInputRangeElement, self), n);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050f57d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLInputElement = &IID_DispHTMLInputElement_Value;
pub const DispHTMLInputElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050f2aa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextAreaElement = &IID_IHTMLTextAreaElement_Value;
pub const IHTMLTextAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLTextAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLTextAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLTextAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultValue: fn(
            self: *const IHTMLTextAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLTextAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_readOnly: fn(
            self: *const IHTMLTextAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readOnly: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rows: fn(
            self: *const IHTMLTextAreaElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rows: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cols: fn(
            self: *const IHTMLTextAreaElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cols: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_wrap: fn(
            self: *const IHTMLTextAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wrap: fn(
            self: *const IHTMLTextAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLTextAreaElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_defaultValue(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_defaultValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).select(@ptrCast(*const IHTMLTextAreaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_readOnly(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_rows(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_rows(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_rows(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_cols(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_cols(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_wrap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_wrap(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_wrap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_wrap(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLTextAreaElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextAreaElement2_Value = @import("../zig.zig").Guid.initString("3050f2d3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTextAreaElement2 = &IID_IHTMLTextAreaElement2_Value;
pub const IHTMLTextAreaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectionStart: fn(
            self: *const IHTMLTextAreaElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectionStart: fn(
            self: *const IHTMLTextAreaElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectionEnd: fn(
            self: *const IHTMLTextAreaElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectionEnd: fn(
            self: *const IHTMLTextAreaElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSelectionRange: fn(
            self: *const IHTMLTextAreaElement2,
            start: i32,
            end: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_put_selectionStart(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).put_selectionStart(@ptrCast(*const IHTMLTextAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_get_selectionStart(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).get_selectionStart(@ptrCast(*const IHTMLTextAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_put_selectionEnd(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).put_selectionEnd(@ptrCast(*const IHTMLTextAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_get_selectionEnd(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).get_selectionEnd(@ptrCast(*const IHTMLTextAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_setSelectionRange(self: *const T, start: i32, end: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).setSelectionRange(@ptrCast(*const IHTMLTextAreaElement2, self), start, end);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050f521-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTextAreaElement = &IID_DispHTMLTextAreaElement_Value;
pub const DispHTMLTextAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRichtextElement_Value = @import("../zig.zig").Guid.initString("3050f54d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLRichtextElement = &IID_DispHTMLRichtextElement_Value;
pub const DispHTMLRichtextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050f2bb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLButtonElement = &IID_IHTMLButtonElement_Value;
pub const IHTMLButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLButtonElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLButtonElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLButtonElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLButtonElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLButtonElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLButtonElement,
            range: ?*?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_status(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_createTextRange(self: *const T, range: ?*?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLButtonElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLButtonElement2_Value = @import("../zig.zig").Guid.initString("305106f3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLButtonElement2 = &IID_IHTMLButtonElement2_Value;
pub const IHTMLButtonElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLButtonElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLButtonElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement2_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLButtonElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement2_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLButtonElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050f51f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLButtonElement = &IID_DispHTMLButtonElement_Value;
pub const DispHTMLButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMarqueeElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f61f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLMarqueeElementEvents2 = &IID_HTMLMarqueeElementEvents2_Value;
pub const HTMLMarqueeElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMarqueeElementEvents_Value = @import("../zig.zig").Guid.initString("3050f2b8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLMarqueeElementEvents = &IID_HTMLMarqueeElementEvents_Value;
pub const HTMLMarqueeElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050f2b5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMarqueeElement = &IID_IHTMLMarqueeElement_Value;
pub const IHTMLMarqueeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollDelay: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollDelay: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_direction: fn(
            self: *const IHTMLMarqueeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_behavior: fn(
            self: *const IHTMLMarqueeElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behavior: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollAmount: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollAmount: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfinish: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfinish: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstart: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstart: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbounce: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbounce: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_trueSpeed: fn(
            self: *const IHTMLMarqueeElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_trueSpeed: fn(
            self: *const IHTMLMarqueeElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        start: fn(
            self: *const IHTMLMarqueeElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stop: fn(
            self: *const IHTMLMarqueeElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_scrollDelay(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_scrollDelay(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_scrollDelay(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_scrollDelay(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_direction(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_direction(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_behavior(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_behavior(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_scrollAmount(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_scrollAmount(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_scrollAmount(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_scrollAmount(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_loop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_loop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onfinish(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onfinish(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onfinish(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onfinish(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onstart(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onstart(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onbounce(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onbounce(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onbounce(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onbounce(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_trueSpeed(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_trueSpeed(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_trueSpeed(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_trueSpeed(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).start(@ptrCast(*const IHTMLMarqueeElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).stop(@ptrCast(*const IHTMLMarqueeElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050f527-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMarqueeElement = &IID_DispHTMLMarqueeElement_Value;
pub const DispHTMLMarqueeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050f81c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLHtmlElement = &IID_IHTMLHtmlElement_Value;
pub const IHTMLHtmlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_version: fn(
            self: *const IHTMLHtmlElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IHTMLHtmlElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHtmlElement_put_version(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHtmlElement.VTable, self.vtable).put_version(@ptrCast(*const IHTMLHtmlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHtmlElement_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHtmlElement.VTable, self.vtable).get_version(@ptrCast(*const IHTMLHtmlElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050f81d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLHeadElement = &IID_IHTMLHeadElement_Value;
pub const IHTMLHeadElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_profile: fn(
            self: *const IHTMLHeadElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_profile: fn(
            self: *const IHTMLHeadElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement_put_profile(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement.VTable, self.vtable).put_profile(@ptrCast(*const IHTMLHeadElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement_get_profile(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement.VTable, self.vtable).get_profile(@ptrCast(*const IHTMLHeadElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeadElement2_Value = @import("../zig.zig").Guid.initString("3051042f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLHeadElement2 = &IID_IHTMLHeadElement2_Value;
pub const IHTMLHeadElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_profile: fn(
            self: *const IHTMLHeadElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_profile: fn(
            self: *const IHTMLHeadElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement2_put_profile(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement2.VTable, self.vtable).put_profile(@ptrCast(*const IHTMLHeadElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement2_get_profile(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement2.VTable, self.vtable).get_profile(@ptrCast(*const IHTMLHeadElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050f322-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTitleElement = &IID_IHTMLTitleElement_Value;
pub const IHTMLTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLTitleElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLTitleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTitleElement_put_text(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTitleElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLTitleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTitleElement_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTitleElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLTitleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050f203-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMetaElement = &IID_IHTMLMetaElement_Value;
pub const IHTMLMetaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_httpEquiv: fn(
            self: *const IHTMLMetaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_httpEquiv: fn(
            self: *const IHTMLMetaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_content: fn(
            self: *const IHTMLMetaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_content: fn(
            self: *const IHTMLMetaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLMetaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLMetaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_url: fn(
            self: *const IHTMLMetaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IHTMLMetaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IHTMLMetaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IHTMLMetaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_httpEquiv(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_httpEquiv(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_httpEquiv(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_httpEquiv(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_content(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_content(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_content(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_content(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_url(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_url(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_url(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_url(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_charset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLMetaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement2_Value = @import("../zig.zig").Guid.initString("3050f81f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMetaElement2 = &IID_IHTMLMetaElement2_Value;
pub const IHTMLMetaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scheme: fn(
            self: *const IHTMLMetaElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scheme: fn(
            self: *const IHTMLMetaElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement2_put_scheme(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement2.VTable, self.vtable).put_scheme(@ptrCast(*const IHTMLMetaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement2_get_scheme(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement2.VTable, self.vtable).get_scheme(@ptrCast(*const IHTMLMetaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement3_Value = @import("../zig.zig").Guid.initString("30510495-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMetaElement3 = &IID_IHTMLMetaElement3_Value;
pub const IHTMLMetaElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_url: fn(
            self: *const IHTMLMetaElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IHTMLMetaElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement3_put_url(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement3.VTable, self.vtable).put_url(@ptrCast(*const IHTMLMetaElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement3_get_url(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement3.VTable, self.vtable).get_url(@ptrCast(*const IHTMLMetaElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050f204-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBaseElement = &IID_IHTMLBaseElement_Value;
pub const IHTMLBaseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLBaseElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLBaseElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_target: fn(
            self: *const IHTMLBaseElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IHTMLBaseElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLBaseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLBaseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_put_target(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLBaseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLBaseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseElement2_Value = @import("../zig.zig").Guid.initString("30510420-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBaseElement2 = &IID_IHTMLBaseElement2_Value;
pub const IHTMLBaseElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLBaseElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLBaseElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement2_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement2.VTable, self.vtable).put_href(@ptrCast(*const IHTMLBaseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement2_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement2.VTable, self.vtable).get_href(@ptrCast(*const IHTMLBaseElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050f560-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLHtmlElement = &IID_DispHTMLHtmlElement_Value;
pub const DispHTMLHtmlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050f561-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLHeadElement = &IID_DispHTMLHeadElement_Value;
pub const DispHTMLHeadElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050f516-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTitleElement = &IID_DispHTMLTitleElement_Value;
pub const DispHTMLTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050f517-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMetaElement = &IID_DispHTMLMetaElement_Value;
pub const DispHTMLMetaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050f518-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBaseElement = &IID_DispHTMLBaseElement_Value;
pub const DispHTMLBaseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050f206-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIsIndexElement = &IID_IHTMLIsIndexElement_Value;
pub const IHTMLIsIndexElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_prompt: fn(
            self: *const IHTMLIsIndexElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prompt: fn(
            self: *const IHTMLIsIndexElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_action: fn(
            self: *const IHTMLIsIndexElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_action: fn(
            self: *const IHTMLIsIndexElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_put_prompt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).put_prompt(@ptrCast(*const IHTMLIsIndexElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_get_prompt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).get_prompt(@ptrCast(*const IHTMLIsIndexElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_put_action(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).put_action(@ptrCast(*const IHTMLIsIndexElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_get_action(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).get_action(@ptrCast(*const IHTMLIsIndexElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIsIndexElement2_Value = @import("../zig.zig").Guid.initString("3050f82f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIsIndexElement2 = &IID_IHTMLIsIndexElement2_Value;
pub const IHTMLIsIndexElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLIsIndexElement2,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement2_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLIsIndexElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050f207-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLNextIdElement = &IID_IHTMLNextIdElement_Value;
pub const IHTMLNextIdElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_n: fn(
            self: *const IHTMLNextIdElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_n: fn(
            self: *const IHTMLNextIdElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNextIdElement_put_n(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNextIdElement.VTable, self.vtable).put_n(@ptrCast(*const IHTMLNextIdElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNextIdElement_get_n(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNextIdElement.VTable, self.vtable).get_n(@ptrCast(*const IHTMLNextIdElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050f519-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLIsIndexElement = &IID_DispHTMLIsIndexElement_Value;
pub const DispHTMLIsIndexElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050f51a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLNextIdElement = &IID_DispHTMLNextIdElement_Value;
pub const DispHTMLNextIdElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050f202-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBaseFontElement = &IID_IHTMLBaseFontElement_Value;
pub const IHTMLBaseFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_color: fn(
            self: *const IHTMLBaseFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_color: fn(
            self: *const IHTMLBaseFontElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_face: fn(
            self: *const IHTMLBaseFontElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_face: fn(
            self: *const IHTMLBaseFontElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_size: fn(
            self: *const IHTMLBaseFontElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: fn(
            self: *const IHTMLBaseFontElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_color(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_face(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_face(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_face(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_face(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_size(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050f504-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBaseFontElement = &IID_DispHTMLBaseFontElement_Value;
pub const DispHTMLBaseFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050f209-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLUnknownElement = &IID_IHTMLUnknownElement_Value;
pub const IHTMLUnknownElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050f539-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLUnknownElement = &IID_DispHTMLUnknownElement_Value;
pub const DispHTMLUnknownElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeolocation_Value = @import("../zig.zig").Guid.initString("305107c5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IWebGeolocation = &IID_IWebGeolocation_Value;
pub const IWebGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getCurrentPosition: fn(
            self: *const IWebGeolocation,
            successCallback: ?*IDispatch,
            errorCallback: ?*IDispatch,
            options: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        watchPosition: fn(
            self: *const IWebGeolocation,
            successCallback: ?*IDispatch,
            errorCallback: ?*IDispatch,
            options: ?*IDispatch,
            watchId: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearWatch: fn(
            self: *const IWebGeolocation,
            watchId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_getCurrentPosition(self: *const T, successCallback: ?*IDispatch, errorCallback: ?*IDispatch, options: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).getCurrentPosition(@ptrCast(*const IWebGeolocation, self), successCallback, errorCallback, options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_watchPosition(self: *const T, successCallback: ?*IDispatch, errorCallback: ?*IDispatch, options: ?*IDispatch, watchId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).watchPosition(@ptrCast(*const IWebGeolocation, self), successCallback, errorCallback, options, watchId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_clearWatch(self: *const T, watchId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).clearWatch(@ptrCast(*const IWebGeolocation, self), watchId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMimeTypesCollection_Value = @import("../zig.zig").Guid.initString("3050f3fc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMimeTypesCollection = &IID_IHTMLMimeTypesCollection_Value;
pub const IHTMLMimeTypesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLMimeTypesCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMimeTypesCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMimeTypesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLMimeTypesCollection, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPluginsCollection_Value = @import("../zig.zig").Guid.initString("3050f3fd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPluginsCollection = &IID_IHTMLPluginsCollection_Value;
pub const IHTMLPluginsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLPluginsCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        refresh: fn(
            self: *const IHTMLPluginsCollection,
            reload: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPluginsCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPluginsCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLPluginsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPluginsCollection_refresh(self: *const T, reload: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPluginsCollection.VTable, self.vtable).refresh(@ptrCast(*const IHTMLPluginsCollection, self), reload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOmHistory_Value = @import("../zig.zig").Guid.initString("feceaaa2-8405-11cf-8ba1-00aa00476da6");
pub const IID_IOmHistory = &IID_IOmHistory_Value;
pub const IOmHistory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IOmHistory,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        back: fn(
            self: *const IOmHistory,
            pvargdistance: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        forward: fn(
            self: *const IOmHistory,
            pvargdistance: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        go: fn(
            self: *const IOmHistory,
            pvargdistance: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_get_length(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).get_length(@ptrCast(*const IOmHistory, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_back(self: *const T, pvargdistance: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).back(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_forward(self: *const T, pvargdistance: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).forward(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_go(self: *const T, pvargdistance: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).go(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOpsProfile_Value = @import("../zig.zig").Guid.initString("3050f401-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOpsProfile = &IID_IHTMLOpsProfile_Value;
pub const IHTMLOpsProfile = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addRequest: fn(
            self: *const IHTMLOpsProfile,
            name: ?BSTR,
            reserved: VARIANT,
            success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearRequest: fn(
            self: *const IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doRequest: fn(
            self: *const IHTMLOpsProfile,
            usage: VARIANT,
            fname: VARIANT,
            domain: VARIANT,
            path: VARIANT,
            expire: VARIANT,
            reserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLOpsProfile,
            name: ?BSTR,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLOpsProfile,
            name: ?BSTR,
            value: ?BSTR,
            prefs: VARIANT,
            success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        commitChanges: fn(
            self: *const IHTMLOpsProfile,
            success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addReadRequest: fn(
            self: *const IHTMLOpsProfile,
            name: ?BSTR,
            reserved: VARIANT,
            success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doReadRequest: fn(
            self: *const IHTMLOpsProfile,
            usage: VARIANT,
            fname: VARIANT,
            domain: VARIANT,
            path: VARIANT,
            expire: VARIANT,
            reserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doWriteRequest: fn(
            self: *const IHTMLOpsProfile,
            success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_addRequest(self: *const T, name: ?BSTR, reserved: VARIANT, success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).addRequest(@ptrCast(*const IHTMLOpsProfile, self), name, reserved, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_clearRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).clearRequest(@ptrCast(*const IHTMLOpsProfile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doRequest(self: *const T, usage: VARIANT, fname: VARIANT, domain: VARIANT, path: VARIANT, expire: VARIANT, reserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doRequest(@ptrCast(*const IHTMLOpsProfile, self), usage, fname, domain, path, expire, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_getAttribute(self: *const T, name: ?BSTR, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLOpsProfile, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_setAttribute(self: *const T, name: ?BSTR, value: ?BSTR, prefs: VARIANT, success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLOpsProfile, self), name, value, prefs, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_commitChanges(self: *const T, success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).commitChanges(@ptrCast(*const IHTMLOpsProfile, self), success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_addReadRequest(self: *const T, name: ?BSTR, reserved: VARIANT, success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).addReadRequest(@ptrCast(*const IHTMLOpsProfile, self), name, reserved, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doReadRequest(self: *const T, usage: VARIANT, fname: VARIANT, domain: VARIANT, path: VARIANT, expire: VARIANT, reserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doReadRequest(@ptrCast(*const IHTMLOpsProfile, self), usage, fname, domain, path, expire, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doWriteRequest(self: *const T, success: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doWriteRequest(@ptrCast(*const IHTMLOpsProfile, self), success);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOmNavigator_Value = @import("../zig.zig").Guid.initString("feceaaa5-8405-11cf-8ba1-00aa00476da6");
pub const IID_IOmNavigator = &IID_IOmNavigator_Value;
pub const IOmNavigator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_appCodeName: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_appName: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_appVersion: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_userAgent: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        javaEnabled: fn(
            self: *const IOmNavigator,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        taintEnabled: fn(
            self: *const IOmNavigator,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeTypes: fn(
            self: *const IOmNavigator,
            p: ?*?*IHTMLMimeTypesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_plugins: fn(
            self: *const IOmNavigator,
            p: ?*?*IHTMLPluginsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cookieEnabled: fn(
            self: *const IOmNavigator,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_opsProfile: fn(
            self: *const IOmNavigator,
            p: ?*?*IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IOmNavigator,
            string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cpuClass: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemLanguage: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_browserLanguage: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_userLanguage: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_platform: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_appMinorVersion: fn(
            self: *const IOmNavigator,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connectionSpeed: fn(
            self: *const IOmNavigator,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onLine: fn(
            self: *const IOmNavigator,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_userProfile: fn(
            self: *const IOmNavigator,
            p: ?*?*IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appCodeName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appCodeName(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appName(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appVersion(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appVersion(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userAgent(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userAgent(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_javaEnabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).javaEnabled(@ptrCast(*const IOmNavigator, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_taintEnabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).taintEnabled(@ptrCast(*const IOmNavigator, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_mimeTypes(self: *const T, p: ?*?*IHTMLMimeTypesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_mimeTypes(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_plugins(self: *const T, p: ?*?*IHTMLPluginsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_plugins(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_cookieEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_cookieEnabled(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_opsProfile(self: *const T, p: ?*?*IHTMLOpsProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_opsProfile(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_toString(self: *const T, string: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).toString(@ptrCast(*const IOmNavigator, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_cpuClass(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_cpuClass(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_systemLanguage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_systemLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_browserLanguage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_browserLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userLanguage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_platform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_platform(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appMinorVersion(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appMinorVersion(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_connectionSpeed(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_connectionSpeed(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_onLine(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_onLine(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userProfile(self: *const T, p: ?*?*IHTMLOpsProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userProfile(@ptrCast(*const IOmNavigator, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INavigatorGeolocation_Value = @import("../zig.zig").Guid.initString("305107cf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_INavigatorGeolocation = &IID_INavigatorGeolocation_Value;
pub const INavigatorGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_geolocation: fn(
            self: *const INavigatorGeolocation,
            p: ?*?*IWebGeolocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INavigatorGeolocation_get_geolocation(self: *const T, p: ?*?*IWebGeolocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const INavigatorGeolocation.VTable, self.vtable).get_geolocation(@ptrCast(*const INavigatorGeolocation, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INavigatorDoNotTrack_Value = @import("../zig.zig").Guid.initString("30510804-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_INavigatorDoNotTrack = &IID_INavigatorDoNotTrack_Value;
pub const INavigatorDoNotTrack = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msDoNotTrack: fn(
            self: *const INavigatorDoNotTrack,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INavigatorDoNotTrack_get_msDoNotTrack(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INavigatorDoNotTrack.VTable, self.vtable).get_msDoNotTrack(@ptrCast(*const INavigatorDoNotTrack, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLocation_Value = @import("../zig.zig").Guid.initString("163bb1e0-6e00-11cf-837a-48dc04c10000");
pub const IID_IHTMLLocation = &IID_IHTMLLocation_Value;
pub const IHTMLLocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_protocol: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocol: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_host: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_host: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hostname: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hostname: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_port: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_port: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pathname: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathname: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_search: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_search: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hash: fn(
            self: *const IHTMLLocation,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hash: fn(
            self: *const IHTMLLocation,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reload: fn(
            self: *const IHTMLLocation,
            flag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replace: fn(
            self: *const IHTMLLocation,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        assign: fn(
            self: *const IHTMLLocation,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLLocation,
            string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_protocol(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_protocol(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_host(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_host(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_host(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_host(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_hostname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_hostname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_port(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_port(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_port(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_port(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_pathname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_pathname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_search(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_search(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_search(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_search(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_hash(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_hash(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_reload(self: *const T, flag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).reload(@ptrCast(*const IHTMLLocation, self), flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_replace(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).replace(@ptrCast(*const IHTMLLocation, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_assign(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).assign(@ptrCast(*const IHTMLLocation, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_toString(self: *const T, string: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).toString(@ptrCast(*const IHTMLLocation, self), string);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHistory_Value = @import("../zig.zig").Guid.initString("3050f549-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLHistory = &IID_DispHTMLHistory_Value;
pub const DispHTMLHistory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNavigator_Value = @import("../zig.zig").Guid.initString("3050f54c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLNavigator = &IID_DispHTMLNavigator_Value;
pub const DispHTMLNavigator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLocation_Value = @import("../zig.zig").Guid.initString("3050f54e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLLocation = &IID_DispHTMLLocation_Value;
pub const DispHTMLLocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCPlugins_Value = @import("../zig.zig").Guid.initString("3050f54a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCPlugins = &IID_DispCPlugins_Value;
pub const DispCPlugins = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBookmarkCollection_Value = @import("../zig.zig").Guid.initString("3050f4ce-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBookmarkCollection = &IID_IHTMLBookmarkCollection_Value;
pub const IHTMLBookmarkCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLBookmarkCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLBookmarkCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLBookmarkCollection,
            index: i32,
            pVarBookmark: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLBookmarkCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLBookmarkCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_item(self: *const T, index: i32, pVarBookmark: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLBookmarkCollection, self), index, pVarBookmark);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDataTransfer_Value = @import("../zig.zig").Guid.initString("3050f4b3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDataTransfer = &IID_IHTMLDataTransfer_Value;
pub const IHTMLDataTransfer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setData: fn(
            self: *const IHTMLDataTransfer,
            format: ?BSTR,
            data: ?*VARIANT,
            pret: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getData: fn(
            self: *const IHTMLDataTransfer,
            format: ?BSTR,
            pvarRet: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearData: fn(
            self: *const IHTMLDataTransfer,
            format: ?BSTR,
            pret: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dropEffect: fn(
            self: *const IHTMLDataTransfer,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dropEffect: fn(
            self: *const IHTMLDataTransfer,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_effectAllowed: fn(
            self: *const IHTMLDataTransfer,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_effectAllowed: fn(
            self: *const IHTMLDataTransfer,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_setData(self: *const T, format: ?BSTR, data: ?*VARIANT, pret: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).setData(@ptrCast(*const IHTMLDataTransfer, self), format, data, pret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_getData(self: *const T, format: ?BSTR, pvarRet: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).getData(@ptrCast(*const IHTMLDataTransfer, self), format, pvarRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_clearData(self: *const T, format: ?BSTR, pret: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).clearData(@ptrCast(*const IHTMLDataTransfer, self), format, pret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_put_dropEffect(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).put_dropEffect(@ptrCast(*const IHTMLDataTransfer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_get_dropEffect(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).get_dropEffect(@ptrCast(*const IHTMLDataTransfer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_put_effectAllowed(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).put_effectAllowed(@ptrCast(*const IHTMLDataTransfer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_get_effectAllowed(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).get_effectAllowed(@ptrCast(*const IHTMLDataTransfer, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj2_Value = @import("../zig.zig").Guid.initString("3050f48b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj2 = &IID_IHTMLEventObj2_Value;
pub const IHTMLEventObj2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: ?BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: ?BSTR,
            lFlags: i32,
            AttributeValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: ?BSTR,
            lFlags: i32,
            pfSuccess: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_propertyName: fn(
            self: *const IHTMLEventObj2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_propertyName: fn(
            self: *const IHTMLEventObj2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_bookmarks: fn(
            self: *const IHTMLEventObj2,
            v: ?*IHTMLBookmarkCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bookmarks: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLBookmarkCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_recordset: fn(
            self: *const IHTMLEventObj2,
            v: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_recordset: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataFld: fn(
            self: *const IHTMLEventObj2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataFld: fn(
            self: *const IHTMLEventObj2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_boundElements: fn(
            self: *const IHTMLEventObj2,
            v: ?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_boundElements: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_repeat: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_repeat: fn(
            self: *const IHTMLEventObj2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_srcUrn: fn(
            self: *const IHTMLEventObj2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcUrn: fn(
            self: *const IHTMLEventObj2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_srcElement: fn(
            self: *const IHTMLEventObj2,
            v: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcElement: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_altKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altKey: fn(
            self: *const IHTMLEventObj2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ctrlKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ctrlKey: fn(
            self: *const IHTMLEventObj2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shiftKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shiftKey: fn(
            self: *const IHTMLEventObj2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fromElement: fn(
            self: *const IHTMLEventObj2,
            v: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fromElement: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_toElement: fn(
            self: *const IHTMLEventObj2,
            v: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_toElement: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_button: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_button: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLEventObj2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLEventObj2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_qualifier: fn(
            self: *const IHTMLEventObj2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_qualifier: fn(
            self: *const IHTMLEventObj2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_reason: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_reason: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clientX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientX: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_clientY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientY: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_offsetX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetX: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_offsetY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetY: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_screenX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenX: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_screenY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenY: fn(
            self: *const IHTMLEventObj2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_srcFilter: fn(
            self: *const IHTMLEventObj2,
            v: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcFilter: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataTransfer: fn(
            self: *const IHTMLEventObj2,
            p: ?*?*IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_setAttribute(self: *const T, strAttributeName: ?BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_getAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, AttributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_removeAttribute(self: *const T, strAttributeName: ?BSTR, lFlags: i32, pfSuccess: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_propertyName(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_propertyName(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_propertyName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_propertyName(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_bookmarks(self: *const T, v: ?*IHTMLBookmarkCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_bookmarks(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_bookmarks(self: *const T, p: ?*?*IHTMLBookmarkCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_bookmarks(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_recordset(self: *const T, v: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_recordset(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_recordset(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_dataFld(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_dataFld(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_dataFld(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_dataFld(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_boundElements(self: *const T, v: ?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_boundElements(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_boundElements(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_boundElements(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_repeat(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_repeat(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_repeat(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_repeat(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_srcUrn(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_srcUrn(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcUrn(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcUrn(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_srcElement(self: *const T, v: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_srcElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_altKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_altKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_altKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_altKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_ctrlKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_ctrlKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_ctrlKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_shiftKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_shiftKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_shiftKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_shiftKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_fromElement(self: *const T, v: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_fromElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_fromElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_fromElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_toElement(self: *const T, v: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_toElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_toElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_toElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_button(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_button(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_button(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_button(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_qualifier(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_qualifier(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_qualifier(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_qualifier(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_reason(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_reason(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_reason(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_reason(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_x(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_x(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_x(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_x(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_y(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_y(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_y(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_y(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_clientX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_clientX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_clientX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_clientX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_clientY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_clientY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_clientY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_clientY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_offsetX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_offsetX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_offsetX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_offsetX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_offsetY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_offsetY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_offsetY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_offsetY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_screenX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_screenX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_screenX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_screenY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_screenY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_screenY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_srcFilter(self: *const T, v: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_srcFilter(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcFilter(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcFilter(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_dataTransfer(self: *const T, p: ?*?*IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_dataTransfer(@ptrCast(*const IHTMLEventObj2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj3_Value = @import("../zig.zig").Guid.initString("3050f680-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj3 = &IID_IHTMLEventObj3_Value;
pub const IHTMLEventObj3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentOverflow: fn(
            self: *const IHTMLEventObj3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shiftLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shiftLeft: fn(
            self: *const IHTMLEventObj3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_altLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altLeft: fn(
            self: *const IHTMLEventObj3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ctrlLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ctrlLeft: fn(
            self: *const IHTMLEventObj3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeCompositionChange: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeNotifyCommand: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeNotifyData: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeRequest: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imeRequestData: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_keyboardLayout: fn(
            self: *const IHTMLEventObj3,
            p: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behaviorCookie: fn(
            self: *const IHTMLEventObj3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_behaviorPart: fn(
            self: *const IHTMLEventObj3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextPage: fn(
            self: *const IHTMLEventObj3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_contentOverflow(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_contentOverflow(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_shiftLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_shiftLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_shiftLeft(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_shiftLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_altLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_altLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_altLeft(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_altLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_ctrlLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_ctrlLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_ctrlLeft(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_ctrlLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeCompositionChange(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeCompositionChange(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeNotifyCommand(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeNotifyCommand(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeNotifyData(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeNotifyData(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeRequest(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeRequest(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeRequestData(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeRequestData(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_keyboardLayout(self: *const T, p: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_keyboardLayout(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_behaviorCookie(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_behaviorCookie(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_behaviorPart(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_behaviorPart(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_nextPage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_nextPage(@ptrCast(*const IHTMLEventObj3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj4_Value = @import("../zig.zig").Guid.initString("3050f814-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj4 = &IID_IHTMLEventObj4_Value;
pub const IHTMLEventObj4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wheelDelta: fn(
            self: *const IHTMLEventObj4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj4_get_wheelDelta(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj4.VTable, self.vtable).get_wheelDelta(@ptrCast(*const IHTMLEventObj4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj5_Value = @import("../zig.zig").Guid.initString("30510478-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj5 = &IID_IHTMLEventObj5_Value;
pub const IHTMLEventObj5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_url: fn(
            self: *const IHTMLEventObj5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IHTMLEventObj5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IHTMLEventObj5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLEventObj5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_source: fn(
            self: *const IHTMLEventObj5,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_origin: fn(
            self: *const IHTMLEventObj5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_origin: fn(
            self: *const IHTMLEventObj5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_issession: fn(
            self: *const IHTMLEventObj5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_issession: fn(
            self: *const IHTMLEventObj5,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_url(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_url(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_url(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_url(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_data(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_data(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_source(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_source(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_origin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_origin(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_origin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_origin(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_issession(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_issession(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_issession(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_issession(@ptrCast(*const IHTMLEventObj5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj6_Value = @import("../zig.zig").Guid.initString("30510734-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEventObj6 = &IID_IHTMLEventObj6_Value;
pub const IHTMLEventObj6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_actionURL: fn(
            self: *const IHTMLEventObj6,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_buttonID: fn(
            self: *const IHTMLEventObj6,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj6_get_actionURL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj6.VTable, self.vtable).get_actionURL(@ptrCast(*const IHTMLEventObj6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj6_get_buttonID(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj6.VTable, self.vtable).get_buttonID(@ptrCast(*const IHTMLEventObj6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCEventObj_Value = @import("../zig.zig").Guid.initString("3050f558-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCEventObj = &IID_DispCEventObj_Value;
pub const DispCEventObj = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3051074b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleMedia = &IID_IHTMLStyleMedia_Value;
pub const IHTMLStyleMedia = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLStyleMedia,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        matchMedium: fn(
            self: *const IHTMLStyleMedia,
            mediaQuery: ?BSTR,
            matches: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleMedia_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleMedia.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleMedia, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleMedia_matchMedium(self: *const T, mediaQuery: ?BSTR, matches: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleMedia.VTable, self.vtable).matchMedium(@ptrCast(*const IHTMLStyleMedia, self), mediaQuery, matches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3059009e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleMedia = &IID_DispHTMLStyleMedia_Value;
pub const DispHTMLStyleMedia = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFramesCollection2_Value = @import("../zig.zig").Guid.initString("332c4426-26cb-11d0-b483-00c04fd90119");
pub const IID_IHTMLFramesCollection2 = &IID_IHTMLFramesCollection2_Value;
pub const IHTMLFramesCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLFramesCollection2,
            pvarIndex: ?*VARIANT,
            pvarResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLFramesCollection2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFramesCollection2_item(self: *const T, pvarIndex: ?*VARIANT, pvarResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFramesCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLFramesCollection2, self), pvarIndex, pvarResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFramesCollection2_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFramesCollection2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFramesCollection2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents3_Value = @import("../zig.zig").Guid.initString("3050f5a1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLWindowEvents3 = &IID_HTMLWindowEvents3_Value;
pub const HTMLWindowEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents2_Value = @import("../zig.zig").Guid.initString("3050f625-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLWindowEvents2 = &IID_HTMLWindowEvents2_Value;
pub const HTMLWindowEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents_Value = @import("../zig.zig").Guid.initString("96a0a4e0-d062-11cf-94b6-00aa0060275c");
pub const IID_HTMLWindowEvents = &IID_HTMLWindowEvents_Value;
pub const HTMLWindowEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument2_Value = @import("../zig.zig").Guid.initString("332c4425-26cb-11d0-b483-00c04fd90119");
pub const IID_IHTMLDocument2 = &IID_IHTMLDocument2_Value;
pub const IHTMLDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLDocument.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_all: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_body: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_activeElement: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_images: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_applets: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_links: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_forms: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anchors: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_title: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_title: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scripts: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_designMode: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_designMode: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selection: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frames: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLFramesCollection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_embeds: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_plugins: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alinkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alinkColor: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fgColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fgColor: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_linkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_linkColor: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vlinkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vlinkColor: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_referrer: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_location: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLLocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastModified: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_domain: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domain: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cookie: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cookie: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_expando: fn(
            self: *const IHTMLDocument2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expando: fn(
            self: *const IHTMLDocument2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultCharset: fn(
            self: *const IHTMLDocument2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultCharset: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileCreatedDate: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_security: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocol: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nameProp: fn(
            self: *const IHTMLDocument2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        write: fn(
            self: *const IHTMLDocument2,
            psarray: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        writeln: fn(
            self: *const IHTMLDocument2,
            psarray: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLDocument2,
            url: ?BSTR,
            name: VARIANT,
            features: VARIANT,
            replace: VARIANT,
            pomWindowResult: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pcmdText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pcmdValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLDocument2,
            cmdID: ?BSTR,
            pfRet: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IHTMLDocument2,
            eTag: ?BSTR,
            newElem: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhelp: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhelp: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onclick: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onclick: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondblclick: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondblclick: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeyup: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeyup: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeydown: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeydown: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeypress: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeypress: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseup: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseup: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousedown: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousedown: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousemove: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousemove: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseout: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseout: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseover: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseover: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onafterupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onafterupdate: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowexit: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowexit: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowenter: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowenter: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragstart: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragstart: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselectstart: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselectstart: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementFromPoint: fn(
            self: *const IHTMLDocument2,
            x: i32,
            y: i32,
            elementHit: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentWindow: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleSheets: fn(
            self: *const IHTMLDocument2,
            p: ?*?*IHTMLStyleSheetsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeupdate: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerrorupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerrorupdate: fn(
            self: *const IHTMLDocument2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDocument2,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createStyleSheet: fn(
            self: *const IHTMLDocument2,
            bstrHref: ?BSTR,
            lIndex: i32,
            ppnewStyleSheet: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_all(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_all(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_body(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_body(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_activeElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_activeElement(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_images(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_images(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_applets(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_applets(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_links(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_links(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_forms(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_forms(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_anchors(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_anchors(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_title(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_title(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_title(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_title(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_scripts(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_scripts(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_designMode(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_designMode(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_designMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_designMode(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_selection(self: *const T, p: ?*?*IHTMLSelectionObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_selection(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_frames(self: *const T, p: ?*?*IHTMLFramesCollection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_frames(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_embeds(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_embeds(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_plugins(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_plugins(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_alinkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_alinkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_alinkColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_alinkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_fgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_fgColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fgColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_linkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_linkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_linkColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_linkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_vlinkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_vlinkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_vlinkColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_vlinkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_referrer(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_referrer(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_location(self: *const T, p: ?*?*IHTMLLocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_location(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_lastModified(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_lastModified(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_URL(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_URL(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_URL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_URL(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_domain(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_domain(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_domain(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_domain(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_cookie(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_cookie(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_cookie(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_cookie(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_expando(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_expando(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_expando(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_expando(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_charset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_defaultCharset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_defaultCharset(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_defaultCharset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_defaultCharset(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_mimeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileSize(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileCreatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileCreatedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileModifiedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileUpdatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_security(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_security(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_protocol(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_nameProp(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_write(self: *const T, psarray: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).write(@ptrCast(*const IHTMLDocument2, self), psarray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_writeln(self: *const T, psarray: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).writeln(@ptrCast(*const IHTMLDocument2, self), psarray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_open(self: *const T, url: ?BSTR, name: VARIANT, features: VARIANT, replace: VARIANT, pomWindowResult: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).open(@ptrCast(*const IHTMLDocument2, self), url, name, features, replace, pomWindowResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).close(@ptrCast(*const IHTMLDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).clear(@ptrCast(*const IHTMLDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandSupported(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandEnabled(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandState(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandIndeterm(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandText(self: *const T, cmdID: ?BSTR, pcmdText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLDocument2, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandValue(self: *const T, cmdID: ?BSTR, pcmdValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLDocument2, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_execCommand(self: *const T, cmdID: ?BSTR, showUI: i16, value: VARIANT, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLDocument2, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_execCommandShowHelp(self: *const T, cmdID: ?BSTR, pfRet: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_createElement(self: *const T, eTag: ?BSTR, newElem: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).createElement(@ptrCast(*const IHTMLDocument2, self), eTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onhelp(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_ondblclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeyup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeydown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeypress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmousedown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmousemove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onafterupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onafterupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onafterupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onafterupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onrowexit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onrowexit(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onrowexit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onrowexit(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onrowenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onrowenter(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onrowenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onrowenter(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_ondragstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onselectstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onselectstart(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onselectstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onselectstart(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_elementFromPoint(self: *const T, x: i32, y: i32, elementHit: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).elementFromPoint(@ptrCast(*const IHTMLDocument2, self), x, y, elementHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_parentWindow(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_parentWindow(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_styleSheets(self: *const T, p: ?*?*IHTMLStyleSheetsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_styleSheets(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onbeforeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onbeforeupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onbeforeupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onbeforeupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onerrorupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onerrorupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onerrorupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onerrorupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).toString(@ptrCast(*const IHTMLDocument2, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_createStyleSheet(self: *const T, bstrHref: ?BSTR, lIndex: i32, ppnewStyleSheet: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).createStyleSheet(@ptrCast(*const IHTMLDocument2, self), bstrHref, lIndex, ppnewStyleSheet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow2_Value = @import("../zig.zig").Guid.initString("332c4427-26cb-11d0-b483-00c04fd90119");
pub const IID_IHTMLWindow2 = &IID_IHTMLWindow2_Value;
pub const IHTMLWindow2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLFramesCollection2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frames: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLFramesCollection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultStatus: fn(
            self: *const IHTMLWindow2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultStatus: fn(
            self: *const IHTMLWindow2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLWindow2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLWindow2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTimeout: fn(
            self: *const IHTMLWindow2,
            expression: ?BSTR,
            msec: i32,
            language: ?*VARIANT,
            timerID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearTimeout: fn(
            self: *const IHTMLWindow2,
            timerID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        alert: fn(
            self: *const IHTMLWindow2,
            message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        confirm: fn(
            self: *const IHTMLWindow2,
            message: ?BSTR,
            confirmed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        prompt: fn(
            self: *const IHTMLWindow2,
            message: ?BSTR,
            defstr: ?BSTR,
            textdata: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Image: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLImageElementFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_location: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLLocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_history: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IOmHistory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_opener: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_opener: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_navigator: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IOmNavigator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLWindow2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLWindow2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLWindow2,
            url: ?BSTR,
            name: ?BSTR,
            features: ?BSTR,
            replace: i16,
            pomWindowResult: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_self: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_top: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_window: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        navigate: fn(
            self: *const IHTMLWindow2,
            url: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeunload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeunload: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onunload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onunload: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhelp: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhelp: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onresize: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onresize: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onscroll: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onscroll: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_event: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showModalDialog: fn(
            self: *const IHTMLWindow2,
            dialog: ?BSTR,
            varArgIn: ?*VARIANT,
            varOptions: ?*VARIANT,
            varArgOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showHelp: fn(
            self: *const IHTMLWindow2,
            helpURL: ?BSTR,
            helpArg: VARIANT,
            features: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screen: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLScreen,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Option: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IHTMLOptionElementFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_closed: fn(
            self: *const IHTMLWindow2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scroll: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientInformation: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IOmNavigator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setInterval: fn(
            self: *const IHTMLWindow2,
            expression: ?BSTR,
            msec: i32,
            language: ?*VARIANT,
            timerID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearInterval: fn(
            self: *const IHTMLWindow2,
            timerID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_offscreenBuffering: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offscreenBuffering: fn(
            self: *const IHTMLWindow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execScript: fn(
            self: *const IHTMLWindow2,
            code: ?BSTR,
            language: ?BSTR,
            pvarRet: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLWindow2,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resizeTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resizeBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_external: fn(
            self: *const IHTMLWindow2,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLFramesCollection2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_frames(self: *const T, p: ?*?*IHTMLFramesCollection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_frames(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_defaultStatus(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_defaultStatus(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_defaultStatus(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_defaultStatus(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_status(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_status(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_status(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_status(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_setTimeout(self: *const T, expression: ?BSTR, msec: i32, language: ?*VARIANT, timerID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).setTimeout(@ptrCast(*const IHTMLWindow2, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_clearTimeout(self: *const T, timerID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).clearTimeout(@ptrCast(*const IHTMLWindow2, self), timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_alert(self: *const T, message: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).alert(@ptrCast(*const IHTMLWindow2, self), message);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_confirm(self: *const T, message: ?BSTR, confirmed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).confirm(@ptrCast(*const IHTMLWindow2, self), message, confirmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_prompt(self: *const T, message: ?BSTR, defstr: ?BSTR, textdata: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).prompt(@ptrCast(*const IHTMLWindow2, self), message, defstr, textdata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_Image(self: *const T, p: ?*?*IHTMLImageElementFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_Image(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_location(self: *const T, p: ?*?*IHTMLLocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_location(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_history(self: *const T, p: ?*?*IOmHistory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_history(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).close(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_opener(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_opener(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_opener(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_opener(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_navigator(self: *const T, p: ?*?*IOmNavigator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_navigator(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_name(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_parent(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_parent(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_open(self: *const T, url: ?BSTR, name: ?BSTR, features: ?BSTR, replace: i16, pomWindowResult: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).open(@ptrCast(*const IHTMLWindow2, self), url, name, features, replace, pomWindowResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_self(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_self(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_top(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_top(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_window(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_window(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_navigate(self: *const T, url: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).navigate(@ptrCast(*const IHTMLWindow2, self), url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onbeforeunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onhelp(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onresize(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onscroll(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_document(self: *const T, p: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_document(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_event(self: *const T, p: ?*?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_event(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_showModalDialog(self: *const T, dialog: ?BSTR, varArgIn: ?*VARIANT, varOptions: ?*VARIANT, varArgOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).showModalDialog(@ptrCast(*const IHTMLWindow2, self), dialog, varArgIn, varOptions, varArgOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_showHelp(self: *const T, helpURL: ?BSTR, helpArg: VARIANT, features: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).showHelp(@ptrCast(*const IHTMLWindow2, self), helpURL, helpArg, features);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_screen(self: *const T, p: ?*?*IHTMLScreen) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_screen(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_Option(self: *const T, p: ?*?*IHTMLOptionElementFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_Option(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).focus(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_closed(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_closed(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).blur(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scroll(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scroll(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_clientInformation(self: *const T, p: ?*?*IOmNavigator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_clientInformation(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_setInterval(self: *const T, expression: ?BSTR, msec: i32, language: ?*VARIANT, timerID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).setInterval(@ptrCast(*const IHTMLWindow2, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_clearInterval(self: *const T, timerID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).clearInterval(@ptrCast(*const IHTMLWindow2, self), timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_offscreenBuffering(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_offscreenBuffering(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_offscreenBuffering(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_offscreenBuffering(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_execScript(self: *const T, code: ?BSTR, language: ?BSTR, pvarRet: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).execScript(@ptrCast(*const IHTMLWindow2, self), code, language, pvarRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).toString(@ptrCast(*const IHTMLWindow2, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scrollBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scrollBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scrollTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scrollTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_moveTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).moveTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_moveBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).moveBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_resizeTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).resizeTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_resizeBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).resizeBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_external(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_external(@ptrCast(*const IHTMLWindow2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow3_Value = @import("../zig.zig").Guid.initString("3050f4ae-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow3 = &IID_IHTMLWindow3_Value;
pub const IHTMLWindow3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenLeft: fn(
            self: *const IHTMLWindow3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenTop: fn(
            self: *const IHTMLWindow3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLWindow3,
            event: ?BSTR,
            pDisp: ?*IDispatch,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLWindow3,
            event: ?BSTR,
            pDisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTimeout: fn(
            self: *const IHTMLWindow3,
            expression: ?*VARIANT,
            msec: i32,
            language: ?*VARIANT,
            timerID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setInterval: fn(
            self: *const IHTMLWindow3,
            expression: ?*VARIANT,
            msec: i32,
            language: ?*VARIANT,
            timerID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        print: fn(
            self: *const IHTMLWindow3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeprint: fn(
            self: *const IHTMLWindow3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeprint: fn(
            self: *const IHTMLWindow3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onafterprint: fn(
            self: *const IHTMLWindow3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onafterprint: fn(
            self: *const IHTMLWindow3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipboardData: fn(
            self: *const IHTMLWindow3,
            p: ?*?*IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showModelessDialog: fn(
            self: *const IHTMLWindow3,
            url: ?BSTR,
            varArgIn: ?*VARIANT,
            options: ?*VARIANT,
            pDialog: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_screenLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_screenLeft(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_screenTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_screenTop(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_attachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLWindow3, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_detachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLWindow3, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_setTimeout(self: *const T, expression: ?*VARIANT, msec: i32, language: ?*VARIANT, timerID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).setTimeout(@ptrCast(*const IHTMLWindow3, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_setInterval(self: *const T, expression: ?*VARIANT, msec: i32, language: ?*VARIANT, timerID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).setInterval(@ptrCast(*const IHTMLWindow3, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_print(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).print(@ptrCast(*const IHTMLWindow3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLWindow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_onbeforeprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLWindow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_onafterprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_clipboardData(self: *const T, p: ?*?*IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_clipboardData(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_showModelessDialog(self: *const T, url: ?BSTR, varArgIn: ?*VARIANT, options: ?*VARIANT, pDialog: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).showModelessDialog(@ptrCast(*const IHTMLWindow3, self), url, varArgIn, options, pDialog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050f311-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameBase = &IID_IHTMLFrameBase_Value;
pub const IHTMLFrameBase = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLFrameBase,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLFrameBase,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLFrameBase,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLFrameBase,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLFrameBase,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameBorder: fn(
            self: *const IHTMLFrameBase,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameBorder: fn(
            self: *const IHTMLFrameBase,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameSpacing: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameSpacing: fn(
            self: *const IHTMLFrameBase,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginWidth: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginWidth: fn(
            self: *const IHTMLFrameBase,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginHeight: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginHeight: fn(
            self: *const IHTMLFrameBase,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noResize: fn(
            self: *const IHTMLFrameBase,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noResize: fn(
            self: *const IHTMLFrameBase,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrolling: fn(
            self: *const IHTMLFrameBase,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrolling: fn(
            self: *const IHTMLFrameBase,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_src(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_src(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_border(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_border(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_frameBorder(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_frameBorder(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_frameSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_frameSpacing(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_frameSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_frameSpacing(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_marginWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_marginWidth(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_marginWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_marginWidth(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_marginHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_marginHeight(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_marginHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_marginHeight(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_noResize(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_noResize(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_noResize(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_noResize(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_scrolling(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_scrolling(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_scrolling(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_scrolling(@ptrCast(*const IHTMLFrameBase, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStorage_Value = @import("../zig.zig").Guid.initString("30510474-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStorage = &IID_IHTMLStorage_Value;
pub const IHTMLStorage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStorage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_remainingSpace: fn(
            self: *const IHTMLStorage,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        key: fn(
            self: *const IHTMLStorage,
            lIndex: i32,
            __MIDL__IHTMLStorage0000: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const IHTMLStorage,
            bstrKey: ?BSTR,
            __MIDL__IHTMLStorage0001: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setItem: fn(
            self: *const IHTMLStorage,
            bstrKey: ?BSTR,
            bstrValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const IHTMLStorage,
            bstrKey: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStorage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_get_remainingSpace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).get_remainingSpace(@ptrCast(*const IHTMLStorage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_key(self: *const T, lIndex: i32, __MIDL__IHTMLStorage0000: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).key(@ptrCast(*const IHTMLStorage, self), lIndex, __MIDL__IHTMLStorage0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_getItem(self: *const T, bstrKey: ?BSTR, __MIDL__IHTMLStorage0001: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).getItem(@ptrCast(*const IHTMLStorage, self), bstrKey, __MIDL__IHTMLStorage0001);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_setItem(self: *const T, bstrKey: ?BSTR, bstrValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).setItem(@ptrCast(*const IHTMLStorage, self), bstrKey, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_removeItem(self: *const T, bstrKey: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).removeItem(@ptrCast(*const IHTMLStorage, self), bstrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).clear(@ptrCast(*const IHTMLStorage, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformance_Value = @import("../zig.zig").Guid.initString("3051074e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPerformance = &IID_IHTMLPerformance_Value;
pub const IHTMLPerformance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_navigation: fn(
            self: *const IHTMLPerformance,
            p: ?*?*IHTMLPerformanceNavigation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timing: fn(
            self: *const IHTMLPerformance,
            p: ?*?*IHTMLPerformanceTiming,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformance,
            string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformance,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_get_navigation(self: *const T, p: ?*?*IHTMLPerformanceNavigation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).get_navigation(@ptrCast(*const IHTMLPerformance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_get_timing(self: *const T, p: ?*?*IHTMLPerformanceTiming) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).get_timing(@ptrCast(*const IHTMLPerformance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_toString(self: *const T, string: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformance, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_toJSON(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformance, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLApplicationCache_Value = @import("../zig.zig").Guid.initString("30510828-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLApplicationCache = &IID_IHTMLApplicationCache_Value;
pub const IHTMLApplicationCache = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLApplicationCache,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchecking: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchecking: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onnoupdate: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onnoupdate: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondownloading: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondownloading: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onprogress: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onprogress: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onupdateready: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onupdateready: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncached: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncached: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onobsolete: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onobsolete: fn(
            self: *const IHTMLApplicationCache,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        update: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        swapCache: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_status(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_status(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onchecking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onchecking(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onchecking(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onchecking(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onnoupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onnoupdate(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onnoupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onnoupdate(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_ondownloading(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_ondownloading(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_ondownloading(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_ondownloading(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onprogress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onupdateready(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onupdateready(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onupdateready(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onupdateready(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_oncached(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_oncached(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_oncached(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_oncached(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onobsolete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onobsolete(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onobsolete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onobsolete(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_update(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).update(@ptrCast(*const IHTMLApplicationCache, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_swapCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).swapCache(@ptrCast(*const IHTMLApplicationCache, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).abort(@ptrCast(*const IHTMLApplicationCache, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen_Value = @import("../zig.zig").Guid.initString("3050f35c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScreen = &IID_IHTMLScreen_Value;
pub const IHTMLScreen = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_colorDepth: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bufferDepth: fn(
            self: *const IHTMLScreen,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bufferDepth: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_updateInterval: fn(
            self: *const IHTMLScreen,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_updateInterval: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_availHeight: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_availWidth: fn(
            self: *const IHTMLScreen,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSmoothingEnabled: fn(
            self: *const IHTMLScreen,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_colorDepth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_colorDepth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_put_bufferDepth(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).put_bufferDepth(@ptrCast(*const IHTMLScreen, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_bufferDepth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_bufferDepth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_width(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_height(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_put_updateInterval(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).put_updateInterval(@ptrCast(*const IHTMLScreen, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_updateInterval(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_updateInterval(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_availHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_availHeight(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_availWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_availWidth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_fontSmoothingEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_fontSmoothingEnabled(@ptrCast(*const IHTMLScreen, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen2_Value = @import("../zig.zig").Guid.initString("3050f84a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScreen2 = &IID_IHTMLScreen2_Value;
pub const IHTMLScreen2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_logicalXDPI: fn(
            self: *const IHTMLScreen2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_logicalYDPI: fn(
            self: *const IHTMLScreen2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deviceXDPI: fn(
            self: *const IHTMLScreen2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deviceYDPI: fn(
            self: *const IHTMLScreen2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_logicalXDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_logicalXDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_logicalYDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_logicalYDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_deviceXDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_deviceXDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_deviceYDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_deviceYDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen3_Value = @import("../zig.zig").Guid.initString("305104a1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScreen3 = &IID_IHTMLScreen3_Value;
pub const IHTMLScreen3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemXDPI: fn(
            self: *const IHTMLScreen3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemYDPI: fn(
            self: *const IHTMLScreen3,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen3_get_systemXDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen3.VTable, self.vtable).get_systemXDPI(@ptrCast(*const IHTMLScreen3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen3_get_systemYDPI(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen3.VTable, self.vtable).get_systemYDPI(@ptrCast(*const IHTMLScreen3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen4_Value = @import("../zig.zig").Guid.initString("3051076b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScreen4 = &IID_IHTMLScreen4_Value;
pub const IHTMLScreen4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelDepth: fn(
            self: *const IHTMLScreen4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen4_get_pixelDepth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen4.VTable, self.vtable).get_pixelDepth(@ptrCast(*const IHTMLScreen4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow4_Value = @import("../zig.zig").Guid.initString("3050f6cf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow4 = &IID_IHTMLWindow4_Value;
pub const IHTMLWindow4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createPopup: fn(
            self: *const IHTMLWindow4,
            varArgIn: ?*VARIANT,
            ppPopup: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameElement: fn(
            self: *const IHTMLWindow4,
            p: ?*?*IHTMLFrameBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow4_createPopup(self: *const T, varArgIn: ?*VARIANT, ppPopup: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow4.VTable, self.vtable).createPopup(@ptrCast(*const IHTMLWindow4, self), varArgIn, ppPopup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow4_get_frameElement(self: *const T, p: ?*?*IHTMLFrameBase) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow4.VTable, self.vtable).get_frameElement(@ptrCast(*const IHTMLWindow4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow5_Value = @import("../zig.zig").Guid.initString("3051040e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow5 = &IID_IHTMLWindow5_Value;
pub const IHTMLWindow5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XMLHttpRequest: fn(
            self: *const IHTMLWindow5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLHttpRequest: fn(
            self: *const IHTMLWindow5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow5_put_XMLHttpRequest(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow5.VTable, self.vtable).put_XMLHttpRequest(@ptrCast(*const IHTMLWindow5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow5_get_XMLHttpRequest(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow5.VTable, self.vtable).get_XMLHttpRequest(@ptrCast(*const IHTMLWindow5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow6_Value = @import("../zig.zig").Guid.initString("30510453-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow6 = &IID_IHTMLWindow6_Value;
pub const IHTMLWindow6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XDomainRequest: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XDomainRequest: fn(
            self: *const IHTMLWindow6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sessionStorage: fn(
            self: *const IHTMLWindow6,
            p: ?*?*IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_localStorage: fn(
            self: *const IHTMLWindow6,
            p: ?*?*IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhashchange: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhashchange: fn(
            self: *const IHTMLWindow6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxConnectionsPerServer: fn(
            self: *const IHTMLWindow6,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        postMessage: fn(
            self: *const IHTMLWindow6,
            msg: ?BSTR,
            targetOrigin: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toStaticHTML: fn(
            self: *const IHTMLWindow6,
            bstrHTML: ?BSTR,
            pbstrStaticHTML: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmessage: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmessage: fn(
            self: *const IHTMLWindow6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msWriteProfilerMark: fn(
            self: *const IHTMLWindow6,
            bstrProfilerMarkName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_XDomainRequest(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_XDomainRequest(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_XDomainRequest(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_XDomainRequest(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_sessionStorage(self: *const T, p: ?*?*IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_sessionStorage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_localStorage(self: *const T, p: ?*?*IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_localStorage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_onhashchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_maxConnectionsPerServer(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_maxConnectionsPerServer(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_postMessage(self: *const T, msg: ?BSTR, targetOrigin: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).postMessage(@ptrCast(*const IHTMLWindow6, self), msg, targetOrigin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_toStaticHTML(self: *const T, bstrHTML: ?BSTR, pbstrStaticHTML: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).toStaticHTML(@ptrCast(*const IHTMLWindow6, self), bstrHTML, pbstrStaticHTML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_onmessage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_msWriteProfilerMark(self: *const T, bstrProfilerMarkName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).msWriteProfilerMark(@ptrCast(*const IHTMLWindow6, self), bstrProfilerMarkName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow7_Value = @import("../zig.zig").Guid.initString("305104b7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow7 = &IID_IHTMLWindow7_Value;
pub const IHTMLWindow7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getSelection: fn(
            self: *const IHTMLWindow7,
            ppIHTMLSelection: ?*?*IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComputedStyle: fn(
            self: *const IHTMLWindow7,
            varArgIn: ?*IHTMLDOMNode,
            bstrPseudoElt: ?BSTR,
            ppComputedStyle: ?*?*IHTMLCSSStyleDeclaration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleMedia: fn(
            self: *const IHTMLWindow7,
            p: ?*?*IHTMLStyleMedia,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_performance: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_performance: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_innerWidth: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_innerHeight: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageXOffset: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageYOffset: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenX: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenY: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outerWidth: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_outerHeight: fn(
            self: *const IHTMLWindow7,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onabort: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onabort: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplay: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplay: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncanplaythrough: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncanplaythrough: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onchange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onchange: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onclick: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onclick: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncontextmenu: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncontextmenu: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondblclick: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondblclick: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrag: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrag: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragend: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragend: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragenter: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragenter: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragleave: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragleave: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragover: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragover: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondragstart: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondragstart: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondrop: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondrop: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondurationchange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondurationchange: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusin: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusin: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusout: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusout: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oninput: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oninput: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onemptied: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onemptied: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onended: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onended: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeydown: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeydown: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeypress: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeypress: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onkeyup: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onkeyup: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadeddata: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadeddata: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadedmetadata: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadedmetadata: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onloadstart: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onloadstart: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousedown: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousedown: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseenter: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseenter: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseleave: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseleave: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousemove: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousemove: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseout: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseout: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseover: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseover: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmouseup: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmouseup: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousewheel: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousewheel: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onoffline: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onoffline: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ononline: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ononline: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onprogress: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onprogress: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onratechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onratechange: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreset: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreset: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeked: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeked: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onseeking: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onseeking: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselect: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselect: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstalled: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstalled: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstorage: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstorage: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsubmit: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsubmit: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onsuspend: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onsuspend: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontimeupdate: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ontimeupdate: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpause: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpause: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplay: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplay: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onplaying: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onplaying: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onvolumechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onvolumechange: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onwaiting: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onwaiting: fn(
            self: *const IHTMLWindow7,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_getSelection(self: *const T, ppIHTMLSelection: ?*?*IHTMLSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).getSelection(@ptrCast(*const IHTMLWindow7, self), ppIHTMLSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_getComputedStyle(self: *const T, varArgIn: ?*IHTMLDOMNode, bstrPseudoElt: ?BSTR, ppComputedStyle: ?*?*IHTMLCSSStyleDeclaration) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).getComputedStyle(@ptrCast(*const IHTMLWindow7, self), varArgIn, bstrPseudoElt, ppComputedStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_styleMedia(self: *const T, p: ?*?*IHTMLStyleMedia) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_styleMedia(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_performance(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_performance(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_performance(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_performance(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_innerWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_innerWidth(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_innerHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_innerHeight(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_pageXOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_pageXOffset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_pageYOffset(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_pageYOffset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_screenX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_screenY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_outerWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_outerWidth(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_outerHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_outerHeight(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onabort(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncanplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncanplaythrough(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncontextmenu(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondblclick(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondrag(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragleave(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondrop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondurationchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onfocusin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onfocusout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oninput(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onemptied(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onended(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeydown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeypress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeyup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadeddata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadedmetadata(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadstart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousedown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseenter(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseenter(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseenter(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseleave(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseleave(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseleave(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousemove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousewheel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onoffline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ononline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onprogress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onratechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onreset(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onseeked(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onseeking(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onstalled(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onstorage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onsubmit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onsuspend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ontimeupdate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onpause(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onplay(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onplaying(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onvolumechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onwaiting(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLWindow7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow8_Value = @import("../zig.zig").Guid.initString("305107ab-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLWindow8 = &IID_IHTMLWindow8_Value;
pub const IHTMLWindow8 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerdown: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerdown: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointermove: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointermove: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerup: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerup: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerover: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerover: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerout: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerout: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointercancel: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointercancel: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerhover: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerhover: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturestart: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturestart: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturechange: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturechange: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgestureend: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgestureend: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturehold: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturehold: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturetap: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturetap: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsinertiastart: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsinertiastart: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_applicationCache: fn(
            self: *const IHTMLWindow8,
            p: ?*?*IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpopstate: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpopstate: fn(
            self: *const IHTMLWindow8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerdown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointermove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointercancel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerhover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturestart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgestureend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturehold(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturetap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturedoubletap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsinertiastart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_applicationCache(self: *const T, p: ?*?*IHTMLApplicationCache) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_applicationCache(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onpopstate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onpopstate(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onpopstate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onpopstate(@ptrCast(*const IHTMLWindow8, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLScreen_Value = @import("../zig.zig").Guid.initString("3050f591-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLScreen = &IID_DispHTMLScreen_Value;
pub const DispHTMLScreen = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWindow2_Value = @import("../zig.zig").Guid.initString("3050f55d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLWindow2 = &IID_DispHTMLWindow2_Value;
pub const DispHTMLWindow2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWindowProxy_Value = @import("../zig.zig").Guid.initString("3050f55e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLWindowProxy = &IID_DispHTMLWindowProxy_Value;
pub const DispHTMLWindowProxy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3051041a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocumentCompatibleInfo = &IID_IHTMLDocumentCompatibleInfo_Value;
pub const IHTMLDocumentCompatibleInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_userAgent: fn(
            self: *const IHTMLDocumentCompatibleInfo,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IHTMLDocumentCompatibleInfo,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfo_get_userAgent(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfo.VTable, self.vtable).get_userAgent(@ptrCast(*const IHTMLDocumentCompatibleInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfo_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfo.VTable, self.vtable).get_version(@ptrCast(*const IHTMLDocumentCompatibleInfo, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("30510418-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocumentCompatibleInfoCollection = &IID_IHTMLDocumentCompatibleInfoCollection_Value;
pub const IHTMLDocumentCompatibleInfoCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLDocumentCompatibleInfoCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLDocumentCompatibleInfoCollection,
            index: i32,
            compatibleInfo: ?*?*IHTMLDocumentCompatibleInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfoCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfoCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDocumentCompatibleInfoCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfoCollection_item(self: *const T, index: i32, compatibleInfo: ?*?*IHTMLDocumentCompatibleInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfoCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLDocumentCompatibleInfoCollection, self), index, compatibleInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3050f53e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDocumentCompatibleInfo = &IID_DispHTMLDocumentCompatibleInfo_Value;
pub const DispHTMLDocumentCompatibleInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("3050f53f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDocumentCompatibleInfoCollection = &IID_DispHTMLDocumentCompatibleInfoCollection_Value;
pub const DispHTMLDocumentCompatibleInfoCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents4_Value = @import("../zig.zig").Guid.initString("30510737-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLDocumentEvents4 = &IID_HTMLDocumentEvents4_Value;
pub const HTMLDocumentEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents3_Value = @import("../zig.zig").Guid.initString("3050f5a0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLDocumentEvents3 = &IID_HTMLDocumentEvents3_Value;
pub const HTMLDocumentEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents2_Value = @import("../zig.zig").Guid.initString("3050f613-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLDocumentEvents2 = &IID_HTMLDocumentEvents2_Value;
pub const HTMLDocumentEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents_Value = @import("../zig.zig").Guid.initString("3050f260-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLDocumentEvents = &IID_HTMLDocumentEvents_Value;
pub const HTMLDocumentEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSVGElement_Value = @import("../zig.zig").Guid.initString("305104e7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGSVGElement = &IID_ISVGSVGElement_Value;
pub const ISVGSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contentScriptType: fn(
            self: *const ISVGSVGElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentScriptType: fn(
            self: *const ISVGSVGElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contentStyleType: fn(
            self: *const ISVGSVGElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentStyleType: fn(
            self: *const ISVGSVGElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewport: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewport: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelUnitToMillimeterX: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelUnitToMillimeterX: fn(
            self: *const ISVGSVGElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pixelUnitToMillimeterY: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pixelUnitToMillimeterY: fn(
            self: *const ISVGSVGElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_screenPixelToMillimeterX: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenPixelToMillimeterX: fn(
            self: *const ISVGSVGElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_screenPixelToMillimeterY: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenPixelToMillimeterY: fn(
            self: *const ISVGSVGElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_useCurrentView: fn(
            self: *const ISVGSVGElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_useCurrentView: fn(
            self: *const ISVGSVGElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentView: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGViewSpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentView: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGViewSpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentScale: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentScale: fn(
            self: *const ISVGSVGElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentTranslate: fn(
            self: *const ISVGSVGElement,
            v: ?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentTranslate: fn(
            self: *const ISVGSVGElement,
            p: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        suspendRedraw: fn(
            self: *const ISVGSVGElement,
            maxWaitMilliseconds: u32,
            pResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unsuspendRedraw: fn(
            self: *const ISVGSVGElement,
            suspendHandeID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unsuspendRedrawAll: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        forceRedraw: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pauseAnimations: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unpauseAnimations: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        animationsPaused: fn(
            self: *const ISVGSVGElement,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCurrentTime: fn(
            self: *const ISVGSVGElement,
            pResult: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setCurrentTime: fn(
            self: *const ISVGSVGElement,
            seconds: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIntersectionList: fn(
            self: *const ISVGSVGElement,
            rect: ?*ISVGRect,
            referenceElement: ?*ISVGElement,
            pResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEnclosureList: fn(
            self: *const ISVGSVGElement,
            rect: ?*ISVGRect,
            referenceElement: ?*ISVGElement,
            pResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        checkIntersection: fn(
            self: *const ISVGSVGElement,
            element: ?*ISVGElement,
            rect: ?*ISVGRect,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        checkEnclosure: fn(
            self: *const ISVGSVGElement,
            element: ?*ISVGElement,
            rect: ?*ISVGRect,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deselectAll: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGNumber: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGLength: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGAngle: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPoint: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGMatrix: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGRect: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransform: fn(
            self: *const ISVGSVGElement,
            pResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransformFromMatrix: fn(
            self: *const ISVGSVGElement,
            matrix: ?*ISVGMatrix,
            pResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const ISVGSVGElement,
            elementId: ?BSTR,
            pResult: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_contentScriptType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_contentScriptType(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_contentScriptType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_contentScriptType(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_contentStyleType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_contentStyleType(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_contentStyleType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_contentStyleType(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_viewport(self: *const T, v: ?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_viewport(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_viewport(self: *const T, p: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_viewport(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_pixelUnitToMillimeterX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_pixelUnitToMillimeterX(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_pixelUnitToMillimeterX(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_pixelUnitToMillimeterX(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_pixelUnitToMillimeterY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_pixelUnitToMillimeterY(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_pixelUnitToMillimeterY(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_pixelUnitToMillimeterY(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_screenPixelToMillimeterX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_screenPixelToMillimeterX(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_screenPixelToMillimeterX(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_screenPixelToMillimeterX(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_screenPixelToMillimeterY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_screenPixelToMillimeterY(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_screenPixelToMillimeterY(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_screenPixelToMillimeterY(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_useCurrentView(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_useCurrentView(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_useCurrentView(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_useCurrentView(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_currentView(self: *const T, v: ?*ISVGViewSpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_currentView(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentView(self: *const T, p: ?*?*ISVGViewSpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentView(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_currentScale(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_currentScale(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentScale(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentScale(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_currentTranslate(self: *const T, v: ?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_currentTranslate(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentTranslate(self: *const T, p: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentTranslate(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_suspendRedraw(self: *const T, maxWaitMilliseconds: u32, pResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).suspendRedraw(@ptrCast(*const ISVGSVGElement, self), maxWaitMilliseconds, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unsuspendRedraw(self: *const T, suspendHandeID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unsuspendRedraw(@ptrCast(*const ISVGSVGElement, self), suspendHandeID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unsuspendRedrawAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unsuspendRedrawAll(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_forceRedraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).forceRedraw(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_pauseAnimations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).pauseAnimations(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unpauseAnimations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unpauseAnimations(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_animationsPaused(self: *const T, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).animationsPaused(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getCurrentTime(self: *const T, pResult: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getCurrentTime(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_setCurrentTime(self: *const T, seconds: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).setCurrentTime(@ptrCast(*const ISVGSVGElement, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getIntersectionList(self: *const T, rect: ?*ISVGRect, referenceElement: ?*ISVGElement, pResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getIntersectionList(@ptrCast(*const ISVGSVGElement, self), rect, referenceElement, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getEnclosureList(self: *const T, rect: ?*ISVGRect, referenceElement: ?*ISVGElement, pResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getEnclosureList(@ptrCast(*const ISVGSVGElement, self), rect, referenceElement, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_checkIntersection(self: *const T, element: ?*ISVGElement, rect: ?*ISVGRect, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).checkIntersection(@ptrCast(*const ISVGSVGElement, self), element, rect, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_checkEnclosure(self: *const T, element: ?*ISVGElement, rect: ?*ISVGRect, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).checkEnclosure(@ptrCast(*const ISVGSVGElement, self), element, rect, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_deselectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).deselectAll(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGNumber(self: *const T, pResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGNumber(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGLength(self: *const T, pResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGLength(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGAngle(self: *const T, pResult: ?*?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGAngle(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGPoint(self: *const T, pResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGPoint(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGMatrix(self: *const T, pResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGMatrix(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGRect(self: *const T, pResult: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGRect(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGTransform(self: *const T, pResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGTransform(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGTransformFromMatrix(self: *const T, matrix: ?*ISVGMatrix, pResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGTransformFromMatrix(@ptrCast(*const ISVGSVGElement, self), matrix, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getElementById(self: *const T, elementId: ?BSTR, pResult: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getElementById(@ptrCast(*const ISVGSVGElement, self), elementId, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMNodeIterator_Value = @import("../zig.zig").Guid.initString("30510746-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMNodeIterator = &IID_IDOMNodeIterator_Value;
pub const IDOMNodeIterator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: fn(
            self: *const IDOMNodeIterator,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whatToShow: fn(
            self: *const IDOMNodeIterator,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IDOMNodeIterator,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expandEntityReferences: fn(
            self: *const IDOMNodeIterator,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IDOMNodeIterator,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousNode: fn(
            self: *const IDOMNodeIterator,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detach: fn(
            self: *const IDOMNodeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_root(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_root(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_whatToShow(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_whatToShow(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_filter(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_filter(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_expandEntityReferences(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_expandEntityReferences(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_nextNode(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).nextNode(@ptrCast(*const IDOMNodeIterator, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_previousNode(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).previousNode(@ptrCast(*const IDOMNodeIterator, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).detach(@ptrCast(*const IDOMNodeIterator, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMTreeWalker_Value = @import("../zig.zig").Guid.initString("30510748-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMTreeWalker = &IID_IDOMTreeWalker_Value;
pub const IDOMTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: fn(
            self: *const IDOMTreeWalker,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whatToShow: fn(
            self: *const IDOMTreeWalker,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filter: fn(
            self: *const IDOMTreeWalker,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expandEntityReferences: fn(
            self: *const IDOMTreeWalker,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentNode: fn(
            self: *const IDOMTreeWalker,
            v: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentNode: fn(
            self: *const IDOMTreeWalker,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parentNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        firstChild: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lastChild: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousSibling: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextSibling: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_root(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_root(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_whatToShow(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_whatToShow(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_filter(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_filter(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_expandEntityReferences(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_expandEntityReferences(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_putref_currentNode(self: *const T, v: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).putref_currentNode(@ptrCast(*const IDOMTreeWalker, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_currentNode(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_currentNode(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_parentNode(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).parentNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_firstChild(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).firstChild(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_lastChild(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).lastChild(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_previousSibling(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).previousSibling(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_nextSibling(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).nextSibling(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_previousNode(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).previousNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_nextNode(self: *const T, ppRetNode: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).nextNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("30510742-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMProcessingInstruction = &IID_IDOMProcessingInstruction_Value;
pub const IDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IDOMProcessingInstruction,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IDOMProcessingInstruction,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IDOMProcessingInstruction,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).get_target(@ptrCast(*const IDOMProcessingInstruction, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).put_data(@ptrCast(*const IDOMProcessingInstruction, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).get_data(@ptrCast(*const IDOMProcessingInstruction, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument3_Value = @import("../zig.zig").Guid.initString("3050f485-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument3 = &IID_IHTMLDocument3_Value;
pub const IHTMLDocument3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        releaseCapture: fn(
            self: *const IHTMLDocument3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        recalc: fn(
            self: *const IHTMLDocument3,
            fForce: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextNode: fn(
            self: *const IHTMLDocument3,
            text: ?BSTR,
            newTextNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_documentElement: fn(
            self: *const IHTMLDocument3,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uniqueID: fn(
            self: *const IHTMLDocument3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLDocument3,
            event: ?BSTR,
            pDisp: ?*IDispatch,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLDocument3,
            event: ?BSTR,
            pDisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowsdelete: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowsdelete: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onrowsinserted: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onrowsinserted: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncellchange: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncellchange: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondatasetchanged: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondatasetchanged: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondataavailable: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondataavailable: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondatasetcomplete: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondatasetcomplete: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onpropertychange: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onpropertychange: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dir: fn(
            self: *const IHTMLDocument3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dir: fn(
            self: *const IHTMLDocument3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncontextmenu: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncontextmenu: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstop: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstop: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFragment: fn(
            self: *const IHTMLDocument3,
            pNewDoc: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentDocument: fn(
            self: *const IHTMLDocument3,
            p: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableDownload: fn(
            self: *const IHTMLDocument3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableDownload: fn(
            self: *const IHTMLDocument3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseUrl: fn(
            self: *const IHTMLDocument3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseUrl: fn(
            self: *const IHTMLDocument3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const IHTMLDocument3,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_inheritStyleSheets: fn(
            self: *const IHTMLDocument3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inheritStyleSheets: fn(
            self: *const IHTMLDocument3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeeditfocus: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeeditfocus: fn(
            self: *const IHTMLDocument3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByName: fn(
            self: *const IHTMLDocument3,
            v: ?BSTR,
            pelColl: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const IHTMLDocument3,
            v: ?BSTR,
            pel: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IHTMLDocument3,
            v: ?BSTR,
            pelColl: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_releaseCapture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).releaseCapture(@ptrCast(*const IHTMLDocument3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_recalc(self: *const T, fForce: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).recalc(@ptrCast(*const IHTMLDocument3, self), fForce);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_createTextNode(self: *const T, text: ?BSTR, newTextNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).createTextNode(@ptrCast(*const IHTMLDocument3, self), text, newTextNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_documentElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_documentElement(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_uniqueID(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_uniqueID(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_attachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLDocument3, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_detachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLDocument3, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onrowsdelete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onrowsdelete(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onrowsdelete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onrowsdelete(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onrowsinserted(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onrowsinserted(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onrowsinserted(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onrowsinserted(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_oncellchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_oncellchange(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_oncellchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_oncellchange(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondatasetchanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondatasetchanged(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondatasetchanged(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondatasetchanged(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondataavailable(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondataavailable(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondataavailable(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondatasetcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondatasetcomplete(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondatasetcomplete(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondatasetcomplete(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onpropertychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onpropertychange(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onpropertychange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onpropertychange(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_dir(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_dir(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_oncontextmenu(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onstop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onstop(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onstop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onstop(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_createDocumentFragment(self: *const T, pNewDoc: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).createDocumentFragment(@ptrCast(*const IHTMLDocument3, self), pNewDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_parentDocument(self: *const T, p: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_parentDocument(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_enableDownload(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_enableDownload(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_enableDownload(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_enableDownload(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_baseUrl(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_baseUrl(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_baseUrl(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_baseUrl(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_childNodes(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_inheritStyleSheets(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_inheritStyleSheets(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_inheritStyleSheets(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_inheritStyleSheets(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onbeforeeditfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onbeforeeditfocus(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onbeforeeditfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onbeforeeditfocus(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementsByName(self: *const T, v: ?BSTR, pelColl: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementsByName(@ptrCast(*const IHTMLDocument3, self), v, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementById(self: *const T, v: ?BSTR, pel: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementById(@ptrCast(*const IHTMLDocument3, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementsByTagName(self: *const T, v: ?BSTR, pelColl: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IHTMLDocument3, self), v, pelColl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument4_Value = @import("../zig.zig").Guid.initString("3050f69a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument4 = &IID_IHTMLDocument4_Value;
pub const IHTMLDocument4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        focus: fn(
            self: *const IHTMLDocument4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasFocus: fn(
            self: *const IHTMLDocument4,
            pfFocus: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onselectionchange: fn(
            self: *const IHTMLDocument4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onselectionchange: fn(
            self: *const IHTMLDocument4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaces: fn(
            self: *const IHTMLDocument4,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFromUrl: fn(
            self: *const IHTMLDocument4,
            bstrUrl: ?BSTR,
            bstrOptions: ?BSTR,
            newDoc: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLDocument4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLDocument4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEventObject: fn(
            self: *const IHTMLDocument4,
            pvarEventObject: ?*VARIANT,
            ppEventObj: ?*?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fireEvent: fn(
            self: *const IHTMLDocument4,
            bstrEventName: ?BSTR,
            pvarEventObject: ?*VARIANT,
            pfCancelled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRenderStyle: fn(
            self: *const IHTMLDocument4,
            v: ?BSTR,
            ppIHTMLRenderStyle: ?*?*IHTMLRenderStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_oncontrolselect: fn(
            self: *const IHTMLDocument4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oncontrolselect: fn(
            self: *const IHTMLDocument4,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URLUnencoded: fn(
            self: *const IHTMLDocument4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).focus(@ptrCast(*const IHTMLDocument4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_hasFocus(self: *const T, pfFocus: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).hasFocus(@ptrCast(*const IHTMLDocument4, self), pfFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_onselectionchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_onselectionchange(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_onselectionchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_onselectionchange(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_namespaces(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_namespaces(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createDocumentFromUrl(self: *const T, bstrUrl: ?BSTR, bstrOptions: ?BSTR, newDoc: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createDocumentFromUrl(@ptrCast(*const IHTMLDocument4, self), bstrUrl, bstrOptions, newDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_media(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_media(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createEventObject(self: *const T, pvarEventObject: ?*VARIANT, ppEventObj: ?*?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createEventObject(@ptrCast(*const IHTMLDocument4, self), pvarEventObject, ppEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_fireEvent(self: *const T, bstrEventName: ?BSTR, pvarEventObject: ?*VARIANT, pfCancelled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).fireEvent(@ptrCast(*const IHTMLDocument4, self), bstrEventName, pvarEventObject, pfCancelled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createRenderStyle(self: *const T, v: ?BSTR, ppIHTMLRenderStyle: ?*?*IHTMLRenderStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createRenderStyle(@ptrCast(*const IHTMLDocument4, self), v, ppIHTMLRenderStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_oncontrolselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_oncontrolselect(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_oncontrolselect(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_oncontrolselect(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_URLUnencoded(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_URLUnencoded(@ptrCast(*const IHTMLDocument4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument5_Value = @import("../zig.zig").Guid.initString("3050f80c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument5 = &IID_IHTMLDocument5_Value;
pub const IHTMLDocument5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmousewheel: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmousewheel: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: fn(
            self: *const IHTMLDocument5,
            p: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_implementation: fn(
            self: *const IHTMLDocument5,
            p: ?*?*IHTMLDOMImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IHTMLDocument5,
            bstrattrName: ?BSTR,
            ppattribute: ?*?*IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createComment: fn(
            self: *const IHTMLDocument5,
            bstrdata: ?BSTR,
            ppRetNode: ?*?*IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusin: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusin: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocusout: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocusout: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onactivate: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ondeactivate: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeactivate: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforedeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforedeactivate: fn(
            self: *const IHTMLDocument5,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compatMode: fn(
            self: *const IHTMLDocument5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onmousewheel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_doctype(self: *const T, p: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_doctype(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_implementation(self: *const T, p: ?*?*IHTMLDOMImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_implementation(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_createAttribute(self: *const T, bstrattrName: ?BSTR, ppattribute: ?*?*IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).createAttribute(@ptrCast(*const IHTMLDocument5, self), bstrattrName, ppattribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_createComment(self: *const T, bstrdata: ?BSTR, ppRetNode: ?*?*IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).createComment(@ptrCast(*const IHTMLDocument5, self), bstrdata, ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onfocusin(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onfocusout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_ondeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_ondeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_ondeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_ondeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onbeforeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onbeforeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onbeforeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onbeforeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onbeforedeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onbeforedeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onbeforedeactivate(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onbeforedeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_compatMode(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_compatMode(@ptrCast(*const IHTMLDocument5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument6_Value = @import("../zig.zig").Guid.initString("30510417-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument6 = &IID_IHTMLDocument6_Value;
pub const IHTMLDocument6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_compatible: fn(
            self: *const IHTMLDocument6,
            p: ?*?*IHTMLDocumentCompatibleInfoCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_documentMode: fn(
            self: *const IHTMLDocument6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstorage: fn(
            self: *const IHTMLDocument6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstorage: fn(
            self: *const IHTMLDocument6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstoragecommit: fn(
            self: *const IHTMLDocument6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstoragecommit: fn(
            self: *const IHTMLDocument6,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const IHTMLDocument6,
            bstrId: ?BSTR,
            ppRetElement: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        updateSettings: fn(
            self: *const IHTMLDocument6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_compatible(self: *const T, p: ?*?*IHTMLDocumentCompatibleInfoCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_compatible(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_documentMode(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_documentMode(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLDocument6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_onstorage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_put_onstoragecommit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).put_onstoragecommit(@ptrCast(*const IHTMLDocument6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_onstoragecommit(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_onstoragecommit(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_getElementById(self: *const T, bstrId: ?BSTR, ppRetElement: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).getElementById(@ptrCast(*const IHTMLDocument6, self), bstrId, ppRetElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_updateSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).updateSettings(@ptrCast(*const IHTMLDocument6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument8_Value = @import("../zig.zig").Guid.initString("305107d0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDocument8 = &IID_IHTMLDocument8_Value;
pub const IHTMLDocument8 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmscontentzoom: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmscontentzoom: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerdown: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerdown: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointermove: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointermove: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerup: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerup: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerover: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerover: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerout: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerout: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointercancel: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointercancel: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmspointerhover: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmspointerhover: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturestart: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturestart: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturechange: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturechange: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgestureend: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgestureend: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturehold: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturehold: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturetap: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturetap: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsinertiastart: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsinertiastart: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementsFromPoint: fn(
            self: *const IHTMLDocument8,
            x: f32,
            y: f32,
            elementsHit: ?*?*IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementsFromRect: fn(
            self: *const IHTMLDocument8,
            left: f32,
            top: f32,
            width: f32,
            height: f32,
            elementsHit: ?*?*IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmsmanipulationstatechanged: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmsmanipulationstatechanged: fn(
            self: *const IHTMLDocument8,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msCapsLockWarningOff: fn(
            self: *const IHTMLDocument8,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msCapsLockWarningOff: fn(
            self: *const IHTMLDocument8,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmscontentzoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmscontentzoom(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmscontentzoom(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmscontentzoom(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerdown(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointermove(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerup(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointercancel(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerhover(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturestart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgestureend(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturehold(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturetap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturedoubletap(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsinertiastart(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_elementsFromPoint(self: *const T, x: f32, y: f32, elementsHit: ?*?*IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).elementsFromPoint(@ptrCast(*const IHTMLDocument8, self), x, y, elementsHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_elementsFromRect(self: *const T, left: f32, top: f32, width: f32, height: f32, elementsHit: ?*?*IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).elementsFromRect(@ptrCast(*const IHTMLDocument8, self), left, top, width, height, elementsHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsmanipulationstatechanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsmanipulationstatechanged(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsmanipulationstatechanged(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsmanipulationstatechanged(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_msCapsLockWarningOff(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_msCapsLockWarningOff(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_msCapsLockWarningOff(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_msCapsLockWarningOff(@ptrCast(*const IHTMLDocument8, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentEvent_Value = @import("../zig.zig").Guid.initString("305104bc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDocumentEvent = &IID_IDocumentEvent_Value;
pub const IDocumentEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createEvent: fn(
            self: *const IDocumentEvent,
            eventType: ?BSTR,
            ppEvent: ?*?*IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentEvent_createEvent(self: *const T, eventType: ?BSTR, ppEvent: ?*?*IDOMEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentEvent.VTable, self.vtable).createEvent(@ptrCast(*const IDocumentEvent, self), eventType, ppEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentRange_Value = @import("../zig.zig").Guid.initString("305104af-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDocumentRange = &IID_IDocumentRange_Value;
pub const IDocumentRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRange: fn(
            self: *const IDocumentRange,
            ppIHTMLDOMRange: ?*?*IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentRange_createRange(self: *const T, ppIHTMLDOMRange: ?*?*IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentRange.VTable, self.vtable).createRange(@ptrCast(*const IDocumentRange, self), ppIHTMLDOMRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentSelector_Value = @import("../zig.zig").Guid.initString("30510462-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDocumentSelector = &IID_IDocumentSelector_Value;
pub const IDocumentSelector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        querySelector: fn(
            self: *const IDocumentSelector,
            v: ?BSTR,
            pel: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        querySelectorAll: fn(
            self: *const IDocumentSelector,
            v: ?BSTR,
            pel: ?*?*IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentSelector_querySelector(self: *const T, v: ?BSTR, pel: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentSelector.VTable, self.vtable).querySelector(@ptrCast(*const IDocumentSelector, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentSelector_querySelectorAll(self: *const T, v: ?BSTR, pel: ?*?*IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentSelector.VTable, self.vtable).querySelectorAll(@ptrCast(*const IDocumentSelector, self), v, pel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentTraversal_Value = @import("../zig.zig").Guid.initString("30510744-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDocumentTraversal = &IID_IDocumentTraversal_Value;
pub const IDocumentTraversal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createNodeIterator: fn(
            self: *const IDocumentTraversal,
            pRootNode: ?*IDispatch,
            ulWhatToShow: i32,
            pFilter: ?*VARIANT,
            fEntityReferenceExpansion: i16,
            ppNodeIterator: ?*?*IDOMNodeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTreeWalker: fn(
            self: *const IDocumentTraversal,
            pRootNode: ?*IDispatch,
            ulWhatToShow: i32,
            pFilter: ?*VARIANT,
            fEntityReferenceExpansion: i16,
            ppTreeWalker: ?*?*IDOMTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentTraversal_createNodeIterator(self: *const T, pRootNode: ?*IDispatch, ulWhatToShow: i32, pFilter: ?*VARIANT, fEntityReferenceExpansion: i16, ppNodeIterator: ?*?*IDOMNodeIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentTraversal.VTable, self.vtable).createNodeIterator(@ptrCast(*const IDocumentTraversal, self), pRootNode, ulWhatToShow, pFilter, fEntityReferenceExpansion, ppNodeIterator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentTraversal_createTreeWalker(self: *const T, pRootNode: ?*IDispatch, ulWhatToShow: i32, pFilter: ?*VARIANT, fEntityReferenceExpansion: i16, ppTreeWalker: ?*?*IDOMTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentTraversal.VTable, self.vtable).createTreeWalker(@ptrCast(*const IDocumentTraversal, self), pRootNode, ulWhatToShow, pFilter, fEntityReferenceExpansion, ppTreeWalker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocument_Value = @import("../zig.zig").Guid.initString("3050f55f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDocument = &IID_DispHTMLDocument_Value;
pub const DispHTMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBridgeEvents_Value = @import("../zig.zig").Guid.initString("a6d897ff-0a95-11d1-b0ba-006008166e11");
pub const IID_DWebBridgeEvents = &IID_DWebBridgeEvents_Value;
pub const DWebBridgeEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBridge_Value = @import("../zig.zig").Guid.initString("ae24fdad-03c6-11d1-8b76-0080c744f389");
pub const IID_IWebBridge = &IID_IWebBridge_Value;
pub const IWebBridge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: fn(
            self: *const IWebBridge,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: fn(
            self: *const IWebBridge,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scrollbar: fn(
            self: *const IWebBridge,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scrollbar: fn(
            self: *const IWebBridge,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_embed: fn(
            self: *const IWebBridge,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_embed: fn(
            self: *const IWebBridge,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_event: fn(
            self: *const IWebBridge,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IWebBridge,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AboutBox: fn(
            self: *const IWebBridge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_URL(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_URL(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_URL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_URL(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_Scrollbar(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_Scrollbar(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_Scrollbar(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_Scrollbar(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_embed(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_embed(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_embed(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_embed(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_event(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_event(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_readyState(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_readyState(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_AboutBox(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).AboutBox(@ptrCast(*const IWebBridge, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWBScriptControl_Value = @import("../zig.zig").Guid.initString("a5170870-0cf8-11d1-8b91-0080c744f389");
pub const IID_IWBScriptControl = &IID_IWBScriptControl_Value;
pub const IWBScriptControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        raiseEvent: fn(
            self: *const IWBScriptControl,
            name: ?BSTR,
            eventData: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        bubbleEvent: fn(
            self: *const IWBScriptControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setContextMenu: fn(
            self: *const IWBScriptControl,
            menuItemPairs: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectableContent: fn(
            self: *const IWBScriptControl,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectableContent: fn(
            self: *const IWBScriptControl,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frozen: fn(
            self: *const IWBScriptControl,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollbar: fn(
            self: *const IWBScriptControl,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollbar: fn(
            self: *const IWBScriptControl,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IWBScriptControl,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_visibility: fn(
            self: *const IWBScriptControl,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onvisibilitychange: fn(
            self: *const IWBScriptControl,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onvisibilitychange: fn(
            self: *const IWBScriptControl,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_raiseEvent(self: *const T, name: ?BSTR, eventData: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).raiseEvent(@ptrCast(*const IWBScriptControl, self), name, eventData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_bubbleEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).bubbleEvent(@ptrCast(*const IWBScriptControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_setContextMenu(self: *const T, menuItemPairs: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).setContextMenu(@ptrCast(*const IWBScriptControl, self), menuItemPairs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_selectableContent(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_selectableContent(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_selectableContent(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_selectableContent(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_frozen(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_frozen(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_scrollbar(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_scrollbar(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_scrollbar(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_scrollbar(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_version(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_visibility(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_visibility(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_onvisibilitychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_onvisibilitychange(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_onvisibilitychange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_onvisibilitychange(@ptrCast(*const IWBScriptControl, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEmbedElement_Value = @import("../zig.zig").Guid.initString("3050f25f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEmbedElement = &IID_IHTMLEmbedElement_Value;
pub const IHTMLEmbedElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hidden: fn(
            self: *const IHTMLEmbedElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hidden: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_palette: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pluginspage: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLEmbedElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_units: fn(
            self: *const IHTMLEmbedElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_units: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLEmbedElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLEmbedElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLEmbedElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLEmbedElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLEmbedElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLEmbedElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_hidden(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_hidden(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_hidden(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_hidden(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_palette(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_palette(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_pluginspage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_pluginspage(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_units(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_units(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_units(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_units(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEmbedElement2_Value = @import("../zig.zig").Guid.initString("30510493-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEmbedElement2 = &IID_IHTMLEmbedElement2_Value;
pub const IHTMLEmbedElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLEmbedElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLEmbedElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pluginspage: fn(
            self: *const IHTMLEmbedElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).put_src(@ptrCast(*const IHTMLEmbedElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).get_src(@ptrCast(*const IHTMLEmbedElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_get_pluginspage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).get_pluginspage(@ptrCast(*const IHTMLEmbedElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLEmbed_Value = @import("../zig.zig").Guid.initString("3050f52e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLEmbed = &IID_DispHTMLEmbed_Value;
pub const DispHTMLEmbed = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMapEvents2_Value = @import("../zig.zig").Guid.initString("3050f61e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLMapEvents2 = &IID_HTMLMapEvents2_Value;
pub const HTMLMapEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMapEvents_Value = @import("../zig.zig").Guid.initString("3050f3ba-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLMapEvents = &IID_HTMLMapEvents_Value;
pub const HTMLMapEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050f383-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreasCollection = &IID_IHTMLAreasCollection_Value;
pub const IHTMLAreasCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: fn(
            self: *const IHTMLAreasCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLAreasCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLAreasCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAreasCollection,
            name: VARIANT,
            index: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLAreasCollection,
            tagName: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLAreasCollection,
            element: ?*IHTMLElement,
            before: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLAreasCollection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).put_length(@ptrCast(*const IHTMLAreasCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAreasCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLAreasCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLAreasCollection, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_tags(self: *const T, tagName: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).tags(@ptrCast(*const IHTMLAreasCollection, self), tagName, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_add(self: *const T, element: ?*IHTMLElement, before: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).add(@ptrCast(*const IHTMLAreasCollection, self), element, before);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).remove(@ptrCast(*const IHTMLAreasCollection, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection2_Value = @import("../zig.zig").Guid.initString("3050f5ec-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreasCollection2 = &IID_IHTMLAreasCollection2_Value;
pub const IHTMLAreasCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLAreasCollection2,
            urn: VARIANT,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection2_urns(self: *const T, urn: VARIANT, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection2.VTable, self.vtable).urns(@ptrCast(*const IHTMLAreasCollection2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection3_Value = @import("../zig.zig").Guid.initString("3050f837-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreasCollection3 = &IID_IHTMLAreasCollection3_Value;
pub const IHTMLAreasCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLAreasCollection3,
            name: ?BSTR,
            pdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection3_namedItem(self: *const T, name: ?BSTR, pdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLAreasCollection3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection4_Value = @import("../zig.zig").Guid.initString("30510492-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreasCollection4 = &IID_IHTMLAreasCollection4_Value;
pub const IHTMLAreasCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLAreasCollection4,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAreasCollection4,
            index: i32,
            pNode: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedItem: fn(
            self: *const IHTMLAreasCollection4,
            name: ?BSTR,
            pNode: ?*?*IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAreasCollection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_item(self: *const T, index: i32, pNode: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLAreasCollection4, self), index, pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_namedItem(self: *const T, name: ?BSTR, pNode: ?*?*IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLAreasCollection4, self), name, pNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050f266-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMapElement = &IID_IHTMLMapElement_Value;
pub const IHTMLMapElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_areas: fn(
            self: *const IHTMLMapElement,
            p: ?*?*IHTMLAreasCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLMapElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLMapElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_get_areas(self: *const T, p: ?*?*IHTMLAreasCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).get_areas(@ptrCast(*const IHTMLMapElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMapElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMapElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050f56a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAreasCollection = &IID_DispHTMLAreasCollection_Value;
pub const DispHTMLAreasCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050f526-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMapElement = &IID_DispHTMLMapElement_Value;
pub const DispHTMLMapElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAreaEvents2_Value = @import("../zig.zig").Guid.initString("3050f611-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLAreaEvents2 = &IID_HTMLAreaEvents2_Value;
pub const HTMLAreaEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAreaEvents_Value = @import("../zig.zig").Guid.initString("3050f366-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLAreaEvents = &IID_HTMLAreaEvents_Value;
pub const HTMLAreaEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050f265-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreaElement = &IID_IHTMLAreaElement_Value;
pub const IHTMLAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shape: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shape: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_coords: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_coords: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_target: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noHref: fn(
            self: *const IHTMLAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noHref: fn(
            self: *const IHTMLAreaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_host: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_host: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hostname: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hostname: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pathname: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathname: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_port: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_port: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_protocol: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_protocol: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_search: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_search: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hash: fn(
            self: *const IHTMLAreaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hash: fn(
            self: *const IHTMLAreaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onblur: fn(
            self: *const IHTMLAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onblur: fn(
            self: *const IHTMLAreaElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onfocus: fn(
            self: *const IHTMLAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onfocus: fn(
            self: *const IHTMLAreaElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tabIndex: fn(
            self: *const IHTMLAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tabIndex: fn(
            self: *const IHTMLAreaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_shape(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_shape(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_coords(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_coords(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_target(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_target(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_noHref(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_noHref(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_noHref(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_noHref(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_host(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_host(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_host(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_host(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_hostname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_hostname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_pathname(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_pathname(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_port(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_port(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_port(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_port(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_protocol(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_protocol(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_search(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_search(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_search(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_search(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_hash(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_hash(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_onblur(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_onfocus(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_tabIndex(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLAreaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLAreaElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreaElement2_Value = @import("../zig.zig").Guid.initString("3051041f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAreaElement2 = &IID_IHTMLAreaElement2_Value;
pub const IHTMLAreaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shape: fn(
            self: *const IHTMLAreaElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shape: fn(
            self: *const IHTMLAreaElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_coords: fn(
            self: *const IHTMLAreaElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_coords: fn(
            self: *const IHTMLAreaElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_href: fn(
            self: *const IHTMLAreaElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const IHTMLAreaElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_shape(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_shape(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_coords(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_coords(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_href(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_href(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050f503-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAreaElement = &IID_DispHTMLAreaElement_Value;
pub const DispHTMLAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050f2eb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCaption = &IID_IHTMLTableCaption_Value;
pub const IHTMLTableCaption = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTableCaption,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTableCaption,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vAlign: fn(
            self: *const IHTMLTableCaption,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vAlign: fn(
            self: *const IHTMLTableCaption,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCaption, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCaption, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_put_vAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCaption, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_get_vAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCaption, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050f508-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTableCaption = &IID_DispHTMLTableCaption_Value;
pub const DispHTMLTableCaption = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050f20c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCommentElement = &IID_IHTMLCommentElement_Value;
pub const IHTMLCommentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLCommentElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLCommentElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_atomic: fn(
            self: *const IHTMLCommentElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_atomic: fn(
            self: *const IHTMLCommentElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_put_text(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLCommentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLCommentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_put_atomic(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).put_atomic(@ptrCast(*const IHTMLCommentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_get_atomic(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).get_atomic(@ptrCast(*const IHTMLCommentElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement2_Value = @import("../zig.zig").Guid.initString("3050f813-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCommentElement2 = &IID_IHTMLCommentElement2_Value;
pub const IHTMLCommentElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IHTMLCommentElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLCommentElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLCommentElement2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        substringData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
            pbstrsubString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IHTMLCommentElement2,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).put_data(@ptrCast(*const IHTMLCommentElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).get_data(@ptrCast(*const IHTMLCommentElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCommentElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).substringData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_appendData(self: *const T, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).appendData(@ptrCast(*const IHTMLCommentElement2, self), bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_insertData(self: *const T, offset: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).insertData(@ptrCast(*const IHTMLCommentElement2, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement3_Value = @import("../zig.zig").Guid.initString("3051073f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCommentElement3 = &IID_IHTMLCommentElement3_Value;
pub const IHTMLCommentElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
            pbstrsubString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
            bstrstring: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).substringData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_insertData(self: *const T, offset: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).insertData(@ptrCast(*const IHTMLCommentElement3, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050f50a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCommentElement = &IID_DispHTMLCommentElement_Value;
pub const DispHTMLCommentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050f20a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPhraseElement = &IID_IHTMLPhraseElement_Value;
pub const IHTMLPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement2_Value = @import("../zig.zig").Guid.initString("3050f824-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPhraseElement2 = &IID_IHTMLPhraseElement2_Value;
pub const IHTMLPhraseElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cite: fn(
            self: *const IHTMLPhraseElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cite: fn(
            self: *const IHTMLPhraseElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dateTime: fn(
            self: *const IHTMLPhraseElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dateTime: fn(
            self: *const IHTMLPhraseElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_put_cite(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLPhraseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_get_cite(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLPhraseElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_put_dateTime(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).put_dateTime(@ptrCast(*const IHTMLPhraseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_get_dateTime(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).get_dateTime(@ptrCast(*const IHTMLPhraseElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement3_Value = @import("../zig.zig").Guid.initString("3051043d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPhraseElement3 = &IID_IHTMLPhraseElement3_Value;
pub const IHTMLPhraseElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cite: fn(
            self: *const IHTMLPhraseElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cite: fn(
            self: *const IHTMLPhraseElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement3_put_cite(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement3.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLPhraseElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement3_get_cite(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement3.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLPhraseElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050f3f3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSpanElement = &IID_IHTMLSpanElement_Value;
pub const IHTMLSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050f52d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLPhraseElement = &IID_DispHTMLPhraseElement_Value;
pub const DispHTMLPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050f548-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLSpanElement = &IID_DispHTMLSpanElement_Value;
pub const DispHTMLSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTableEvents2_Value = @import("../zig.zig").Guid.initString("3050f623-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLTableEvents2 = &IID_HTMLTableEvents2_Value;
pub const HTMLTableEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTableEvents_Value = @import("../zig.zig").Guid.initString("3050f407-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLTableEvents = &IID_HTMLTableEvents_Value;
pub const HTMLTableEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050f23b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableSection = &IID_IHTMLTableSection_Value;
pub const IHTMLTableSection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTableSection,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTableSection,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vAlign: fn(
            self: *const IHTMLTableSection,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vAlign: fn(
            self: *const IHTMLTableSection,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLTableSection,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLTableSection,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rows: fn(
            self: *const IHTMLTableSection,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTableSection,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTableSection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_vAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_vAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_rows(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_insertRow(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTableSection, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTableSection, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable_Value = @import("../zig.zig").Guid.initString("3050f21e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTable = &IID_IHTMLTable_Value;
pub const IHTMLTable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cols: fn(
            self: *const IHTMLTable,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cols: fn(
            self: *const IHTMLTable,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frame: fn(
            self: *const IHTMLTable,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frame: fn(
            self: *const IHTMLTable,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rules: fn(
            self: *const IHTMLTable,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rules: fn(
            self: *const IHTMLTable,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cellSpacing: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cellSpacing: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cellPadding: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cellPadding: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLTable,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLTable,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorLight: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorLight: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorDark: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorDark: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTable,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTable,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        refresh: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rows: fn(
            self: *const IHTMLTable,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataPageSize: fn(
            self: *const IHTMLTable,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataPageSize: fn(
            self: *const IHTMLTable,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextPage: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousPage: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tHead: fn(
            self: *const IHTMLTable,
            p: ?*?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tFoot: fn(
            self: *const IHTMLTable,
            p: ?*?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tBodies: fn(
            self: *const IHTMLTable,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_caption: fn(
            self: *const IHTMLTable,
            p: ?*?*IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTHead: fn(
            self: *const IHTMLTable,
            head: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteTHead: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTFoot: fn(
            self: *const IHTMLTable,
            foot: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteTFoot: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCaption: fn(
            self: *const IHTMLTable,
            caption: ?*?*IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCaption: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTable,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTable,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLTable,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLTable,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cols(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cols(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_border(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_border(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_frame(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_frame(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_frame(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_frame(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_rules(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_rules(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_rules(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_rules(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cellSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cellSpacing(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cellSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cellSpacing(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cellPadding(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cellPadding(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cellPadding(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cellPadding(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_background(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_background(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColorLight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColorDark(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).refresh(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_rows(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_dataPageSize(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_dataPageSize(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_dataPageSize(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_dataPageSize(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_nextPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).nextPage(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_previousPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).previousPage(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tHead(self: *const T, p: ?*?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tHead(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tFoot(self: *const T, p: ?*?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tFoot(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tBodies(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tBodies(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_caption(self: *const T, p: ?*?*IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createTHead(self: *const T, head: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createTHead(@ptrCast(*const IHTMLTable, self), head);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteTHead(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteTHead(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createTFoot(self: *const T, foot: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createTFoot(@ptrCast(*const IHTMLTable, self), foot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteTFoot(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteTFoot(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createCaption(self: *const T, caption: ?*?*IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createCaption(@ptrCast(*const IHTMLTable, self), caption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteCaption(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteCaption(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_insertRow(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTable, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTable, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLTable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable2_Value = @import("../zig.zig").Guid.initString("3050f4ad-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTable2 = &IID_IHTMLTable2_Value;
pub const IHTMLTable2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        firstPage: fn(
            self: *const IHTMLTable2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lastPage: fn(
            self: *const IHTMLTable2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cells: fn(
            self: *const IHTMLTable2,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveRow: fn(
            self: *const IHTMLTable2,
            indexFrom: i32,
            indexTo: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_firstPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).firstPage(@ptrCast(*const IHTMLTable2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_lastPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).lastPage(@ptrCast(*const IHTMLTable2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_get_cells(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).get_cells(@ptrCast(*const IHTMLTable2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_moveRow(self: *const T, indexFrom: i32, indexTo: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).moveRow(@ptrCast(*const IHTMLTable2, self), indexFrom, indexTo, row);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable3_Value = @import("../zig.zig").Guid.initString("3050f829-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTable3 = &IID_IHTMLTable3_Value;
pub const IHTMLTable3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_summary: fn(
            self: *const IHTMLTable3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_summary: fn(
            self: *const IHTMLTable3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable3_put_summary(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable3.VTable, self.vtable).put_summary(@ptrCast(*const IHTMLTable3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable3_get_summary(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable3.VTable, self.vtable).get_summary(@ptrCast(*const IHTMLTable3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable4_Value = @import("../zig.zig").Guid.initString("305106c2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTable4 = &IID_IHTMLTable4_Value;
pub const IHTMLTable4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_tHead: fn(
            self: *const IHTMLTable4,
            v: ?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tHead: fn(
            self: *const IHTMLTable4,
            p: ?*?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_tFoot: fn(
            self: *const IHTMLTable4,
            v: ?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tFoot: fn(
            self: *const IHTMLTable4,
            p: ?*?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_caption: fn(
            self: *const IHTMLTable4,
            v: ?*IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_caption: fn(
            self: *const IHTMLTable4,
            p: ?*?*IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTable4,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTable4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTBody: fn(
            self: *const IHTMLTable4,
            tbody: ?*?*IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_tHead(self: *const T, v: ?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_tHead(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_tHead(self: *const T, p: ?*?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_tHead(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_tFoot(self: *const T, v: ?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_tFoot(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_tFoot(self: *const T, p: ?*?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_tFoot(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_caption(self: *const T, v: ?*IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_caption(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_caption(self: *const T, p: ?*?*IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_insertRow(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTable4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTable4, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_createTBody(self: *const T, tbody: ?*?*IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).createTBody(@ptrCast(*const IHTMLTable4, self), tbody);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050f23a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCol = &IID_IHTMLTableCol_Value;
pub const IHTMLTableCol = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_span: fn(
            self: *const IHTMLTableCol,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_span: fn(
            self: *const IHTMLTableCol,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLTableCol,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLTableCol,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTableCol,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTableCol,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vAlign: fn(
            self: *const IHTMLTableCol,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vAlign: fn(
            self: *const IHTMLTableCol,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_span(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_span(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_span(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_span(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_vAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_vAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCol, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol2_Value = @import("../zig.zig").Guid.initString("3050f82a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCol2 = &IID_IHTMLTableCol2_Value;
pub const IHTMLTableCol2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableCol2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableCol2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableCol2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableCol2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCol2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCol2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCol2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCol2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol3_Value = @import("../zig.zig").Guid.initString("305106c4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCol3 = &IID_IHTMLTableCol3_Value;
pub const IHTMLTableCol3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableCol3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableCol3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableCol3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableCol3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCol3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCol3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCol3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCol3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection2_Value = @import("../zig.zig").Guid.initString("3050f5c7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableSection2 = &IID_IHTMLTableSection2_Value;
pub const IHTMLTableSection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        moveRow: fn(
            self: *const IHTMLTableSection2,
            indexFrom: i32,
            indexTo: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection2_moveRow(self: *const T, indexFrom: i32, indexTo: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection2.VTable, self.vtable).moveRow(@ptrCast(*const IHTMLTableSection2, self), indexFrom, indexTo, row);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection3_Value = @import("../zig.zig").Guid.initString("3050f82b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableSection3 = &IID_IHTMLTableSection3_Value;
pub const IHTMLTableSection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableSection3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableSection3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableSection3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableSection3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableSection3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableSection3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableSection3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableSection3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection4_Value = @import("../zig.zig").Guid.initString("305106c5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableSection4 = &IID_IHTMLTableSection4_Value;
pub const IHTMLTableSection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableSection4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableSection4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableSection4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableSection4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTableSection4,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTableSection4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableSection4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableSection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableSection4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableSection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_insertRow(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTableSection4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTableSection4, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050f23c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableRow = &IID_IHTMLTableRow_Value;
pub const IHTMLTableRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTableRow,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTableRow,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vAlign: fn(
            self: *const IHTMLTableRow,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vAlign: fn(
            self: *const IHTMLTableRow,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLTableRow,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLTableRow,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorLight: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorLight: fn(
            self: *const IHTMLTableRow,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorDark: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorDark: fn(
            self: *const IHTMLTableRow,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rowIndex: fn(
            self: *const IHTMLTableRow,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sectionRowIndex: fn(
            self: *const IHTMLTableRow,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cells: fn(
            self: *const IHTMLTableRow,
            p: ?*?*IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertCell: fn(
            self: *const IHTMLTableRow,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCell: fn(
            self: *const IHTMLTableRow,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_vAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_vAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColorLight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColorDark(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_rowIndex(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_rowIndex(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_sectionRowIndex(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_sectionRowIndex(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_cells(self: *const T, p: ?*?*IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_cells(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_insertCell(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).insertCell(@ptrCast(*const IHTMLTableRow, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_deleteCell(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).deleteCell(@ptrCast(*const IHTMLTableRow, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow2_Value = @import("../zig.zig").Guid.initString("3050f4a1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableRow2 = &IID_IHTMLTableRow2_Value;
pub const IHTMLTableRow2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLTableRow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLTableRow2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTableRow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow2_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTableRow2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow3_Value = @import("../zig.zig").Guid.initString("3050f82c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableRow3 = &IID_IHTMLTableRow3_Value;
pub const IHTMLTableRow3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableRow3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableRow3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableRow3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableRow3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableRow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableRow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableRow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableRow3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow4_Value = @import("../zig.zig").Guid.initString("305106c6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableRow4 = &IID_IHTMLTableRow4_Value;
pub const IHTMLTableRow4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableRow4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableRow4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableRow4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableRow4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertCell: fn(
            self: *const IHTMLTableRow4,
            index: i32,
            row: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCell: fn(
            self: *const IHTMLTableRow4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableRow4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableRow4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableRow4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableRow4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_insertCell(self: *const T, index: i32, row: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).insertCell(@ptrCast(*const IHTMLTableRow4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_deleteCell(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).deleteCell(@ptrCast(*const IHTMLTableRow4, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRowMetrics_Value = @import("../zig.zig").Guid.initString("3050f413-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableRowMetrics = &IID_IHTMLTableRowMetrics_Value;
pub const IHTMLTableRowMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientHeight: fn(
            self: *const IHTMLTableRowMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientWidth: fn(
            self: *const IHTMLTableRowMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientTop: fn(
            self: *const IHTMLTableRowMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientLeft: fn(
            self: *const IHTMLTableRowMetrics,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050f23d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCell = &IID_IHTMLTableCell_Value;
pub const IHTMLTableCell = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rowSpan: fn(
            self: *const IHTMLTableCell,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rowSpan: fn(
            self: *const IHTMLTableCell,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_colSpan: fn(
            self: *const IHTMLTableCell,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_colSpan: fn(
            self: *const IHTMLTableCell,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLTableCell,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLTableCell,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vAlign: fn(
            self: *const IHTMLTableCell,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vAlign: fn(
            self: *const IHTMLTableCell,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bgColor: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bgColor: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_noWrap: fn(
            self: *const IHTMLTableCell,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_noWrap: fn(
            self: *const IHTMLTableCell,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_background: fn(
            self: *const IHTMLTableCell,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_background: fn(
            self: *const IHTMLTableCell,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorLight: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorLight: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColorDark: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColorDark: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLTableCell,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cellIndex: fn(
            self: *const IHTMLTableCell,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_rowSpan(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_rowSpan(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_rowSpan(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_rowSpan(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_colSpan(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_colSpan(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_colSpan(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_colSpan(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_vAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_vAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_bgColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_noWrap(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_background(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_background(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_background(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_background(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColorLight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColorDark(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_cellIndex(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_cellIndex(@ptrCast(*const IHTMLTableCell, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell2_Value = @import("../zig.zig").Guid.initString("3050f82d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCell2 = &IID_IHTMLTableCell2_Value;
pub const IHTMLTableCell2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_abbr: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_abbr: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_axis: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_axis: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_headers: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_headers: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scope: fn(
            self: *const IHTMLTableCell2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scope: fn(
            self: *const IHTMLTableCell2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_abbr(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_abbr(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_abbr(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_abbr(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_axis(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_axis(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_axis(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_axis(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_headers(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_headers(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_headers(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_headers(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_scope(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_scope(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_scope(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_scope(@ptrCast(*const IHTMLTableCell2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell3_Value = @import("../zig.zig").Guid.initString("305106c7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTableCell3 = &IID_IHTMLTableCell3_Value;
pub const IHTMLTableCell3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ch: fn(
            self: *const IHTMLTableCell3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ch: fn(
            self: *const IHTMLTableCell3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_chOff: fn(
            self: *const IHTMLTableCell3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_chOff: fn(
            self: *const IHTMLTableCell3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_put_ch(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCell3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_get_ch(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCell3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_put_chOff(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCell3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_get_chOff(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCell3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTable_Value = @import("../zig.zig").Guid.initString("3050f532-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTable = &IID_DispHTMLTable_Value;
pub const DispHTMLTable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050f533-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTableCol = &IID_DispHTMLTableCol_Value;
pub const DispHTMLTableCol = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050f534-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTableSection = &IID_DispHTMLTableSection_Value;
pub const DispHTMLTableSection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050f535-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTableRow = &IID_DispHTMLTableRow_Value;
pub const DispHTMLTableRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050f536-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTableCell = &IID_DispHTMLTableCell_Value;
pub const DispHTMLTableCell = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLScriptEvents2_Value = @import("../zig.zig").Guid.initString("3050f621-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLScriptEvents2 = &IID_HTMLScriptEvents2_Value;
pub const HTMLScriptEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLScriptEvents_Value = @import("../zig.zig").Guid.initString("3050f3e2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLScriptEvents = &IID_HTMLScriptEvents_Value;
pub const HTMLScriptEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050f28b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScriptElement = &IID_IHTMLScriptElement_Value;
pub const IHTMLScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_htmlFor: fn(
            self: *const IHTMLScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_htmlFor: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_event: fn(
            self: *const IHTMLScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_event: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IHTMLScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defer: fn(
            self: *const IHTMLScriptElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defer: fn(
            self: *const IHTMLScriptElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLScriptElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLScriptElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_htmlFor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_htmlFor(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_htmlFor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_htmlFor(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_event(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_event(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_event(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_event(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_text(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_defer(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_defer(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_defer(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_defer(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLScriptElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement2_Value = @import("../zig.zig").Guid.initString("3050f828-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScriptElement2 = &IID_IHTMLScriptElement2_Value;
pub const IHTMLScriptElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IHTMLScriptElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IHTMLScriptElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement2_put_charset(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLScriptElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement2_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLScriptElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement3_Value = @import("../zig.zig").Guid.initString("30510447-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScriptElement3 = &IID_IHTMLScriptElement3_Value;
pub const IHTMLScriptElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLScriptElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLScriptElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement3_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLScriptElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement3_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLScriptElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement4_Value = @import("../zig.zig").Guid.initString("30510801-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLScriptElement4 = &IID_IHTMLScriptElement4_Value;
pub const IHTMLScriptElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_usedCharset: fn(
            self: *const IHTMLScriptElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement4_get_usedCharset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement4.VTable, self.vtable).get_usedCharset(@ptrCast(*const IHTMLScriptElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050f530-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLScriptElement = &IID_DispHTMLScriptElement_Value;
pub const DispHTMLScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050f38a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLNoShowElement = &IID_IHTMLNoShowElement_Value;
pub const IHTMLNoShowElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050f528-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLNoShowElement = &IID_DispHTMLNoShowElement_Value;
pub const DispHTMLNoShowElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLObjectElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f620-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLObjectElementEvents2 = &IID_HTMLObjectElementEvents2_Value;
pub const HTMLObjectElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLObjectElementEvents_Value = @import("../zig.zig").Guid.initString("3050f3c4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLObjectElementEvents = &IID_HTMLObjectElementEvents_Value;
pub const HTMLObjectElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050f24f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLObjectElement = &IID_IHTMLObjectElement_Value;
pub const IHTMLObjectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_object: fn(
            self: *const IHTMLObjectElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_classid: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_recordset: fn(
            self: *const IHTMLObjectElement,
            v: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_recordset: fn(
            self: *const IHTMLObjectElement,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_codeBase: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_codeBase: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_codeType: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_codeType: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_code: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseHref: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLObjectElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLObjectElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLObjectElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLObjectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLObjectElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLObjectElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_altHtml: fn(
            self: *const IHTMLObjectElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altHtml: fn(
            self: *const IHTMLObjectElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLObjectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLObjectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLObjectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLObjectElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_object(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_object(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_classid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_classid(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_putref_recordset(self: *const T, v: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).putref_recordset(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_recordset(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_codeBase(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_codeBase(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_codeBase(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_codeBase(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_codeType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_codeType(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_codeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_codeType(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_code(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_code(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_code(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_code(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_BaseHref(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_BaseHref(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_readyState(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_altHtml(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_altHtml(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_altHtml(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_altHtml(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLObjectElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement2_Value = @import("../zig.zig").Guid.initString("3050f4cd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLObjectElement2 = &IID_IHTMLObjectElement2_Value;
pub const IHTMLObjectElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedRecordset: fn(
            self: *const IHTMLObjectElement2,
            dataMember: ?BSTR,
            hierarchy: ?*VARIANT,
            ppRecordset: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_classid: fn(
            self: *const IHTMLObjectElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_classid: fn(
            self: *const IHTMLObjectElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IHTMLObjectElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLObjectElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_namedRecordset(self: *const T, dataMember: ?BSTR, hierarchy: ?*VARIANT, ppRecordset: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).namedRecordset(@ptrCast(*const IHTMLObjectElement2, self), dataMember, hierarchy, ppRecordset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_put_classid(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).put_classid(@ptrCast(*const IHTMLObjectElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_get_classid(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).get_classid(@ptrCast(*const IHTMLObjectElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).put_data(@ptrCast(*const IHTMLObjectElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement3_Value = @import("../zig.zig").Guid.initString("3050f827-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLObjectElement3 = &IID_IHTMLObjectElement3_Value;
pub const IHTMLObjectElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_archive: fn(
            self: *const IHTMLObjectElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_archive: fn(
            self: *const IHTMLObjectElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_alt: fn(
            self: *const IHTMLObjectElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_alt: fn(
            self: *const IHTMLObjectElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_declare: fn(
            self: *const IHTMLObjectElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_declare: fn(
            self: *const IHTMLObjectElement3,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_standby: fn(
            self: *const IHTMLObjectElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_standby: fn(
            self: *const IHTMLObjectElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLObjectElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLObjectElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_useMap: fn(
            self: *const IHTMLObjectElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_useMap: fn(
            self: *const IHTMLObjectElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_archive(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_archive(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_archive(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_archive(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_alt(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_alt(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_declare(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_declare(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_declare(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_declare(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_standby(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_standby(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_standby(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_standby(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_border(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_border(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_useMap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_useMap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement4_Value = @import("../zig.zig").Guid.initString("3051043e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLObjectElement4 = &IID_IHTMLObjectElement4_Value;
pub const IHTMLObjectElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentDocument: fn(
            self: *const IHTMLObjectElement4,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_codeBase: fn(
            self: *const IHTMLObjectElement4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_codeBase: fn(
            self: *const IHTMLObjectElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IHTMLObjectElement4,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IHTMLObjectElement4,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_contentDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_put_codeBase(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).put_codeBase(@ptrCast(*const IHTMLObjectElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_codeBase(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_codeBase(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_put_data(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).put_data(@ptrCast(*const IHTMLObjectElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement5_Value = @import("../zig.zig").Guid.initString("305104b5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLObjectElement5 = &IID_IHTMLObjectElement5_Value;
pub const IHTMLObjectElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_object: fn(
            self: *const IHTMLObjectElement5,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_object: fn(
            self: *const IHTMLObjectElement5,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement5_put_object(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement5.VTable, self.vtable).put_object(@ptrCast(*const IHTMLObjectElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement5_get_object(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement5.VTable, self.vtable).get_object(@ptrCast(*const IHTMLObjectElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050f83d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLParamElement = &IID_IHTMLParamElement_Value;
pub const IHTMLParamElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLParamElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLParamElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLParamElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLParamElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLParamElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLParamElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueType: fn(
            self: *const IHTMLParamElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueType: fn(
            self: *const IHTMLParamElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_valueType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_valueType(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_valueType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_valueType(@ptrCast(*const IHTMLParamElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParamElement2_Value = @import("../zig.zig").Guid.initString("30510444-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLParamElement2 = &IID_IHTMLParamElement2_Value;
pub const IHTMLParamElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLParamElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLParamElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLParamElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLParamElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLParamElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLParamElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueType: fn(
            self: *const IHTMLParamElement2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueType: fn(
            self: *const IHTMLParamElement2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_name(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_value(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_value(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_value(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_value(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_valueType(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_valueType(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_valueType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_valueType(@ptrCast(*const IHTMLParamElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050f529-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLObjectElement = &IID_DispHTMLObjectElement_Value;
pub const DispHTMLObjectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050f590-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLParamElement = &IID_DispHTMLParamElement_Value;
pub const DispHTMLParamElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFrameSiteEvents2_Value = @import("../zig.zig").Guid.initString("3050f7ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLFrameSiteEvents2 = &IID_HTMLFrameSiteEvents2_Value;
pub const HTMLFrameSiteEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFrameSiteEvents_Value = @import("../zig.zig").Guid.initString("3050f800-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLFrameSiteEvents = &IID_HTMLFrameSiteEvents_Value;
pub const HTMLFrameSiteEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase2_Value = @import("../zig.zig").Guid.initString("3050f6db-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameBase2 = &IID_IHTMLFrameBase2_Value;
pub const IHTMLFrameBase2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentWindow: fn(
            self: *const IHTMLFrameBase2,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLFrameBase2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLFrameBase2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLFrameBase2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLFrameBase2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLFrameBase2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_allowTransparency: fn(
            self: *const IHTMLFrameBase2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allowTransparency: fn(
            self: *const IHTMLFrameBase2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_contentWindow(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_contentWindow(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_allowTransparency(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_allowTransparency(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_allowTransparency(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_allowTransparency(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase3_Value = @import("../zig.zig").Guid.initString("3050f82e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameBase3 = &IID_IHTMLFrameBase3_Value;
pub const IHTMLFrameBase3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_longDesc: fn(
            self: *const IHTMLFrameBase3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longDesc: fn(
            self: *const IHTMLFrameBase3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase3_put_longDesc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLFrameBase3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase3_get_longDesc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLFrameBase3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050f541-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFrameBase = &IID_DispHTMLFrameBase_Value;
pub const DispHTMLFrameBase = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050f313-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameElement = &IID_IHTMLFrameElement_Value;
pub const IHTMLFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLFrameElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLFrameElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement_get_borderColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLFrameElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement2_Value = @import("../zig.zig").Guid.initString("3050f7f5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameElement2 = &IID_IHTMLFrameElement2_Value;
pub const IHTMLFrameElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLFrameElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLFrameElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLFrameElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLFrameElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement3_Value = @import("../zig.zig").Guid.initString("3051042d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameElement3 = &IID_IHTMLFrameElement3_Value;
pub const IHTMLFrameElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentDocument: fn(
            self: *const IHTMLFrameElement3,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_longDesc: fn(
            self: *const IHTMLFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longDesc: fn(
            self: *const IHTMLFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameBorder: fn(
            self: *const IHTMLFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameBorder: fn(
            self: *const IHTMLFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_contentDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_longDesc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_longDesc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_frameBorder(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_frameBorder(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050f513-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFrameElement = &IID_DispHTMLFrameElement_Value;
pub const DispHTMLFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement_Value = @import("../zig.zig").Guid.initString("3050f315-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIFrameElement = &IID_IHTMLIFrameElement_Value;
pub const IHTMLIFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_vspace: fn(
            self: *const IHTMLIFrameElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_vspace: fn(
            self: *const IHTMLIFrameElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hspace: fn(
            self: *const IHTMLIFrameElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hspace: fn(
            self: *const IHTMLIFrameElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLIFrameElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLIFrameElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_vspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_hspace(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement2_Value = @import("../zig.zig").Guid.initString("3050f4e6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIFrameElement2 = &IID_IHTMLIFrameElement2_Value;
pub const IHTMLIFrameElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLIFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLIFrameElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLIFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLIFrameElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLIFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_get_height(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLIFrameElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLIFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_get_width(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLIFrameElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement3_Value = @import("../zig.zig").Guid.initString("30510433-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIFrameElement3 = &IID_IHTMLIFrameElement3_Value;
pub const IHTMLIFrameElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentDocument: fn(
            self: *const IHTMLIFrameElement3,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLIFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLIFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_longDesc: fn(
            self: *const IHTMLIFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longDesc: fn(
            self: *const IHTMLIFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameBorder: fn(
            self: *const IHTMLIFrameElement3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameBorder: fn(
            self: *const IHTMLIFrameElement3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_contentDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_longDesc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_longDesc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_frameBorder(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_frameBorder(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLIFrame_Value = @import("../zig.zig").Guid.initString("3050f51b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLIFrame = &IID_DispHTMLIFrame_Value;
pub const DispHTMLIFrame = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050f212-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDivPosition = &IID_IHTMLDivPosition_Value;
pub const IHTMLDivPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLDivPosition,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLDivPosition,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivPosition_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivPosition.VTable, self.vtable).put_align(@ptrCast(*const IHTMLDivPosition, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivPosition_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivPosition.VTable, self.vtable).get_align(@ptrCast(*const IHTMLDivPosition, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050f3e7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFieldSetElement = &IID_IHTMLFieldSetElement_Value;
pub const IHTMLFieldSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLFieldSetElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLFieldSetElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLFieldSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLFieldSetElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFieldSetElement2_Value = @import("../zig.zig").Guid.initString("3050f833-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFieldSetElement2 = &IID_IHTMLFieldSetElement2_Value;
pub const IHTMLFieldSetElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLFieldSetElement2,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement2_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLFieldSetElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050f3ea-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLegendElement = &IID_IHTMLLegendElement_Value;
pub const IHTMLLegendElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLLegendElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLLegendElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLLegendElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLLegendElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLegendElement2_Value = @import("../zig.zig").Guid.initString("3050f834-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLLegendElement2 = &IID_IHTMLLegendElement2_Value;
pub const IHTMLLegendElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLLegendElement2,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement2_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLLegendElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050f50f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLDivPosition = &IID_DispHTMLDivPosition_Value;
pub const DispHTMLDivPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050f545-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFieldSetElement = &IID_DispHTMLFieldSetElement_Value;
pub const DispHTMLFieldSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050f546-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLLegendElement = &IID_DispHTMLLegendElement_Value;
pub const DispHTMLLegendElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050f3e5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSpanFlow = &IID_IHTMLSpanFlow_Value;
pub const IHTMLSpanFlow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const IHTMLSpanFlow,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const IHTMLSpanFlow,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSpanFlow_put_align(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSpanFlow.VTable, self.vtable).put_align(@ptrCast(*const IHTMLSpanFlow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSpanFlow_get_align(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSpanFlow.VTable, self.vtable).get_align(@ptrCast(*const IHTMLSpanFlow, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050f544-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLSpanFlow = &IID_DispHTMLSpanFlow_Value;
pub const DispHTMLSpanFlow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement_Value = @import("../zig.zig").Guid.initString("3050f319-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameSetElement = &IID_IHTMLFrameSetElement_Value;
pub const IHTMLFrameSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rows: fn(
            self: *const IHTMLFrameSetElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rows: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_cols: fn(
            self: *const IHTMLFrameSetElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cols: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderColor: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderColor: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameBorder: fn(
            self: *const IHTMLFrameSetElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameBorder: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameSpacing: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameSpacing: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: fn(
            self: *const IHTMLFrameSetElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onunload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onunload: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeunload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeunload: fn(
            self: *const IHTMLFrameSetElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_rows(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_rows(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_rows(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_cols(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_cols(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_border(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_borderColor(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_frameBorder(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_frameBorder(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_frameSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_frameSpacing(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_frameSpacing(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_frameSpacing(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_name(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onbeforeunload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement2_Value = @import("../zig.zig").Guid.initString("3050f5c6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameSetElement2 = &IID_IHTMLFrameSetElement2_Value;
pub const IHTMLFrameSetElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onbeforeprint: fn(
            self: *const IHTMLFrameSetElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onbeforeprint: fn(
            self: *const IHTMLFrameSetElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onafterprint: fn(
            self: *const IHTMLFrameSetElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onafterprint: fn(
            self: *const IHTMLFrameSetElement2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLFrameSetElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_get_onbeforeprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLFrameSetElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLFrameSetElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_get_onafterprint(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLFrameSetElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement3_Value = @import("../zig.zig").Guid.initString("30510796-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFrameSetElement3 = &IID_IHTMLFrameSetElement3_Value;
pub const IHTMLFrameSetElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onhashchange: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onhashchange: fn(
            self: *const IHTMLFrameSetElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onmessage: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onmessage: fn(
            self: *const IHTMLFrameSetElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onoffline: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onoffline: fn(
            self: *const IHTMLFrameSetElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ononline: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ononline: fn(
            self: *const IHTMLFrameSetElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onstorage: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onstorage: fn(
            self: *const IHTMLFrameSetElement3,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onhashchange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onmessage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onoffline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_ononline(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onstorage(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameSetSite_Value = @import("../zig.zig").Guid.initString("3050f514-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLFrameSetSite = &IID_DispHTMLFrameSetSite_Value;
pub const DispHTMLFrameSetSite = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050f369-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLBGsound = &IID_IHTMLBGsound_Value;
pub const IHTMLBGsound = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLBGsound,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLBGsound,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLBGsound,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_volume: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_volume: fn(
            self: *const IHTMLBGsound,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_balance: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_balance: fn(
            self: *const IHTMLBGsound,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_src(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_src(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_loop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_volume(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_volume(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_volume(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_volume(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_balance(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_balance(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_balance(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_balance(@ptrCast(*const IHTMLBGsound, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050f53c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLBGsound = &IID_DispHTMLBGsound_Value;
pub const DispHTMLBGsound = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontNamesCollection_Value = @import("../zig.zig").Guid.initString("3050f376-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFontNamesCollection = &IID_IHTMLFontNamesCollection_Value;
pub const IHTMLFontNamesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLFontNamesCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLFontNamesCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFontNamesCollection,
            index: i32,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFontNamesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFontNamesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_item(self: *const T, index: i32, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFontNamesCollection, self), index, pBstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontSizesCollection_Value = @import("../zig.zig").Guid.initString("3050f377-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLFontSizesCollection = &IID_IHTMLFontSizesCollection_Value;
pub const IHTMLFontSizesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLFontSizesCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLFontSizesCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_forFont: fn(
            self: *const IHTMLFontSizesCollection,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFontSizesCollection,
            index: i32,
            plSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get_forFont(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get_forFont(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_item(self: *const T, index: i32, plSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFontSizesCollection, self), index, plSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionsHolder_Value = @import("../zig.zig").Guid.initString("3050f378-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLOptionsHolder = &IID_IHTMLOptionsHolder_Value;
pub const IHTMLOptionsHolder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fonts: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?*IHTMLFontNamesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_execArg: fn(
            self: *const IHTMLOptionsHolder,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_execArg: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_errorLine: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorLine: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_errorCharacter: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCharacter: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_errorCode: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCode: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_errorMessage: fn(
            self: *const IHTMLOptionsHolder,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorMessage: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_errorDebug: fn(
            self: *const IHTMLOptionsHolder,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorDebug: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unsecuredWindowOfDocument: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_findText: fn(
            self: *const IHTMLOptionsHolder,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_findText: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_anythingAfterFrameset: fn(
            self: *const IHTMLOptionsHolder,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anythingAfterFrameset: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        sizes: fn(
            self: *const IHTMLOptionsHolder,
            fontName: ?BSTR,
            pSizesCollection: ?*?*IHTMLFontSizesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        openfiledlg: fn(
            self: *const IHTMLOptionsHolder,
            initFile: VARIANT,
            initDir: VARIANT,
            filter: VARIANT,
            title: VARIANT,
            pathName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        savefiledlg: fn(
            self: *const IHTMLOptionsHolder,
            initFile: VARIANT,
            initDir: VARIANT,
            filter: VARIANT,
            title: VARIANT,
            pathName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        choosecolordlg: fn(
            self: *const IHTMLOptionsHolder,
            initColor: VARIANT,
            rgbColor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showSecurityInfo: fn(
            self: *const IHTMLOptionsHolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isApartmentModel: fn(
            self: *const IHTMLOptionsHolder,
            object: ?*IHTMLObjectElement,
            fApartment: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharset: fn(
            self: *const IHTMLOptionsHolder,
            fontName: ?BSTR,
            charset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_secureConnectionInfo: fn(
            self: *const IHTMLOptionsHolder,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_document(self: *const T, p: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_document(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_fonts(self: *const T, p: ?*?*IHTMLFontNamesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_fonts(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_execArg(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_execArg(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_execArg(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_execArg(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorLine(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorLine(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorLine(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorLine(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorCharacter(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorCharacter(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorCharacter(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorCharacter(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorCode(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorCode(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorCode(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorCode(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorMessage(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorMessage(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorMessage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorMessage(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorDebug(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorDebug(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorDebug(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorDebug(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_unsecuredWindowOfDocument(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_unsecuredWindowOfDocument(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_findText(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_findText(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_findText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_findText(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_anythingAfterFrameset(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_anythingAfterFrameset(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_anythingAfterFrameset(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_anythingAfterFrameset(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_sizes(self: *const T, fontName: ?BSTR, pSizesCollection: ?*?*IHTMLFontSizesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).sizes(@ptrCast(*const IHTMLOptionsHolder, self), fontName, pSizesCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_openfiledlg(self: *const T, initFile: VARIANT, initDir: VARIANT, filter: VARIANT, title: VARIANT, pathName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).openfiledlg(@ptrCast(*const IHTMLOptionsHolder, self), initFile, initDir, filter, title, pathName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_savefiledlg(self: *const T, initFile: VARIANT, initDir: VARIANT, filter: VARIANT, title: VARIANT, pathName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).savefiledlg(@ptrCast(*const IHTMLOptionsHolder, self), initFile, initDir, filter, title, pathName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_choosecolordlg(self: *const T, initColor: VARIANT, rgbColor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).choosecolordlg(@ptrCast(*const IHTMLOptionsHolder, self), initColor, rgbColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_showSecurityInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).showSecurityInfo(@ptrCast(*const IHTMLOptionsHolder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_isApartmentModel(self: *const T, object: ?*IHTMLObjectElement, fApartment: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).isApartmentModel(@ptrCast(*const IHTMLOptionsHolder, self), object, fApartment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_getCharset(self: *const T, fontName: ?BSTR, charset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).getCharset(@ptrCast(*const IHTMLOptionsHolder, self), fontName, charset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_secureConnectionInfo(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_secureConnectionInfo(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLStyleElementEvents2_Value = @import("../zig.zig").Guid.initString("3050f615-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLStyleElementEvents2 = &IID_HTMLStyleElementEvents2_Value;
pub const HTMLStyleElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLStyleElementEvents_Value = @import("../zig.zig").Guid.initString("3050f3cb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLStyleElementEvents = &IID_HTMLStyleElementEvents_Value;
pub const HTMLStyleElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050f375-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleElement = &IID_IHTMLStyleElement_Value;
pub const IHTMLStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLStyleElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLStyleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLStyleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLStyleElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLStyleElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLStyleElement,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_styleSheet: fn(
            self: *const IHTMLStyleElement,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disabled: fn(
            self: *const IHTMLStyleElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disabled: fn(
            self: *const IHTMLStyleElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLStyleElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLStyleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_readyState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_styleSheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_disabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleElement2_Value = @import("../zig.zig").Guid.initString("3051072a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleElement2 = &IID_IHTMLStyleElement2_Value;
pub const IHTMLStyleElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sheet: fn(
            self: *const IHTMLStyleElement2,
            p: ?*?*IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement2_get_sheet(self: *const T, p: ?*?*IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement2.VTable, self.vtable).get_sheet(@ptrCast(*const IHTMLStyleElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050f511-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleElement = &IID_DispHTMLStyleElement_Value;
pub const DispHTMLStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("3050f3d5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleFontFace = &IID_IHTMLStyleFontFace_Value;
pub const IHTMLStyleFontFace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fontsrc: fn(
            self: *const IHTMLStyleFontFace,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontsrc: fn(
            self: *const IHTMLStyleFontFace,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace_put_fontsrc(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace.VTable, self.vtable).put_fontsrc(@ptrCast(*const IHTMLStyleFontFace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace_get_fontsrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace.VTable, self.vtable).get_fontsrc(@ptrCast(*const IHTMLStyleFontFace, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleFontFace2_Value = @import("../zig.zig").Guid.initString("305106ec-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleFontFace2 = &IID_IHTMLStyleFontFace2_Value;
pub const IHTMLStyleFontFace2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_style: fn(
            self: *const IHTMLStyleFontFace2,
            p: ?*?*IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace2_get_style(self: *const T, p: ?*?*IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace2.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleFontFace2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("30590081-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleFontFace = &IID_DispHTMLStyleFontFace_Value;
pub const DispHTMLStyleFontFace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXDomainRequest_Value = @import("../zig.zig").Guid.initString("30510454-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLXDomainRequest = &IID_IHTMLXDomainRequest_Value;
pub const IHTMLXDomainRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_timeout: fn(
            self: *const IHTMLXDomainRequest,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timeout: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentType: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onprogress: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onprogress: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onerror: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onerror: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontimeout: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ontimeout: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onload: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onload: fn(
            self: *const IHTMLXDomainRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLXDomainRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLXDomainRequest,
            bstrMethod: ?BSTR,
            bstrUrl: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IHTMLXDomainRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_responseText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_timeout(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_timeout(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_timeout(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_timeout(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_contentType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_contentType(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onprogress(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onerror(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_ontimeout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_ontimeout(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_ontimeout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_ontimeout(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onload(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).abort(@ptrCast(*const IHTMLXDomainRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_open(self: *const T, bstrMethod: ?BSTR, bstrUrl: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).open(@ptrCast(*const IHTMLXDomainRequest, self), bstrMethod, bstrUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).send(@ptrCast(*const IHTMLXDomainRequest, self), varBody);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXDomainRequestFactory_Value = @import("../zig.zig").Guid.initString("30510456-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLXDomainRequestFactory = &IID_IHTMLXDomainRequestFactory_Value;
pub const IHTMLXDomainRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLXDomainRequestFactory,
            __MIDL__IHTMLXDomainRequestFactory0000: ?*?*IHTMLXDomainRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequestFactory_create(self: *const T, __MIDL__IHTMLXDomainRequestFactory0000: ?*?*IHTMLXDomainRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequestFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLXDomainRequestFactory, self), __MIDL__IHTMLXDomainRequestFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXDomainRequest_Value = @import("../zig.zig").Guid.initString("3050f599-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispXDomainRequest = &IID_DispXDomainRequest_Value;
pub const DispXDomainRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStorage2_Value = @import("../zig.zig").Guid.initString("30510799-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStorage2 = &IID_IHTMLStorage2_Value;
pub const IHTMLStorage2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setItem: fn(
            self: *const IHTMLStorage2,
            bstrKey: ?BSTR,
            bstrValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage2_setItem(self: *const T, bstrKey: ?BSTR, bstrValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage2.VTable, self.vtable).setItem(@ptrCast(*const IHTMLStorage2, self), bstrKey, bstrValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStorage_Value = @import("../zig.zig").Guid.initString("3050f59d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStorage = &IID_DispHTMLStorage_Value;
pub const DispHTMLStorage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventTarget_Value = @import("../zig.zig").Guid.initString("305104b9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IEventTarget = &IID_IEventTarget_Value;
pub const IEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addEventListener: fn(
            self: *const IEventTarget,
            type: ?BSTR,
            listener: ?*IDispatch,
            useCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeEventListener: fn(
            self: *const IEventTarget,
            type: ?BSTR,
            listener: ?*IDispatch,
            useCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dispatchEvent: fn(
            self: *const IEventTarget,
            evt: ?*IDOMEvent,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_addEventListener(self: *const T, type_: ?BSTR, listener: ?*IDispatch, useCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).addEventListener(@ptrCast(*const IEventTarget, self), type_, listener, useCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_removeEventListener(self: *const T, type_: ?BSTR, listener: ?*IDispatch, useCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).removeEventListener(@ptrCast(*const IEventTarget, self), type_, listener, useCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_dispatchEvent(self: *const T, evt: ?*IDOMEvent, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).dispatchEvent(@ptrCast(*const IEventTarget, self), evt, pfResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMEvent_Value = @import("../zig.zig").Guid.initString("3050f5a2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMEvent = &IID_DispDOMEvent_Value;
pub const DispDOMEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMUIEvent_Value = @import("../zig.zig").Guid.initString("305106ca-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMUIEvent = &IID_IDOMUIEvent_Value;
pub const IDOMUIEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_view: fn(
            self: *const IDOMUIEvent,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_detail: fn(
            self: *const IDOMUIEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initUIEvent: fn(
            self: *const IDOMUIEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            view: ?*IHTMLWindow2,
            detail: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_get_view(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).get_view(@ptrCast(*const IDOMUIEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_get_detail(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).get_detail(@ptrCast(*const IDOMUIEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_initUIEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, view: ?*IHTMLWindow2, detail: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).initUIEvent(@ptrCast(*const IDOMUIEvent, self), eventType, canBubble, cancelable, view, detail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMUIEvent_Value = @import("../zig.zig").Guid.initString("30590072-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMUIEvent = &IID_DispDOMUIEvent_Value;
pub const DispDOMUIEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMouseEvent_Value = @import("../zig.zig").Guid.initString("305106ce-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMouseEvent = &IID_IDOMMouseEvent_Value;
pub const IDOMMouseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenX: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_screenY: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientX: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clientY: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ctrlKey: fn(
            self: *const IDOMMouseEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shiftKey: fn(
            self: *const IDOMMouseEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altKey: fn(
            self: *const IDOMMouseEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_metaKey: fn(
            self: *const IDOMMouseEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_button: fn(
            self: *const IDOMMouseEvent,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_relatedTarget: fn(
            self: *const IDOMMouseEvent,
            p: ?*?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMouseEvent: fn(
            self: *const IDOMMouseEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            ctrlKeyArg: i16,
            altKeyArg: i16,
            shiftKeyArg: i16,
            metaKeyArg: i16,
            buttonArg: u16,
            relatedTargetArg: ?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getModifierState: fn(
            self: *const IDOMMouseEvent,
            keyArg: ?BSTR,
            activated: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_buttons: fn(
            self: *const IDOMMouseEvent,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fromElement: fn(
            self: *const IDOMMouseEvent,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_toElement: fn(
            self: *const IDOMMouseEvent,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetX: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offsetY: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageX: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageY: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layerX: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_layerY: fn(
            self: *const IDOMMouseEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_which: fn(
            self: *const IDOMMouseEvent,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_screenX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_screenX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_screenY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_screenY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_clientX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_clientX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_clientY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_clientY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_ctrlKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_shiftKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_shiftKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_altKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_altKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_metaKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_metaKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_button(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_button(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_relatedTarget(self: *const T, p: ?*?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_relatedTarget(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_initMouseEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, ctrlKeyArg: i16, altKeyArg: i16, shiftKeyArg: i16, metaKeyArg: i16, buttonArg: u16, relatedTargetArg: ?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).initMouseEvent(@ptrCast(*const IDOMMouseEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_getModifierState(self: *const T, keyArg: ?BSTR, activated: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).getModifierState(@ptrCast(*const IDOMMouseEvent, self), keyArg, activated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_buttons(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_buttons(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_fromElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_fromElement(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_toElement(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_toElement(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_x(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_x(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_y(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_y(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_offsetX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_offsetX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_offsetY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_offsetY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_pageX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_pageX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_pageY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_pageY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_layerX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_layerX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_layerY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_layerY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_which(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_which(@ptrCast(*const IDOMMouseEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMouseEvent_Value = @import("../zig.zig").Guid.initString("30590073-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMouseEvent = &IID_DispDOMMouseEvent_Value;
pub const DispDOMMouseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMDragEvent_Value = @import("../zig.zig").Guid.initString("30510761-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMDragEvent = &IID_IDOMDragEvent_Value;
pub const IDOMDragEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataTransfer: fn(
            self: *const IDOMDragEvent,
            p: ?*?*IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initDragEvent: fn(
            self: *const IDOMDragEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            ctrlKeyArg: i16,
            altKeyArg: i16,
            shiftKeyArg: i16,
            metaKeyArg: i16,
            buttonArg: u16,
            relatedTargetArg: ?*IEventTarget,
            dataTransferArg: ?*IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDragEvent_get_dataTransfer(self: *const T, p: ?*?*IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDragEvent.VTable, self.vtable).get_dataTransfer(@ptrCast(*const IDOMDragEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDragEvent_initDragEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, ctrlKeyArg: i16, altKeyArg: i16, shiftKeyArg: i16, metaKeyArg: i16, buttonArg: u16, relatedTargetArg: ?*IEventTarget, dataTransferArg: ?*IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDragEvent.VTable, self.vtable).initDragEvent(@ptrCast(*const IDOMDragEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg, dataTransferArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMDragEvent_Value = @import("../zig.zig").Guid.initString("305900a7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMDragEvent = &IID_DispDOMDragEvent_Value;
pub const DispDOMDragEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("305106d0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMouseWheelEvent = &IID_IDOMMouseWheelEvent_Value;
pub const IDOMMouseWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wheelDelta: fn(
            self: *const IDOMMouseWheelEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMouseWheelEvent: fn(
            self: *const IDOMMouseWheelEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            buttonArg: u16,
            relatedTargetArg: ?*IEventTarget,
            modifiersListArg: ?BSTR,
            wheelDeltaArg: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseWheelEvent_get_wheelDelta(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseWheelEvent.VTable, self.vtable).get_wheelDelta(@ptrCast(*const IDOMMouseWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseWheelEvent_initMouseWheelEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, buttonArg: u16, relatedTargetArg: ?*IEventTarget, modifiersListArg: ?BSTR, wheelDeltaArg: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseWheelEvent.VTable, self.vtable).initMouseWheelEvent(@ptrCast(*const IDOMMouseWheelEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, buttonArg, relatedTargetArg, modifiersListArg, wheelDeltaArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("30590074-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMouseWheelEvent = &IID_DispDOMMouseWheelEvent_Value;
pub const DispDOMMouseWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMWheelEvent_Value = @import("../zig.zig").Guid.initString("305106d2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMWheelEvent = &IID_IDOMWheelEvent_Value;
pub const IDOMWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deltaX: fn(
            self: *const IDOMWheelEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deltaY: fn(
            self: *const IDOMWheelEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deltaZ: fn(
            self: *const IDOMWheelEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deltaMode: fn(
            self: *const IDOMWheelEvent,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initWheelEvent: fn(
            self: *const IDOMWheelEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            buttonArg: u16,
            relatedTargetArg: ?*IEventTarget,
            modifiersListArg: ?BSTR,
            deltaX: i32,
            deltaY: i32,
            deltaZ: i32,
            deltaMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaX(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaX(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaY(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaY(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaZ(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaZ(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaMode(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaMode(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_initWheelEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, buttonArg: u16, relatedTargetArg: ?*IEventTarget, modifiersListArg: ?BSTR, deltaX: i32, deltaY: i32, deltaZ: i32, deltaMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).initWheelEvent(@ptrCast(*const IDOMWheelEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, buttonArg, relatedTargetArg, modifiersListArg, deltaX, deltaY, deltaZ, deltaMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMWheelEvent_Value = @import("../zig.zig").Guid.initString("30590075-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMWheelEvent = &IID_DispDOMWheelEvent_Value;
pub const DispDOMWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMTextEvent_Value = @import("../zig.zig").Guid.initString("305106d4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMTextEvent = &IID_IDOMTextEvent_Value;
pub const IDOMTextEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IDOMTextEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inputMethod: fn(
            self: *const IDOMTextEvent,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initTextEvent: fn(
            self: *const IDOMTextEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            dataArg: ?BSTR,
            inputMethod: u32,
            locale: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_locale: fn(
            self: *const IDOMTextEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMTextEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_inputMethod(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_inputMethod(@ptrCast(*const IDOMTextEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_initTextEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, dataArg: ?BSTR, inputMethod: u32, locale: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).initTextEvent(@ptrCast(*const IDOMTextEvent, self), eventType, canBubble, cancelable, viewArg, dataArg, inputMethod, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_locale(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMTextEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMTextEvent_Value = @import("../zig.zig").Guid.initString("30590076-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMTextEvent = &IID_DispDOMTextEvent_Value;
pub const DispDOMTextEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("305106d6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMKeyboardEvent = &IID_IDOMKeyboardEvent_Value;
pub const IDOMKeyboardEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_key: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_location: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ctrlKey: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shiftKey: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altKey: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_metaKey: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_repeat: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getModifierState: fn(
            self: *const IDOMKeyboardEvent,
            keyArg: ?BSTR,
            state: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initKeyboardEvent: fn(
            self: *const IDOMKeyboardEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            keyArg: ?BSTR,
            locationArg: u32,
            modifiersListArg: ?BSTR,
            repeat: i16,
            locale: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_keyCode: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charCode: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_which: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ie9_char: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_locale: fn(
            self: *const IDOMKeyboardEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_key(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_key(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_location(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_location(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_ctrlKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_shiftKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_shiftKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_altKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_altKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_metaKey(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_metaKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_repeat(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_repeat(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_getModifierState(self: *const T, keyArg: ?BSTR, state: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).getModifierState(@ptrCast(*const IDOMKeyboardEvent, self), keyArg, state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_initKeyboardEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, keyArg: ?BSTR, locationArg: u32, modifiersListArg: ?BSTR, repeat: i16, locale: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).initKeyboardEvent(@ptrCast(*const IDOMKeyboardEvent, self), eventType, canBubble, cancelable, viewArg, keyArg, locationArg, modifiersListArg, repeat, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_keyCode(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_keyCode(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_charCode(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_charCode(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_which(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_which(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_ie9_char(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_ie9_char(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_locale(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("30590077-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMKeyboardEvent = &IID_DispDOMKeyboardEvent_Value;
pub const DispDOMKeyboardEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("305106d8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMCompositionEvent = &IID_IDOMCompositionEvent_Value;
pub const IDOMCompositionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IDOMCompositionEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCompositionEvent: fn(
            self: *const IDOMCompositionEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            data: ?BSTR,
            locale: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_locale: fn(
            self: *const IDOMCompositionEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMCompositionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_initCompositionEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, data: ?BSTR, locale: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).initCompositionEvent(@ptrCast(*const IDOMCompositionEvent, self), eventType, canBubble, cancelable, viewArg, data, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_get_locale(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMCompositionEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("30590078-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMCompositionEvent = &IID_DispDOMCompositionEvent_Value;
pub const DispDOMCompositionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMutationEvent_Value = @import("../zig.zig").Guid.initString("305106da-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMutationEvent = &IID_IDOMMutationEvent_Value;
pub const IDOMMutationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_relatedNode: fn(
            self: *const IDOMMutationEvent,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prevValue: fn(
            self: *const IDOMMutationEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_newValue: fn(
            self: *const IDOMMutationEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attrName: fn(
            self: *const IDOMMutationEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attrChange: fn(
            self: *const IDOMMutationEvent,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMutationEvent: fn(
            self: *const IDOMMutationEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            relatedNodeArg: ?*IDispatch,
            prevValueArg: ?BSTR,
            newValueArg: ?BSTR,
            attrNameArg: ?BSTR,
            attrChangeArg: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_relatedNode(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_relatedNode(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_prevValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_prevValue(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_newValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_newValue(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_attrName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_attrName(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_attrChange(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_attrChange(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_initMutationEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, relatedNodeArg: ?*IDispatch, prevValueArg: ?BSTR, newValueArg: ?BSTR, attrNameArg: ?BSTR, attrChangeArg: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).initMutationEvent(@ptrCast(*const IDOMMutationEvent, self), eventType, canBubble, cancelable, relatedNodeArg, prevValueArg, newValueArg, attrNameArg, attrChangeArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMutationEvent_Value = @import("../zig.zig").Guid.initString("30590079-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMutationEvent = &IID_DispDOMMutationEvent_Value;
pub const DispDOMMutationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("30510763-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMBeforeUnloadEvent = &IID_IDOMBeforeUnloadEvent_Value;
pub const IDOMBeforeUnloadEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_returnValue: fn(
            self: *const IDOMBeforeUnloadEvent,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_returnValue: fn(
            self: *const IDOMBeforeUnloadEvent,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMBeforeUnloadEvent_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMBeforeUnloadEvent.VTable, self.vtable).put_returnValue(@ptrCast(*const IDOMBeforeUnloadEvent, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMBeforeUnloadEvent_get_returnValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMBeforeUnloadEvent.VTable, self.vtable).get_returnValue(@ptrCast(*const IDOMBeforeUnloadEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("305900a8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMBeforeUnloadEvent = &IID_DispDOMBeforeUnloadEvent_Value;
pub const DispDOMBeforeUnloadEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMFocusEvent_Value = @import("../zig.zig").Guid.initString("305106cc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMFocusEvent = &IID_IDOMFocusEvent_Value;
pub const IDOMFocusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_relatedTarget: fn(
            self: *const IDOMFocusEvent,
            p: ?*?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initFocusEvent: fn(
            self: *const IDOMFocusEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            view: ?*IHTMLWindow2,
            detail: i32,
            relatedTargetArg: ?*IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMFocusEvent_get_relatedTarget(self: *const T, p: ?*?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMFocusEvent.VTable, self.vtable).get_relatedTarget(@ptrCast(*const IDOMFocusEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMFocusEvent_initFocusEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, view: ?*IHTMLWindow2, detail: i32, relatedTargetArg: ?*IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMFocusEvent.VTable, self.vtable).initFocusEvent(@ptrCast(*const IDOMFocusEvent, self), eventType, canBubble, cancelable, view, detail, relatedTargetArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMFocusEvent_Value = @import("../zig.zig").Guid.initString("30590071-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMFocusEvent = &IID_DispDOMFocusEvent_Value;
pub const DispDOMFocusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCustomEvent_Value = @import("../zig.zig").Guid.initString("305106de-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMCustomEvent = &IID_IDOMCustomEvent_Value;
pub const IDOMCustomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_detail: fn(
            self: *const IDOMCustomEvent,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCustomEvent: fn(
            self: *const IDOMCustomEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            detail: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCustomEvent_get_detail(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCustomEvent.VTable, self.vtable).get_detail(@ptrCast(*const IDOMCustomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCustomEvent_initCustomEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, detail: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCustomEvent.VTable, self.vtable).initCustomEvent(@ptrCast(*const IDOMCustomEvent, self), eventType, canBubble, cancelable, detail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCustomEvent_Value = @import("../zig.zig").Guid.initString("3059007c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMCustomEvent = &IID_DispDOMCustomEvent_Value;
pub const DispDOMCustomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasGradient_Value = @import("../zig.zig").Guid.initString("30510714-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasGradient = &IID_ICanvasGradient_Value;
pub const ICanvasGradient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addColorStop: fn(
            self: *const ICanvasGradient,
            offset: f32,
            color: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasGradient_addColorStop(self: *const T, offset: f32, color: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasGradient.VTable, self.vtable).addColorStop(@ptrCast(*const ICanvasGradient, self), offset, color);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPattern_Value = @import("../zig.zig").Guid.initString("30510716-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasPattern = &IID_ICanvasPattern_Value;
pub const ICanvasPattern = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("30510718-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasTextMetrics = &IID_ICanvasTextMetrics_Value;
pub const ICanvasTextMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ICanvasTextMetrics,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasTextMetrics_get_width(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasTextMetrics.VTable, self.vtable).get_width(@ptrCast(*const ICanvasTextMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasImageData_Value = @import("../zig.zig").Guid.initString("3051071a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasImageData = &IID_ICanvasImageData_Value;
pub const ICanvasImageData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ICanvasImageData,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ICanvasImageData,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const ICanvasImageData,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_width(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_width(@ptrCast(*const ICanvasImageData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_height(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_height(@ptrCast(*const ICanvasImageData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_data(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_data(@ptrCast(*const ICanvasImageData, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPixelArray_Value = @import("../zig.zig").Guid.initString("3051071c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasPixelArray = &IID_ICanvasPixelArray_Value;
pub const ICanvasPixelArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const ICanvasPixelArray,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasPixelArray_get_length(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasPixelArray.VTable, self.vtable).get_length(@ptrCast(*const ICanvasPixelArray, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("305106e4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCanvasElement = &IID_IHTMLCanvasElement_Value;
pub const IHTMLCanvasElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLCanvasElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLCanvasElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLCanvasElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLCanvasElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getContext: fn(
            self: *const IHTMLCanvasElement,
            contextId: ?BSTR,
            ppContext: ?*?*ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toDataURL: fn(
            self: *const IHTMLCanvasElement,
            type: ?BSTR,
            jpegquality: VARIANT,
            pUrl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLCanvasElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCanvasElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLCanvasElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCanvasElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_getContext(self: *const T, contextId: ?BSTR, ppContext: ?*?*ICanvasRenderingContext2D) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).getContext(@ptrCast(*const IHTMLCanvasElement, self), contextId, ppContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_toDataURL(self: *const T, type_: ?BSTR, jpegquality: VARIANT, pUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).toDataURL(@ptrCast(*const IHTMLCanvasElement, self), type_, jpegquality, pUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("305106ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasRenderingContext2D = &IID_ICanvasRenderingContext2D_Value;
pub const ICanvasRenderingContext2D = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_canvas: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?*IHTMLCanvasElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        restore: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        save: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotate: fn(
            self: *const ICanvasRenderingContext2D,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scale: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTransform: fn(
            self: *const ICanvasRenderingContext2D,
            m11: f32,
            m12: f32,
            m21: f32,
            m22: f32,
            dx: f32,
            dy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transform: fn(
            self: *const ICanvasRenderingContext2D,
            m11: f32,
            m12: f32,
            m21: f32,
            m22: f32,
            dx: f32,
            dy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        translate: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_globalAlpha: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_globalAlpha: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_globalCompositeOperation: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_globalCompositeOperation: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fillStyle: fn(
            self: *const ICanvasRenderingContext2D,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fillStyle: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_strokeStyle: fn(
            self: *const ICanvasRenderingContext2D,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strokeStyle: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createLinearGradient: fn(
            self: *const ICanvasRenderingContext2D,
            x0: f32,
            y0: f32,
            x1: f32,
            y1: f32,
            ppCanvasGradient: ?*?*ICanvasGradient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRadialGradient: fn(
            self: *const ICanvasRenderingContext2D,
            x0: f32,
            y0: f32,
            r0: f32,
            x1: f32,
            y1: f32,
            r1: f32,
            ppCanvasGradient: ?*?*ICanvasGradient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPattern: fn(
            self: *const ICanvasRenderingContext2D,
            image: ?*IDispatch,
            repetition: VARIANT,
            ppCanvasPattern: ?*?*ICanvasPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineCap: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineCap: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineJoin: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineJoin: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_lineWidth: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineWidth: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_miterLimit: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_miterLimit: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shadowBlur: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shadowBlur: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shadowColor: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shadowColor: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shadowOffsetX: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shadowOffsetX: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_shadowOffsetY: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shadowOffsetY: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fillRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        strokeRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        arc: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            radius: f32,
            startAngle: f32,
            endAngle: f32,
            anticlockwise: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        arcTo: fn(
            self: *const ICanvasRenderingContext2D,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        beginPath: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        bezierCurveTo: fn(
            self: *const ICanvasRenderingContext2D,
            cp1x: f32,
            cp1y: f32,
            cp2x: f32,
            cp2y: f32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clip: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        closePath: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fill: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lineTo: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveTo: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        quadraticCurveTo: fn(
            self: *const ICanvasRenderingContext2D,
            cpx: f32,
            cpy: f32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stroke: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isPointInPath: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_font: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_font: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textAlign: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textAlign: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textBaseline: fn(
            self: *const ICanvasRenderingContext2D,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textBaseline: fn(
            self: *const ICanvasRenderingContext2D,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fillText: fn(
            self: *const ICanvasRenderingContext2D,
            text: ?BSTR,
            x: f32,
            y: f32,
            maxWidth: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        measureText: fn(
            self: *const ICanvasRenderingContext2D,
            text: ?BSTR,
            ppCanvasTextMetrics: ?*?*ICanvasTextMetrics,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        strokeText: fn(
            self: *const ICanvasRenderingContext2D,
            text: ?BSTR,
            x: f32,
            y: f32,
            maxWidth: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        drawImage: fn(
            self: *const ICanvasRenderingContext2D,
            pSrc: ?*IDispatch,
            a1: VARIANT,
            a2: VARIANT,
            a3: VARIANT,
            a4: VARIANT,
            a5: VARIANT,
            a6: VARIANT,
            a7: VARIANT,
            a8: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createImageData: fn(
            self: *const ICanvasRenderingContext2D,
            a1: VARIANT,
            a2: VARIANT,
            ppCanvasImageData: ?*?*ICanvasImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getImageData: fn(
            self: *const ICanvasRenderingContext2D,
            sx: f32,
            sy: f32,
            sw: f32,
            sh: f32,
            ppCanvasImageData: ?*?*ICanvasImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putImageData: fn(
            self: *const ICanvasRenderingContext2D,
            imagedata: ?*ICanvasImageData,
            dx: f32,
            dy: f32,
            dirtyX: VARIANT,
            dirtyY: VARIANT,
            dirtyWidth: VARIANT,
            dirtyHeight: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_canvas(self: *const T, p: ?*?*IHTMLCanvasElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_canvas(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_restore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).restore(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_save(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).save(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_rotate(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).rotate(@ptrCast(*const ICanvasRenderingContext2D, self), angle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_scale(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).scale(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_setTransform(self: *const T, m11: f32, m12: f32, m21: f32, m22: f32, dx: f32, dy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).setTransform(@ptrCast(*const ICanvasRenderingContext2D, self), m11, m12, m21, m22, dx, dy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_transform(self: *const T, m11: f32, m12: f32, m21: f32, m22: f32, dx: f32, dy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).transform(@ptrCast(*const ICanvasRenderingContext2D, self), m11, m12, m21, m22, dx, dy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_translate(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).translate(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_globalAlpha(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_globalAlpha(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_globalAlpha(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_globalAlpha(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_globalCompositeOperation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_globalCompositeOperation(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_globalCompositeOperation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_globalCompositeOperation(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_fillStyle(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_fillStyle(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_fillStyle(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_fillStyle(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_strokeStyle(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_strokeStyle(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_strokeStyle(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_strokeStyle(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createLinearGradient(self: *const T, x0: f32, y0: f32, x1: f32, y1: f32, ppCanvasGradient: ?*?*ICanvasGradient) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createLinearGradient(@ptrCast(*const ICanvasRenderingContext2D, self), x0, y0, x1, y1, ppCanvasGradient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createRadialGradient(self: *const T, x0: f32, y0: f32, r0: f32, x1: f32, y1: f32, r1: f32, ppCanvasGradient: ?*?*ICanvasGradient) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createRadialGradient(@ptrCast(*const ICanvasRenderingContext2D, self), x0, y0, r0, x1, y1, r1, ppCanvasGradient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createPattern(self: *const T, image: ?*IDispatch, repetition: VARIANT, ppCanvasPattern: ?*?*ICanvasPattern) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createPattern(@ptrCast(*const ICanvasRenderingContext2D, self), image, repetition, ppCanvasPattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineCap(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineCap(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineCap(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineCap(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineJoin(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineJoin(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineJoin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineJoin(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineWidth(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineWidth(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineWidth(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineWidth(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_miterLimit(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_miterLimit(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_miterLimit(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_miterLimit(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowBlur(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowBlur(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowBlur(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowBlur(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowColor(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowColor(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowColor(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowColor(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowOffsetX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowOffsetX(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowOffsetX(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowOffsetX(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowOffsetY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowOffsetY(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowOffsetY(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowOffsetY(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_clearRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).clearRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fillRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fillRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_strokeRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).strokeRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_arc(self: *const T, x: f32, y: f32, radius: f32, startAngle: f32, endAngle: f32, anticlockwise: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).arc(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, radius, startAngle, endAngle, anticlockwise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_arcTo(self: *const T, x1: f32, y1: f32, x2: f32, y2: f32, radius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).arcTo(@ptrCast(*const ICanvasRenderingContext2D, self), x1, y1, x2, y2, radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_beginPath(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).beginPath(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_bezierCurveTo(self: *const T, cp1x: f32, cp1y: f32, cp2x: f32, cp2y: f32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).bezierCurveTo(@ptrCast(*const ICanvasRenderingContext2D, self), cp1x, cp1y, cp2x, cp2y, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_clip(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).clip(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_closePath(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).closePath(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fill(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fill(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_lineTo(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).lineTo(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_moveTo(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).moveTo(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_quadraticCurveTo(self: *const T, cpx: f32, cpy: f32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).quadraticCurveTo(@ptrCast(*const ICanvasRenderingContext2D, self), cpx, cpy, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_rect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).rect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_stroke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).stroke(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_isPointInPath(self: *const T, x: f32, y: f32, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).isPointInPath(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_font(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_font(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_font(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_font(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_textAlign(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_textAlign(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_textAlign(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_textAlign(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_textBaseline(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_textBaseline(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_textBaseline(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_textBaseline(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fillText(self: *const T, text: ?BSTR, x: f32, y: f32, maxWidth: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fillText(@ptrCast(*const ICanvasRenderingContext2D, self), text, x, y, maxWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_measureText(self: *const T, text: ?BSTR, ppCanvasTextMetrics: ?*?*ICanvasTextMetrics) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).measureText(@ptrCast(*const ICanvasRenderingContext2D, self), text, ppCanvasTextMetrics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_strokeText(self: *const T, text: ?BSTR, x: f32, y: f32, maxWidth: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).strokeText(@ptrCast(*const ICanvasRenderingContext2D, self), text, x, y, maxWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_drawImage(self: *const T, pSrc: ?*IDispatch, a1: VARIANT, a2: VARIANT, a3: VARIANT, a4: VARIANT, a5: VARIANT, a6: VARIANT, a7: VARIANT, a8: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).drawImage(@ptrCast(*const ICanvasRenderingContext2D, self), pSrc, a1, a2, a3, a4, a5, a6, a7, a8);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createImageData(self: *const T, a1: VARIANT, a2: VARIANT, ppCanvasImageData: ?*?*ICanvasImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createImageData(@ptrCast(*const ICanvasRenderingContext2D, self), a1, a2, ppCanvasImageData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_getImageData(self: *const T, sx: f32, sy: f32, sw: f32, sh: f32, ppCanvasImageData: ?*?*ICanvasImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).getImageData(@ptrCast(*const ICanvasRenderingContext2D, self), sx, sy, sw, sh, ppCanvasImageData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_putImageData(self: *const T, imagedata: ?*ICanvasImageData, dx: f32, dy: f32, dirtyX: VARIANT, dirtyY: VARIANT, dirtyWidth: VARIANT, dirtyHeight: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).putImageData(@ptrCast(*const ICanvasRenderingContext2D, self), imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasGradient_Value = @import("../zig.zig").Guid.initString("3059008c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCanvasGradient = &IID_DispCanvasGradient_Value;
pub const DispCanvasGradient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasPattern_Value = @import("../zig.zig").Guid.initString("3059008d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCanvasPattern = &IID_DispCanvasPattern_Value;
pub const DispCanvasPattern = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("3059008e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCanvasTextMetrics = &IID_DispCanvasTextMetrics_Value;
pub const DispCanvasTextMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasImageData_Value = @import("../zig.zig").Guid.initString("3059008f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCanvasImageData = &IID_DispCanvasImageData_Value;
pub const DispCanvasImageData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("30590082-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCanvasRenderingContext2D = &IID_DispCanvasRenderingContext2D_Value;
pub const DispCanvasRenderingContext2D = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("3059007b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLCanvasElement = &IID_DispHTMLCanvasElement_Value;
pub const DispHTMLCanvasElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMProgressEvent_Value = @import("../zig.zig").Guid.initString("3051071e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMProgressEvent = &IID_IDOMProgressEvent_Value;
pub const IDOMProgressEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lengthComputable: fn(
            self: *const IDOMProgressEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loaded: fn(
            self: *const IDOMProgressEvent,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_total: fn(
            self: *const IDOMProgressEvent,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initProgressEvent: fn(
            self: *const IDOMProgressEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            lengthComputableArg: i16,
            loadedArg: u64,
            totalArg: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_lengthComputable(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_lengthComputable(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_loaded(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_loaded(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_total(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_total(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_initProgressEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, lengthComputableArg: i16, loadedArg: u64, totalArg: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).initProgressEvent(@ptrCast(*const IDOMProgressEvent, self), eventType, canBubble, cancelable, lengthComputableArg, loadedArg, totalArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMProgressEvent_Value = @import("../zig.zig").Guid.initString("30590091-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMProgressEvent = &IID_DispDOMProgressEvent_Value;
pub const DispDOMProgressEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30510720-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMessageEvent = &IID_IDOMMessageEvent_Value;
pub const IDOMMessageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IDOMMessageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_origin: fn(
            self: *const IDOMMessageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_source: fn(
            self: *const IDOMMessageEvent,
            p: ?*?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMessageEvent: fn(
            self: *const IDOMMessageEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            data: ?BSTR,
            origin: ?BSTR,
            lastEventId: ?BSTR,
            source: ?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_data(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_origin(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_origin(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_source(self: *const T, p: ?*?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_source(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_initMessageEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, data: ?BSTR, origin: ?BSTR, lastEventId: ?BSTR, source: ?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).initMessageEvent(@ptrCast(*const IDOMMessageEvent, self), eventType, canBubble, cancelable, data, origin, lastEventId, source);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30590092-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMessageEvent = &IID_DispDOMMessageEvent_Value;
pub const DispDOMMessageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("30510765-98b6-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMSiteModeEvent = &IID_IDOMSiteModeEvent_Value;
pub const IDOMSiteModeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_buttonID: fn(
            self: *const IDOMSiteModeEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_actionURL: fn(
            self: *const IDOMSiteModeEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMSiteModeEvent_get_buttonID(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMSiteModeEvent.VTable, self.vtable).get_buttonID(@ptrCast(*const IDOMSiteModeEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMSiteModeEvent_get_actionURL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMSiteModeEvent.VTable, self.vtable).get_actionURL(@ptrCast(*const IDOMSiteModeEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("305900a9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMSiteModeEvent = &IID_DispDOMSiteModeEvent_Value;
pub const DispDOMSiteModeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30510722-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMStorageEvent = &IID_IDOMStorageEvent_Value;
pub const IDOMStorageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_key: fn(
            self: *const IDOMStorageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_oldValue: fn(
            self: *const IDOMStorageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_newValue: fn(
            self: *const IDOMStorageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IDOMStorageEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_storageArea: fn(
            self: *const IDOMStorageEvent,
            p: ?*?*IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initStorageEvent: fn(
            self: *const IDOMStorageEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            keyArg: ?BSTR,
            oldValueArg: ?BSTR,
            newValueArg: ?BSTR,
            urlArg: ?BSTR,
            storageAreaArg: ?*IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_key(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_key(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_oldValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_oldValue(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_newValue(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_newValue(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_url(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_url(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_storageArea(self: *const T, p: ?*?*IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_storageArea(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_initStorageEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, keyArg: ?BSTR, oldValueArg: ?BSTR, newValueArg: ?BSTR, urlArg: ?BSTR, storageAreaArg: ?*IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).initStorageEvent(@ptrCast(*const IDOMStorageEvent, self), eventType, canBubble, cancelable, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30590093-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMStorageEvent = &IID_DispDOMStorageEvent_Value;
pub const DispDOMStorageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("30510830-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IXMLHttpRequestEventTarget = &IID_IXMLHttpRequestEventTarget_Value;
pub const IXMLHttpRequestEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("305900e7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispXMLHttpRequestEventTarget = &IID_DispXMLHttpRequestEventTarget_Value;
pub const DispXMLHttpRequestEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLXMLHttpRequestEvents_Value = @import("../zig.zig").Guid.initString("30510498-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLXMLHttpRequestEvents = &IID_HTMLXMLHttpRequestEvents_Value;
pub const HTMLXMLHttpRequestEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3051040a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLXMLHttpRequest = &IID_IHTMLXMLHttpRequest_Value;
pub const IHTMLXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseBody: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseXML: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_statusText: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLXMLHttpRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLXMLHttpRequest,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrMethod: ?BSTR,
            bstrUrl: ?BSTR,
            varAsync: VARIANT,
            varUser: VARIANT,
            varPassword: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IHTMLXMLHttpRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllResponseHeaders: fn(
            self: *const IHTMLXMLHttpRequest,
            __MIDL__IHTMLXMLHttpRequest0000: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getResponseHeader: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrHeader: ?BSTR,
            __MIDL__IHTMLXMLHttpRequest0001: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRequestHeader: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrHeader: ?BSTR,
            bstrValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_readyState(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseBody(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseBody(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseXML(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseXML(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_status(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_status(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_statusText(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_statusText(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLXMLHttpRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).abort(@ptrCast(*const IHTMLXMLHttpRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_open(self: *const T, bstrMethod: ?BSTR, bstrUrl: ?BSTR, varAsync: VARIANT, varUser: VARIANT, varPassword: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).open(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrMethod, bstrUrl, varAsync, varUser, varPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).send(@ptrCast(*const IHTMLXMLHttpRequest, self), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_getAllResponseHeaders(self: *const T, __MIDL__IHTMLXMLHttpRequest0000: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).getAllResponseHeaders(@ptrCast(*const IHTMLXMLHttpRequest, self), __MIDL__IHTMLXMLHttpRequest0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_getResponseHeader(self: *const T, bstrHeader: ?BSTR, __MIDL__IHTMLXMLHttpRequest0001: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).getResponseHeader(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrHeader, __MIDL__IHTMLXMLHttpRequest0001);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_setRequestHeader(self: *const T, bstrHeader: ?BSTR, bstrValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).setRequestHeader(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrHeader, bstrValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequest2_Value = @import("../zig.zig").Guid.initString("30510482-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLXMLHttpRequest2 = &IID_IHTMLXMLHttpRequest2_Value;
pub const IHTMLXMLHttpRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_timeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontimeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ontimeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_put_timeout(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).put_timeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_get_timeout(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).get_timeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_put_ontimeout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).put_ontimeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_get_ontimeout(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).get_ontimeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequestFactory_Value = @import("../zig.zig").Guid.initString("3051040c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLXMLHttpRequestFactory = &IID_IHTMLXMLHttpRequestFactory_Value;
pub const IHTMLXMLHttpRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLXMLHttpRequestFactory,
            __MIDL__IHTMLXMLHttpRequestFactory0000: ?*?*IHTMLXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequestFactory_create(self: *const T, __MIDL__IHTMLXMLHttpRequestFactory0000: ?*?*IHTMLXMLHttpRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequestFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLXMLHttpRequestFactory, self), __MIDL__IHTMLXMLHttpRequestFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3050f596-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLXMLHttpRequest = &IID_DispHTMLXMLHttpRequest_Value;
pub const DispHTMLXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAngle_Value = @import("../zig.zig").Guid.initString("305104d3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAngle = &IID_ISVGAngle_Value;
pub const ISVGAngle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unitType: fn(
            self: *const ISVGAngle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unitType: fn(
            self: *const ISVGAngle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const ISVGAngle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const ISVGAngle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueInSpecifiedUnits: fn(
            self: *const ISVGAngle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueInSpecifiedUnits: fn(
            self: *const ISVGAngle,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueAsString: fn(
            self: *const ISVGAngle,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueAsString: fn(
            self: *const ISVGAngle,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        newValueSpecifiedUnits: fn(
            self: *const ISVGAngle,
            unitType: i16,
            valueInSpecifiedUnits: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        convertToSpecifiedUnits: fn(
            self: *const ISVGAngle,
            unitType: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_unitType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_unitType(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_unitType(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_unitType(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_value(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_value(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_value(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_valueInSpecifiedUnits(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_valueInSpecifiedUnits(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_valueInSpecifiedUnits(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_valueInSpecifiedUnits(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_valueAsString(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_valueAsString(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_valueAsString(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_valueAsString(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_newValueSpecifiedUnits(self: *const T, unitType: i16, valueInSpecifiedUnits: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).newValueSpecifiedUnits(@ptrCast(*const ISVGAngle, self), unitType, valueInSpecifiedUnits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_convertToSpecifiedUnits(self: *const T, unitType: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).convertToSpecifiedUnits(@ptrCast(*const ISVGAngle, self), unitType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElement_Value = @import("../zig.zig").Guid.initString("305104c5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGElement = &IID_ISVGElement_Value;
pub const ISVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmlbase: fn(
            self: *const ISVGElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmlbase: fn(
            self: *const ISVGElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ownerSVGElement: fn(
            self: *const ISVGElement,
            v: ?*ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerSVGElement: fn(
            self: *const ISVGElement,
            p: ?*?*ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewportElement: fn(
            self: *const ISVGElement,
            v: ?*ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewportElement: fn(
            self: *const ISVGElement,
            p: ?*?*ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_focusable: fn(
            self: *const ISVGElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_focusable: fn(
            self: *const ISVGElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_put_xmlbase(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).put_xmlbase(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_xmlbase(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_xmlbase(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_ownerSVGElement(self: *const T, v: ?*ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_ownerSVGElement(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_ownerSVGElement(self: *const T, p: ?*?*ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_ownerSVGElement(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_viewportElement(self: *const T, v: ?*ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_viewportElement(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_viewportElement(self: *const T, p: ?*?*ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_viewportElement(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_focusable(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_focusable(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_focusable(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_focusable(@ptrCast(*const ISVGElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRect_Value = @import("../zig.zig").Guid.initString("305104d7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGRect = &IID_ISVGRect_Value;
pub const ISVGRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGRect,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGRect,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGRect,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGRect,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_x(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_x(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_y(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_y(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_width(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_width(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_width(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_width(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_height(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_height(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_height(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_height(@ptrCast(*const ISVGRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMatrix_Value = @import("../zig.zig").Guid.initString("305104f6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGMatrix = &IID_ISVGMatrix_Value;
pub const ISVGMatrix = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_a: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_a: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_b: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_b: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_c: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_c: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_d: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_d: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_e: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_e: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_f: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_f: fn(
            self: *const ISVGMatrix,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        multiply: fn(
            self: *const ISVGMatrix,
            secondMatrix: ?*ISVGMatrix,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        inverse: fn(
            self: *const ISVGMatrix,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        translate: fn(
            self: *const ISVGMatrix,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scale: fn(
            self: *const ISVGMatrix,
            scaleFactor: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scaleNonUniform: fn(
            self: *const ISVGMatrix,
            scaleFactorX: f32,
            scaleFactorY: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotate: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotateFromVector: fn(
            self: *const ISVGMatrix,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        flipX: fn(
            self: *const ISVGMatrix,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        flipY: fn(
            self: *const ISVGMatrix,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skewX: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skewY: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_a(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_a(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_a(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_a(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_b(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_b(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_b(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_b(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_c(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_c(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_c(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_c(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_d(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_d(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_d(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_d(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_e(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_e(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_e(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_e(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_f(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_f(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_f(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_f(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_multiply(self: *const T, secondMatrix: ?*ISVGMatrix, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).multiply(@ptrCast(*const ISVGMatrix, self), secondMatrix, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_inverse(self: *const T, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).inverse(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_translate(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).translate(@ptrCast(*const ISVGMatrix, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_scale(self: *const T, scaleFactor: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).scale(@ptrCast(*const ISVGMatrix, self), scaleFactor, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_scaleNonUniform(self: *const T, scaleFactorX: f32, scaleFactorY: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).scaleNonUniform(@ptrCast(*const ISVGMatrix, self), scaleFactorX, scaleFactorY, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_rotate(self: *const T, angle: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).rotate(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_rotateFromVector(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).rotateFromVector(@ptrCast(*const ISVGMatrix, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_flipX(self: *const T, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).flipX(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_flipY(self: *const T, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).flipY(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_skewX(self: *const T, angle: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).skewX(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_skewY(self: *const T, angle: f32, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).skewY(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStringList_Value = @import("../zig.zig").Guid.initString("305104c8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGStringList = &IID_ISVGStringList_Value;
pub const ISVGStringList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGStringList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGStringList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGStringList,
            newItem: ?BSTR,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGStringList,
            index: i32,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGStringList,
            newItem: ?BSTR,
            index: i32,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGStringList,
            newItem: ?BSTR,
            index: i32,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGStringList,
            index: i32,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGStringList,
            newItem: ?BSTR,
            ppResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGStringList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGStringList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).clear(@ptrCast(*const ISVGStringList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_initialize(self: *const T, newItem: ?BSTR, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).initialize(@ptrCast(*const ISVGStringList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_getItem(self: *const T, index: i32, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).getItem(@ptrCast(*const ISVGStringList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_insertItemBefore(self: *const T, newItem: ?BSTR, index: i32, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGStringList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_replaceItem(self: *const T, newItem: ?BSTR, index: i32, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGStringList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_removeItem(self: *const T, index: i32, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGStringList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_appendItem(self: *const T, newItem: ?BSTR, ppResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGStringList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedRect_Value = @import("../zig.zig").Guid.initString("305104d8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedRect = &IID_ISVGAnimatedRect_Value;
pub const ISVGAnimatedRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedRect,
            v: ?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedRect,
            p: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedRect,
            v: ?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedRect,
            p: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_putref_baseVal(self: *const T, v: ?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_get_baseVal(self: *const T, p: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_putref_animVal(self: *const T, v: ?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_get_animVal(self: *const T, p: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedString_Value = @import("../zig.zig").Guid.initString("305104c7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedString = &IID_ISVGAnimatedString_Value;
pub const ISVGAnimatedString = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseVal: fn(
            self: *const ISVGAnimatedString,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedString,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedString,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_put_baseVal(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedString, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_get_baseVal(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedString, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_get_animVal(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedString, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedBoolean_Value = @import("../zig.zig").Guid.initString("305104c6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedBoolean = &IID_ISVGAnimatedBoolean_Value;
pub const ISVGAnimatedBoolean = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseVal: fn(
            self: *const ISVGAnimatedBoolean,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedBoolean,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animVal: fn(
            self: *const ISVGAnimatedBoolean,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedBoolean,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_put_baseVal(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedBoolean, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_get_baseVal(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedBoolean, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_put_animVal(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedBoolean, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_get_animVal(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedBoolean, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedTransformList_Value = @import("../zig.zig").Guid.initString("305104f9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedTransformList = &IID_ISVGAnimatedTransformList_Value;
pub const ISVGAnimatedTransformList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedTransformList,
            v: ?*ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedTransformList,
            p: ?*?*ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedTransformList,
            v: ?*ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedTransformList,
            p: ?*?*ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_putref_baseVal(self: *const T, v: ?*ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_get_baseVal(self: *const T, p: ?*?*ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedTransformList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_putref_animVal(self: *const T, v: ?*ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_get_animVal(self: *const T, p: ?*?*ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedTransformList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305104fb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedPreserveAspectRatio = &IID_ISVGAnimatedPreserveAspectRatio_Value;
pub const ISVGAnimatedPreserveAspectRatio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            v: ?*ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            p: ?*?*ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            v: ?*ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            p: ?*?*ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_putref_baseVal(self: *const T, v: ?*ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_get_baseVal(self: *const T, p: ?*?*ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_putref_animVal(self: *const T, v: ?*ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_get_animVal(self: *const T, p: ?*?*ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStylable_Value = @import("../zig.zig").Guid.initString("305104da-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGStylable = &IID_ISVGStylable_Value;
pub const ISVGStylable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_className: fn(
            self: *const ISVGStylable,
            p: ?*?*ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStylable_get_className(self: *const T, p: ?*?*ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStylable.VTable, self.vtable).get_className(@ptrCast(*const ISVGStylable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLocatable_Value = @import("../zig.zig").Guid.initString("305104db-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLocatable = &IID_ISVGLocatable_Value;
pub const ISVGLocatable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nearestViewportElement: fn(
            self: *const ISVGLocatable,
            p: ?*?*ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_farthestViewportElement: fn(
            self: *const ISVGLocatable,
            p: ?*?*ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBBox: fn(
            self: *const ISVGLocatable,
            ppResult: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCTM: fn(
            self: *const ISVGLocatable,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getScreenCTM: fn(
            self: *const ISVGLocatable,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTransformToElement: fn(
            self: *const ISVGLocatable,
            pElement: ?*ISVGElement,
            ppResult: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_get_nearestViewportElement(self: *const T, p: ?*?*ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).get_nearestViewportElement(@ptrCast(*const ISVGLocatable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_get_farthestViewportElement(self: *const T, p: ?*?*ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).get_farthestViewportElement(@ptrCast(*const ISVGLocatable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getBBox(self: *const T, ppResult: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getBBox(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getCTM(self: *const T, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getCTM(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getScreenCTM(self: *const T, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getScreenCTM(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getTransformToElement(self: *const T, pElement: ?*ISVGElement, ppResult: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getTransformToElement(@ptrCast(*const ISVGLocatable, self), pElement, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransformable_Value = @import("../zig.zig").Guid.initString("305104dc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTransformable = &IID_ISVGTransformable_Value;
pub const ISVGTransformable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_transform: fn(
            self: *const ISVGTransformable,
            p: ?*?*ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformable_get_transform(self: *const T, p: ?*?*ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformable.VTable, self.vtable).get_transform(@ptrCast(*const ISVGTransformable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTests_Value = @import("../zig.zig").Guid.initString("305104dd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTests = &IID_ISVGTests_Value;
pub const ISVGTests = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_requiredFeatures: fn(
            self: *const ISVGTests,
            p: ?*?*ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_requiredExtensions: fn(
            self: *const ISVGTests,
            p: ?*?*ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemLanguage: fn(
            self: *const ISVGTests,
            p: ?*?*ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasExtension: fn(
            self: *const ISVGTests,
            extension: ?BSTR,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_requiredFeatures(self: *const T, p: ?*?*ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_requiredFeatures(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_requiredExtensions(self: *const T, p: ?*?*ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_requiredExtensions(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_systemLanguage(self: *const T, p: ?*?*ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_systemLanguage(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_hasExtension(self: *const T, extension: ?BSTR, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).hasExtension(@ptrCast(*const ISVGTests, self), extension, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLangSpace_Value = @import("../zig.zig").Guid.initString("305104de-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLangSpace = &IID_ISVGLangSpace_Value;
pub const ISVGLangSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmllang: fn(
            self: *const ISVGLangSpace,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmllang: fn(
            self: *const ISVGLangSpace,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_xmlspace: fn(
            self: *const ISVGLangSpace,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xmlspace: fn(
            self: *const ISVGLangSpace,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_put_xmllang(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).put_xmllang(@ptrCast(*const ISVGLangSpace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_get_xmllang(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).get_xmllang(@ptrCast(*const ISVGLangSpace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_put_xmlspace(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).put_xmlspace(@ptrCast(*const ISVGLangSpace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_get_xmlspace(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).get_xmlspace(@ptrCast(*const ISVGLangSpace, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGExternalResourcesRequired_Value = @import("../zig.zig").Guid.initString("305104df-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGExternalResourcesRequired = &IID_ISVGExternalResourcesRequired_Value;
pub const ISVGExternalResourcesRequired = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_externalResourcesRequired: fn(
            self: *const ISVGExternalResourcesRequired,
            p: ?*?*ISVGAnimatedBoolean,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGExternalResourcesRequired_get_externalResourcesRequired(self: *const T, p: ?*?*ISVGAnimatedBoolean) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGExternalResourcesRequired.VTable, self.vtable).get_externalResourcesRequired(@ptrCast(*const ISVGExternalResourcesRequired, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGFitToViewBox_Value = @import("../zig.zig").Guid.initString("305104e0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGFitToViewBox = &IID_ISVGFitToViewBox_Value;
pub const ISVGFitToViewBox = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewBox: fn(
            self: *const ISVGFitToViewBox,
            p: ?*?*ISVGAnimatedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_preserveAspectRatio: fn(
            self: *const ISVGFitToViewBox,
            v: ?*ISVGAnimatedPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_preserveAspectRatio: fn(
            self: *const ISVGFitToViewBox,
            p: ?*?*ISVGAnimatedPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_get_viewBox(self: *const T, p: ?*?*ISVGAnimatedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).get_viewBox(@ptrCast(*const ISVGFitToViewBox, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_putref_preserveAspectRatio(self: *const T, v: ?*ISVGAnimatedPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).putref_preserveAspectRatio(@ptrCast(*const ISVGFitToViewBox, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_get_preserveAspectRatio(self: *const T, p: ?*?*ISVGAnimatedPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).get_preserveAspectRatio(@ptrCast(*const ISVGFitToViewBox, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGZoomAndPan_Value = @import("../zig.zig").Guid.initString("305104e1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGZoomAndPan = &IID_ISVGZoomAndPan_Value;
pub const ISVGZoomAndPan = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoomAndPan: fn(
            self: *const ISVGZoomAndPan,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomAndPan_get_zoomAndPan(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomAndPan.VTable, self.vtable).get_zoomAndPan(@ptrCast(*const ISVGZoomAndPan, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGURIReference_Value = @import("../zig.zig").Guid.initString("305104e3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGURIReference = &IID_ISVGURIReference_Value;
pub const ISVGURIReference = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_href: fn(
            self: *const ISVGURIReference,
            p: ?*?*ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGURIReference_get_href(self: *const T, p: ?*?*ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGURIReference.VTable, self.vtable).get_href(@ptrCast(*const ISVGURIReference, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedAngle_Value = @import("../zig.zig").Guid.initString("305104d4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedAngle = &IID_ISVGAnimatedAngle_Value;
pub const ISVGAnimatedAngle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedAngle,
            v: ?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedAngle,
            p: ?*?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedAngle,
            v: ?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedAngle,
            p: ?*?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_putref_baseVal(self: *const T, v: ?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_get_baseVal(self: *const T, p: ?*?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_putref_animVal(self: *const T, v: ?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_get_animVal(self: *const T, p: ?*?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedAngle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransformList_Value = @import("../zig.zig").Guid.initString("305104f8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTransformList = &IID_ISVGTransformList_Value;
pub const ISVGTransformList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGTransformList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGTransformList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGTransformList,
            newItem: ?*ISVGTransform,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGTransformList,
            index: i32,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGTransformList,
            newItem: ?*ISVGTransform,
            index: i32,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGTransformList,
            newItem: ?*ISVGTransform,
            index: i32,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGTransformList,
            index: i32,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGTransformList,
            newItem: ?*ISVGTransform,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransformFromMatrix: fn(
            self: *const ISVGTransformList,
            newItem: ?*ISVGMatrix,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        consolidate: fn(
            self: *const ISVGTransformList,
            ppResult: ?*?*ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGTransformList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).clear(@ptrCast(*const ISVGTransformList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_initialize(self: *const T, newItem: ?*ISVGTransform, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).initialize(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_getItem(self: *const T, index: i32, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).getItem(@ptrCast(*const ISVGTransformList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_insertItemBefore(self: *const T, newItem: ?*ISVGTransform, index: i32, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGTransformList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_replaceItem(self: *const T, newItem: ?*ISVGTransform, index: i32, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGTransformList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_removeItem(self: *const T, index: i32, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGTransformList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_appendItem(self: *const T, newItem: ?*ISVGTransform, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_createSVGTransformFromMatrix(self: *const T, newItem: ?*ISVGMatrix, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).createSVGTransformFromMatrix(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_consolidate(self: *const T, ppResult: ?*?*ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).consolidate(@ptrCast(*const ISVGTransformList, self), ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedEnumeration_Value = @import("../zig.zig").Guid.initString("305104c9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedEnumeration = &IID_ISVGAnimatedEnumeration_Value;
pub const ISVGAnimatedEnumeration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseVal: fn(
            self: *const ISVGAnimatedEnumeration,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedEnumeration,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animVal: fn(
            self: *const ISVGAnimatedEnumeration,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedEnumeration,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_put_baseVal(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedEnumeration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_get_baseVal(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedEnumeration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_put_animVal(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedEnumeration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_get_animVal(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedEnumeration, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedInteger_Value = @import("../zig.zig").Guid.initString("305104ca-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedInteger = &IID_ISVGAnimatedInteger_Value;
pub const ISVGAnimatedInteger = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseVal: fn(
            self: *const ISVGAnimatedInteger,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedInteger,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animVal: fn(
            self: *const ISVGAnimatedInteger,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedInteger,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_put_baseVal(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedInteger, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_get_baseVal(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedInteger, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_put_animVal(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedInteger, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_get_animVal(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedInteger, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLength_Value = @import("../zig.zig").Guid.initString("305104cf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLength = &IID_ISVGLength_Value;
pub const ISVGLength = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unitType: fn(
            self: *const ISVGLength,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unitType: fn(
            self: *const ISVGLength,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const ISVGLength,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const ISVGLength,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueInSpecifiedUnits: fn(
            self: *const ISVGLength,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueInSpecifiedUnits: fn(
            self: *const ISVGLength,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_valueAsString: fn(
            self: *const ISVGLength,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_valueAsString: fn(
            self: *const ISVGLength,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        newValueSpecifiedUnits: fn(
            self: *const ISVGLength,
            unitType: i16,
            valueInSpecifiedUnits: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        convertToSpecifiedUnits: fn(
            self: *const ISVGLength,
            unitType: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_unitType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_unitType(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_unitType(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_unitType(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_value(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_value(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_value(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_valueInSpecifiedUnits(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_valueInSpecifiedUnits(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_valueInSpecifiedUnits(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_valueInSpecifiedUnits(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_valueAsString(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_valueAsString(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_valueAsString(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_valueAsString(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_newValueSpecifiedUnits(self: *const T, unitType: i16, valueInSpecifiedUnits: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).newValueSpecifiedUnits(@ptrCast(*const ISVGLength, self), unitType, valueInSpecifiedUnits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_convertToSpecifiedUnits(self: *const T, unitType: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).convertToSpecifiedUnits(@ptrCast(*const ISVGLength, self), unitType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedLength_Value = @import("../zig.zig").Guid.initString("305104d0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedLength = &IID_ISVGAnimatedLength_Value;
pub const ISVGAnimatedLength = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedLength,
            v: ?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedLength,
            p: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedLength,
            v: ?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedLength,
            p: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_putref_baseVal(self: *const T, v: ?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_get_baseVal(self: *const T, p: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_putref_animVal(self: *const T, v: ?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_get_animVal(self: *const T, p: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedLength, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLengthList_Value = @import("../zig.zig").Guid.initString("305104d1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLengthList = &IID_ISVGLengthList_Value;
pub const ISVGLengthList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGLengthList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGLengthList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGLengthList,
            newItem: ?*ISVGLength,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGLengthList,
            index: i32,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGLengthList,
            newItem: ?*ISVGLength,
            index: i32,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGLengthList,
            newItem: ?*ISVGLength,
            index: i32,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGLengthList,
            index: i32,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGLengthList,
            newItem: ?*ISVGLength,
            ppResult: ?*?*ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGLengthList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).clear(@ptrCast(*const ISVGLengthList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_initialize(self: *const T, newItem: ?*ISVGLength, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).initialize(@ptrCast(*const ISVGLengthList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_getItem(self: *const T, index: i32, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).getItem(@ptrCast(*const ISVGLengthList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_insertItemBefore(self: *const T, newItem: ?*ISVGLength, index: i32, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGLengthList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_replaceItem(self: *const T, newItem: ?*ISVGLength, index: i32, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGLengthList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_removeItem(self: *const T, index: i32, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGLengthList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_appendItem(self: *const T, newItem: ?*ISVGLength, ppResult: ?*?*ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGLengthList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedLengthList_Value = @import("../zig.zig").Guid.initString("305104d2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedLengthList = &IID_ISVGAnimatedLengthList_Value;
pub const ISVGAnimatedLengthList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedLengthList,
            v: ?*ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedLengthList,
            p: ?*?*ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedLengthList,
            v: ?*ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedLengthList,
            p: ?*?*ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_putref_baseVal(self: *const T, v: ?*ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_get_baseVal(self: *const T, p: ?*?*ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedLengthList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_putref_animVal(self: *const T, v: ?*ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_get_animVal(self: *const T, p: ?*?*ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedLengthList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGNumber_Value = @import("../zig.zig").Guid.initString("305104cb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGNumber = &IID_ISVGNumber_Value;
pub const ISVGNumber = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const ISVGNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const ISVGNumber,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumber_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumber.VTable, self.vtable).put_value(@ptrCast(*const ISVGNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumber_get_value(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumber.VTable, self.vtable).get_value(@ptrCast(*const ISVGNumber, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedNumber_Value = @import("../zig.zig").Guid.initString("305104cc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedNumber = &IID_ISVGAnimatedNumber_Value;
pub const ISVGAnimatedNumber = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseVal: fn(
            self: *const ISVGAnimatedNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedNumber,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_animVal: fn(
            self: *const ISVGAnimatedNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedNumber,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_put_baseVal(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_get_baseVal(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedNumber, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_put_animVal(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_get_animVal(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedNumber, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGNumberList_Value = @import("../zig.zig").Guid.initString("305104cd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGNumberList = &IID_ISVGNumberList_Value;
pub const ISVGNumberList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGNumberList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGNumberList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGNumberList,
            newItem: ?*ISVGNumber,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGNumberList,
            index: i32,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGNumberList,
            newItem: ?*ISVGNumber,
            index: i32,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGNumberList,
            newItem: ?*ISVGNumber,
            index: i32,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGNumberList,
            index: i32,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGNumberList,
            newItem: ?*ISVGNumber,
            ppResult: ?*?*ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGNumberList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).clear(@ptrCast(*const ISVGNumberList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_initialize(self: *const T, newItem: ?*ISVGNumber, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).initialize(@ptrCast(*const ISVGNumberList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_getItem(self: *const T, index: i32, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).getItem(@ptrCast(*const ISVGNumberList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_insertItemBefore(self: *const T, newItem: ?*ISVGNumber, index: i32, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGNumberList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_replaceItem(self: *const T, newItem: ?*ISVGNumber, index: i32, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGNumberList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_removeItem(self: *const T, index: i32, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGNumberList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_appendItem(self: *const T, newItem: ?*ISVGNumber, ppResult: ?*?*ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGNumberList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedNumberList_Value = @import("../zig.zig").Guid.initString("305104ce-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedNumberList = &IID_ISVGAnimatedNumberList_Value;
pub const ISVGAnimatedNumberList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedNumberList,
            v: ?*ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseVal: fn(
            self: *const ISVGAnimatedNumberList,
            p: ?*?*ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedNumberList,
            v: ?*ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animVal: fn(
            self: *const ISVGAnimatedNumberList,
            p: ?*?*ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_putref_baseVal(self: *const T, v: ?*ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_get_baseVal(self: *const T, p: ?*?*ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedNumberList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_putref_animVal(self: *const T, v: ?*ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_get_animVal(self: *const T, p: ?*?*ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedNumberList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGClipPathElement_Value = @import("../zig.zig").Guid.initString("3051052d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGClipPathElement = &IID_ISVGClipPathElement_Value;
pub const ISVGClipPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_clipPathUnits: fn(
            self: *const ISVGClipPathElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_clipPathUnits: fn(
            self: *const ISVGClipPathElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGClipPathElement_putref_clipPathUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGClipPathElement.VTable, self.vtable).putref_clipPathUnits(@ptrCast(*const ISVGClipPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGClipPathElement_get_clipPathUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGClipPathElement.VTable, self.vtable).get_clipPathUnits(@ptrCast(*const ISVGClipPathElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGClipPathElement_Value = @import("../zig.zig").Guid.initString("3059003b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGClipPathElement = &IID_DispSVGClipPathElement_Value;
pub const DispSVGClipPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDocument_Value = @import("../zig.zig").Guid.initString("305104e6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGDocument = &IID_ISVGDocument_Value;
pub const ISVGDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rootElement: fn(
            self: *const ISVGDocument,
            p: ?*?*ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGDocument_get_rootElement(self: *const T, p: ?*?*ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGDocument.VTable, self.vtable).get_rootElement(@ptrCast(*const ISVGDocument, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSVGDocument_Value = @import("../zig.zig").Guid.initString("305105ab-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IGetSVGDocument = &IID_IGetSVGDocument_Value;
pub const IGetSVGDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getSVGDocument: fn(
            self: *const IGetSVGDocument,
            ppSVGDocument: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetSVGDocument_getSVGDocument(self: *const T, ppSVGDocument: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetSVGDocument.VTable, self.vtable).getSVGDocument(@ptrCast(*const IGetSVGDocument, self), ppSVGDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElement_Value = @import("../zig.zig").Guid.initString("30590000-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGElement = &IID_DispSVGElement_Value;
pub const DispSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IICCSVGColor_Value = @import("../zig.zig").Guid.initString("305104d6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IICCSVGColor = &IID_IICCSVGColor_Value;
pub const IICCSVGColor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPaint_Value = @import("../zig.zig").Guid.initString("30510524-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPaint = &IID_ISVGPaint_Value;
pub const ISVGPaint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPatternElement_Value = @import("../zig.zig").Guid.initString("3051052c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPatternElement = &IID_ISVGPatternElement_Value;
pub const ISVGPatternElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_patternUnits: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_patternUnits: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_patternContentUnits: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_patternContentUnits: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_patternTransform: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_patternTransform: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGPatternElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGPatternElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternUnits(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternUnits(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternContentUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternContentUnits(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternContentUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternContentUnits(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternTransform(self: *const T, v: ?*ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternTransform(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternTransform(self: *const T, p: ?*?*ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternTransform(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGPatternElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPatternElement_Value = @import("../zig.zig").Guid.initString("3059002c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPatternElement = &IID_DispSVGPatternElement_Value;
pub const DispSVGPatternElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSeg_Value = @import("../zig.zig").Guid.initString("305104fc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSeg = &IID_ISVGPathSeg_Value;
pub const ISVGPathSeg = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pathSegType: fn(
            self: *const ISVGPathSeg,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathSegType: fn(
            self: *const ISVGPathSeg,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathSegTypeAsLetter: fn(
            self: *const ISVGPathSeg,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_put_pathSegType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).put_pathSegType(@ptrCast(*const ISVGPathSeg, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_get_pathSegType(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).get_pathSegType(@ptrCast(*const ISVGPathSeg, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_get_pathSegTypeAsLetter(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).get_pathSegTypeAsLetter(@ptrCast(*const ISVGPathSeg, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("30510506-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegArcAbs = &IID_ISVGPathSegArcAbs_Value;
pub const ISVGPathSegArcAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_r1: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r1: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_r2: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r2: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_angle: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_angle: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_largeArcFlag: fn(
            self: *const ISVGPathSegArcAbs,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_largeArcFlag: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_sweepFlag: fn(
            self: *const ISVGPathSegArcAbs,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sweepFlag: fn(
            self: *const ISVGPathSegArcAbs,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_r1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_r1(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_r1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_r1(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_r2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_r2(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_r2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_r2(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_angle(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_angle(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_angle(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_largeArcFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_largeArcFlag(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_largeArcFlag(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_largeArcFlag(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_sweepFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_sweepFlag(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_sweepFlag(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_sweepFlag(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("30510507-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegArcRel = &IID_ISVGPathSegArcRel_Value;
pub const ISVGPathSegArcRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_r1: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r1: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_r2: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r2: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_angle: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_angle: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_largeArcFlag: fn(
            self: *const ISVGPathSegArcRel,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_largeArcFlag: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_sweepFlag: fn(
            self: *const ISVGPathSegArcRel,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sweepFlag: fn(
            self: *const ISVGPathSegArcRel,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_r1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_r1(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_r1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_r1(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_r2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_r2(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_r2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_r2(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_angle(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_angle(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_angle(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_largeArcFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_largeArcFlag(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_largeArcFlag(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_largeArcFlag(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_sweepFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_sweepFlag(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_sweepFlag(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_sweepFlag(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("305104fd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegClosePath = &IID_ISVGPathSegClosePath_Value;
pub const ISVGPathSegClosePath = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("305104fe-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegMovetoAbs = &IID_ISVGPathSegMovetoAbs_Value;
pub const ISVGPathSegMovetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegMovetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegMovetoAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegMovetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegMovetoAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegMovetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegMovetoAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegMovetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegMovetoAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("305104ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegMovetoRel = &IID_ISVGPathSegMovetoRel_Value;
pub const ISVGPathSegMovetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegMovetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegMovetoRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegMovetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegMovetoRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegMovetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegMovetoRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegMovetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegMovetoRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("30510500-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoAbs = &IID_ISVGPathSegLinetoAbs_Value;
pub const ISVGPathSegLinetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegLinetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegLinetoAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegLinetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegLinetoAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("30510501-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoRel = &IID_ISVGPathSegLinetoRel_Value;
pub const ISVGPathSegLinetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegLinetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegLinetoRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegLinetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegLinetoRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("30510502-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoCubicAbs = &IID_ISVGPathSegCurvetoCubicAbs_Value;
pub const ISVGPathSegCurvetoCubicAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("30510503-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoCubicRel = &IID_ISVGPathSegCurvetoCubicRel_Value;
pub const ISVGPathSegCurvetoCubicRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("3051050c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoCubicSmoothAbs = &IID_ISVGPathSegCurvetoCubicSmoothAbs_Value;
pub const ISVGPathSegCurvetoCubicSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_x2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_y2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("3051050d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoCubicSmoothRel = &IID_ISVGPathSegCurvetoCubicSmoothRel_Value;
pub const ISVGPathSegCurvetoCubicSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_x2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_y2(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("30510504-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoQuadraticAbs = &IID_ISVGPathSegCurvetoQuadraticAbs_Value;
pub const ISVGPathSegCurvetoQuadraticAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_x1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_y1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("30510505-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoQuadraticRel = &IID_ISVGPathSegCurvetoQuadraticRel_Value;
pub const ISVGPathSegCurvetoQuadraticRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_x1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_y1(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("3051050e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoQuadraticSmoothAbs = &IID_ISVGPathSegCurvetoQuadraticSmoothAbs_Value;
pub const ISVGPathSegCurvetoQuadraticSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("3051050f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegCurvetoQuadraticSmoothRel = &IID_ISVGPathSegCurvetoQuadraticSmoothRel_Value;
pub const ISVGPathSegCurvetoQuadraticSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("30510508-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoHorizontalAbs = &IID_ISVGPathSegLinetoHorizontalAbs_Value;
pub const ISVGPathSegLinetoHorizontalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegLinetoHorizontalAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegLinetoHorizontalAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoHorizontalAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalAbs_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoHorizontalAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("30510509-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoHorizontalRel = &IID_ISVGPathSegLinetoHorizontalRel_Value;
pub const ISVGPathSegLinetoHorizontalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPathSegLinetoHorizontalRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPathSegLinetoHorizontalRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoHorizontalRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalRel_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoHorizontalRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("3051050a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoVerticalAbs = &IID_ISVGPathSegLinetoVerticalAbs_Value;
pub const ISVGPathSegLinetoVerticalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegLinetoVerticalAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegLinetoVerticalAbs,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoVerticalAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalAbs_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoVerticalAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("3051050b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegLinetoVerticalRel = &IID_ISVGPathSegLinetoVerticalRel_Value;
pub const ISVGPathSegLinetoVerticalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPathSegLinetoVerticalRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPathSegLinetoVerticalRel,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoVerticalRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalRel_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoVerticalRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("30590013-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegArcAbs = &IID_DispSVGPathSegArcAbs_Value;
pub const DispSVGPathSegArcAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("30590014-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegArcRel = &IID_DispSVGPathSegArcRel_Value;
pub const DispSVGPathSegArcRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("30590015-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegClosePath = &IID_DispSVGPathSegClosePath_Value;
pub const DispSVGPathSegClosePath = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("30590024-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegMovetoAbs = &IID_DispSVGPathSegMovetoAbs_Value;
pub const DispSVGPathSegMovetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("30590025-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegMovetoRel = &IID_DispSVGPathSegMovetoRel_Value;
pub const DispSVGPathSegMovetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("3059001e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoAbs = &IID_DispSVGPathSegLinetoAbs_Value;
pub const DispSVGPathSegLinetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("30590021-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoRel = &IID_DispSVGPathSegLinetoRel_Value;
pub const DispSVGPathSegLinetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("30590016-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoCubicAbs = &IID_DispSVGPathSegCurvetoCubicAbs_Value;
pub const DispSVGPathSegCurvetoCubicAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("30590017-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoCubicRel = &IID_DispSVGPathSegCurvetoCubicRel_Value;
pub const DispSVGPathSegCurvetoCubicRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("30590018-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoCubicSmoothAbs = &IID_DispSVGPathSegCurvetoCubicSmoothAbs_Value;
pub const DispSVGPathSegCurvetoCubicSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("30590019-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoCubicSmoothRel = &IID_DispSVGPathSegCurvetoCubicSmoothRel_Value;
pub const DispSVGPathSegCurvetoCubicSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("3059001a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoQuadraticAbs = &IID_DispSVGPathSegCurvetoQuadraticAbs_Value;
pub const DispSVGPathSegCurvetoQuadraticAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("3059001b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoQuadraticRel = &IID_DispSVGPathSegCurvetoQuadraticRel_Value;
pub const DispSVGPathSegCurvetoQuadraticRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("3059001c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoQuadraticSmoothAbs = &IID_DispSVGPathSegCurvetoQuadraticSmoothAbs_Value;
pub const DispSVGPathSegCurvetoQuadraticSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("3059001d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegCurvetoQuadraticSmoothRel = &IID_DispSVGPathSegCurvetoQuadraticSmoothRel_Value;
pub const DispSVGPathSegCurvetoQuadraticSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("3059001f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoHorizontalAbs = &IID_DispSVGPathSegLinetoHorizontalAbs_Value;
pub const DispSVGPathSegLinetoHorizontalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("30590020-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoHorizontalRel = &IID_DispSVGPathSegLinetoHorizontalRel_Value;
pub const DispSVGPathSegLinetoHorizontalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("30590022-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoVerticalAbs = &IID_DispSVGPathSegLinetoVerticalAbs_Value;
pub const DispSVGPathSegLinetoVerticalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("30590023-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathSegLinetoVerticalRel = &IID_DispSVGPathSegLinetoVerticalRel_Value;
pub const DispSVGPathSegLinetoVerticalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegList_Value = @import("../zig.zig").Guid.initString("30510510-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathSegList = &IID_ISVGPathSegList_Value;
pub const ISVGPathSegList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGPathSegList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGPathSegList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGPathSegList,
            newItem: ?*ISVGPathSeg,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGPathSegList,
            index: i32,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGPathSegList,
            newItem: ?*ISVGPathSeg,
            index: i32,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGPathSegList,
            newItem: ?*ISVGPathSeg,
            index: i32,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGPathSegList,
            index: i32,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGPathSegList,
            newItem: ?*ISVGPathSeg,
            ppResult: ?*?*ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGPathSegList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGPathSegList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).clear(@ptrCast(*const ISVGPathSegList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_initialize(self: *const T, newItem: ?*ISVGPathSeg, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).initialize(@ptrCast(*const ISVGPathSegList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_getItem(self: *const T, index: i32, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).getItem(@ptrCast(*const ISVGPathSegList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_insertItemBefore(self: *const T, newItem: ?*ISVGPathSeg, index: i32, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGPathSegList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_replaceItem(self: *const T, newItem: ?*ISVGPathSeg, index: i32, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGPathSegList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_removeItem(self: *const T, index: i32, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGPathSegList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_appendItem(self: *const T, newItem: ?*ISVGPathSeg, ppResult: ?*?*ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGPathSegList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPoint_Value = @import("../zig.zig").Guid.initString("305104f4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPoint = &IID_ISVGPoint_Value;
pub const ISVGPoint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_x: fn(
            self: *const ISVGPoint,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGPoint,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_y: fn(
            self: *const ISVGPoint,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGPoint,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        matrixTransform: fn(
            self: *const ISVGPoint,
            pMatrix: ?*ISVGMatrix,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).put_x(@ptrCast(*const ISVGPoint, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_get_x(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).get_x(@ptrCast(*const ISVGPoint, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).put_y(@ptrCast(*const ISVGPoint, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_get_y(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).get_y(@ptrCast(*const ISVGPoint, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_matrixTransform(self: *const T, pMatrix: ?*ISVGMatrix, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).matrixTransform(@ptrCast(*const ISVGPoint, self), pMatrix, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPointList_Value = @import("../zig.zig").Guid.initString("305104f5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPointList = &IID_ISVGPointList_Value;
pub const ISVGPointList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_numberOfItems: fn(
            self: *const ISVGPointList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_numberOfItems: fn(
            self: *const ISVGPointList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGPointList,
            pNewItem: ?*ISVGPoint,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGPointList,
            index: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGPointList,
            pNewItem: ?*ISVGPoint,
            index: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGPointList,
            pNewItem: ?*ISVGPoint,
            index: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGPointList,
            index: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGPointList,
            pNewItem: ?*ISVGPoint,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGPointList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_get_numberOfItems(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGPointList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).clear(@ptrCast(*const ISVGPointList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_initialize(self: *const T, pNewItem: ?*ISVGPoint, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).initialize(@ptrCast(*const ISVGPointList, self), pNewItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_getItem(self: *const T, index: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).getItem(@ptrCast(*const ISVGPointList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_insertItemBefore(self: *const T, pNewItem: ?*ISVGPoint, index: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGPointList, self), pNewItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_replaceItem(self: *const T, pNewItem: ?*ISVGPoint, index: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGPointList, self), pNewItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_removeItem(self: *const T, index: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGPointList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_appendItem(self: *const T, pNewItem: ?*ISVGPoint, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGPointList, self), pNewItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGViewSpec_Value = @import("../zig.zig").Guid.initString("305104e2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGViewSpec = &IID_ISVGViewSpec_Value;
pub const ISVGViewSpec = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransform_Value = @import("../zig.zig").Guid.initString("305104f7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTransform = &IID_ISVGTransform_Value;
pub const ISVGTransform = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const ISVGTransform,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const ISVGTransform,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_matrix: fn(
            self: *const ISVGTransform,
            v: ?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_matrix: fn(
            self: *const ISVGTransform,
            p: ?*?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_angle: fn(
            self: *const ISVGTransform,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_angle: fn(
            self: *const ISVGTransform,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setMatrix: fn(
            self: *const ISVGTransform,
            matrix: ?*ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTranslate: fn(
            self: *const ISVGTransform,
            tx: f32,
            ty: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setScale: fn(
            self: *const ISVGTransform,
            sx: f32,
            sy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRotate: fn(
            self: *const ISVGTransform,
            angle: f32,
            cx: f32,
            cy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSkewX: fn(
            self: *const ISVGTransform,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSkewY: fn(
            self: *const ISVGTransform,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_put_type(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).put_type(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_type(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_type(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_putref_matrix(self: *const T, v: ?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).putref_matrix(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_matrix(self: *const T, p: ?*?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_matrix(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).put_angle(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_angle(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_angle(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setMatrix(self: *const T, matrix: ?*ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setMatrix(@ptrCast(*const ISVGTransform, self), matrix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setTranslate(self: *const T, tx: f32, ty: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setTranslate(@ptrCast(*const ISVGTransform, self), tx, ty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setScale(self: *const T, sx: f32, sy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setScale(@ptrCast(*const ISVGTransform, self), sx, sy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setRotate(self: *const T, angle: f32, cx: f32, cy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setRotate(@ptrCast(*const ISVGTransform, self), angle, cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setSkewX(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setSkewX(@ptrCast(*const ISVGTransform, self), angle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setSkewY(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setSkewY(@ptrCast(*const ISVGTransform, self), angle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSVGElement_Value = @import("../zig.zig").Guid.initString("30590001-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGSVGElement = &IID_DispSVGSVGElement_Value;
pub const DispSVGSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElementInstance_Value = @import("../zig.zig").Guid.initString("305104ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGElementInstance = &IID_ISVGElementInstance_Value;
pub const ISVGElementInstance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_correspondingElement: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_correspondingUseElement: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGUseElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentNode: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstanceList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousSibling: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextSibling: fn(
            self: *const ISVGElementInstance,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_correspondingElement(self: *const T, p: ?*?*ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_correspondingElement(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_correspondingUseElement(self: *const T, p: ?*?*ISVGUseElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_correspondingUseElement(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_parentNode(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_parentNode(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_childNodes(self: *const T, p: ?*?*ISVGElementInstanceList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_childNodes(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_firstChild(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_firstChild(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_lastChild(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_lastChild(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_previousSibling(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_previousSibling(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_nextSibling(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_nextSibling(@ptrCast(*const ISVGElementInstance, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGUseElement_Value = @import("../zig.zig").Guid.initString("305104ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGUseElement = &IID_ISVGUseElement_Value;
pub const ISVGUseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_instanceRoot: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_instanceRoot: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedInstanceRoot: fn(
            self: *const ISVGUseElement,
            v: ?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animatedInstanceRoot: fn(
            self: *const ISVGUseElement,
            p: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_instanceRoot(self: *const T, v: ?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_instanceRoot(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_instanceRoot(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_instanceRoot(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_animatedInstanceRoot(self: *const T, v: ?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_animatedInstanceRoot(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_animatedInstanceRoot(self: *const T, p: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_animatedInstanceRoot(@ptrCast(*const ISVGUseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGUseElement_Value = @import("../zig.zig").Guid.initString("30590010-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGUseElement = &IID_DispSVGUseElement_Value;
pub const DispSVGUseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("305104c0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLStyleSheetRulesAppliedCollection = &IID_IHTMLStyleSheetRulesAppliedCollection_Value;
pub const IHTMLStyleSheetRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            index: i32,
            ppHTMLStyleSheetRule: ?*?*IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedBy: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: ?BSTR,
            ppRule: ?*?*IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedTrace: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: ?BSTR,
            index: i32,
            ppRule: ?*?*IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedTraceLength: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: ?BSTR,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_item(self: *const T, index: i32, ppHTMLStyleSheetRule: ?*?*IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), index, ppHTMLStyleSheetRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedBy(self: *const T, name: ?BSTR, ppRule: ?*?*IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedBy(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, ppRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedTrace(self: *const T, name: ?BSTR, index: i32, ppRule: ?*?*IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedTrace(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, index, ppRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedTraceLength(self: *const T, name: ?BSTR, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedTraceLength(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, pLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRulesApplied_Value = @import("../zig.zig").Guid.initString("305104bf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IRulesApplied = &IID_IRulesApplied_Value;
pub const IRulesApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_element: fn(
            self: *const IRulesApplied,
            p: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inlineStyles: fn(
            self: *const IRulesApplied,
            p: ?*?*IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_appliedRules: fn(
            self: *const IRulesApplied,
            p: ?*?*IHTMLStyleSheetRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyIsInline: fn(
            self: *const IRulesApplied,
            name: ?BSTR,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyIsInheritable: fn(
            self: *const IRulesApplied,
            name: ?BSTR,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasInheritableProperty: fn(
            self: *const IRulesApplied,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_element(self: *const T, p: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_element(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_inlineStyles(self: *const T, p: ?*?*IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_inlineStyles(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_appliedRules(self: *const T, p: ?*?*IHTMLStyleSheetRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_appliedRules(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_propertyIsInline(self: *const T, name: ?BSTR, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).propertyIsInline(@ptrCast(*const IRulesApplied, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_propertyIsInheritable(self: *const T, name: ?BSTR, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).propertyIsInheritable(@ptrCast(*const IRulesApplied, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_hasInheritableProperty(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).hasInheritableProperty(@ptrCast(*const IRulesApplied, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("3050f5a6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLStyleSheetRulesAppliedCollection = &IID_DispHTMLStyleSheetRulesAppliedCollection_Value;
pub const DispHTMLStyleSheetRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRulesApplied_Value = @import("../zig.zig").Guid.initString("3050f5a5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispRulesApplied = &IID_DispRulesApplied_Value;
pub const DispRulesApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("3050f5a4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispRulesAppliedCollection = &IID_DispRulesAppliedCollection_Value;
pub const DispRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLW3CComputedStyle_Value = @import("../zig.zig").Guid.initString("30590070-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLW3CComputedStyle = &IID_DispHTMLW3CComputedStyle_Value;
pub const DispHTMLW3CComputedStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPoints_Value = @import("../zig.zig").Guid.initString("30510517-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedPoints = &IID_ISVGAnimatedPoints_Value;
pub const ISVGAnimatedPoints = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_points: fn(
            self: *const ISVGAnimatedPoints,
            v: ?*ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_points: fn(
            self: *const ISVGAnimatedPoints,
            p: ?*?*ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedPoints: fn(
            self: *const ISVGAnimatedPoints,
            v: ?*ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animatedPoints: fn(
            self: *const ISVGAnimatedPoints,
            p: ?*?*ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_putref_points(self: *const T, v: ?*ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).putref_points(@ptrCast(*const ISVGAnimatedPoints, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_get_points(self: *const T, p: ?*?*ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).get_points(@ptrCast(*const ISVGAnimatedPoints, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_putref_animatedPoints(self: *const T, v: ?*ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).putref_animatedPoints(@ptrCast(*const ISVGAnimatedPoints, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_get_animatedPoints(self: *const T, p: ?*?*ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).get_animatedPoints(@ptrCast(*const ISVGAnimatedPoints, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGCircleElement_Value = @import("../zig.zig").Guid.initString("30510514-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGCircleElement = &IID_ISVGCircleElement_Value;
pub const ISVGCircleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGCircleElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cx: fn(
            self: *const ISVGCircleElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGCircleElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cy: fn(
            self: *const ISVGCircleElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_r: fn(
            self: *const ISVGCircleElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r: fn(
            self: *const ISVGCircleElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_cx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_cx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGCircleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_cy(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_cy(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGCircleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_r(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_r(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_r(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_r(@ptrCast(*const ISVGCircleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGEllipseElement_Value = @import("../zig.zig").Guid.initString("30510515-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGEllipseElement = &IID_ISVGEllipseElement_Value;
pub const ISVGEllipseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGEllipseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cx: fn(
            self: *const ISVGEllipseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGEllipseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cy: fn(
            self: *const ISVGEllipseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rx: fn(
            self: *const ISVGEllipseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rx: fn(
            self: *const ISVGEllipseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ry: fn(
            self: *const ISVGEllipseElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ry: fn(
            self: *const ISVGEllipseElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_cx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_cx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_cy(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_cy(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_rx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_rx(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_rx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_rx(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_ry(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_ry(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_ry(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_ry(@ptrCast(*const ISVGEllipseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLineElement_Value = @import("../zig.zig").Guid.initString("30510516-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLineElement = &IID_ISVGLineElement_Value;
pub const ISVGLineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x1: fn(
            self: *const ISVGLineElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGLineElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y1: fn(
            self: *const ISVGLineElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGLineElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x2: fn(
            self: *const ISVGLineElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGLineElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y2: fn(
            self: *const ISVGLineElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGLineElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_x1(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_x1(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_x1(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_x1(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_y1(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_y1(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_y1(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_y1(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_x2(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_x2(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_x2(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_x2(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_y2(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_y2(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_y2(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_y2(@ptrCast(*const ISVGLineElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRectElement_Value = @import("../zig.zig").Guid.initString("30510513-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGRectElement = &IID_ISVGRectElement_Value;
pub const ISVGRectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rx: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rx: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ry: fn(
            self: *const ISVGRectElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ry: fn(
            self: *const ISVGRectElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_rx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_rx(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_rx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_rx(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_ry(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_ry(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_ry(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_ry(@ptrCast(*const ISVGRectElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPolygonElement_Value = @import("../zig.zig").Guid.initString("30510519-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPolygonElement = &IID_ISVGPolygonElement_Value;
pub const ISVGPolygonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPolylineElement_Value = @import("../zig.zig").Guid.initString("30510518-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPolylineElement = &IID_ISVGPolylineElement_Value;
pub const ISVGPolylineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGCircleElement_Value = @import("../zig.zig").Guid.initString("3059000a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGCircleElement = &IID_DispSVGCircleElement_Value;
pub const DispSVGCircleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGEllipseElement_Value = @import("../zig.zig").Guid.initString("3059000b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGEllipseElement = &IID_DispSVGEllipseElement_Value;
pub const DispSVGEllipseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGLineElement_Value = @import("../zig.zig").Guid.initString("3059000c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGLineElement = &IID_DispSVGLineElement_Value;
pub const DispSVGLineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGRectElement_Value = @import("../zig.zig").Guid.initString("30590009-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGRectElement = &IID_DispSVGRectElement_Value;
pub const DispSVGRectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPolygonElement_Value = @import("../zig.zig").Guid.initString("3059000d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPolygonElement = &IID_DispSVGPolygonElement_Value;
pub const DispSVGPolygonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPolylineElement_Value = @import("../zig.zig").Guid.initString("3059000e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPolylineElement = &IID_DispSVGPolylineElement_Value;
pub const DispSVGPolylineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGGElement_Value = @import("../zig.zig").Guid.initString("305104e8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGGElement = &IID_ISVGGElement_Value;
pub const ISVGGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGGElement_Value = @import("../zig.zig").Guid.initString("30590002-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGGElement = &IID_DispSVGGElement_Value;
pub const DispSVGGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSymbolElement_Value = @import("../zig.zig").Guid.initString("305104ec-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGSymbolElement = &IID_ISVGSymbolElement_Value;
pub const ISVGSymbolElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSymbolElement_Value = @import("../zig.zig").Guid.initString("30590004-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGSymbolElement = &IID_DispSVGSymbolElement_Value;
pub const DispSVGSymbolElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDefsElement_Value = @import("../zig.zig").Guid.initString("305104e9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGDefsElement = &IID_ISVGDefsElement_Value;
pub const ISVGDefsElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGDefsElement_Value = @import("../zig.zig").Guid.initString("30590003-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGDefsElement = &IID_DispSVGDefsElement_Value;
pub const DispSVGDefsElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPathData_Value = @import("../zig.zig").Guid.initString("30510511-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAnimatedPathData = &IID_ISVGAnimatedPathData_Value;
pub const ISVGAnimatedPathData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_pathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: ?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: ?*?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_normalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: ?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_normalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: ?*?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: ?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animatedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: ?*?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedNormalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: ?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animatedNormalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: ?*?*ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_pathSegList(self: *const T, v: ?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_pathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_pathSegList(self: *const T, p: ?*?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_pathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_normalizedPathSegList(self: *const T, v: ?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_normalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_normalizedPathSegList(self: *const T, p: ?*?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_normalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_animatedPathSegList(self: *const T, v: ?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_animatedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_animatedPathSegList(self: *const T, p: ?*?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_animatedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_animatedNormalizedPathSegList(self: *const T, v: ?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_animatedNormalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_animatedNormalizedPathSegList(self: *const T, p: ?*?*ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_animatedNormalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathElement_Value = @import("../zig.zig").Guid.initString("30510512-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPathElement = &IID_ISVGPathElement_Value;
pub const ISVGPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_pathLength: fn(
            self: *const ISVGPathElement,
            v: ?*ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pathLength: fn(
            self: *const ISVGPathElement,
            p: ?*?*ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTotalLength: fn(
            self: *const ISVGPathElement,
            pfltResult: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPointAtLength: fn(
            self: *const ISVGPathElement,
            fltdistance: f32,
            ppPointResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPathSegAtLength: fn(
            self: *const ISVGPathElement,
            fltdistance: f32,
            plResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegClosePath: fn(
            self: *const ISVGPathElement,
            ppResult: ?*?*ISVGPathSegClosePath,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegMovetoAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegMovetoAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegMovetoRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegMovetoRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegLinetoAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegLinetoRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            ppResult: ?*?*ISVGPathSegCurvetoCubicAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            ppResult: ?*?*ISVGPathSegCurvetoCubicRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            ppResult: ?*?*ISVGPathSegCurvetoQuadraticAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            ppResult: ?*?*ISVGPathSegCurvetoQuadraticRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegArcAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            r1: f32,
            r2: f32,
            angle: f32,
            largeArcFlag: i16,
            sweepFlag: i16,
            ppResult: ?*?*ISVGPathSegArcAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegArcRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            r1: f32,
            r2: f32,
            angle: f32,
            largeArcFlag: i16,
            sweepFlag: i16,
            ppResult: ?*?*ISVGPathSegArcRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoHorizontalAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            ppResult: ?*?*ISVGPathSegLinetoHorizontalAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoHorizontalRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            ppResult: ?*?*ISVGPathSegLinetoHorizontalRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoVerticalAbs: fn(
            self: *const ISVGPathElement,
            y: f32,
            ppResult: ?*?*ISVGPathSegLinetoVerticalAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoVerticalRel: fn(
            self: *const ISVGPathElement,
            y: f32,
            ppResult: ?*?*ISVGPathSegLinetoVerticalRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicSmoothAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x2: f32,
            y2: f32,
            ppResult: ?*?*ISVGPathSegCurvetoCubicSmoothAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicSmoothRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x2: f32,
            y2: f32,
            ppResult: ?*?*ISVGPathSegCurvetoCubicSmoothRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticSmoothAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegCurvetoQuadraticSmoothAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticSmoothRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: ?*?*ISVGPathSegCurvetoQuadraticSmoothRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_putref_pathLength(self: *const T, v: ?*ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).putref_pathLength(@ptrCast(*const ISVGPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_get_pathLength(self: *const T, p: ?*?*ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).get_pathLength(@ptrCast(*const ISVGPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getTotalLength(self: *const T, pfltResult: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getTotalLength(@ptrCast(*const ISVGPathElement, self), pfltResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getPointAtLength(self: *const T, fltdistance: f32, ppPointResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getPointAtLength(@ptrCast(*const ISVGPathElement, self), fltdistance, ppPointResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getPathSegAtLength(self: *const T, fltdistance: f32, plResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getPathSegAtLength(@ptrCast(*const ISVGPathElement, self), fltdistance, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegClosePath(self: *const T, ppResult: ?*?*ISVGPathSegClosePath) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegClosePath(@ptrCast(*const ISVGPathElement, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegMovetoAbs(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegMovetoAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegMovetoAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegMovetoRel(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegMovetoRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegMovetoRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoAbs(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegLinetoAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoRel(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegLinetoRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicAbs(self: *const T, x: f32, y: f32, x1: f32, y1: f32, x2: f32, y2: f32, ppResult: ?*?*ISVGPathSegCurvetoCubicAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicAbs(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicRel(self: *const T, x: f32, y: f32, x1: f32, y1: f32, x2: f32, y2: f32, ppResult: ?*?*ISVGPathSegCurvetoCubicRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicRel(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticAbs(self: *const T, x: f32, y: f32, x1: f32, y1: f32, ppResult: ?*?*ISVGPathSegCurvetoQuadraticAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticAbs(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticRel(self: *const T, x: f32, y: f32, x1: f32, y1: f32, ppResult: ?*?*ISVGPathSegCurvetoQuadraticRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticRel(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegArcAbs(self: *const T, x: f32, y: f32, r1: f32, r2: f32, angle: f32, largeArcFlag: i16, sweepFlag: i16, ppResult: ?*?*ISVGPathSegArcAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegArcAbs(@ptrCast(*const ISVGPathElement, self), x, y, r1, r2, angle, largeArcFlag, sweepFlag, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegArcRel(self: *const T, x: f32, y: f32, r1: f32, r2: f32, angle: f32, largeArcFlag: i16, sweepFlag: i16, ppResult: ?*?*ISVGPathSegArcRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegArcRel(@ptrCast(*const ISVGPathElement, self), x, y, r1, r2, angle, largeArcFlag, sweepFlag, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoHorizontalAbs(self: *const T, x: f32, ppResult: ?*?*ISVGPathSegLinetoHorizontalAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoHorizontalAbs(@ptrCast(*const ISVGPathElement, self), x, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoHorizontalRel(self: *const T, x: f32, ppResult: ?*?*ISVGPathSegLinetoHorizontalRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoHorizontalRel(@ptrCast(*const ISVGPathElement, self), x, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoVerticalAbs(self: *const T, y: f32, ppResult: ?*?*ISVGPathSegLinetoVerticalAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoVerticalAbs(@ptrCast(*const ISVGPathElement, self), y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoVerticalRel(self: *const T, y: f32, ppResult: ?*?*ISVGPathSegLinetoVerticalRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoVerticalRel(@ptrCast(*const ISVGPathElement, self), y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicSmoothAbs(self: *const T, x: f32, y: f32, x2: f32, y2: f32, ppResult: ?*?*ISVGPathSegCurvetoCubicSmoothAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicSmoothAbs(@ptrCast(*const ISVGPathElement, self), x, y, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicSmoothRel(self: *const T, x: f32, y: f32, x2: f32, y2: f32, ppResult: ?*?*ISVGPathSegCurvetoCubicSmoothRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicSmoothRel(@ptrCast(*const ISVGPathElement, self), x, y, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticSmoothAbs(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegCurvetoQuadraticSmoothAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticSmoothAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticSmoothRel(self: *const T, x: f32, y: f32, ppResult: ?*?*ISVGPathSegCurvetoQuadraticSmoothRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticSmoothRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathElement_Value = @import("../zig.zig").Guid.initString("30590011-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGPathElement = &IID_DispSVGPathElement_Value;
pub const DispSVGPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305104fa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGPreserveAspectRatio = &IID_ISVGPreserveAspectRatio_Value;
pub const ISVGPreserveAspectRatio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_align: fn(
            self: *const ISVGPreserveAspectRatio,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_align: fn(
            self: *const ISVGPreserveAspectRatio,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_meetOrSlice: fn(
            self: *const ISVGPreserveAspectRatio,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_meetOrSlice: fn(
            self: *const ISVGPreserveAspectRatio,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_put_align(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).put_align(@ptrCast(*const ISVGPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_get_align(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).get_align(@ptrCast(*const ISVGPreserveAspectRatio, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_put_meetOrSlice(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).put_meetOrSlice(@ptrCast(*const ISVGPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_get_meetOrSlice(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).get_meetOrSlice(@ptrCast(*const ISVGPreserveAspectRatio, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextElement_Value = @import("../zig.zig").Guid.initString("3051051c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTextElement = &IID_ISVGTextElement_Value;
pub const ISVGTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextElement_Value = @import("../zig.zig").Guid.initString("30590037-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTextElement = &IID_DispSVGTextElement_Value;
pub const DispSVGTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGImageElement_Value = @import("../zig.zig").Guid.initString("305104f0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGImageElement = &IID_ISVGImageElement_Value;
pub const ISVGImageElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGImageElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGImageElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGImageElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGImageElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGImageElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGImageElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGImageElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGImageElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGImageElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGImageElement_Value = @import("../zig.zig").Guid.initString("30590027-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGImageElement = &IID_DispSVGImageElement_Value;
pub const DispSVGImageElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStopElement_Value = @import("../zig.zig").Guid.initString("3051052b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGStopElement = &IID_ISVGStopElement_Value;
pub const ISVGStopElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_offset: fn(
            self: *const ISVGStopElement,
            v: ?*ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_offset: fn(
            self: *const ISVGStopElement,
            p: ?*?*ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStopElement_putref_offset(self: *const T, v: ?*ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStopElement.VTable, self.vtable).putref_offset(@ptrCast(*const ISVGStopElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStopElement_get_offset(self: *const T, p: ?*?*ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStopElement.VTable, self.vtable).get_offset(@ptrCast(*const ISVGStopElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGStopElement_Value = @import("../zig.zig").Guid.initString("3059002d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGStopElement = &IID_DispSVGStopElement_Value;
pub const DispSVGStopElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGGradientElement_Value = @import("../zig.zig").Guid.initString("30510528-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGGradientElement = &IID_ISVGGradientElement_Value;
pub const ISVGGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_gradientUnits: fn(
            self: *const ISVGGradientElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_gradientUnits: fn(
            self: *const ISVGGradientElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_gradientTransform: fn(
            self: *const ISVGGradientElement,
            v: ?*ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_gradientTransform: fn(
            self: *const ISVGGradientElement,
            p: ?*?*ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_spreadMethod: fn(
            self: *const ISVGGradientElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_spreadMethod: fn(
            self: *const ISVGGradientElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_gradientUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_gradientUnits(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_gradientUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_gradientUnits(@ptrCast(*const ISVGGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_gradientTransform(self: *const T, v: ?*ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_gradientTransform(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_gradientTransform(self: *const T, p: ?*?*ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_gradientTransform(@ptrCast(*const ISVGGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_spreadMethod(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_spreadMethod(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_spreadMethod(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_spreadMethod(@ptrCast(*const ISVGGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGGradientElement_Value = @import("../zig.zig").Guid.initString("3059002e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGGradientElement = &IID_DispSVGGradientElement_Value;
pub const DispSVGGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("30510529-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGLinearGradientElement = &IID_ISVGLinearGradientElement_Value;
pub const ISVGLinearGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x1: fn(
            self: *const ISVGLinearGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x1: fn(
            self: *const ISVGLinearGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y1: fn(
            self: *const ISVGLinearGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y1: fn(
            self: *const ISVGLinearGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x2: fn(
            self: *const ISVGLinearGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x2: fn(
            self: *const ISVGLinearGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y2: fn(
            self: *const ISVGLinearGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y2: fn(
            self: *const ISVGLinearGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_x1(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_x1(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_x1(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_x1(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_y1(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_y1(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_y1(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_y1(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_x2(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_x2(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_x2(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_x2(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_y2(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_y2(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_y2(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_y2(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("3059002a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGLinearGradientElement = &IID_DispSVGLinearGradientElement_Value;
pub const DispSVGLinearGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("3051052a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGRadialGradientElement = &IID_ISVGRadialGradientElement_Value;
pub const ISVGRadialGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGRadialGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cx: fn(
            self: *const ISVGRadialGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGRadialGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cy: fn(
            self: *const ISVGRadialGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_r: fn(
            self: *const ISVGRadialGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_r: fn(
            self: *const ISVGRadialGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fx: fn(
            self: *const ISVGRadialGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fx: fn(
            self: *const ISVGRadialGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fy: fn(
            self: *const ISVGRadialGradientElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fy: fn(
            self: *const ISVGRadialGradientElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_cx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_cx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_cy(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_cy(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_r(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_r(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_r(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_r(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_fx(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_fx(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_fx(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_fx(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_fy(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_fy(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_fy(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_fy(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("3059002b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGRadialGradientElement = &IID_DispSVGRadialGradientElement_Value;
pub const DispSVGRadialGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMaskElement_Value = @import("../zig.zig").Guid.initString("3051052e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGMaskElement = &IID_ISVGMaskElement_Value;
pub const ISVGMaskElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_maskUnits: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maskUnits: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_maskContentUnits: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maskContentUnits: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGMaskElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const ISVGMaskElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_maskUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_maskUnits(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_maskUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_maskUnits(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_maskContentUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_maskContentUnits(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_maskContentUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_maskContentUnits(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_x(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_y(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_width(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_width(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_height(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_height(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGMaskElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMaskElement_Value = @import("../zig.zig").Guid.initString("3059003c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGMaskElement = &IID_DispSVGMaskElement_Value;
pub const DispSVGMaskElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMarkerElement_Value = @import("../zig.zig").Guid.initString("30510525-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGMarkerElement = &IID_ISVGMarkerElement_Value;
pub const ISVGMarkerElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_refX: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_refX: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_refY: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_refY: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerUnits: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerUnits: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerWidth: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerWidth: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerHeight: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerHeight: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_orientType: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orientType: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_orientAngle: fn(
            self: *const ISVGMarkerElement,
            v: ?*ISVGAnimatedAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orientAngle: fn(
            self: *const ISVGMarkerElement,
            p: ?*?*ISVGAnimatedAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setOrientToAuto: fn(
            self: *const ISVGMarkerElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setOrientToAngle: fn(
            self: *const ISVGMarkerElement,
            pSVGAngle: ?*ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_refX(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_refX(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_refX(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_refX(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_refY(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_refY(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_refY(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_refY(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerUnits(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerUnits(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerUnits(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerUnits(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerWidth(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerWidth(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerWidth(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerWidth(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerHeight(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerHeight(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerHeight(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerHeight(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_orientType(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_orientType(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_orientType(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_orientType(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_orientAngle(self: *const T, v: ?*ISVGAnimatedAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_orientAngle(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_orientAngle(self: *const T, p: ?*?*ISVGAnimatedAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_orientAngle(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_setOrientToAuto(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).setOrientToAuto(@ptrCast(*const ISVGMarkerElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_setOrientToAngle(self: *const T, pSVGAngle: ?*ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).setOrientToAngle(@ptrCast(*const ISVGMarkerElement, self), pSVGAngle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMarkerElement_Value = @import("../zig.zig").Guid.initString("30590036-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGMarkerElement = &IID_DispSVGMarkerElement_Value;
pub const DispSVGMarkerElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGZoomEvent_Value = @import("../zig.zig").Guid.initString("3051054e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGZoomEvent = &IID_ISVGZoomEvent_Value;
pub const ISVGZoomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_zoomRectScreen: fn(
            self: *const ISVGZoomEvent,
            p: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousScale: fn(
            self: *const ISVGZoomEvent,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousTranslate: fn(
            self: *const ISVGZoomEvent,
            p: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_newScale: fn(
            self: *const ISVGZoomEvent,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_newTranslate: fn(
            self: *const ISVGZoomEvent,
            p: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_zoomRectScreen(self: *const T, p: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_zoomRectScreen(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_previousScale(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_previousScale(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_previousTranslate(self: *const T, p: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_previousTranslate(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_newScale(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_newScale(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_newTranslate(self: *const T, p: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_newTranslate(@ptrCast(*const ISVGZoomEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGZoomEvent_Value = @import("../zig.zig").Guid.initString("30590031-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGZoomEvent = &IID_DispSVGZoomEvent_Value;
pub const DispSVGZoomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAElement_Value = @import("../zig.zig").Guid.initString("3051054b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGAElement = &IID_ISVGAElement_Value;
pub const ISVGAElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_target: fn(
            self: *const ISVGAElement,
            v: ?*ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const ISVGAElement,
            p: ?*?*ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAElement_putref_target(self: *const T, v: ?*ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAElement.VTable, self.vtable).putref_target(@ptrCast(*const ISVGAElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAElement_get_target(self: *const T, p: ?*?*ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAElement.VTable, self.vtable).get_target(@ptrCast(*const ISVGAElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGAElement_Value = @import("../zig.zig").Guid.initString("30590033-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGAElement = &IID_DispSVGAElement_Value;
pub const DispSVGAElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGViewElement_Value = @import("../zig.zig").Guid.initString("3051054c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGViewElement = &IID_ISVGViewElement_Value;
pub const ISVGViewElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_viewTarget: fn(
            self: *const ISVGViewElement,
            v: ?*ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_viewTarget: fn(
            self: *const ISVGViewElement,
            p: ?*?*ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGViewElement_putref_viewTarget(self: *const T, v: ?*ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGViewElement.VTable, self.vtable).putref_viewTarget(@ptrCast(*const ISVGViewElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGViewElement_get_viewTarget(self: *const T, p: ?*?*ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGViewElement.VTable, self.vtable).get_viewTarget(@ptrCast(*const ISVGViewElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGViewElement_Value = @import("../zig.zig").Guid.initString("30590034-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGViewElement = &IID_DispSVGViewElement_Value;
pub const DispSVGViewElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaError_Value = @import("../zig.zig").Guid.initString("30510704-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMediaError = &IID_IHTMLMediaError_Value;
pub const IHTMLMediaError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IHTMLMediaError,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaError_get_code(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaError.VTable, self.vtable).get_code(@ptrCast(*const IHTMLMediaError, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("30510705-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTimeRanges = &IID_IHTMLTimeRanges_Value;
pub const IHTMLTimeRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLTimeRanges,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        start: fn(
            self: *const IHTMLTimeRanges,
            index: i32,
            startTime: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        end: fn(
            self: *const IHTMLTimeRanges,
            index: i32,
            endTime: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).get_length(@ptrCast(*const IHTMLTimeRanges, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_start(self: *const T, index: i32, startTime: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).start(@ptrCast(*const IHTMLTimeRanges, self), index, startTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_end(self: *const T, index: i32, endTime: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).end(@ptrCast(*const IHTMLTimeRanges, self), index, endTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTimeRanges2_Value = @import("../zig.zig").Guid.initString("3051080b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLTimeRanges2 = &IID_IHTMLTimeRanges2_Value;
pub const IHTMLTimeRanges2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDouble: fn(
            self: *const IHTMLTimeRanges2,
            index: i32,
            startTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDouble: fn(
            self: *const IHTMLTimeRanges2,
            index: i32,
            endTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges2_startDouble(self: *const T, index: i32, startTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges2.VTable, self.vtable).startDouble(@ptrCast(*const IHTMLTimeRanges2, self), index, startTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges2_endDouble(self: *const T, index: i32, endTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges2.VTable, self.vtable).endDouble(@ptrCast(*const IHTMLTimeRanges2, self), index, endTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaElement_Value = @import("../zig.zig").Guid.initString("30510706-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMediaElement = &IID_IHTMLMediaElement_Value;
pub const IHTMLMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_error: fn(
            self: *const IHTMLMediaElement,
            p: ?*?*IHTMLMediaError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLMediaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLMediaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentSrc: fn(
            self: *const IHTMLMediaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_networkState: fn(
            self: *const IHTMLMediaElement,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_preload: fn(
            self: *const IHTMLMediaElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_preload: fn(
            self: *const IHTMLMediaElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_buffered: fn(
            self: *const IHTMLMediaElement,
            p: ?*?*IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        load: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canPlayType: fn(
            self: *const IHTMLMediaElement,
            type: ?BSTR,
            canPlay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_seeking: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentTime: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentTime: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_initialTime: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_duration: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_paused: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultPlaybackRate: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultPlaybackRate: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_playbackRate: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playbackRate: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_played: fn(
            self: *const IHTMLMediaElement,
            p: ?*?*IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_seekable: fn(
            self: *const IHTMLMediaElement,
            p: ?*?*IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ended: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_autoplay: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_autoplay: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_loop: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loop: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        play: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pause: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_controls: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_controls: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_volume: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_volume: fn(
            self: *const IHTMLMediaElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_muted: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_muted: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_autobuffer: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_autobuffer: fn(
            self: *const IHTMLMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_error(self: *const T, p: ?*?*IHTMLMediaError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_error(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_currentSrc(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_currentSrc(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_networkState(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_networkState(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_preload(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_preload(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_preload(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_preload(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_buffered(self: *const T, p: ?*?*IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_buffered(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_load(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).load(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_canPlayType(self: *const T, type_: ?BSTR, canPlay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).canPlayType(@ptrCast(*const IHTMLMediaElement, self), type_, canPlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_seeking(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_seeking(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_currentTime(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_currentTime(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_currentTime(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_currentTime(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_initialTime(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_initialTime(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_duration(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_duration(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_paused(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_paused(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_defaultPlaybackRate(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_defaultPlaybackRate(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_defaultPlaybackRate(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_defaultPlaybackRate(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_playbackRate(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_playbackRate(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_playbackRate(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_playbackRate(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_played(self: *const T, p: ?*?*IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_played(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_seekable(self: *const T, p: ?*?*IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_seekable(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_ended(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_ended(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_autoplay(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_autoplay(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_autoplay(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_autoplay(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_loop(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_loop(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_play(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).play(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).pause(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_controls(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_controls(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_controls(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_controls(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_volume(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_volume(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_volume(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_volume(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_muted(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_muted(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_muted(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_muted(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_autobuffer(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_autobuffer(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_autobuffer(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_autobuffer(@ptrCast(*const IHTMLMediaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaElement2_Value = @import("../zig.zig").Guid.initString("30510809-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMediaElement2 = &IID_IHTMLMediaElement2_Value;
pub const IHTMLMediaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_initialTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_durationDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultPlaybackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultPlaybackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_playbackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playbackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_volumeDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_volumeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_currentTimeDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_currentTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_currentTimeDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_currentTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_initialTimeDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_initialTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_durationDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_durationDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_defaultPlaybackRateDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_defaultPlaybackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_defaultPlaybackRateDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_defaultPlaybackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_playbackRateDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_playbackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_playbackRateDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_playbackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_volumeDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_volumeDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_volumeDouble(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_volumeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSMediaElement_Value = @import("../zig.zig").Guid.initString("30510792-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLMSMediaElement = &IID_IHTMLMSMediaElement_Value;
pub const IHTMLMSMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPlayToDisabled: fn(
            self: *const IHTMLMSMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPlayToDisabled: fn(
            self: *const IHTMLMSMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_msPlayToPrimary: fn(
            self: *const IHTMLMSMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msPlayToPrimary: fn(
            self: *const IHTMLMSMediaElement,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_put_msPlayToDisabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).put_msPlayToDisabled(@ptrCast(*const IHTMLMSMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_get_msPlayToDisabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).get_msPlayToDisabled(@ptrCast(*const IHTMLMSMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_put_msPlayToPrimary(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).put_msPlayToPrimary(@ptrCast(*const IHTMLMSMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_get_msPlayToPrimary(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).get_msPlayToPrimary(@ptrCast(*const IHTMLMSMediaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSourceElement_Value = @import("../zig.zig").Guid.initString("30510707-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLSourceElement = &IID_IHTMLSourceElement_Value;
pub const IHTMLSourceElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_src: fn(
            self: *const IHTMLSourceElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_src: fn(
            self: *const IHTMLSourceElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const IHTMLSourceElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLSourceElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const IHTMLSourceElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const IHTMLSourceElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_src(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_src(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLSourceElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSourceElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLSourceElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAudioElement_Value = @import("../zig.zig").Guid.initString("30510708-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAudioElement = &IID_IHTMLAudioElement_Value;
pub const IHTMLAudioElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLVideoElement_Value = @import("../zig.zig").Guid.initString("30510709-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLVideoElement = &IID_IHTMLVideoElement_Value;
pub const IHTMLVideoElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_width: fn(
            self: *const IHTMLVideoElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IHTMLVideoElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_height: fn(
            self: *const IHTMLVideoElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IHTMLVideoElement,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_videoWidth: fn(
            self: *const IHTMLVideoElement,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_videoHeight: fn(
            self: *const IHTMLVideoElement,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_poster: fn(
            self: *const IHTMLVideoElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_poster: fn(
            self: *const IHTMLVideoElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_videoWidth(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_videoWidth(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_videoHeight(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_videoHeight(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_poster(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_poster(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_poster(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_poster(@ptrCast(*const IHTMLVideoElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAudioElementFactory_Value = @import("../zig.zig").Guid.initString("305107eb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAudioElementFactory = &IID_IHTMLAudioElementFactory_Value;
pub const IHTMLAudioElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLAudioElementFactory,
            src: VARIANT,
            __MIDL__IHTMLAudioElementFactory0000: ?*?*IHTMLAudioElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAudioElementFactory_create(self: *const T, src: VARIANT, __MIDL__IHTMLAudioElementFactory0000: ?*?*IHTMLAudioElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAudioElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLAudioElementFactory, self), src, __MIDL__IHTMLAudioElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMediaError_Value = @import("../zig.zig").Guid.initString("30590086-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMediaError = &IID_DispHTMLMediaError_Value;
pub const DispHTMLMediaError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("30590087-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLTimeRanges = &IID_DispHTMLTimeRanges_Value;
pub const DispHTMLTimeRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMediaElement_Value = @import("../zig.zig").Guid.initString("30590088-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLMediaElement = &IID_DispHTMLMediaElement_Value;
pub const DispHTMLMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSourceElement_Value = @import("../zig.zig").Guid.initString("30590089-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLSourceElement = &IID_DispHTMLSourceElement_Value;
pub const DispHTMLSourceElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAudioElement_Value = @import("../zig.zig").Guid.initString("3059008a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAudioElement = &IID_DispHTMLAudioElement_Value;
pub const DispHTMLAudioElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLVideoElement_Value = @import("../zig.zig").Guid.initString("3059008b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLVideoElement = &IID_DispHTMLVideoElement_Value;
pub const DispHTMLVideoElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSwitchElement_Value = @import("../zig.zig").Guid.initString("305104f1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGSwitchElement = &IID_ISVGSwitchElement_Value;
pub const ISVGSwitchElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSwitchElement_Value = @import("../zig.zig").Guid.initString("30590030-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGSwitchElement = &IID_DispSVGSwitchElement_Value;
pub const DispSVGSwitchElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDescElement_Value = @import("../zig.zig").Guid.initString("305104ea-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGDescElement = &IID_ISVGDescElement_Value;
pub const ISVGDescElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGDescElement_Value = @import("../zig.zig").Guid.initString("30590005-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGDescElement = &IID_DispSVGDescElement_Value;
pub const DispSVGDescElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTitleElement_Value = @import("../zig.zig").Guid.initString("305104eb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTitleElement = &IID_ISVGTitleElement_Value;
pub const ISVGTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTitleElement_Value = @import("../zig.zig").Guid.initString("30590006-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTitleElement = &IID_DispSVGTitleElement_Value;
pub const DispSVGTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMetadataElement_Value = @import("../zig.zig").Guid.initString("30510560-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGMetadataElement = &IID_ISVGMetadataElement_Value;
pub const ISVGMetadataElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMetadataElement_Value = @import("../zig.zig").Guid.initString("3059002f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGMetadataElement = &IID_DispSVGMetadataElement_Value;
pub const DispSVGMetadataElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("305104ef-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGElementInstanceList = &IID_ISVGElementInstanceList_Value;
pub const ISVGElementInstanceList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const ISVGElementInstanceList,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const ISVGElementInstanceList,
            index: i32,
            ppResult: ?*?*ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstanceList_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstanceList.VTable, self.vtable).get_length(@ptrCast(*const ISVGElementInstanceList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstanceList_item(self: *const T, index: i32, ppResult: ?*?*ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstanceList.VTable, self.vtable).item(@ptrCast(*const ISVGElementInstanceList, self), index, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElementInstance_Value = @import("../zig.zig").Guid.initString("30590007-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGElementInstance = &IID_DispSVGElementInstance_Value;
pub const DispSVGElementInstance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("30590008-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGElementInstanceList = &IID_DispSVGElementInstanceList_Value;
pub const DispSVGElementInstanceList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMException_Value = @import("../zig.zig").Guid.initString("3051072b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMException = &IID_IDOMException_Value;
pub const IDOMException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_code: fn(
            self: *const IDOMException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IDOMException,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_message: fn(
            self: *const IDOMException,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).put_code(@ptrCast(*const IDOMException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_get_code(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).get_code(@ptrCast(*const IDOMException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_get_message(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).get_message(@ptrCast(*const IDOMException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMException_Value = @import("../zig.zig").Guid.initString("30590094-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMException = &IID_DispDOMException_Value;
pub const DispDOMException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRangeException_Value = @import("../zig.zig").Guid.initString("3051072d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IRangeException = &IID_IRangeException_Value;
pub const IRangeException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_code: fn(
            self: *const IRangeException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IRangeException,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_message: fn(
            self: *const IRangeException,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).put_code(@ptrCast(*const IRangeException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_get_code(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).get_code(@ptrCast(*const IRangeException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_get_message(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).get_message(@ptrCast(*const IRangeException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRangeException_Value = @import("../zig.zig").Guid.initString("30590095-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispRangeException = &IID_DispRangeException_Value;
pub const DispRangeException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGException_Value = @import("../zig.zig").Guid.initString("3051072f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGException = &IID_ISVGException_Value;
pub const ISVGException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_code: fn(
            self: *const ISVGException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const ISVGException,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_message: fn(
            self: *const ISVGException,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).put_code(@ptrCast(*const ISVGException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_get_code(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).get_code(@ptrCast(*const ISVGException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_get_message(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).get_message(@ptrCast(*const ISVGException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGException_Value = @import("../zig.zig").Guid.initString("30590096-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGException = &IID_DispSVGException_Value;
pub const DispSVGException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventException_Value = @import("../zig.zig").Guid.initString("3051073a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IEventException = &IID_IEventException_Value;
pub const IEventException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_code: fn(
            self: *const IEventException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IEventException,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_message: fn(
            self: *const IEventException,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).put_code(@ptrCast(*const IEventException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_get_code(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).get_code(@ptrCast(*const IEventException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_get_message(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).get_message(@ptrCast(*const IEventException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispEventException_Value = @import("../zig.zig").Guid.initString("30590099-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispEventException = &IID_DispEventException_Value;
pub const DispEventException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGScriptElement_Value = @import("../zig.zig").Guid.initString("3051054d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGScriptElement = &IID_ISVGScriptElement_Value;
pub const ISVGScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const ISVGScriptElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const ISVGScriptElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGScriptElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGScriptElement.VTable, self.vtable).put_type(@ptrCast(*const ISVGScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGScriptElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGScriptElement.VTable, self.vtable).get_type(@ptrCast(*const ISVGScriptElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGScriptElement_Value = @import("../zig.zig").Guid.initString("30590039-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGScriptElement = &IID_DispSVGScriptElement_Value;
pub const DispSVGScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStyleElement_Value = @import("../zig.zig").Guid.initString("305104f3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGStyleElement = &IID_ISVGStyleElement_Value;
pub const ISVGStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_type: fn(
            self: *const ISVGStyleElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const ISVGStyleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_media: fn(
            self: *const ISVGStyleElement,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_media: fn(
            self: *const ISVGStyleElement,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_put_type(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).put_type(@ptrCast(*const ISVGStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_get_type(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).get_type(@ptrCast(*const ISVGStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_put_media(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).put_media(@ptrCast(*const ISVGStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_get_media(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).get_media(@ptrCast(*const ISVGStyleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGStyleElement_Value = @import("../zig.zig").Guid.initString("30590029-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGStyleElement = &IID_DispSVGStyleElement_Value;
pub const DispSVGStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextContentElement_Value = @import("../zig.zig").Guid.initString("3051051a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTextContentElement = &IID_ISVGTextContentElement_Value;
pub const ISVGTextContentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_textLength: fn(
            self: *const ISVGTextContentElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textLength: fn(
            self: *const ISVGTextContentElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_lengthAdjust: fn(
            self: *const ISVGTextContentElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lengthAdjust: fn(
            self: *const ISVGTextContentElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getNumberOfChars: fn(
            self: *const ISVGTextContentElement,
            pResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComputedTextLength: fn(
            self: *const ISVGTextContentElement,
            pResult: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSubStringLength: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            nchars: i32,
            pResult: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getStartPositionOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEndPositionOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: ?*?*ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExtentOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: ?*?*ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRotationOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            pResult: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharNumAtPosition: fn(
            self: *const ISVGTextContentElement,
            point: ?*ISVGPoint,
            pResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectSubString: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            nchars: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_putref_textLength(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).putref_textLength(@ptrCast(*const ISVGTextContentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_get_textLength(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).get_textLength(@ptrCast(*const ISVGTextContentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_putref_lengthAdjust(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).putref_lengthAdjust(@ptrCast(*const ISVGTextContentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_get_lengthAdjust(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).get_lengthAdjust(@ptrCast(*const ISVGTextContentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getNumberOfChars(self: *const T, pResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getNumberOfChars(@ptrCast(*const ISVGTextContentElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getComputedTextLength(self: *const T, pResult: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getComputedTextLength(@ptrCast(*const ISVGTextContentElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getSubStringLength(self: *const T, charnum: i32, nchars: i32, pResult: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getSubStringLength(@ptrCast(*const ISVGTextContentElement, self), charnum, nchars, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getStartPositionOfChar(self: *const T, charnum: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getStartPositionOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getEndPositionOfChar(self: *const T, charnum: i32, ppResult: ?*?*ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getEndPositionOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getExtentOfChar(self: *const T, charnum: i32, ppResult: ?*?*ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getExtentOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getRotationOfChar(self: *const T, charnum: i32, pResult: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getRotationOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getCharNumAtPosition(self: *const T, point: ?*ISVGPoint, pResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getCharNumAtPosition(@ptrCast(*const ISVGTextContentElement, self), point, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_selectSubString(self: *const T, charnum: i32, nchars: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).selectSubString(@ptrCast(*const ISVGTextContentElement, self), charnum, nchars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextContentElement_Value = @import("../zig.zig").Guid.initString("30590035-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTextContentElement = &IID_DispSVGTextContentElement_Value;
pub const DispSVGTextContentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("3051051b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTextPositioningElement = &IID_ISVGTextPositioningElement_Value;
pub const ISVGTextPositioningElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGTextPositioningElement,
            v: ?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ISVGTextPositioningElement,
            p: ?*?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGTextPositioningElement,
            v: ?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_y: fn(
            self: *const ISVGTextPositioningElement,
            p: ?*?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dx: fn(
            self: *const ISVGTextPositioningElement,
            v: ?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dx: fn(
            self: *const ISVGTextPositioningElement,
            p: ?*?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dy: fn(
            self: *const ISVGTextPositioningElement,
            v: ?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dy: fn(
            self: *const ISVGTextPositioningElement,
            p: ?*?*ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rotate: fn(
            self: *const ISVGTextPositioningElement,
            v: ?*ISVGAnimatedNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rotate: fn(
            self: *const ISVGTextPositioningElement,
            p: ?*?*ISVGAnimatedNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_x(self: *const T, v: ?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_x(self: *const T, p: ?*?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_y(self: *const T, v: ?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_y(self: *const T, p: ?*?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_dx(self: *const T, v: ?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_dx(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_dx(self: *const T, p: ?*?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_dx(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_dy(self: *const T, v: ?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_dy(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_dy(self: *const T, p: ?*?*ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_dy(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_rotate(self: *const T, v: ?*ISVGAnimatedNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_rotate(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_rotate(self: *const T, p: ?*?*ISVGAnimatedNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_rotate(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("30590038-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTextPositioningElement = &IID_DispSVGTextPositioningElement_Value;
pub const DispSVGTextPositioningElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMDocumentType_Value = @import("../zig.zig").Guid.initString("30590098-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMDocumentType = &IID_DispDOMDocumentType_Value;
pub const DispDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispNodeIterator_Value = @import("../zig.zig").Guid.initString("3059009c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispNodeIterator = &IID_DispNodeIterator_Value;
pub const DispNodeIterator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispTreeWalker_Value = @import("../zig.zig").Guid.initString("3059009d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispTreeWalker = &IID_DispTreeWalker_Value;
pub const DispTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("3059009b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMProcessingInstruction = &IID_DispDOMProcessingInstruction_Value;
pub const DispDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("30510750-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPerformanceNavigation = &IID_IHTMLPerformanceNavigation_Value;
pub const IHTMLPerformanceNavigation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IHTMLPerformanceNavigation,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_redirectCount: fn(
            self: *const IHTMLPerformanceNavigation,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformanceNavigation,
            string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformanceNavigation,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_get_type(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).get_type(@ptrCast(*const IHTMLPerformanceNavigation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_get_redirectCount(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).get_redirectCount(@ptrCast(*const IHTMLPerformanceNavigation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_toString(self: *const T, string: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformanceNavigation, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_toJSON(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformanceNavigation, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("30510752-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPerformanceTiming = &IID_IHTMLPerformanceTiming_Value;
pub const IHTMLPerformanceTiming = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_navigationStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unloadEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unloadEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_redirectStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_redirectEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fetchStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domainLookupStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domainLookupEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connectStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connectEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_requestStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domLoading: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domInteractive: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domContentLoadedEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domContentLoadedEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domComplete: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loadEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_loadEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_msFirstPaint: fn(
            self: *const IHTMLPerformanceTiming,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformanceTiming,
            string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformanceTiming,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_navigationStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_navigationStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_unloadEventStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_unloadEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_unloadEventEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_unloadEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_redirectStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_redirectStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_redirectEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_redirectEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_fetchStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_fetchStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domainLookupStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domainLookupStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domainLookupEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domainLookupEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_connectStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_connectStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_connectEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_connectEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_requestStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_requestStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_responseStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_responseStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_responseEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_responseEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domLoading(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domLoading(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domInteractive(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domInteractive(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domContentLoadedEventStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domContentLoadedEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domContentLoadedEventEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domContentLoadedEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domComplete(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domComplete(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_loadEventStart(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_loadEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_loadEventEnd(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_loadEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_msFirstPaint(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_msFirstPaint(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_toString(self: *const T, string: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformanceTiming, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_toJSON(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformanceTiming, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformance_Value = @import("../zig.zig").Guid.initString("3059009f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLPerformance = &IID_DispHTMLPerformance_Value;
pub const DispHTMLPerformance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("305900a0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLPerformanceNavigation = &IID_DispHTMLPerformanceNavigation_Value;
pub const DispHTMLPerformanceNavigation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("305900a1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLPerformanceTiming = &IID_DispHTMLPerformanceTiming_Value;
pub const DispHTMLPerformanceTiming = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTSpanElement_Value = @import("../zig.zig").Guid.initString("3051051d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTSpanElement = &IID_ISVGTSpanElement_Value;
pub const ISVGTSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTSpanElement_Value = @import("../zig.zig").Guid.initString("3059003a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTSpanElement = &IID_DispSVGTSpanElement_Value;
pub const DispSVGTSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter_Value = @import("../zig.zig").Guid.initString("3050f6b4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITemplatePrinter = &IID_ITemplatePrinter_Value;
pub const ITemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDoc: fn(
            self: *const ITemplatePrinter,
            bstrTitle: ?BSTR,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopDoc: fn(
            self: *const ITemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printBlankPage: fn(
            self: *const ITemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printPage: fn(
            self: *const ITemplatePrinter,
            pElemDisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ensurePrintDialogDefaults: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showPrintDialog: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showPageSetupDialog: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printNonNative: fn(
            self: *const ITemplatePrinter,
            pMarkup: ?*IUnknown,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printNonNativeFrames: fn(
            self: *const ITemplatePrinter,
            pMarkup: ?*IUnknown,
            fActiveFrame: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_framesetDocument: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_framesetDocument: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameActive: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameActive: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameAsShown: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameAsShown: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selection: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selection: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectedPages: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectedPages: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentPage: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPage: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentPageAvail: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPageAvail: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_collate: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_collate: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_duplex: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_copies: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_copies: fn(
            self: *const ITemplatePrinter,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageFrom: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageFrom: fn(
            self: *const ITemplatePrinter,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageTo: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageTo: fn(
            self: *const ITemplatePrinter,
            p: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tableOfLinks: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tableOfLinks: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_allLinkedDocuments: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allLinkedDocuments: fn(
            self: *const ITemplatePrinter,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_header: fn(
            self: *const ITemplatePrinter,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_header: fn(
            self: *const ITemplatePrinter,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_footer: fn(
            self: *const ITemplatePrinter,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_footer: fn(
            self: *const ITemplatePrinter,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginLeft: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginLeft: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginRight: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginRight: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginTop: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginTop: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_marginBottom: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_marginBottom: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageWidth: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageHeight: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unprintableLeft: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unprintableTop: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unprintableRight: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unprintableBottom: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        updatePageStatus: fn(
            self: *const ITemplatePrinter,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_startDoc(self: *const T, bstrTitle: ?BSTR, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).startDoc(@ptrCast(*const ITemplatePrinter, self), bstrTitle, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_stopDoc(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).stopDoc(@ptrCast(*const ITemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printBlankPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printBlankPage(@ptrCast(*const ITemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printPage(self: *const T, pElemDisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printPage(@ptrCast(*const ITemplatePrinter, self), pElemDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_ensurePrintDialogDefaults(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).ensurePrintDialogDefaults(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_showPrintDialog(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).showPrintDialog(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_showPageSetupDialog(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).showPageSetupDialog(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printNonNative(self: *const T, pMarkup: ?*IUnknown, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printNonNative(@ptrCast(*const ITemplatePrinter, self), pMarkup, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printNonNativeFrames(self: *const T, pMarkup: ?*IUnknown, fActiveFrame: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printNonNativeFrames(@ptrCast(*const ITemplatePrinter, self), pMarkup, fActiveFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_framesetDocument(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_framesetDocument(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_framesetDocument(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_framesetDocument(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_frameActive(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_frameActive(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_frameActive(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_frameActive(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_frameAsShown(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_frameAsShown(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_frameAsShown(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_frameAsShown(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_selection(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_selection(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_selection(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_selection(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_selectedPages(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_selectedPages(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_selectedPages(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_selectedPages(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_currentPage(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_currentPage(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_currentPage(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_currentPage(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_currentPageAvail(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_currentPageAvail(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_currentPageAvail(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_currentPageAvail(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_collate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_collate(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_collate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_collate(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_duplex(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_duplex(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_copies(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_copies(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_copies(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_copies(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_pageFrom(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_pageFrom(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageFrom(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageFrom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_pageTo(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_pageTo(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageTo(self: *const T, p: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageTo(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_tableOfLinks(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_tableOfLinks(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_tableOfLinks(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_tableOfLinks(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_allLinkedDocuments(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_allLinkedDocuments(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_allLinkedDocuments(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_allLinkedDocuments(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_header(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_header(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_header(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_header(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_footer(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_footer(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_footer(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_footer(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginLeft(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginLeft(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginRight(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginRight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginRight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginTop(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginTop(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginBottom(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginBottom(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginBottom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageWidth(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageHeight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableLeft(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableLeft(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableTop(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableTop(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableRight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableRight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableBottom(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableBottom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_updatePageStatus(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).updatePageStatus(@ptrCast(*const ITemplatePrinter, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter2_Value = @import("../zig.zig").Guid.initString("3050f83f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITemplatePrinter2 = &IID_ITemplatePrinter2_Value;
pub const ITemplatePrinter2 = extern struct {
    pub const VTable = extern struct {
        base: ITemplatePrinter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selectionEnabled: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selectionEnabled: fn(
            self: *const ITemplatePrinter2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_frameActiveEnabled: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameActiveEnabled: fn(
            self: *const ITemplatePrinter2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_orientation: fn(
            self: *const ITemplatePrinter2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_orientation: fn(
            self: *const ITemplatePrinter2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_usePrinterCopyCollate: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_usePrinterCopyCollate: fn(
            self: *const ITemplatePrinter2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deviceSupports: fn(
            self: *const ITemplatePrinter2,
            bstrProperty: ?BSTR,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITemplatePrinter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_selectionEnabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_selectionEnabled(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_selectionEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_selectionEnabled(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_frameActiveEnabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_frameActiveEnabled(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_frameActiveEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_frameActiveEnabled(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_orientation(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_orientation(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_orientation(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_orientation(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_usePrinterCopyCollate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_usePrinterCopyCollate(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_usePrinterCopyCollate(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_usePrinterCopyCollate(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_deviceSupports(self: *const T, bstrProperty: ?BSTR, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).deviceSupports(@ptrCast(*const ITemplatePrinter2, self), bstrProperty, pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter3_Value = @import("../zig.zig").Guid.initString("305104a3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITemplatePrinter3 = &IID_ITemplatePrinter3_Value;
pub const ITemplatePrinter3 = extern struct {
    pub const VTable = extern struct {
        base: ITemplatePrinter2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_headerFooterFont: fn(
            self: *const ITemplatePrinter3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_headerFooterFont: fn(
            self: *const ITemplatePrinter3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginTop: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginRight: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginBottom: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginLeft: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginTopImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pbImportant: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginRightImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pbImportant: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginBottomImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pbImportant: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginLeftImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: ?*IDispatch,
            pbImportant: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITemplatePrinter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_put_headerFooterFont(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).put_headerFooterFont(@ptrCast(*const ITemplatePrinter3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_get_headerFooterFont(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).get_headerFooterFont(@ptrCast(*const ITemplatePrinter3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginTop(self: *const T, pageRule: ?*IDispatch, pageWidth: i32, pageHeight: i32, pMargin: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginTop(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginRight(self: *const T, pageRule: ?*IDispatch, pageWidth: i32, pageHeight: i32, pMargin: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginRight(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginBottom(self: *const T, pageRule: ?*IDispatch, pageWidth: i32, pageHeight: i32, pMargin: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginBottom(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginLeft(self: *const T, pageRule: ?*IDispatch, pageWidth: i32, pageHeight: i32, pMargin: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginLeft(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginTopImportant(self: *const T, pageRule: ?*IDispatch, pbImportant: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginTopImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginRightImportant(self: *const T, pageRule: ?*IDispatch, pbImportant: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginRightImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginBottomImportant(self: *const T, pageRule: ?*IDispatch, pbImportant: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginBottomImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginLeftImportant(self: *const T, pageRule: ?*IDispatch, pbImportant: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginLeftImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("f633be14-9eff-4c4d-929e-05717b21b3e6");
pub const IID_IPrintManagerTemplatePrinter = &IID_IPrintManagerTemplatePrinter_Value;
pub const IPrintManagerTemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startPrint: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        drawPreviewPage: fn(
            self: *const IPrintManagerTemplatePrinter,
            pElemDisp: ?*IDispatch,
            nPage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPageCount: fn(
            self: *const IPrintManagerTemplatePrinter,
            nPage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        invalidatePreview: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPrintTaskOptionValue: fn(
            self: *const IPrintManagerTemplatePrinter,
            bstrKey: ?BSTR,
            pvarin: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endPrint: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_startPrint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).startPrint(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_drawPreviewPage(self: *const T, pElemDisp: ?*IDispatch, nPage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).drawPreviewPage(@ptrCast(*const IPrintManagerTemplatePrinter, self), pElemDisp, nPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_setPageCount(self: *const T, nPage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).setPageCount(@ptrCast(*const IPrintManagerTemplatePrinter, self), nPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_invalidatePreview(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).invalidatePreview(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_getPrintTaskOptionValue(self: *const T, bstrKey: ?BSTR, pvarin: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).getPrintTaskOptionValue(@ptrCast(*const IPrintManagerTemplatePrinter, self), bstrKey, pvarin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_endPrint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).endPrint(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintManagerTemplatePrinter2_Value = @import("../zig.zig").Guid.initString("c6403497-7493-4f09-8016-54b03e9bda69");
pub const IID_IPrintManagerTemplatePrinter2 = &IID_IPrintManagerTemplatePrinter2_Value;
pub const IPrintManagerTemplatePrinter2 = extern struct {
    pub const VTable = extern struct {
        base: IPrintManagerTemplatePrinter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_showHeaderFooter: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_shrinkToFit: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_percentScale: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPrintManagerTemplatePrinter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_showHeaderFooter(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_showHeaderFooter(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_shrinkToFit(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_shrinkToFit(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_percentScale(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_percentScale(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("305900e9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispCPrintManagerTemplatePrinter = &IID_DispCPrintManagerTemplatePrinter_Value;
pub const DispCPrintManagerTemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextPathElement_Value = @import("../zig.zig").Guid.initString("3051051f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISVGTextPathElement = &IID_ISVGTextPathElement_Value;
pub const ISVGTextPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_startOffset: fn(
            self: *const ISVGTextPathElement,
            v: ?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startOffset: fn(
            self: *const ISVGTextPathElement,
            p: ?*?*ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_method: fn(
            self: *const ISVGTextPathElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_method: fn(
            self: *const ISVGTextPathElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_spacing: fn(
            self: *const ISVGTextPathElement,
            v: ?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_spacing: fn(
            self: *const ISVGTextPathElement,
            p: ?*?*ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_startOffset(self: *const T, v: ?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_startOffset(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_startOffset(self: *const T, p: ?*?*ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_startOffset(@ptrCast(*const ISVGTextPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_method(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_method(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_method(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_method(@ptrCast(*const ISVGTextPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_spacing(self: *const T, v: ?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_spacing(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_spacing(self: *const T, p: ?*?*ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_spacing(@ptrCast(*const ISVGTextPathElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextPathElement_Value = @import("../zig.zig").Guid.initString("3059003d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispSVGTextPathElement = &IID_DispSVGTextPathElement_Value;
pub const DispSVGTextPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMXmlSerializer_Value = @import("../zig.zig").Guid.initString("3051077d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMXmlSerializer = &IID_IDOMXmlSerializer_Value;
pub const IDOMXmlSerializer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        serializeToString: fn(
            self: *const IDOMXmlSerializer,
            pNode: ?*IHTMLDOMNode,
            pString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMXmlSerializer_serializeToString(self: *const T, pNode: ?*IHTMLDOMNode, pString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMXmlSerializer.VTable, self.vtable).serializeToString(@ptrCast(*const IDOMXmlSerializer, self), pNode, pString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMParser_Value = @import("../zig.zig").Guid.initString("30510781-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMParser = &IID_IDOMParser_Value;
pub const IDOMParser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        parseFromString: fn(
            self: *const IDOMParser,
            xmlSource: ?BSTR,
            mimeType: ?BSTR,
            ppNode: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMParser_parseFromString(self: *const T, xmlSource: ?BSTR, mimeType: ?BSTR, ppNode: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMParser.VTable, self.vtable).parseFromString(@ptrCast(*const IDOMParser, self), xmlSource, mimeType, ppNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXMLSerializer_Value = @import("../zig.zig").Guid.initString("305900ad-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispXMLSerializer = &IID_DispXMLSerializer_Value;
pub const DispXMLSerializer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMParser_Value = @import("../zig.zig").Guid.initString("305900ae-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMParser = &IID_DispDOMParser_Value;
pub const DispDOMParser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMXmlSerializerFactory_Value = @import("../zig.zig").Guid.initString("3051077f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMXmlSerializerFactory = &IID_IDOMXmlSerializerFactory_Value;
pub const IDOMXmlSerializerFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IDOMXmlSerializerFactory,
            __MIDL__IDOMXmlSerializerFactory0000: ?*?*IDOMXmlSerializer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMXmlSerializerFactory_create(self: *const T, __MIDL__IDOMXmlSerializerFactory0000: ?*?*IDOMXmlSerializer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMXmlSerializerFactory.VTable, self.vtable).create(@ptrCast(*const IDOMXmlSerializerFactory, self), __MIDL__IDOMXmlSerializerFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMParserFactory_Value = @import("../zig.zig").Guid.initString("30510783-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMParserFactory = &IID_IDOMParserFactory_Value;
pub const IDOMParserFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IDOMParserFactory,
            __MIDL__IDOMParserFactory0000: ?*?*IDOMParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMParserFactory_create(self: *const T, __MIDL__IDOMParserFactory0000: ?*?*IDOMParser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMParserFactory.VTable, self.vtable).create(@ptrCast(*const IDOMParserFactory, self), __MIDL__IDOMParserFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSemanticElement_Value = @import("../zig.zig").Guid.initString("305900ba-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLSemanticElement = &IID_DispHTMLSemanticElement_Value;
pub const DispHTMLSemanticElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLProgressElement_Value = @import("../zig.zig").Guid.initString("3050f2d6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLProgressElement = &IID_IHTMLProgressElement_Value;
pub const IHTMLProgressElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IHTMLProgressElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IHTMLProgressElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_max: fn(
            self: *const IHTMLProgressElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_max: fn(
            self: *const IHTMLProgressElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_position: fn(
            self: *const IHTMLProgressElement,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_form: fn(
            self: *const IHTMLProgressElement,
            p: ?*?*IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLProgressElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_value(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_put_max(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).put_max(@ptrCast(*const IHTMLProgressElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_max(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_max(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_position(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_position(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_form(self: *const T, p: ?*?*IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLProgressElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLProgressElement_Value = @import("../zig.zig").Guid.initString("305900af-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLProgressElement = &IID_DispHTMLProgressElement_Value;
pub const DispHTMLProgressElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305107b5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMSTransitionEvent = &IID_IDOMMSTransitionEvent_Value;
pub const IDOMMSTransitionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_propertyName: fn(
            self: *const IDOMMSTransitionEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_elapsedTime: fn(
            self: *const IDOMMSTransitionEvent,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSTransitionEvent: fn(
            self: *const IDOMMSTransitionEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            propertyName: ?BSTR,
            elapsedTime: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_get_propertyName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).get_propertyName(@ptrCast(*const IDOMMSTransitionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_get_elapsedTime(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).get_elapsedTime(@ptrCast(*const IDOMMSTransitionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_initMSTransitionEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, propertyName: ?BSTR, elapsedTime: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).initMSTransitionEvent(@ptrCast(*const IDOMMSTransitionEvent, self), eventType, canBubble, cancelable, propertyName, elapsedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305900bb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMSTransitionEvent = &IID_DispDOMMSTransitionEvent_Value;
pub const DispDOMMSTransitionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305107b7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMSAnimationEvent = &IID_IDOMMSAnimationEvent_Value;
pub const IDOMMSAnimationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_animationName: fn(
            self: *const IDOMMSAnimationEvent,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_elapsedTime: fn(
            self: *const IDOMMSAnimationEvent,
            p: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSAnimationEvent: fn(
            self: *const IDOMMSAnimationEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            animationName: ?BSTR,
            elapsedTime: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_get_animationName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).get_animationName(@ptrCast(*const IDOMMSAnimationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_get_elapsedTime(self: *const T, p: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).get_elapsedTime(@ptrCast(*const IDOMMSAnimationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_initMSAnimationEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, animationName: ?BSTR, elapsedTime: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).initMSAnimationEvent(@ptrCast(*const IDOMMSAnimationEvent, self), eventType, canBubble, cancelable, animationName, elapsedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305900bc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMSAnimationEvent = &IID_DispDOMMSAnimationEvent_Value;
pub const DispDOMMSAnimationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305107c7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IWebGeocoordinates = &IID_IWebGeocoordinates_Value;
pub const IWebGeocoordinates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_latitude: fn(
            self: *const IWebGeocoordinates,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_longitude: fn(
            self: *const IWebGeocoordinates,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altitude: fn(
            self: *const IWebGeocoordinates,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accuracy: fn(
            self: *const IWebGeocoordinates,
            p: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_altitudeAccuracy: fn(
            self: *const IWebGeocoordinates,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_heading: fn(
            self: *const IWebGeocoordinates,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_speed: fn(
            self: *const IWebGeocoordinates,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_latitude(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_latitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_longitude(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_longitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_altitude(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_altitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_accuracy(self: *const T, p: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_accuracy(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_altitudeAccuracy(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_altitudeAccuracy(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_heading(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_heading(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_speed(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_speed(@ptrCast(*const IWebGeocoordinates, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeopositionError_Value = @import("../zig.zig").Guid.initString("305107c9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IWebGeopositionError = &IID_IWebGeopositionError_Value;
pub const IWebGeopositionError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_code: fn(
            self: *const IWebGeopositionError,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_message: fn(
            self: *const IWebGeopositionError,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeopositionError_get_code(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeopositionError.VTable, self.vtable).get_code(@ptrCast(*const IWebGeopositionError, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeopositionError_get_message(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeopositionError.VTable, self.vtable).get_message(@ptrCast(*const IWebGeopositionError, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeoposition_Value = @import("../zig.zig").Guid.initString("305107cd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IWebGeoposition = &IID_IWebGeoposition_Value;
pub const IWebGeoposition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_coords: fn(
            self: *const IWebGeoposition,
            p: ?*?*IWebGeocoordinates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timestamp: fn(
            self: *const IWebGeoposition,
            p: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeoposition_get_coords(self: *const T, p: ?*?*IWebGeocoordinates) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeoposition.VTable, self.vtable).get_coords(@ptrCast(*const IWebGeoposition, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeoposition_get_timestamp(self: *const T, p: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeoposition.VTable, self.vtable).get_timestamp(@ptrCast(*const IWebGeoposition, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeolocation_Value = @import("../zig.zig").Guid.initString("305900bd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispWebGeolocation = &IID_DispWebGeolocation_Value;
pub const DispWebGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305900be-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispWebGeocoordinates = &IID_DispWebGeocoordinates_Value;
pub const DispWebGeocoordinates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeopositionError_Value = @import("../zig.zig").Guid.initString("305900bf-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispWebGeopositionError = &IID_DispWebGeopositionError_Value;
pub const DispWebGeopositionError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeoposition_Value = @import("../zig.zig").Guid.initString("305900c1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispWebGeoposition = &IID_DispWebGeoposition_Value;
pub const DispWebGeoposition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClientCaps_Value = @import("../zig.zig").Guid.initString("7e8bc44d-aeff-11d1-89c2-00c04fb6bfc4");
pub const IID_IClientCaps = &IID_IClientCaps_Value;
pub const IClientCaps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_javaEnabled: fn(
            self: *const IClientCaps,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cookieEnabled: fn(
            self: *const IClientCaps,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cpuClass: fn(
            self: *const IClientCaps,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemLanguage: fn(
            self: *const IClientCaps,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_userLanguage: fn(
            self: *const IClientCaps,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_platform: fn(
            self: *const IClientCaps,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connectionSpeed: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onLine: fn(
            self: *const IClientCaps,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_colorDepth: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bufferDepth: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_width: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_height: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_availHeight: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_availWidth: fn(
            self: *const IClientCaps,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connectionType: fn(
            self: *const IClientCaps,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isComponentInstalled: fn(
            self: *const IClientCaps,
            bstrName: ?BSTR,
            bstrUrl: ?BSTR,
            bStrVer: ?BSTR,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComponentVersion: fn(
            self: *const IClientCaps,
            bstrName: ?BSTR,
            bstrUrl: ?BSTR,
            pbstrVer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareVersions: fn(
            self: *const IClientCaps,
            bstrVer1: ?BSTR,
            bstrVer2: ?BSTR,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addComponentRequest: fn(
            self: *const IClientCaps,
            bstrName: ?BSTR,
            bstrUrl: ?BSTR,
            bStrVer: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doComponentRequest: fn(
            self: *const IClientCaps,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearComponentRequest: fn(
            self: *const IClientCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_javaEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_javaEnabled(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_cookieEnabled(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_cookieEnabled(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_cpuClass(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_cpuClass(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_systemLanguage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_systemLanguage(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_userLanguage(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_userLanguage(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_platform(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_platform(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_connectionSpeed(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_connectionSpeed(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_onLine(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_onLine(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_colorDepth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_colorDepth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_bufferDepth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_bufferDepth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_width(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_width(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_height(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_height(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_availHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_availHeight(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_availWidth(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_availWidth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_connectionType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_connectionType(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_isComponentInstalled(self: *const T, bstrName: ?BSTR, bstrUrl: ?BSTR, bStrVer: ?BSTR, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).isComponentInstalled(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, bStrVer, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_getComponentVersion(self: *const T, bstrName: ?BSTR, bstrUrl: ?BSTR, pbstrVer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).getComponentVersion(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, pbstrVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_compareVersions(self: *const T, bstrVer1: ?BSTR, bstrVer2: ?BSTR, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).compareVersions(@ptrCast(*const IClientCaps, self), bstrVer1, bstrVer2, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_addComponentRequest(self: *const T, bstrName: ?BSTR, bstrUrl: ?BSTR, bStrVer: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).addComponentRequest(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, bStrVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_doComponentRequest(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).doComponentRequest(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_clearComponentRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).clearComponentRequest(@ptrCast(*const IClientCaps, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("30510816-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMMSManipulationEvent = &IID_IDOMMSManipulationEvent_Value;
pub const IDOMMSManipulationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastState: fn(
            self: *const IDOMMSManipulationEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentState: fn(
            self: *const IDOMMSManipulationEvent,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSManipulationEvent: fn(
            self: *const IDOMMSManipulationEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: ?*IHTMLWindow2,
            detailArg: i32,
            lastState: i32,
            currentState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_get_lastState(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).get_lastState(@ptrCast(*const IDOMMSManipulationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_get_currentState(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).get_currentState(@ptrCast(*const IDOMMSManipulationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_initMSManipulationEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, viewArg: ?*IHTMLWindow2, detailArg: i32, lastState: i32, currentState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).initMSManipulationEvent(@ptrCast(*const IDOMMSManipulationEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, lastState, currentState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("305900e1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMMSManipulationEvent = &IID_DispDOMMSManipulationEvent_Value;
pub const DispDOMMSManipulationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCloseEvent_Value = @import("../zig.zig").Guid.initString("305107ff-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMCloseEvent = &IID_IDOMCloseEvent_Value;
pub const IDOMCloseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_wasClean: fn(
            self: *const IDOMCloseEvent,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCloseEvent: fn(
            self: *const IDOMCloseEvent,
            eventType: ?BSTR,
            canBubble: i16,
            cancelable: i16,
            wasClean: i16,
            code: i32,
            reason: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCloseEvent_get_wasClean(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCloseEvent.VTable, self.vtable).get_wasClean(@ptrCast(*const IDOMCloseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCloseEvent_initCloseEvent(self: *const T, eventType: ?BSTR, canBubble: i16, cancelable: i16, wasClean: i16, code: i32, reason: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCloseEvent.VTable, self.vtable).initCloseEvent(@ptrCast(*const IDOMCloseEvent, self), eventType, canBubble, cancelable, wasClean, code, reason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCloseEvent_Value = @import("../zig.zig").Guid.initString("305900dc-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispDOMCloseEvent = &IID_DispDOMCloseEvent_Value;
pub const DispDOMCloseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispApplicationCache_Value = @import("../zig.zig").Guid.initString("305900e4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispApplicationCache = &IID_DispApplicationCache_Value;
pub const DispApplicationCache = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICSSFilterSite_Value = @import("../zig.zig").Guid.initString("3050f3ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICSSFilterSite = &IID_ICSSFilterSite_Value;
pub const ICSSFilterSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElement: fn(
            self: *const ICSSFilterSite,
            Element: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireOnFilterChangeEvent: fn(
            self: *const ICSSFilterSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilterSite_GetElement(self: *const T, Element: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilterSite.VTable, self.vtable).GetElement(@ptrCast(*const ICSSFilterSite, self), Element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilterSite_FireOnFilterChangeEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilterSite.VTable, self.vtable).FireOnFilterChangeEvent(@ptrCast(*const ICSSFilterSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupPointer_Value = @import("../zig.zig").Guid.initString("3050f49f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupPointer = &IID_IMarkupPointer_Value;
pub const IMarkupPointer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OwningDoc: fn(
            self: *const IMarkupPointer,
            ppDoc: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Gravity: fn(
            self: *const IMarkupPointer,
            pGravity: ?*POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const IMarkupPointer,
            Gravity: POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cling: fn(
            self: *const IMarkupPointer,
            pfCling: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCling: fn(
            self: *const IMarkupPointer,
            fCLing: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unposition: fn(
            self: *const IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPositioned: fn(
            self: *const IMarkupPointer,
            pfPositioned: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainer: fn(
            self: *const IMarkupPointer,
            ppContainer: ?*?*IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveAdjacentToElement: fn(
            self: *const IMarkupPointer,
            pElement: ?*IHTMLElement,
            eAdj: ELEMENT_ADJACENCY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToPointer: fn(
            self: *const IMarkupPointer,
            pPointer: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToContainer: fn(
            self: *const IMarkupPointer,
            pContainer: ?*IMarkupContainer,
            fAtStart: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Left: fn(
            self: *const IMarkupPointer,
            fMove: BOOL,
            pContext: ?*MARKUP_CONTEXT_TYPE,
            ppElement: ?*?*IHTMLElement,
            pcch: ?*i32,
            pchText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Right: fn(
            self: *const IMarkupPointer,
            fMove: BOOL,
            pContext: ?*MARKUP_CONTEXT_TYPE,
            ppElement: ?*?*IHTMLElement,
            pcch: ?*i32,
            pchText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CurrentScope: fn(
            self: *const IMarkupPointer,
            ppElemCurrent: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOf: fn(
            self: *const IMarkupPointer,
            pPointerThat: ?*IMarkupPointer,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOfOrEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: ?*IMarkupPointer,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOf: fn(
            self: *const IMarkupPointer,
            pPointerThat: ?*IMarkupPointer,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOfOrEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: ?*IMarkupPointer,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: ?*IMarkupPointer,
            pfAreEqual: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnit: fn(
            self: *const IMarkupPointer,
            muAction: MOVEUNIT_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindText: fn(
            self: *const IMarkupPointer,
            pchFindText: ?PWSTR,
            dwFlags: u32,
            pIEndMatch: ?*IMarkupPointer,
            pIEndSearch: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_OwningDoc(self: *const T, ppDoc: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).OwningDoc(@ptrCast(*const IMarkupPointer, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Gravity(self: *const T, pGravity: ?*POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Gravity(@ptrCast(*const IMarkupPointer, self), pGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_SetGravity(self: *const T, Gravity: POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).SetGravity(@ptrCast(*const IMarkupPointer, self), Gravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Cling(self: *const T, pfCling: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Cling(@ptrCast(*const IMarkupPointer, self), pfCling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_SetCling(self: *const T, fCLing: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).SetCling(@ptrCast(*const IMarkupPointer, self), fCLing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Unposition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Unposition(@ptrCast(*const IMarkupPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsPositioned(self: *const T, pfPositioned: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsPositioned(@ptrCast(*const IMarkupPointer, self), pfPositioned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_GetContainer(self: *const T, ppContainer: ?*?*IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).GetContainer(@ptrCast(*const IMarkupPointer, self), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveAdjacentToElement(self: *const T, pElement: ?*IHTMLElement, eAdj: ELEMENT_ADJACENCY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveAdjacentToElement(@ptrCast(*const IMarkupPointer, self), pElement, eAdj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveToPointer(self: *const T, pPointer: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveToPointer(@ptrCast(*const IMarkupPointer, self), pPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveToContainer(self: *const T, pContainer: ?*IMarkupContainer, fAtStart: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveToContainer(@ptrCast(*const IMarkupPointer, self), pContainer, fAtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Left(self: *const T, fMove: BOOL, pContext: ?*MARKUP_CONTEXT_TYPE, ppElement: ?*?*IHTMLElement, pcch: ?*i32, pchText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Left(@ptrCast(*const IMarkupPointer, self), fMove, pContext, ppElement, pcch, pchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Right(self: *const T, fMove: BOOL, pContext: ?*MARKUP_CONTEXT_TYPE, ppElement: ?*?*IHTMLElement, pcch: ?*i32, pchText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Right(@ptrCast(*const IMarkupPointer, self), fMove, pContext, ppElement, pcch, pchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_CurrentScope(self: *const T, ppElemCurrent: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).CurrentScope(@ptrCast(*const IMarkupPointer, self), ppElemCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsLeftOf(self: *const T, pPointerThat: ?*IMarkupPointer, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsLeftOf(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsLeftOfOrEqualTo(self: *const T, pPointerThat: ?*IMarkupPointer, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsLeftOfOrEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsRightOf(self: *const T, pPointerThat: ?*IMarkupPointer, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsRightOf(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsRightOfOrEqualTo(self: *const T, pPointerThat: ?*IMarkupPointer, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsRightOfOrEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsEqualTo(self: *const T, pPointerThat: ?*IMarkupPointer, pfAreEqual: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfAreEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveUnit(self: *const T, muAction: MOVEUNIT_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveUnit(@ptrCast(*const IMarkupPointer, self), muAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_FindText(self: *const T, pchFindText: ?PWSTR, dwFlags: u32, pIEndMatch: ?*IMarkupPointer, pIEndSearch: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).FindText(@ptrCast(*const IMarkupPointer, self), pchFindText, dwFlags, pIEndMatch, pIEndSearch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupContainer_Value = @import("../zig.zig").Guid.initString("3050f5f9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupContainer = &IID_IMarkupContainer_Value;
pub const IMarkupContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OwningDoc: fn(
            self: *const IMarkupContainer,
            ppDoc: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer_OwningDoc(self: *const T, ppDoc: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer.VTable, self.vtable).OwningDoc(@ptrCast(*const IMarkupContainer, self), ppDoc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupContainer2_Value = @import("../zig.zig").Guid.initString("3050f648-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupContainer2 = &IID_IMarkupContainer2_Value;
pub const IMarkupContainer2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupContainer.VTable,
        CreateChangeLog: fn(
            self: *const IMarkupContainer2,
            pChangeSink: ?*IHTMLChangeSink,
            ppChangeLog: ?*?*IHTMLChangeLog,
            fForward: BOOL,
            fBackward: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForDirtyRange: fn(
            self: *const IMarkupContainer2,
            pChangeSink: ?*IHTMLChangeSink,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterForDirtyRange: fn(
            self: *const IMarkupContainer2,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAndClearDirtyRange: fn(
            self: *const IMarkupContainer2,
            dwCookie: u32,
            pIPointerBegin: ?*IMarkupPointer,
            pIPointerEnd: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IMarkupContainer2,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetMasterElement: fn(
            self: *const IMarkupContainer2,
            ppElementMaster: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_CreateChangeLog(self: *const T, pChangeSink: ?*IHTMLChangeSink, ppChangeLog: ?*?*IHTMLChangeLog, fForward: BOOL, fBackward: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).CreateChangeLog(@ptrCast(*const IMarkupContainer2, self), pChangeSink, ppChangeLog, fForward, fBackward);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_RegisterForDirtyRange(self: *const T, pChangeSink: ?*IHTMLChangeSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).RegisterForDirtyRange(@ptrCast(*const IMarkupContainer2, self), pChangeSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_UnRegisterForDirtyRange(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).UnRegisterForDirtyRange(@ptrCast(*const IMarkupContainer2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetAndClearDirtyRange(self: *const T, dwCookie: u32, pIPointerBegin: ?*IMarkupPointer, pIPointerEnd: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetAndClearDirtyRange(@ptrCast(*const IMarkupContainer2, self), dwCookie, pIPointerBegin, pIPointerEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetVersionNumber(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IMarkupContainer2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetMasterElement(self: *const T, ppElementMaster: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetMasterElement(@ptrCast(*const IMarkupContainer2, self), ppElementMaster);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangeLog_Value = @import("../zig.zig").Guid.initString("3050f649-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLChangeLog = &IID_IHTMLChangeLog_Value;
pub const IHTMLChangeLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextChange: fn(
            self: *const IHTMLChangeLog,
            pbBuffer: ?*u8,
            nBufferSize: i32,
            pnRecordLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangeLog_GetNextChange(self: *const T, pbBuffer: ?*u8, nBufferSize: i32, pnRecordLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangeLog.VTable, self.vtable).GetNextChange(@ptrCast(*const IHTMLChangeLog, self), pbBuffer, nBufferSize, pnRecordLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangeSink_Value = @import("../zig.zig").Guid.initString("3050f64a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLChangeSink = &IID_IHTMLChangeSink_Value;
pub const IHTMLChangeSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: fn(
            self: *const IHTMLChangeSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangeSink_Notify(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangeSink.VTable, self.vtable).Notify(@ptrCast(*const IHTMLChangeSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegmentList_Value = @import("../zig.zig").Guid.initString("3050f605-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISegmentList = &IID_ISegmentList_Value;
pub const ISegmentList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIterator: fn(
            self: *const ISegmentList,
            ppIIter: ?*?*ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ISegmentList,
            peType: ?*SELECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEmpty: fn(
            self: *const ISegmentList,
            pfEmpty: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_CreateIterator(self: *const T, ppIIter: ?*?*ISegmentListIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).CreateIterator(@ptrCast(*const ISegmentList, self), ppIIter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_GetType(self: *const T, peType: ?*SELECTION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).GetType(@ptrCast(*const ISegmentList, self), peType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_IsEmpty(self: *const T, pfEmpty: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).IsEmpty(@ptrCast(*const ISegmentList, self), pfEmpty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegmentListIterator_Value = @import("../zig.zig").Guid.initString("3050f692-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISegmentListIterator = &IID_ISegmentListIterator_Value;
pub const ISegmentListIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Current: fn(
            self: *const ISegmentListIterator,
            ppISegment: ?*?*ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        First: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDone: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advance: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_Current(self: *const T, ppISegment: ?*?*ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).Current(@ptrCast(*const ISegmentListIterator, self), ppISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_First(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).First(@ptrCast(*const ISegmentListIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_IsDone(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).IsDone(@ptrCast(*const ISegmentListIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_Advance(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).Advance(@ptrCast(*const ISegmentListIterator, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCaret_Value = @import("../zig.zig").Guid.initString("3050f604-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLCaret = &IID_IHTMLCaret_Value;
pub const IHTMLCaret = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveCaretToPointer: fn(
            self: *const IHTMLCaret,
            pDispPointer: ?*IDisplayPointer,
            fScrollIntoView: BOOL,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveCaretToPointerEx: fn(
            self: *const IHTMLCaret,
            pDispPointer: ?*IDisplayPointer,
            fVisible: BOOL,
            fScrollIntoView: BOOL,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveMarkupPointerToCaret: fn(
            self: *const IHTMLCaret,
            pIMarkupPointer: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDisplayPointerToCaret: fn(
            self: *const IHTMLCaret,
            pDispPointer: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVisible: fn(
            self: *const IHTMLCaret,
            pIsVisible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IHTMLCaret,
            fScrollIntoView: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hide: fn(
            self: *const IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertText: fn(
            self: *const IHTMLCaret,
            pText: ?PWSTR,
            lLen: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IHTMLCaret,
            pPoint: ?*POINT,
            fTranslate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretDirection: fn(
            self: *const IHTMLCaret,
            peDir: ?*CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretDirection: fn(
            self: *const IHTMLCaret,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveCaretToPointer(self: *const T, pDispPointer: ?*IDisplayPointer, fScrollIntoView: BOOL, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveCaretToPointer(@ptrCast(*const IHTMLCaret, self), pDispPointer, fScrollIntoView, eDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveCaretToPointerEx(self: *const T, pDispPointer: ?*IDisplayPointer, fVisible: BOOL, fScrollIntoView: BOOL, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveCaretToPointerEx(@ptrCast(*const IHTMLCaret, self), pDispPointer, fVisible, fScrollIntoView, eDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveMarkupPointerToCaret(self: *const T, pIMarkupPointer: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveMarkupPointerToCaret(@ptrCast(*const IHTMLCaret, self), pIMarkupPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveDisplayPointerToCaret(self: *const T, pDispPointer: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveDisplayPointerToCaret(@ptrCast(*const IHTMLCaret, self), pDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_IsVisible(self: *const T, pIsVisible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).IsVisible(@ptrCast(*const IHTMLCaret, self), pIsVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_Show(self: *const T, fScrollIntoView: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).Show(@ptrCast(*const IHTMLCaret, self), fScrollIntoView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_Hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).Hide(@ptrCast(*const IHTMLCaret, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_InsertText(self: *const T, pText: ?PWSTR, lLen: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).InsertText(@ptrCast(*const IHTMLCaret, self), pText, lLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IHTMLCaret, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_GetLocation(self: *const T, pPoint: ?*POINT, fTranslate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).GetLocation(@ptrCast(*const IHTMLCaret, self), pPoint, fTranslate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_GetCaretDirection(self: *const T, peDir: ?*CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).GetCaretDirection(@ptrCast(*const IHTMLCaret, self), peDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_SetCaretDirection(self: *const T, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).SetCaretDirection(@ptrCast(*const IHTMLCaret, self), eDir);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegment_Value = @import("../zig.zig").Guid.initString("3050f683-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISegment = &IID_ISegment_Value;
pub const ISegment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPointers: fn(
            self: *const ISegment,
            pIStart: ?*IMarkupPointer,
            pIEnd: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegment_GetPointers(self: *const T, pIStart: ?*IMarkupPointer, pIEnd: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegment.VTable, self.vtable).GetPointers(@ptrCast(*const ISegment, self), pIStart, pIEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementSegment_Value = @import("../zig.zig").Guid.initString("3050f68f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementSegment = &IID_IElementSegment_Value;
pub const IElementSegment = extern struct {
    pub const VTable = extern struct {
        base: ISegment.VTable,
        GetElement: fn(
            self: *const IElementSegment,
            ppIElement: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrimary: fn(
            self: *const IElementSegment,
            fPrimary: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrimary: fn(
            self: *const IElementSegment,
            pfPrimary: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_GetElement(self: *const T, ppIElement: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).GetElement(@ptrCast(*const IElementSegment, self), ppIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_SetPrimary(self: *const T, fPrimary: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).SetPrimary(@ptrCast(*const IElementSegment, self), fPrimary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_IsPrimary(self: *const T, pfPrimary: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).IsPrimary(@ptrCast(*const IElementSegment, self), pfPrimary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHighlightSegment_Value = @import("../zig.zig").Guid.initString("3050f690-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHighlightSegment = &IID_IHighlightSegment_Value;
pub const IHighlightSegment = extern struct {
    pub const VTable = extern struct {
        base: ISegment.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISegment.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHighlightRenderingServices_Value = @import("../zig.zig").Guid.initString("3050f606-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHighlightRenderingServices = &IID_IHighlightRenderingServices_Value;
pub const IHighlightRenderingServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSegment: fn(
            self: *const IHighlightRenderingServices,
            pDispPointerStart: ?*IDisplayPointer,
            pDispPointerEnd: ?*IDisplayPointer,
            pIRenderStyle: ?*IHTMLRenderStyle,
            ppISegment: ?*?*IHighlightSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSegmentToPointers: fn(
            self: *const IHighlightRenderingServices,
            pISegment: ?*IHighlightSegment,
            pDispPointerStart: ?*IDisplayPointer,
            pDispPointerEnd: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSegment: fn(
            self: *const IHighlightRenderingServices,
            pISegment: ?*IHighlightSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_AddSegment(self: *const T, pDispPointerStart: ?*IDisplayPointer, pDispPointerEnd: ?*IDisplayPointer, pIRenderStyle: ?*IHTMLRenderStyle, ppISegment: ?*?*IHighlightSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).AddSegment(@ptrCast(*const IHighlightRenderingServices, self), pDispPointerStart, pDispPointerEnd, pIRenderStyle, ppISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_MoveSegmentToPointers(self: *const T, pISegment: ?*IHighlightSegment, pDispPointerStart: ?*IDisplayPointer, pDispPointerEnd: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).MoveSegmentToPointers(@ptrCast(*const IHighlightRenderingServices, self), pISegment, pDispPointerStart, pDispPointerEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_RemoveSegment(self: *const T, pISegment: ?*IHighlightSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).RemoveSegment(@ptrCast(*const IHighlightRenderingServices, self), pISegment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILineInfo_Value = @import("../zig.zig").Guid.initString("3050f7e2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ILineInfo = &IID_ILineInfo_Value;
pub const ILineInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_x: fn(
            self: *const ILineInfo,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseLine: fn(
            self: *const ILineInfo,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textDescent: fn(
            self: *const ILineInfo,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textHeight: fn(
            self: *const ILineInfo,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineDirection: fn(
            self: *const ILineInfo,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_x(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_x(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_baseLine(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_baseLine(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_textDescent(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_textDescent(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_textHeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_textHeight(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_lineDirection(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_lineDirection(@ptrCast(*const ILineInfo, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayPointer_Value = @import("../zig.zig").Guid.initString("3050f69e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDisplayPointer = &IID_IDisplayPointer_Value;
pub const IDisplayPointer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToPoint: fn(
            self: *const IDisplayPointer,
            ptPoint: POINT,
            eCoordSystem: COORD_SYSTEM,
            pElementContext: ?*IHTMLElement,
            dwHitTestOptions: u32,
            pdwHitTestResults: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnit: fn(
            self: *const IDisplayPointer,
            eMoveUnit: DISPLAY_MOVEUNIT,
            lXPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PositionMarkupPointer: fn(
            self: *const IDisplayPointer,
            pMarkupPointer: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToPointer: fn(
            self: *const IDisplayPointer,
            pDispPointer: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPointerGravity: fn(
            self: *const IDisplayPointer,
            eGravity: POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPointerGravity: fn(
            self: *const IDisplayPointer,
            peGravity: ?*POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplayGravity: fn(
            self: *const IDisplayPointer,
            eGravity: DISPLAY_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayGravity: fn(
            self: *const IDisplayPointer,
            peGravity: ?*DISPLAY_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPositioned: fn(
            self: *const IDisplayPointer,
            pfPositioned: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unposition: fn(
            self: *const IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTo: fn(
            self: *const IDisplayPointer,
            pDispPointer: ?*IDisplayPointer,
            pfIsEqual: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOf: fn(
            self: *const IDisplayPointer,
            pDispPointer: ?*IDisplayPointer,
            pfIsLeftOf: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOf: fn(
            self: *const IDisplayPointer,
            pDispPointer: ?*IDisplayPointer,
            pfIsRightOf: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAtBOL: fn(
            self: *const IDisplayPointer,
            pfBOL: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToMarkupPointer: fn(
            self: *const IDisplayPointer,
            pPointer: ?*IMarkupPointer,
            pDispLineContext: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineInfo: fn(
            self: *const IDisplayPointer,
            ppLineInfo: ?*?*ILineInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlowElement: fn(
            self: *const IDisplayPointer,
            ppLayoutElement: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryBreaks: fn(
            self: *const IDisplayPointer,
            pdwBreaks: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToPoint(self: *const T, ptPoint: POINT, eCoordSystem: COORD_SYSTEM, pElementContext: ?*IHTMLElement, dwHitTestOptions: u32, pdwHitTestResults: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToPoint(@ptrCast(*const IDisplayPointer, self), ptPoint, eCoordSystem, pElementContext, dwHitTestOptions, pdwHitTestResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveUnit(self: *const T, eMoveUnit: DISPLAY_MOVEUNIT, lXPos: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveUnit(@ptrCast(*const IDisplayPointer, self), eMoveUnit, lXPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_PositionMarkupPointer(self: *const T, pMarkupPointer: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).PositionMarkupPointer(@ptrCast(*const IDisplayPointer, self), pMarkupPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToPointer(self: *const T, pDispPointer: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToPointer(@ptrCast(*const IDisplayPointer, self), pDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_SetPointerGravity(self: *const T, eGravity: POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).SetPointerGravity(@ptrCast(*const IDisplayPointer, self), eGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetPointerGravity(self: *const T, peGravity: ?*POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetPointerGravity(@ptrCast(*const IDisplayPointer, self), peGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_SetDisplayGravity(self: *const T, eGravity: DISPLAY_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).SetDisplayGravity(@ptrCast(*const IDisplayPointer, self), eGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetDisplayGravity(self: *const T, peGravity: ?*DISPLAY_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetDisplayGravity(@ptrCast(*const IDisplayPointer, self), peGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsPositioned(self: *const T, pfPositioned: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsPositioned(@ptrCast(*const IDisplayPointer, self), pfPositioned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_Unposition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).Unposition(@ptrCast(*const IDisplayPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsEqualTo(self: *const T, pDispPointer: ?*IDisplayPointer, pfIsEqual: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsEqualTo(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsLeftOf(self: *const T, pDispPointer: ?*IDisplayPointer, pfIsLeftOf: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsLeftOf(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsLeftOf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsRightOf(self: *const T, pDispPointer: ?*IDisplayPointer, pfIsRightOf: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsRightOf(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsRightOf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsAtBOL(self: *const T, pfBOL: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsAtBOL(@ptrCast(*const IDisplayPointer, self), pfBOL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToMarkupPointer(self: *const T, pPointer: ?*IMarkupPointer, pDispLineContext: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToMarkupPointer(@ptrCast(*const IDisplayPointer, self), pPointer, pDispLineContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IDisplayPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetLineInfo(self: *const T, ppLineInfo: ?*?*ILineInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetLineInfo(@ptrCast(*const IDisplayPointer, self), ppLineInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetFlowElement(self: *const T, ppLayoutElement: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetFlowElement(@ptrCast(*const IDisplayPointer, self), ppLayoutElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_QueryBreaks(self: *const T, pdwBreaks: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).QueryBreaks(@ptrCast(*const IDisplayPointer, self), pdwBreaks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayServices_Value = @import("../zig.zig").Guid.initString("3050f69d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDisplayServices = &IID_IDisplayServices_Value;
pub const IDisplayServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDisplayPointer: fn(
            self: *const IDisplayServices,
            ppDispPointer: ?*?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformRect: fn(
            self: *const IDisplayServices,
            pRect: ?*RECT,
            eSource: COORD_SYSTEM,
            eDestination: COORD_SYSTEM,
            pIElement: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformPoint: fn(
            self: *const IDisplayServices,
            pPoint: ?*POINT,
            eSource: COORD_SYSTEM,
            eDestination: COORD_SYSTEM,
            pIElement: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaret: fn(
            self: *const IDisplayServices,
            ppCaret: ?*?*IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComputedStyle: fn(
            self: *const IDisplayServices,
            pPointer: ?*IMarkupPointer,
            ppComputedStyle: ?*?*IHTMLComputedStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollRectIntoView: fn(
            self: *const IDisplayServices,
            pIElement: ?*IHTMLElement,
            rect: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasFlowLayout: fn(
            self: *const IDisplayServices,
            pIElement: ?*IHTMLElement,
            pfHasFlowLayout: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_CreateDisplayPointer(self: *const T, ppDispPointer: ?*?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).CreateDisplayPointer(@ptrCast(*const IDisplayServices, self), ppDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_TransformRect(self: *const T, pRect: ?*RECT, eSource: COORD_SYSTEM, eDestination: COORD_SYSTEM, pIElement: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).TransformRect(@ptrCast(*const IDisplayServices, self), pRect, eSource, eDestination, pIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_TransformPoint(self: *const T, pPoint: ?*POINT, eSource: COORD_SYSTEM, eDestination: COORD_SYSTEM, pIElement: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).TransformPoint(@ptrCast(*const IDisplayServices, self), pPoint, eSource, eDestination, pIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_GetCaret(self: *const T, ppCaret: ?*?*IHTMLCaret) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).GetCaret(@ptrCast(*const IDisplayServices, self), ppCaret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_GetComputedStyle(self: *const T, pPointer: ?*IMarkupPointer, ppComputedStyle: ?*?*IHTMLComputedStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).GetComputedStyle(@ptrCast(*const IDisplayServices, self), pPointer, ppComputedStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_ScrollRectIntoView(self: *const T, pIElement: ?*IHTMLElement, rect: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).ScrollRectIntoView(@ptrCast(*const IDisplayServices, self), pIElement, rect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_HasFlowLayout(self: *const T, pIElement: ?*IHTMLElement, pfHasFlowLayout: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).HasFlowLayout(@ptrCast(*const IDisplayServices, self), pIElement, pfHasFlowLayout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHtmlDlgSafeHelper_Value = @import("../zig.zig").Guid.initString("3050f81a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHtmlDlgSafeHelper = &IID_IHtmlDlgSafeHelper_Value;
pub const IHtmlDlgSafeHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        choosecolordlg: fn(
            self: *const IHtmlDlgSafeHelper,
            initColor: VARIANT,
            rgbColor: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharset: fn(
            self: *const IHtmlDlgSafeHelper,
            fontName: ?BSTR,
            charset: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Fonts: fn(
            self: *const IHtmlDlgSafeHelper,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockFormats: fn(
            self: *const IHtmlDlgSafeHelper,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_choosecolordlg(self: *const T, initColor: VARIANT, rgbColor: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).choosecolordlg(@ptrCast(*const IHtmlDlgSafeHelper, self), initColor, rgbColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_getCharset(self: *const T, fontName: ?BSTR, charset: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).getCharset(@ptrCast(*const IHtmlDlgSafeHelper, self), fontName, charset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_get_Fonts(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).get_Fonts(@ptrCast(*const IHtmlDlgSafeHelper, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_get_BlockFormats(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).get_BlockFormats(@ptrCast(*const IHtmlDlgSafeHelper, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBlockFormats_Value = @import("../zig.zig").Guid.initString("3050f830-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IBlockFormats = &IID_IBlockFormats_Value;
pub const IBlockFormats = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IBlockFormats,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IBlockFormats,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IBlockFormats,
            pvarIndex: ?*VARIANT,
            pbstrBlockFormat: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_get__NewEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).get__NewEnum(@ptrCast(*const IBlockFormats, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_get_Count(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).get_Count(@ptrCast(*const IBlockFormats, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_Item(self: *const T, pvarIndex: ?*VARIANT, pbstrBlockFormat: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).Item(@ptrCast(*const IBlockFormats, self), pvarIndex, pbstrBlockFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFontNames_Value = @import("../zig.zig").Guid.initString("3050f839-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IFontNames = &IID_IFontNames_Value;
pub const IFontNames = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IFontNames,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IFontNames,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IFontNames,
            pvarIndex: ?*VARIANT,
            pbstrFontName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_get__NewEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFontNames, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_get_Count(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).get_Count(@ptrCast(*const IFontNames, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_Item(self: *const T, pvarIndex: ?*VARIANT, pbstrFontName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).Item(@ptrCast(*const IFontNames, self), pvarIndex, pbstrFontName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICSSFilter_Value = @import("../zig.zig").Guid.initString("3050f3ec-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICSSFilter = &IID_ICSSFilter_Value;
pub const ICSSFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSite: fn(
            self: *const ICSSFilter,
            pSink: ?*ICSSFilterSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAmbientPropertyChange: fn(
            self: *const ICSSFilter,
            dispid: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilter_SetSite(self: *const T, pSink: ?*ICSSFilterSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilter.VTable, self.vtable).SetSite(@ptrCast(*const ICSSFilter, self), pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilter_OnAmbientPropertyChange(self: *const T, dispid: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilter.VTable, self.vtable).OnAmbientPropertyChange(@ptrCast(*const ICSSFilter, self), dispid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISecureUrlHost_Value = @import("../zig.zig").Guid.initString("c81984c4-74c8-11d2-baa9-00c04fc2040e");
pub const IID_ISecureUrlHost = &IID_ISecureUrlHost_Value;
pub const ISecureUrlHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateSecureUrl: fn(
            self: *const ISecureUrlHost,
            pfAllow: ?*BOOL,
            pchUrlInQuestion: ?PWSTR,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecureUrlHost_ValidateSecureUrl(self: *const T, pfAllow: ?*BOOL, pchUrlInQuestion: ?PWSTR, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecureUrlHost.VTable, self.vtable).ValidateSecureUrl(@ptrCast(*const ISecureUrlHost, self), pfAllow, pchUrlInQuestion, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupServices_Value = @import("../zig.zig").Guid.initString("3050f4a0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupServices = &IID_IMarkupServices_Value;
pub const IMarkupServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMarkupPointer: fn(
            self: *const IMarkupServices,
            ppPointer: ?*?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMarkupContainer: fn(
            self: *const IMarkupServices,
            ppMarkupContainer: ?*?*IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateElement: fn(
            self: *const IMarkupServices,
            tagID: ELEMENT_TAG_ID,
            pchAttributes: ?PWSTR,
            ppElement: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneElement: fn(
            self: *const IMarkupServices,
            pElemCloneThis: ?*IHTMLElement,
            ppElementTheClone: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertElement: fn(
            self: *const IMarkupServices,
            pElementInsert: ?*IHTMLElement,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveElement: fn(
            self: *const IMarkupServices,
            pElementRemove: ?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMarkupServices,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IMarkupServices,
            pPointerSourceStart: ?*IMarkupPointer,
            pPointerSourceFinish: ?*IMarkupPointer,
            pPointerTarget: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const IMarkupServices,
            pPointerSourceStart: ?*IMarkupPointer,
            pPointerSourceFinish: ?*IMarkupPointer,
            pPointerTarget: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertText: fn(
            self: *const IMarkupServices,
            pchText: ?PWSTR,
            cch: i32,
            pPointerTarget: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseString: fn(
            self: *const IMarkupServices,
            pchHTML: ?PWSTR,
            dwFlags: u32,
            ppContainerResult: ?*?*IMarkupContainer,
            ppPointerStart: ?*IMarkupPointer,
            ppPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseGlobal: fn(
            self: *const IMarkupServices,
            hglobalHTML: isize,
            dwFlags: u32,
            ppContainerResult: ?*?*IMarkupContainer,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsScopedElement: fn(
            self: *const IMarkupServices,
            pElement: ?*IHTMLElement,
            pfScoped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementTagId: fn(
            self: *const IMarkupServices,
            pElement: ?*IHTMLElement,
            ptagId: ?*ELEMENT_TAG_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTagIDForName: fn(
            self: *const IMarkupServices,
            bstrName: ?BSTR,
            ptagId: ?*ELEMENT_TAG_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameForTagID: fn(
            self: *const IMarkupServices,
            tagId: ELEMENT_TAG_ID,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePointersToRange: fn(
            self: *const IMarkupServices,
            pIRange: ?*IHTMLTxtRange,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRangeToPointers: fn(
            self: *const IMarkupServices,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
            pIRange: ?*IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUndoUnit: fn(
            self: *const IMarkupServices,
            pchTitle: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUndoUnit: fn(
            self: *const IMarkupServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateMarkupPointer(self: *const T, ppPointer: ?*?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateMarkupPointer(@ptrCast(*const IMarkupServices, self), ppPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateMarkupContainer(self: *const T, ppMarkupContainer: ?*?*IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateMarkupContainer(@ptrCast(*const IMarkupServices, self), ppMarkupContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateElement(self: *const T, tagID: ELEMENT_TAG_ID, pchAttributes: ?PWSTR, ppElement: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateElement(@ptrCast(*const IMarkupServices, self), tagID, pchAttributes, ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CloneElement(self: *const T, pElemCloneThis: ?*IHTMLElement, ppElementTheClone: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CloneElement(@ptrCast(*const IMarkupServices, self), pElemCloneThis, ppElementTheClone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_InsertElement(self: *const T, pElementInsert: ?*IHTMLElement, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).InsertElement(@ptrCast(*const IMarkupServices, self), pElementInsert, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_RemoveElement(self: *const T, pElementRemove: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).RemoveElement(@ptrCast(*const IMarkupServices, self), pElementRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Remove(self: *const T, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Remove(@ptrCast(*const IMarkupServices, self), pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Copy(self: *const T, pPointerSourceStart: ?*IMarkupPointer, pPointerSourceFinish: ?*IMarkupPointer, pPointerTarget: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Copy(@ptrCast(*const IMarkupServices, self), pPointerSourceStart, pPointerSourceFinish, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Move(self: *const T, pPointerSourceStart: ?*IMarkupPointer, pPointerSourceFinish: ?*IMarkupPointer, pPointerTarget: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Move(@ptrCast(*const IMarkupServices, self), pPointerSourceStart, pPointerSourceFinish, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_InsertText(self: *const T, pchText: ?PWSTR, cch: i32, pPointerTarget: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).InsertText(@ptrCast(*const IMarkupServices, self), pchText, cch, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_ParseString(self: *const T, pchHTML: ?PWSTR, dwFlags: u32, ppContainerResult: ?*?*IMarkupContainer, ppPointerStart: ?*IMarkupPointer, ppPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).ParseString(@ptrCast(*const IMarkupServices, self), pchHTML, dwFlags, ppContainerResult, ppPointerStart, ppPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_ParseGlobal(self: *const T, hglobalHTML: isize, dwFlags: u32, ppContainerResult: ?*?*IMarkupContainer, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).ParseGlobal(@ptrCast(*const IMarkupServices, self), hglobalHTML, dwFlags, ppContainerResult, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_IsScopedElement(self: *const T, pElement: ?*IHTMLElement, pfScoped: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).IsScopedElement(@ptrCast(*const IMarkupServices, self), pElement, pfScoped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetElementTagId(self: *const T, pElement: ?*IHTMLElement, ptagId: ?*ELEMENT_TAG_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetElementTagId(@ptrCast(*const IMarkupServices, self), pElement, ptagId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetTagIDForName(self: *const T, bstrName: ?BSTR, ptagId: ?*ELEMENT_TAG_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetTagIDForName(@ptrCast(*const IMarkupServices, self), bstrName, ptagId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetNameForTagID(self: *const T, tagId: ELEMENT_TAG_ID, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetNameForTagID(@ptrCast(*const IMarkupServices, self), tagId, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_MovePointersToRange(self: *const T, pIRange: ?*IHTMLTxtRange, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).MovePointersToRange(@ptrCast(*const IMarkupServices, self), pIRange, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_MoveRangeToPointers(self: *const T, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer, pIRange: ?*IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).MoveRangeToPointers(@ptrCast(*const IMarkupServices, self), pPointerStart, pPointerFinish, pIRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_BeginUndoUnit(self: *const T, pchTitle: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).BeginUndoUnit(@ptrCast(*const IMarkupServices, self), pchTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_EndUndoUnit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).EndUndoUnit(@ptrCast(*const IMarkupServices, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupServices2_Value = @import("../zig.zig").Guid.initString("3050f682-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupServices2 = &IID_IMarkupServices2_Value;
pub const IMarkupServices2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupServices.VTable,
        ParseGlobalEx: fn(
            self: *const IMarkupServices2,
            hglobalHTML: isize,
            dwFlags: u32,
            pContext: ?*IMarkupContainer,
            ppContainerResult: ?*?*IMarkupContainer,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateElements: fn(
            self: *const IMarkupServices2,
            pPointerStart: ?*IMarkupPointer,
            pPointerFinish: ?*IMarkupPointer,
            pPointerTarget: ?*IMarkupPointer,
            pPointerStatus: ?*IMarkupPointer,
            ppElemFailBottom: ?*?*IHTMLElement,
            ppElemFailTop: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveSegmentsToClipboard: fn(
            self: *const IMarkupServices2,
            pSegmentList: ?*ISegmentList,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_ParseGlobalEx(self: *const T, hglobalHTML: isize, dwFlags: u32, pContext: ?*IMarkupContainer, ppContainerResult: ?*?*IMarkupContainer, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).ParseGlobalEx(@ptrCast(*const IMarkupServices2, self), hglobalHTML, dwFlags, pContext, ppContainerResult, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_ValidateElements(self: *const T, pPointerStart: ?*IMarkupPointer, pPointerFinish: ?*IMarkupPointer, pPointerTarget: ?*IMarkupPointer, pPointerStatus: ?*IMarkupPointer, ppElemFailBottom: ?*?*IHTMLElement, ppElemFailTop: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).ValidateElements(@ptrCast(*const IMarkupServices2, self), pPointerStart, pPointerFinish, pPointerTarget, pPointerStatus, ppElemFailBottom, ppElemFailTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_SaveSegmentsToClipboard(self: *const T, pSegmentList: ?*ISegmentList, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).SaveSegmentsToClipboard(@ptrCast(*const IMarkupServices2, self), pSegmentList, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangePlayback_Value = @import("../zig.zig").Guid.initString("3050f6e0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLChangePlayback = &IID_IHTMLChangePlayback_Value;
pub const IHTMLChangePlayback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ExecChange: fn(
            self: *const IHTMLChangePlayback,
            pbRecord: ?*u8,
            fForward: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangePlayback_ExecChange(self: *const T, pbRecord: ?*u8, fForward: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangePlayback.VTable, self.vtable).ExecChange(@ptrCast(*const IHTMLChangePlayback, self), pbRecord, fForward);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupPointer2_Value = @import("../zig.zig").Guid.initString("3050f675-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupPointer2 = &IID_IMarkupPointer2_Value;
pub const IMarkupPointer2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupPointer.VTable,
        IsAtWordBreak: fn(
            self: *const IMarkupPointer2,
            pfAtBreak: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkupPosition: fn(
            self: *const IMarkupPointer2,
            plMP: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToMarkupPosition: fn(
            self: *const IMarkupPointer2,
            pContainer: ?*IMarkupContainer,
            lMP: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnitBounded: fn(
            self: *const IMarkupPointer2,
            muAction: MOVEUNIT_ACTION,
            pIBoundary: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInsideURL: fn(
            self: *const IMarkupPointer2,
            pRight: ?*IMarkupPointer,
            pfResult: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToContent: fn(
            self: *const IMarkupPointer2,
            pIElement: ?*IHTMLElement,
            fAtStart: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupPointer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_IsAtWordBreak(self: *const T, pfAtBreak: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).IsAtWordBreak(@ptrCast(*const IMarkupPointer2, self), pfAtBreak);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_GetMarkupPosition(self: *const T, plMP: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).GetMarkupPosition(@ptrCast(*const IMarkupPointer2, self), plMP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveToMarkupPosition(self: *const T, pContainer: ?*IMarkupContainer, lMP: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveToMarkupPosition(@ptrCast(*const IMarkupPointer2, self), pContainer, lMP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveUnitBounded(self: *const T, muAction: MOVEUNIT_ACTION, pIBoundary: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveUnitBounded(@ptrCast(*const IMarkupPointer2, self), muAction, pIBoundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_IsInsideURL(self: *const T, pRight: ?*IMarkupPointer, pfResult: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).IsInsideURL(@ptrCast(*const IMarkupPointer2, self), pRight, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveToContent(self: *const T, pIElement: ?*IHTMLElement, fAtStart: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveToContent(@ptrCast(*const IMarkupPointer2, self), pIElement, fAtStart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupTextFrags_Value = @import("../zig.zig").Guid.initString("3050f5fa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IMarkupTextFrags = &IID_IMarkupTextFrags_Value;
pub const IMarkupTextFrags = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTextFragCount: fn(
            self: *const IMarkupTextFrags,
            pcFrags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
            pbstrFrag: ?*?BSTR,
            pPointerFrag: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
            bstrInsert: ?BSTR,
            pPointerInsert: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextFragFromMarkupPointer: fn(
            self: *const IMarkupTextFrags,
            pPointerFind: ?*IMarkupPointer,
            piFrag: ?*i32,
            pfFragFound: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_GetTextFragCount(self: *const T, pcFrags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).GetTextFragCount(@ptrCast(*const IMarkupTextFrags, self), pcFrags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_GetTextFrag(self: *const T, iFrag: i32, pbstrFrag: ?*?BSTR, pPointerFrag: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).GetTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag, pbstrFrag, pPointerFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_RemoveTextFrag(self: *const T, iFrag: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).RemoveTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_InsertTextFrag(self: *const T, iFrag: i32, bstrInsert: ?BSTR, pPointerInsert: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).InsertTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag, bstrInsert, pPointerInsert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_FindTextFragFromMarkupPointer(self: *const T, pPointerFind: ?*IMarkupPointer, piFrag: ?*i32, pfFragFound: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).FindTextFragFromMarkupPointer(@ptrCast(*const IMarkupTextFrags, self), pPointerFind, piFrag, pfFragFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLGenericParse_Value = @import("../zig.zig").Guid.initString("e4e23071-4d07-11d2-ae76-0080c73bc199");
pub const IID_IXMLGenericParse = &IID_IXMLGenericParse_Value;
pub const IXMLGenericParse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGenericParse: fn(
            self: *const IXMLGenericParse,
            fDoGeneric: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLGenericParse_SetGenericParse(self: *const T, fDoGeneric: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLGenericParse.VTable, self.vtable).SetGenericParse(@ptrCast(*const IXMLGenericParse, self), fDoGeneric);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditHost_Value = @import("../zig.zig").Guid.initString("3050f6a0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEditHost = &IID_IHTMLEditHost_Value;
pub const IHTMLEditHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SnapRect: fn(
            self: *const IHTMLEditHost,
            pIElement: ?*IHTMLElement,
            prcNew: ?*RECT,
            eHandle: ELEMENT_CORNER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditHost_SnapRect(self: *const T, pIElement: ?*IHTMLElement, prcNew: ?*RECT, eHandle: ELEMENT_CORNER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditHost.VTable, self.vtable).SnapRect(@ptrCast(*const IHTMLEditHost, self), pIElement, prcNew, eHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditHost2_Value = @import("../zig.zig").Guid.initString("3050f848-98b5-11cf-bb82-00aa00bdce0d");
pub const IID_IHTMLEditHost2 = &IID_IHTMLEditHost2_Value;
pub const IHTMLEditHost2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLEditHost.VTable,
        PreDrag: fn(
            self: *const IHTMLEditHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLEditHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditHost2_PreDrag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditHost2.VTable, self.vtable).PreDrag(@ptrCast(*const IHTMLEditHost2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISequenceNumber_Value = @import("../zig.zig").Guid.initString("3050f6c1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISequenceNumber = &IID_ISequenceNumber_Value;
pub const ISequenceNumber = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSequenceNumber: fn(
            self: *const ISequenceNumber,
            nCurrent: i32,
            pnNew: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequenceNumber_GetSequenceNumber(self: *const T, nCurrent: i32, pnNew: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequenceNumber.VTable, self.vtable).GetSequenceNumber(@ptrCast(*const ISequenceNumber, self), nCurrent, pnNew);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIMEServices_Value = @import("../zig.zig").Guid.initString("3050f6ca-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IIMEServices = &IID_IIMEServices_Value;
pub const IIMEServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveIMM: fn(
            self: *const IIMEServices,
            ppActiveIMM: ?*?*IActiveIMMApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIMEServices_GetActiveIMM(self: *const T, ppActiveIMM: ?*?*IActiveIMMApp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIMEServices.VTable, self.vtable).GetActiveIMM(@ptrCast(*const IIMEServices, self), ppActiveIMM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionServicesListener_Value = @import("../zig.zig").Guid.initString("3050f699-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISelectionServicesListener = &IID_ISelectionServicesListener_Value;
pub const ISelectionServicesListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSelectionUndo: fn(
            self: *const ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSelectionUndo: fn(
            self: *const ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectedElementExit: fn(
            self: *const ISelectionServicesListener,
            pIElementStart: ?*IMarkupPointer,
            pIElementEnd: ?*IMarkupPointer,
            pIElementContentStart: ?*IMarkupPointer,
            pIElementContentEnd: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChangeType: fn(
            self: *const ISelectionServicesListener,
            eType: SELECTION_TYPE,
            pIListener: ?*ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeDetail: fn(
            self: *const ISelectionServicesListener,
            pTypeDetail: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_BeginSelectionUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).BeginSelectionUndo(@ptrCast(*const ISelectionServicesListener, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_EndSelectionUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).EndSelectionUndo(@ptrCast(*const ISelectionServicesListener, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_OnSelectedElementExit(self: *const T, pIElementStart: ?*IMarkupPointer, pIElementEnd: ?*IMarkupPointer, pIElementContentStart: ?*IMarkupPointer, pIElementContentEnd: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).OnSelectedElementExit(@ptrCast(*const ISelectionServicesListener, self), pIElementStart, pIElementEnd, pIElementContentStart, pIElementContentEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_OnChangeType(self: *const T, eType: SELECTION_TYPE, pIListener: ?*ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).OnChangeType(@ptrCast(*const ISelectionServicesListener, self), eType, pIListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_GetTypeDetail(self: *const T, pTypeDetail: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).GetTypeDetail(@ptrCast(*const ISelectionServicesListener, self), pTypeDetail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionServices_Value = @import("../zig.zig").Guid.initString("3050f684-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISelectionServices = &IID_ISelectionServices_Value;
pub const ISelectionServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSelectionType: fn(
            self: *const ISelectionServices,
            eType: SELECTION_TYPE,
            pIListener: ?*ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkupContainer: fn(
            self: *const ISelectionServices,
            ppIContainer: ?*?*IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSegment: fn(
            self: *const ISelectionServices,
            pIStart: ?*IMarkupPointer,
            pIEnd: ?*IMarkupPointer,
            ppISegmentAdded: ?*?*ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddElementSegment: fn(
            self: *const ISelectionServices,
            pIElement: ?*IHTMLElement,
            ppISegmentAdded: ?*?*IElementSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSegment: fn(
            self: *const ISelectionServices,
            pISegment: ?*ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionServicesListener: fn(
            self: *const ISelectionServices,
            ppISelectionServicesListener: ?*?*ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_SetSelectionType(self: *const T, eType: SELECTION_TYPE, pIListener: ?*ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).SetSelectionType(@ptrCast(*const ISelectionServices, self), eType, pIListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_GetMarkupContainer(self: *const T, ppIContainer: ?*?*IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).GetMarkupContainer(@ptrCast(*const ISelectionServices, self), ppIContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_AddSegment(self: *const T, pIStart: ?*IMarkupPointer, pIEnd: ?*IMarkupPointer, ppISegmentAdded: ?*?*ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).AddSegment(@ptrCast(*const ISelectionServices, self), pIStart, pIEnd, ppISegmentAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_AddElementSegment(self: *const T, pIElement: ?*IHTMLElement, ppISegmentAdded: ?*?*IElementSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).AddElementSegment(@ptrCast(*const ISelectionServices, self), pIElement, ppISegmentAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_RemoveSegment(self: *const T, pISegment: ?*ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).RemoveSegment(@ptrCast(*const ISelectionServices, self), pISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_GetSelectionServicesListener(self: *const T, ppISelectionServicesListener: ?*?*ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).GetSelectionServicesListener(@ptrCast(*const ISelectionServices, self), ppISelectionServicesListener);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditDesigner_Value = @import("../zig.zig").Guid.initString("3050f662-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEditDesigner = &IID_IHTMLEditDesigner_Value;
pub const IHTMLEditDesigner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreHandleEvent: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostHandleEvent: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostEditorEventNotify: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: ?*IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PreHandleEvent(self: *const T, inEvtDispId: i32, pIEventObj: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PreHandleEvent(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PostHandleEvent(self: *const T, inEvtDispId: i32, pIEventObj: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PostHandleEvent(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_TranslateAccelerator(self: *const T, inEvtDispId: i32, pIEventObj: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PostEditorEventNotify(self: *const T, inEvtDispId: i32, pIEventObj: ?*IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PostEditorEventNotify(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditServices_Value = @import("../zig.zig").Guid.initString("3050f663-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEditServices = &IID_IHTMLEditServices_Value;
pub const IHTMLEditServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDesigner: fn(
            self: *const IHTMLEditServices,
            pIDesigner: ?*IHTMLEditDesigner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDesigner: fn(
            self: *const IHTMLEditServices,
            pIDesigner: ?*IHTMLEditDesigner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionServices: fn(
            self: *const IHTMLEditServices,
            pIContainer: ?*IMarkupContainer,
            ppSelSvc: ?*?*ISelectionServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionAnchor: fn(
            self: *const IHTMLEditServices,
            pIStartAnchor: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionEnd: fn(
            self: *const IHTMLEditServices,
            pIEndAnchor: ?*IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRange: fn(
            self: *const IHTMLEditServices,
            pStart: ?*IMarkupPointer,
            pEnd: ?*IMarkupPointer,
            eType: SELECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_AddDesigner(self: *const T, pIDesigner: ?*IHTMLEditDesigner) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).AddDesigner(@ptrCast(*const IHTMLEditServices, self), pIDesigner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_RemoveDesigner(self: *const T, pIDesigner: ?*IHTMLEditDesigner) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).RemoveDesigner(@ptrCast(*const IHTMLEditServices, self), pIDesigner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_GetSelectionServices(self: *const T, pIContainer: ?*IMarkupContainer, ppSelSvc: ?*?*ISelectionServices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).GetSelectionServices(@ptrCast(*const IHTMLEditServices, self), pIContainer, ppSelSvc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_MoveToSelectionAnchor(self: *const T, pIStartAnchor: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).MoveToSelectionAnchor(@ptrCast(*const IHTMLEditServices, self), pIStartAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_MoveToSelectionEnd(self: *const T, pIEndAnchor: ?*IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).MoveToSelectionEnd(@ptrCast(*const IHTMLEditServices, self), pIEndAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_SelectRange(self: *const T, pStart: ?*IMarkupPointer, pEnd: ?*IMarkupPointer, eType: SELECTION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).SelectRange(@ptrCast(*const IHTMLEditServices, self), pStart, pEnd, eType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditServices2_Value = @import("../zig.zig").Guid.initString("3050f812-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLEditServices2 = &IID_IHTMLEditServices2_Value;
pub const IHTMLEditServices2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLEditServices.VTable,
        MoveToSelectionAnchorEx: fn(
            self: *const IHTMLEditServices2,
            pIStartAnchor: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionEndEx: fn(
            self: *const IHTMLEditServices2,
            pIEndAnchor: ?*IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreezeVirtualCaretPos: fn(
            self: *const IHTMLEditServices2,
            fReCompute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnFreezeVirtualCaretPos: fn(
            self: *const IHTMLEditServices2,
            fReset: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLEditServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_MoveToSelectionAnchorEx(self: *const T, pIStartAnchor: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).MoveToSelectionAnchorEx(@ptrCast(*const IHTMLEditServices2, self), pIStartAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_MoveToSelectionEndEx(self: *const T, pIEndAnchor: ?*IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).MoveToSelectionEndEx(@ptrCast(*const IHTMLEditServices2, self), pIEndAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_FreezeVirtualCaretPos(self: *const T, fReCompute: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).FreezeVirtualCaretPos(@ptrCast(*const IHTMLEditServices2, self), fReCompute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_UnFreezeVirtualCaretPos(self: *const T, fReset: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).UnFreezeVirtualCaretPos(@ptrCast(*const IHTMLEditServices2, self), fReset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLComputedStyle_Value = @import("../zig.zig").Guid.initString("3050f6c3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLComputedStyle = &IID_IHTMLComputedStyle_Value;
pub const IHTMLComputedStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bold: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_italic: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_underline: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_overline: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_strikeOut: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_subScript: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_superScript: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_explicitFace: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontWeight: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontSize: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fontName: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hasBgColor: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textColor: fn(
            self: *const IHTMLComputedStyle,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_backgroundColor: fn(
            self: *const IHTMLComputedStyle,
            p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_preFormatted: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_direction: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_blockDirection: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OL: fn(
            self: *const IHTMLComputedStyle,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IHTMLComputedStyle,
            pComputedStyle: ?*IHTMLComputedStyle,
            pfEqual: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_bold(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_bold(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_italic(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_italic(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_underline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_underline(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_overline(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_overline(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_strikeOut(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_strikeOut(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_subScript(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_subScript(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_superScript(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_superScript(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_explicitFace(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_explicitFace(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontWeight(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontSize(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontName(self: *const T, p: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontName(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_hasBgColor(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_hasBgColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_textColor(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_textColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_backgroundColor(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_preFormatted(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_preFormatted(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_direction(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_blockDirection(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_blockDirection(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_OL(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_OL(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_IsEqual(self: *const T, pComputedStyle: ?*IHTMLComputedStyle, pfEqual: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).IsEqual(@ptrCast(*const IHTMLComputedStyle, self), pComputedStyle, pfEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDeveloperConsoleMessageReceiver_Value = @import("../zig.zig").Guid.initString("30510808-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDeveloperConsoleMessageReceiver = &IID_IDeveloperConsoleMessageReceiver_Value;
pub const IDeveloperConsoleMessageReceiver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: ?[*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrl: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: ?[*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: ?[*:0]const u16,
            fileUrl: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrlAndLine: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: ?[*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: ?[*:0]const u16,
            fileUrl: ?[*:0]const u16,
            line: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrlLineAndColumn: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: ?[*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: ?[*:0]const u16,
            fileUrl: ?[*:0]const u16,
            line: u32,
            column: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_Write(self: *const T, source: ?[*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).Write(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrl(self: *const T, source: ?[*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: ?[*:0]const u16, fileUrl: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrl(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrlAndLine(self: *const T, source: ?[*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: ?[*:0]const u16, fileUrl: ?[*:0]const u16, line: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrlAndLine(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl, line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrlLineAndColumn(self: *const T, source: ?[*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: ?[*:0]const u16, fileUrl: ?[*:0]const u16, line: u32, column: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrlLineAndColumn(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl, line, column);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEventHandler_Value = @import("../zig.zig").Guid.initString("3051083a-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IScriptEventHandler = &IID_IScriptEventHandler_Value;
pub const IScriptEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FunctionName: fn(
            self: *const IScriptEventHandler,
            pbstrFunctionName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugDocumentContext: fn(
            self: *const IScriptEventHandler,
            ppDebugDocumentContext: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EventHandlerDispatch: fn(
            self: *const IScriptEventHandler,
            ppDispHandler: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UsesCapture: fn(
            self: *const IScriptEventHandler,
            pfUsesCapture: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cookie: fn(
            self: *const IScriptEventHandler,
            pullCookie: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_FunctionName(self: *const T, pbstrFunctionName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).FunctionName(@ptrCast(*const IScriptEventHandler, self), pbstrFunctionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_DebugDocumentContext(self: *const T, ppDebugDocumentContext: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).DebugDocumentContext(@ptrCast(*const IScriptEventHandler, self), ppDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_EventHandlerDispatch(self: *const T, ppDispHandler: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).EventHandlerDispatch(@ptrCast(*const IScriptEventHandler, self), ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_UsesCapture(self: *const T, pfUsesCapture: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).UsesCapture(@ptrCast(*const IScriptEventHandler, self), pfUsesCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_Cookie(self: *const T, pullCookie: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).Cookie(@ptrCast(*const IScriptEventHandler, self), pullCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCallbackNotificationHandler_Value = @import("../zig.zig").Guid.initString("30510842-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDebugCallbackNotificationHandler = &IID_IDebugCallbackNotificationHandler_Value;
pub const IDebugCallbackNotificationHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestedCallbackTypes: fn(
            self: *const IDebugCallbackNotificationHandler,
            pCallbackMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeDispatchEvent: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchEventComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: ?*IUnknown,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeInvokeDomCallback: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: ?*IUnknown,
            pCallback: ?*IScriptEventHandler,
            eStage: DOM_EVENT_PHASE,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeDomCallbackComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: ?*IUnknown,
            pCallback: ?*IScriptEventHandler,
            eStage: DOM_EVENT_PHASE,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeInvokeCallback: fn(
            self: *const IDebugCallbackNotificationHandler,
            eCallbackType: SCRIPT_TIMER_TYPE,
            callbackCookie: u32,
            pDispHandler: ?*IDispatch,
            ullHandlerCookie: u64,
            functionName: ?BSTR,
            line: u32,
            column: u32,
            cchLength: u32,
            pDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeCallbackComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            eCallbackType: SCRIPT_TIMER_TYPE,
            callbackCookie: u32,
            pDispHandler: ?*IDispatch,
            ullHandlerCookie: u64,
            functionName: ?BSTR,
            line: u32,
            column: u32,
            cchLength: u32,
            pDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_RequestedCallbackTypes(self: *const T, pCallbackMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).RequestedCallbackTypes(@ptrCast(*const IDebugCallbackNotificationHandler, self), pCallbackMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeDispatchEvent(self: *const T, pEvent: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeDispatchEvent(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_DispatchEventComplete(self: *const T, pEvent: ?*IUnknown, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).DispatchEventComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeInvokeDomCallback(self: *const T, pEvent: ?*IUnknown, pCallback: ?*IScriptEventHandler, eStage: DOM_EVENT_PHASE, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeInvokeDomCallback(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, pCallback, eStage, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_InvokeDomCallbackComplete(self: *const T, pEvent: ?*IUnknown, pCallback: ?*IScriptEventHandler, eStage: DOM_EVENT_PHASE, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).InvokeDomCallbackComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, pCallback, eStage, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeInvokeCallback(self: *const T, eCallbackType: SCRIPT_TIMER_TYPE, callbackCookie: u32, pDispHandler: ?*IDispatch, ullHandlerCookie: u64, functionName: ?BSTR, line: u32, column: u32, cchLength: u32, pDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeInvokeCallback(@ptrCast(*const IDebugCallbackNotificationHandler, self), eCallbackType, callbackCookie, pDispHandler, ullHandlerCookie, functionName, line, column, cchLength, pDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_InvokeCallbackComplete(self: *const T, eCallbackType: SCRIPT_TIMER_TYPE, callbackCookie: u32, pDispHandler: ?*IDispatch, ullHandlerCookie: u64, functionName: ?BSTR, line: u32, column: u32, cchLength: u32, pDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).InvokeCallbackComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), eCallbackType, callbackCookie, pDispHandler, ullHandlerCookie, functionName, line, column, cchLength, pDebugDocumentContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEventHandlerSourceInfo_Value = @import("../zig.zig").Guid.initString("30510841-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IScriptEventHandlerSourceInfo = &IID_IScriptEventHandlerSourceInfo_Value;
pub const IScriptEventHandlerSourceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceInfo: fn(
            self: *const IScriptEventHandlerSourceInfo,
            pbstrFunctionName: ?*?BSTR,
            line: ?*u32,
            column: ?*u32,
            cchLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandlerSourceInfo_GetSourceInfo(self: *const T, pbstrFunctionName: ?*?BSTR, line: ?*u32, column: ?*u32, cchLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandlerSourceInfo.VTable, self.vtable).GetSourceInfo(@ptrCast(*const IScriptEventHandlerSourceInfo, self), pbstrFunctionName, line, column, cchLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMEventRegistrationCallback_Value = @import("../zig.zig").Guid.initString("3051083b-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDOMEventRegistrationCallback = &IID_IDOMEventRegistrationCallback_Value;
pub const IDOMEventRegistrationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDOMEventListenerAdded: fn(
            self: *const IDOMEventRegistrationCallback,
            pszEventType: ?[*:0]const u16,
            pHandler: ?*IScriptEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDOMEventListenerRemoved: fn(
            self: *const IDOMEventRegistrationCallback,
            ullCookie: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEventRegistrationCallback_OnDOMEventListenerAdded(self: *const T, pszEventType: ?[*:0]const u16, pHandler: ?*IScriptEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEventRegistrationCallback.VTable, self.vtable).OnDOMEventListenerAdded(@ptrCast(*const IDOMEventRegistrationCallback, self), pszEventType, pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEventRegistrationCallback_OnDOMEventListenerRemoved(self: *const T, ullCookie: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEventRegistrationCallback.VTable, self.vtable).OnDOMEventListenerRemoved(@ptrCast(*const IDOMEventRegistrationCallback, self), ullCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventTarget2_Value = @import("../zig.zig").Guid.initString("30510839-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IEventTarget2 = &IID_IEventTarget2_Value;
pub const IEventTarget2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegisteredEventTypes: fn(
            self: *const IEventTarget2,
            ppEventTypeArray: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListenersForType: fn(
            self: *const IEventTarget2,
            pszEventType: ?[*:0]const u16,
            ppEventHandlerArray: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForDOMEventListeners: fn(
            self: *const IEventTarget2,
            pCallback: ?*IDOMEventRegistrationCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForDOMEventListeners: fn(
            self: *const IEventTarget2,
            pCallback: ?*IDOMEventRegistrationCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_GetRegisteredEventTypes(self: *const T, ppEventTypeArray: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).GetRegisteredEventTypes(@ptrCast(*const IEventTarget2, self), ppEventTypeArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_GetListenersForType(self: *const T, pszEventType: ?[*:0]const u16, ppEventHandlerArray: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).GetListenersForType(@ptrCast(*const IEventTarget2, self), pszEventType, ppEventHandlerArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_RegisterForDOMEventListeners(self: *const T, pCallback: ?*IDOMEventRegistrationCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).RegisterForDOMEventListeners(@ptrCast(*const IEventTarget2, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_UnregisterForDOMEventListeners(self: *const T, pCallback: ?*IDOMEventRegistrationCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).UnregisterForDOMEventListeners(@ptrCast(*const IEventTarget2, self), pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLNamespaceEvents_Value = @import("../zig.zig").Guid.initString("3050f6bd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_HTMLNamespaceEvents = &IID_HTMLNamespaceEvents_Value;
pub const HTMLNamespaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050f6bb-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLNamespace = &IID_IHTMLNamespace_Value;
pub const IHTMLNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IHTMLNamespace,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_urn: fn(
            self: *const IHTMLNamespace,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagNames: fn(
            self: *const IHTMLNamespace,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IHTMLNamespace,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IHTMLNamespace,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_onreadystatechange: fn(
            self: *const IHTMLNamespace,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doImport: fn(
            self: *const IHTMLNamespace,
            bstrImplementationUrl: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLNamespace,
            event: ?BSTR,
            pDisp: ?*IDispatch,
            pfResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLNamespace,
            event: ?BSTR,
            pDisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_name(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_name(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_urn(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_urn(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_tagNames(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_tagNames(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_readyState(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLNamespace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_onreadystatechange(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_doImport(self: *const T, bstrImplementationUrl: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).doImport(@ptrCast(*const IHTMLNamespace, self), bstrImplementationUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_attachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch, pfResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLNamespace, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_detachEvent(self: *const T, event: ?BSTR, pDisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLNamespace, self), event, pDisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050f6b8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLNamespaceCollection = &IID_IHTMLNamespaceCollection_Value;
pub const IHTMLNamespaceCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLNamespaceCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLNamespaceCollection,
            index: VARIANT,
            ppNamespace: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLNamespaceCollection,
            bstrNamespace: ?BSTR,
            bstrUrn: ?BSTR,
            implementationUrl: VARIANT,
            ppNamespace: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLNamespaceCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_item(self: *const T, index: VARIANT, ppNamespace: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLNamespaceCollection, self), index, ppNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_add(self: *const T, bstrNamespace: ?BSTR, bstrUrn: ?BSTR, implementationUrl: VARIANT, ppNamespace: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).add(@ptrCast(*const IHTMLNamespaceCollection, self), bstrNamespace, bstrUrn, implementationUrl, ppNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050f54f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLNamespace = &IID_DispHTMLNamespace_Value;
pub const DispHTMLNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050f550-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLNamespaceCollection = &IID_DispHTMLNamespaceCollection_Value;
pub const DispHTMLNamespaceCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainter_Value = @import("../zig.zig").Guid.initString("3050f6a6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPainter = &IID_IHTMLPainter_Value;
pub const IHTMLPainter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: fn(
            self: *const IHTMLPainter,
            rcBounds: RECT,
            rcUpdate: RECT,
            lDrawFlags: i32,
            hdc: ?HDC,
            pvDrawObject: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnResize: fn(
            self: *const IHTMLPainter,
            size: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPainterInfo: fn(
            self: *const IHTMLPainter,
            pInfo: ?*HTML_PAINTER_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HitTestPoint: fn(
            self: *const IHTMLPainter,
            pt: POINT,
            pbHit: ?*BOOL,
            plPartID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_Draw(self: *const T, rcBounds: RECT, rcUpdate: RECT, lDrawFlags: i32, hdc: ?HDC, pvDrawObject: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).Draw(@ptrCast(*const IHTMLPainter, self), rcBounds, rcUpdate, lDrawFlags, hdc, pvDrawObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_OnResize(self: *const T, size: SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).OnResize(@ptrCast(*const IHTMLPainter, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_GetPainterInfo(self: *const T, pInfo: ?*HTML_PAINTER_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).GetPainterInfo(@ptrCast(*const IHTMLPainter, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_HitTestPoint(self: *const T, pt: POINT, pbHit: ?*BOOL, plPartID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).HitTestPoint(@ptrCast(*const IHTMLPainter, self), pt, pbHit, plPartID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPaintSite_Value = @import("../zig.zig").Guid.initString("3050f6a7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPaintSite = &IID_IHTMLPaintSite_Value;
pub const IHTMLPaintSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvalidatePainterInfo: fn(
            self: *const IHTMLPaintSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRect: fn(
            self: *const IHTMLPaintSite,
            prcInvalid: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRegion: fn(
            self: *const IHTMLPaintSite,
            rgnInvalid: ?HRGN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawInfo: fn(
            self: *const IHTMLPaintSite,
            lFlags: i32,
            pDrawInfo: ?*HTML_PAINT_DRAW_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformGlobalToLocal: fn(
            self: *const IHTMLPaintSite,
            ptGlobal: POINT,
            pptLocal: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformLocalToGlobal: fn(
            self: *const IHTMLPaintSite,
            ptLocal: POINT,
            pptGlobal: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHitTestCookie: fn(
            self: *const IHTMLPaintSite,
            plCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidatePainterInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidatePainterInfo(@ptrCast(*const IHTMLPaintSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidateRect(self: *const T, prcInvalid: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidateRect(@ptrCast(*const IHTMLPaintSite, self), prcInvalid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidateRegion(self: *const T, rgnInvalid: ?HRGN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidateRegion(@ptrCast(*const IHTMLPaintSite, self), rgnInvalid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_GetDrawInfo(self: *const T, lFlags: i32, pDrawInfo: ?*HTML_PAINT_DRAW_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).GetDrawInfo(@ptrCast(*const IHTMLPaintSite, self), lFlags, pDrawInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_TransformGlobalToLocal(self: *const T, ptGlobal: POINT, pptLocal: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).TransformGlobalToLocal(@ptrCast(*const IHTMLPaintSite, self), ptGlobal, pptLocal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_TransformLocalToGlobal(self: *const T, ptLocal: POINT, pptGlobal: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).TransformLocalToGlobal(@ptrCast(*const IHTMLPaintSite, self), ptLocal, pptGlobal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_GetHitTestCookie(self: *const T, plCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).GetHitTestCookie(@ptrCast(*const IHTMLPaintSite, self), plCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainterEventInfo_Value = @import("../zig.zig").Guid.initString("3050f6df-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPainterEventInfo = &IID_IHTMLPainterEventInfo_Value;
pub const IHTMLPainterEventInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventInfoFlags: fn(
            self: *const IHTMLPainterEventInfo,
            plEventInfoFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventTarget: fn(
            self: *const IHTMLPainterEventInfo,
            ppElement: ?*?*IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCursor: fn(
            self: *const IHTMLPainterEventInfo,
            lPartID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StringFromPartID: fn(
            self: *const IHTMLPainterEventInfo,
            lPartID: i32,
            pbstrPart: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_GetEventInfoFlags(self: *const T, plEventInfoFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).GetEventInfoFlags(@ptrCast(*const IHTMLPainterEventInfo, self), plEventInfoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_GetEventTarget(self: *const T, ppElement: ?*?*IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).GetEventTarget(@ptrCast(*const IHTMLPainterEventInfo, self), ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_SetCursor(self: *const T, lPartID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).SetCursor(@ptrCast(*const IHTMLPainterEventInfo, self), lPartID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_StringFromPartID(self: *const T, lPartID: i32, pbstrPart: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).StringFromPartID(@ptrCast(*const IHTMLPainterEventInfo, self), lPartID, pbstrPart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainterOverlay_Value = @import("../zig.zig").Guid.initString("3050f7e3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPainterOverlay = &IID_IHTMLPainterOverlay_Value;
pub const IHTMLPainterOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMove: fn(
            self: *const IHTMLPainterOverlay,
            rcDevice: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterOverlay_OnMove(self: *const T, rcDevice: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterOverlay.VTable, self.vtable).OnMove(@ptrCast(*const IHTMLPainterOverlay, self), rcDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIPrintCollection_Value = @import("../zig.zig").Guid.initString("3050f6b5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLIPrintCollection = &IID_IHTMLIPrintCollection_Value;
pub const IHTMLIPrintCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IHTMLIPrintCollection,
            p: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IHTMLIPrintCollection,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLIPrintCollection,
            index: i32,
            ppIPrint: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLIPrintCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_get__newEnum(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLIPrintCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_item(self: *const T, index: i32, ppIPrint: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLIPrintCollection, self), index, ppIPrint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumPrivacyRecords_Value = @import("../zig.zig").Guid.initString("3050f844-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IEnumPrivacyRecords = &IID_IEnumPrivacyRecords_Value;
pub const IEnumPrivacyRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IEnumPrivacyRecords,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IEnumPrivacyRecords,
            pSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivacyImpacted: fn(
            self: *const IEnumPrivacyRecords,
            pState: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumPrivacyRecords,
            pbstrUrl: ?*?BSTR,
            pbstrPolicyRef: ?*?BSTR,
            pdwReserved: ?*i32,
            pdwPrivacyFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).Reset(@ptrCast(*const IEnumPrivacyRecords, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_GetSize(self: *const T, pSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).GetSize(@ptrCast(*const IEnumPrivacyRecords, self), pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_GetPrivacyImpacted(self: *const T, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).GetPrivacyImpacted(@ptrCast(*const IEnumPrivacyRecords, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_Next(self: *const T, pbstrUrl: ?*?BSTR, pbstrPolicyRef: ?*?BSTR, pdwReserved: ?*i32, pdwPrivacyFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).Next(@ptrCast(*const IEnumPrivacyRecords, self), pbstrUrl, pbstrPolicyRef, pdwReserved, pdwPrivacyFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWPCBlockedUrls_Value = @import("../zig.zig").Guid.initString("30510413-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IWPCBlockedUrls = &IID_IWPCBlockedUrls_Value;
pub const IWPCBlockedUrls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IWPCBlockedUrls,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUrl: fn(
            self: *const IWPCBlockedUrls,
            dwIdx: u32,
            pbstrUrl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWPCBlockedUrls_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWPCBlockedUrls.VTable, self.vtable).GetCount(@ptrCast(*const IWPCBlockedUrls, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWPCBlockedUrls_GetUrl(self: *const T, dwIdx: u32, pbstrUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWPCBlockedUrls.VTable, self.vtable).GetUrl(@ptrCast(*const IWPCBlockedUrls, self), dwIdx, pbstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMConstructorCollection_Value = @import("../zig.zig").Guid.initString("3051049c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDOMConstructorCollection = &IID_IHTMLDOMConstructorCollection_Value;
pub const IHTMLDOMConstructorCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attr: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BehaviorUrnsCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BookmarkCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CompatibleInfo: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CompatibleInfoCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControlRangeCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSCurrentStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSRuleList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSRuleStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSStyleRule: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSSStyleSheet: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataTransfer: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DOMImplementation: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Element: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Event: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_History: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTCElementBehaviorDefaults: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLAnchorElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLAreaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLAreasCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBaseElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBaseFontElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBGSoundElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBlockElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBodyElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLBRElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLButtonElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLCommentElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLDDElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLDivElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLDocument: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLDListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLDTElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLEmbedElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLFieldSetElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLFontElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLFormElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLFrameElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLFrameSetElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLGenericElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLHeadElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLHeadingElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLHRElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLHtmlElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLIFrameElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLImageElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLInputElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLIsIndexElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLLabelElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLLegendElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLLIElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLLinkElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLMapElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLMarqueeElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLMetaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLModelessDialog: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLNamespaceInfo: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLNamespaceInfoCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLNextIdElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLNoShowElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLObjectElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLOListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLOptionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLParagraphElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLParamElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLPhraseElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLPluginsCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLPopup: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLScriptElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLSelectElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLSpanElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLStyleElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableCaptionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableCellElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableColElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableRowElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTableSectionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTextAreaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTextElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLTitleElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLUListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTMLUnknownElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Image: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Location: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NamedNodeMap: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Navigator: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NodeList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Option: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Screen: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StaticNodeList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Storage: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StyleSheetList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StyleSheetPage: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StyleSheetPageList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRange: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRangeCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRectangle: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRectangleList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Window: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XDomainRequest: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLHttpRequest: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Attr(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Attr(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_BehaviorUrnsCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_BehaviorUrnsCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_BookmarkCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_BookmarkCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CompatibleInfo(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CompatibleInfo(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CompatibleInfoCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CompatibleInfoCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_ControlRangeCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_ControlRangeCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSCurrentStyleDeclaration(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSCurrentStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSRuleList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSRuleList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSRuleStyleDeclaration(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSRuleStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleDeclaration(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleRule(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleRule(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleSheet(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleSheet(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_DataTransfer(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_DataTransfer(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_DOMImplementation(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_DOMImplementation(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Element(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Element(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Event(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Event(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_History(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_History(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTCElementBehaviorDefaults(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTCElementBehaviorDefaults(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAnchorElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAnchorElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAreaElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAreaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAreasCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAreasCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBaseElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBaseElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBaseFontElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBaseFontElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBGSoundElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBGSoundElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBlockElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBlockElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBodyElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBodyElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBRElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBRElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLButtonElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLButtonElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLCommentElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLCommentElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDDElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDDElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDivElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDivElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDocument(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDListElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDTElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDTElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLEmbedElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLEmbedElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFieldSetElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFieldSetElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFontElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFontElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFormElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFormElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFrameElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFrameElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFrameSetElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFrameSetElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLGenericElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLGenericElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHeadElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHeadElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHeadingElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHeadingElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHRElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHRElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHtmlElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHtmlElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLIFrameElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLIFrameElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLImageElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLImageElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLInputElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLInputElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLIsIndexElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLIsIndexElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLabelElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLabelElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLegendElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLegendElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLIElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLIElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLinkElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLinkElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMapElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMapElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMarqueeElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMarqueeElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMetaElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMetaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLModelessDialog(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLModelessDialog(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNamespaceInfo(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNamespaceInfo(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNamespaceInfoCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNamespaceInfoCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNextIdElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNextIdElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNoShowElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNoShowElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLObjectElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLObjectElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLOListElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLOListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLOptionElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLOptionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLParagraphElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLParagraphElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLParamElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLParamElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPhraseElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPhraseElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPluginsCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPluginsCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPopup(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPopup(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLScriptElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLScriptElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLSelectElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLSelectElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLSpanElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLSpanElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLStyleElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLStyleElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableCaptionElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableCaptionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableCellElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableCellElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableColElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableColElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableRowElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableRowElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableSectionElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableSectionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTextAreaElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTextAreaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTextElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTextElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTitleElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTitleElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLUListElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLUListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLUnknownElement(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLUnknownElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Image(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Image(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Location(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Location(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_NamedNodeMap(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_NamedNodeMap(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Navigator(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Navigator(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_NodeList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_NodeList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Option(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Option(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Screen(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Screen(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Selection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Selection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StaticNodeList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StaticNodeList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Storage(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Storage(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetPage(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetPage(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetPageList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetPageList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Text(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Text(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRange(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRange(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRangeCollection(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRangeCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRectangle(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRectangle(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRectangleList(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRectangleList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Window(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Window(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_XDomainRequest(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_XDomainRequest(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_XMLHttpRequest(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_XMLHttpRequest(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog_Value = @import("../zig.zig").Guid.initString("3050f216-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDialog = &IID_IHTMLDialog_Value;
pub const IHTMLDialog = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dialogTop: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogTop: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dialogLeft: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogLeft: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dialogWidth: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogWidth: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dialogHeight: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogHeight: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogArguments: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_menuArguments: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_returnValue: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_returnValue: fn(
            self: *const IHTMLDialog,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDialog,
            String: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogTop(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogTop(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogTop(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogLeft(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogLeft(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogLeft(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogWidth(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogWidth(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogWidth(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogHeight(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogHeight(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogHeight(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogArguments(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogArguments(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_menuArguments(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_menuArguments(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_returnValue(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_returnValue(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_returnValue(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).close(@ptrCast(*const IHTMLDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_toString(self: *const T, String: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).toString(@ptrCast(*const IHTMLDialog, self), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog2_Value = @import("../zig.zig").Guid.initString("3050f5e0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDialog2 = &IID_IHTMLDialog2_Value;
pub const IHTMLDialog2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_status: fn(
            self: *const IHTMLDialog2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IHTMLDialog2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_resizable: fn(
            self: *const IHTMLDialog2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_resizable: fn(
            self: *const IHTMLDialog2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_put_status(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).put_status(@ptrCast(*const IHTMLDialog2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_get_status(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).get_status(@ptrCast(*const IHTMLDialog2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_put_resizable(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).put_resizable(@ptrCast(*const IHTMLDialog2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_get_resizable(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).get_resizable(@ptrCast(*const IHTMLDialog2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog3_Value = @import("../zig.zig").Guid.initString("3050f388-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLDialog3 = &IID_IHTMLDialog3_Value;
pub const IHTMLDialog3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_unadorned: fn(
            self: *const IHTMLDialog3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unadorned: fn(
            self: *const IHTMLDialog3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dialogHide: fn(
            self: *const IHTMLDialog3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dialogHide: fn(
            self: *const IHTMLDialog3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_put_unadorned(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).put_unadorned(@ptrCast(*const IHTMLDialog3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_get_unadorned(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).get_unadorned(@ptrCast(*const IHTMLDialog3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_put_dialogHide(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).put_dialogHide(@ptrCast(*const IHTMLDialog3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_get_dialogHide(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).get_dialogHide(@ptrCast(*const IHTMLDialog3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLModelessInit_Value = @import("../zig.zig").Guid.initString("3050f5e4-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLModelessInit = &IID_IHTMLModelessInit_Value;
pub const IHTMLModelessInit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parameters: fn(
            self: *const IHTMLModelessInit,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_optionString: fn(
            self: *const IHTMLModelessInit,
            p: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_moniker: fn(
            self: *const IHTMLModelessInit,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTMLModelessInit,
            p: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_parameters(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_parameters(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_optionString(self: *const T, p: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_optionString(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_moniker(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_moniker(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_document(self: *const T, p: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_document(@ptrCast(*const IHTMLModelessInit, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPopup_Value = @import("../zig.zig").Guid.initString("3050f666-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPopup = &IID_IHTMLPopup_Value;
pub const IHTMLPopup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        show: fn(
            self: *const IHTMLPopup,
            x: i32,
            y: i32,
            w: i32,
            h: i32,
            pElement: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hide: fn(
            self: *const IHTMLPopup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_document: fn(
            self: *const IHTMLPopup,
            p: ?*?*IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isOpen: fn(
            self: *const IHTMLPopup,
            p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_show(self: *const T, x: i32, y: i32, w: i32, h: i32, pElement: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).show(@ptrCast(*const IHTMLPopup, self), x, y, w, h, pElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).hide(@ptrCast(*const IHTMLPopup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_get_document(self: *const T, p: ?*?*IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).get_document(@ptrCast(*const IHTMLPopup, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_get_isOpen(self: *const T, p: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).get_isOpen(@ptrCast(*const IHTMLPopup, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPopup_Value = @import("../zig.zig").Guid.initString("3050f589-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLPopup = &IID_DispHTMLPopup_Value;
pub const DispHTMLPopup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050f5ca-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAppBehavior = &IID_IHTMLAppBehavior_Value;
pub const IHTMLAppBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_applicationName: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_applicationName: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_version: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_icon: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_icon: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_singleInstance: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_singleInstance: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_minimizeButton: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minimizeButton: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maximizeButton: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maximizeButton: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_border: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_border: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_borderStyle: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_borderStyle: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_sysMenu: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sysMenu: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_caption: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_caption: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_windowState: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_windowState: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_showInTaskBar: fn(
            self: *const IHTMLAppBehavior,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_showInTaskBar: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_commandLine: fn(
            self: *const IHTMLAppBehavior,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_applicationName(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_applicationName(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_applicationName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_applicationName(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_version(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_version(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_version(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_icon(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_icon(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_icon(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_icon(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_singleInstance(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_singleInstance(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_singleInstance(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_singleInstance(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_minimizeButton(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_minimizeButton(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_minimizeButton(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_minimizeButton(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_maximizeButton(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_maximizeButton(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_maximizeButton(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_maximizeButton(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_border(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_border(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_border(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_border(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_borderStyle(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_borderStyle(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_sysMenu(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_sysMenu(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_sysMenu(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_sysMenu(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_caption(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_caption(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_caption(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_windowState(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_windowState(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_windowState(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_windowState(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_showInTaskBar(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_showInTaskBar(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_showInTaskBar(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_showInTaskBar(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_commandLine(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_commandLine(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior2_Value = @import("../zig.zig").Guid.initString("3050f5c9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAppBehavior2 = &IID_IHTMLAppBehavior2_Value;
pub const IHTMLAppBehavior2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contextMenu: fn(
            self: *const IHTMLAppBehavior2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contextMenu: fn(
            self: *const IHTMLAppBehavior2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_innerBorder: fn(
            self: *const IHTMLAppBehavior2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_innerBorder: fn(
            self: *const IHTMLAppBehavior2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scroll: fn(
            self: *const IHTMLAppBehavior2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scroll: fn(
            self: *const IHTMLAppBehavior2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_scrollFlat: fn(
            self: *const IHTMLAppBehavior2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scrollFlat: fn(
            self: *const IHTMLAppBehavior2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_selection: fn(
            self: *const IHTMLAppBehavior2,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selection: fn(
            self: *const IHTMLAppBehavior2,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_contextMenu(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_contextMenu(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_contextMenu(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_contextMenu(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_innerBorder(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_innerBorder(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_innerBorder(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_innerBorder(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_scroll(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_scroll(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_scroll(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_scroll(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_scrollFlat(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_scrollFlat(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_scrollFlat(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_scrollFlat(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_selection(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_selection(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_selection(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_selection(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior3_Value = @import("../zig.zig").Guid.initString("3050f5cd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLAppBehavior3 = &IID_IHTMLAppBehavior3_Value;
pub const IHTMLAppBehavior3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_navigable: fn(
            self: *const IHTMLAppBehavior3,
            v: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_navigable: fn(
            self: *const IHTMLAppBehavior3,
            p: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior3_put_navigable(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior3.VTable, self.vtable).put_navigable(@ptrCast(*const IHTMLAppBehavior3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior3_get_navigable(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior3.VTable, self.vtable).get_navigable(@ptrCast(*const IHTMLAppBehavior3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050f57c-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispHTMLAppBehavior = &IID_DispHTMLAppBehavior_Value;
pub const DispHTMLAppBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050f51e-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispIHTMLInputButtonElement = &IID_DispIHTMLInputButtonElement_Value;
pub const DispIHTMLInputButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050f520-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispIHTMLInputTextElement = &IID_DispIHTMLInputTextElement_Value;
pub const DispIHTMLInputTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050f542-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispIHTMLInputFileElement = &IID_DispIHTMLInputFileElement_Value;
pub const DispIHTMLInputFileElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050f509-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispIHTMLOptionButtonElement = &IID_DispIHTMLOptionButtonElement_Value;
pub const DispIHTMLOptionButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050f51d-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_DispIHTMLInputImage = &IID_DispIHTMLInputImage_Value;
pub const DispIHTMLInputImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespace_Value = @import("../zig.zig").Guid.initString("3050f671-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementNamespace = &IID_IElementNamespace_Value;
pub const IElementNamespace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTag: fn(
            self: *const IElementNamespace,
            bstrTagName: ?BSTR,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespace_AddTag(self: *const T, bstrTagName: ?BSTR, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespace.VTable, self.vtable).AddTag(@ptrCast(*const IElementNamespace, self), bstrTagName, lFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceTable_Value = @import("../zig.zig").Guid.initString("3050f670-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementNamespaceTable = &IID_IElementNamespaceTable_Value;
pub const IElementNamespaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddNamespace: fn(
            self: *const IElementNamespaceTable,
            bstrNamespace: ?BSTR,
            bstrUrn: ?BSTR,
            lFlags: i32,
            pvarFactory: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceTable_AddNamespace(self: *const T, bstrNamespace: ?BSTR, bstrUrn: ?BSTR, lFlags: i32, pvarFactory: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceTable.VTable, self.vtable).AddNamespace(@ptrCast(*const IElementNamespaceTable, self), bstrNamespace, bstrUrn, lFlags, pvarFactory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactory_Value = @import("../zig.zig").Guid.initString("3050f672-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementNamespaceFactory = &IID_IElementNamespaceFactory_Value;
pub const IElementNamespaceFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IElementNamespaceFactory,
            pNamespace: ?*IElementNamespace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactory_Create(self: *const T, pNamespace: ?*IElementNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactory.VTable, self.vtable).Create(@ptrCast(*const IElementNamespaceFactory, self), pNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactory2_Value = @import("../zig.zig").Guid.initString("3050f805-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementNamespaceFactory2 = &IID_IElementNamespaceFactory2_Value;
pub const IElementNamespaceFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IElementNamespaceFactory.VTable,
        CreateWithImplementation: fn(
            self: *const IElementNamespaceFactory2,
            pNamespace: ?*IElementNamespace,
            bstrImplementation: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IElementNamespaceFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactory2_CreateWithImplementation(self: *const T, pNamespace: ?*IElementNamespace, bstrImplementation: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactory2.VTable, self.vtable).CreateWithImplementation(@ptrCast(*const IElementNamespaceFactory2, self), pNamespace, bstrImplementation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactoryCallback_Value = @import("../zig.zig").Guid.initString("3050f7fd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementNamespaceFactoryCallback = &IID_IElementNamespaceFactoryCallback_Value;
pub const IElementNamespaceFactoryCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: fn(
            self: *const IElementNamespaceFactoryCallback,
            bstrNamespace: ?BSTR,
            bstrTagName: ?BSTR,
            bstrAttrs: ?BSTR,
            pNamespace: ?*IElementNamespace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactoryCallback_Resolve(self: *const T, bstrNamespace: ?BSTR, bstrTagName: ?BSTR, bstrAttrs: ?BSTR, pNamespace: ?*IElementNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactoryCallback.VTable, self.vtable).Resolve(@ptrCast(*const IElementNamespaceFactoryCallback, self), bstrNamespace, bstrTagName, bstrAttrs, pNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteOM2_Value = @import("../zig.zig").Guid.initString("3050f659-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteOM2 = &IID_IElementBehaviorSiteOM2_Value;
pub const IElementBehaviorSiteOM2 = extern struct {
    pub const VTable = extern struct {
        base: IElementBehaviorSiteOM.VTable,
        GetDefaults: fn(
            self: *const IElementBehaviorSiteOM2,
            ppDefaults: ?*?*IHTMLElementDefaults,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IElementBehaviorSiteOM.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM2_GetDefaults(self: *const T, ppDefaults: ?*?*IHTMLElementDefaults) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM2.VTable, self.vtable).GetDefaults(@ptrCast(*const IElementBehaviorSiteOM2, self), ppDefaults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorCategory_Value = @import("../zig.zig").Guid.initString("3050f4ed-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorCategory = &IID_IElementBehaviorCategory_Value;
pub const IElementBehaviorCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCategory: fn(
            self: *const IElementBehaviorCategory,
            ppchCategory: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorCategory_GetCategory(self: *const T, ppchCategory: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorCategory.VTable, self.vtable).GetCategory(@ptrCast(*const IElementBehaviorCategory, self), ppchCategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteCategory_Value = @import("../zig.zig").Guid.initString("3050f4ee-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteCategory = &IID_IElementBehaviorSiteCategory_Value;
pub const IElementBehaviorSiteCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelatedBehaviors: fn(
            self: *const IElementBehaviorSiteCategory,
            lDirection: i32,
            pchCategory: ?PWSTR,
            ppEnumerator: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteCategory_GetRelatedBehaviors(self: *const T, lDirection: i32, pchCategory: ?PWSTR, ppEnumerator: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteCategory.VTable, self.vtable).GetRelatedBehaviors(@ptrCast(*const IElementBehaviorSiteCategory, self), lDirection, pchCategory, ppEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSubmit_Value = @import("../zig.zig").Guid.initString("3050f646-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSubmit = &IID_IElementBehaviorSubmit_Value;
pub const IElementBehaviorSubmit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubmitInfo: fn(
            self: *const IElementBehaviorSubmit,
            pSubmitData: ?*IHTMLSubmitData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IElementBehaviorSubmit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSubmit_GetSubmitInfo(self: *const T, pSubmitData: ?*IHTMLSubmitData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSubmit.VTable, self.vtable).GetSubmitInfo(@ptrCast(*const IElementBehaviorSubmit, self), pSubmitData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSubmit_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSubmit.VTable, self.vtable).Reset(@ptrCast(*const IElementBehaviorSubmit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorFocus_Value = @import("../zig.zig").Guid.initString("3050f6b6-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorFocus = &IID_IElementBehaviorFocus_Value;
pub const IElementBehaviorFocus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFocusRect: fn(
            self: *const IElementBehaviorFocus,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorFocus_GetFocusRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorFocus.VTable, self.vtable).GetFocusRect(@ptrCast(*const IElementBehaviorFocus, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorLayout_Value = @import("../zig.zig").Guid.initString("3050f6ba-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorLayout = &IID_IElementBehaviorLayout_Value;
pub const IElementBehaviorLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSize: fn(
            self: *const IElementBehaviorLayout,
            dwFlags: i32,
            sizeContent: SIZE,
            pptTranslateBy: ?*POINT,
            pptTopLeft: ?*POINT,
            psizeProposed: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLayoutInfo: fn(
            self: *const IElementBehaviorLayout,
            plLayoutInfo: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IElementBehaviorLayout,
            lFlags: i32,
            pptTopLeft: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapSize: fn(
            self: *const IElementBehaviorLayout,
            psizeIn: ?*SIZE,
            prcOut: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetSize(self: *const T, dwFlags: i32, sizeContent: SIZE, pptTranslateBy: ?*POINT, pptTopLeft: ?*POINT, psizeProposed: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetSize(@ptrCast(*const IElementBehaviorLayout, self), dwFlags, sizeContent, pptTranslateBy, pptTopLeft, psizeProposed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetLayoutInfo(self: *const T, plLayoutInfo: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetLayoutInfo(@ptrCast(*const IElementBehaviorLayout, self), plLayoutInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetPosition(self: *const T, lFlags: i32, pptTopLeft: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetPosition(@ptrCast(*const IElementBehaviorLayout, self), lFlags, pptTopLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_MapSize(self: *const T, psizeIn: ?*SIZE, prcOut: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).MapSize(@ptrCast(*const IElementBehaviorLayout, self), psizeIn, prcOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorLayout2_Value = @import("../zig.zig").Guid.initString("3050f846-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorLayout2 = &IID_IElementBehaviorLayout2_Value;
pub const IElementBehaviorLayout2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTextDescent: fn(
            self: *const IElementBehaviorLayout2,
            plDescent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout2_GetTextDescent(self: *const T, plDescent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout2.VTable, self.vtable).GetTextDescent(@ptrCast(*const IElementBehaviorLayout2, self), plDescent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteLayout_Value = @import("../zig.zig").Guid.initString("3050f6b7-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteLayout = &IID_IElementBehaviorSiteLayout_Value;
pub const IElementBehaviorSiteLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvalidateLayoutInfo: fn(
            self: *const IElementBehaviorSiteLayout,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateSize: fn(
            self: *const IElementBehaviorSiteLayout,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaResolution: fn(
            self: *const IElementBehaviorSiteLayout,
            psizeResolution: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_InvalidateLayoutInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).InvalidateLayoutInfo(@ptrCast(*const IElementBehaviorSiteLayout, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_InvalidateSize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).InvalidateSize(@ptrCast(*const IElementBehaviorSiteLayout, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_GetMediaResolution(self: *const T, psizeResolution: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).GetMediaResolution(@ptrCast(*const IElementBehaviorSiteLayout, self), psizeResolution);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteLayout2_Value = @import("../zig.zig").Guid.initString("3050f847-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IElementBehaviorSiteLayout2 = &IID_IElementBehaviorSiteLayout2_Value;
pub const IElementBehaviorSiteLayout2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFontInfo: fn(
            self: *const IElementBehaviorSiteLayout2,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout2_GetFontInfo(self: *const T, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout2.VTable, self.vtable).GetFontInfo(@ptrCast(*const IElementBehaviorSiteLayout2, self), plf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostBehaviorInit_Value = @import("../zig.zig").Guid.initString("3050f842-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHostBehaviorInit = &IID_IHostBehaviorInit_Value;
pub const IHostBehaviorInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PopulateNamespaceTable: fn(
            self: *const IHostBehaviorInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostBehaviorInit_PopulateNamespaceTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHostBehaviorInit.VTable, self.vtable).PopulateNamespaceTable(@ptrCast(*const IHostBehaviorInit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfacePresenter_Value = @import("../zig.zig").Guid.initString("305106e2-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISurfacePresenter = &IID_ISurfacePresenter_Value;
pub const ISurfacePresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Present: fn(
            self: *const ISurfacePresenter,
            uBuffer: u32,
            pDirty: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const ISurfacePresenter,
            backBufferIndex: u32,
            riid: ?*const Guid,
            ppBuffer: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrent: fn(
            self: *const ISurfacePresenter,
            pIsCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_Present(self: *const T, uBuffer: u32, pDirty: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).Present(@ptrCast(*const ISurfacePresenter, self), uBuffer, pDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_GetBuffer(self: *const T, backBufferIndex: u32, riid: ?*const Guid, ppBuffer: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).GetBuffer(@ptrCast(*const ISurfacePresenter, self), backBufferIndex, riid, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_IsCurrent(self: *const T, pIsCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).IsCurrent(@ptrCast(*const ISurfacePresenter, self), pIsCurrent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentSite_Value = @import("../zig.zig").Guid.initString("305106e1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentSite = &IID_IViewObjectPresentSite_Value;
pub const IViewObjectPresentSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSurfacePresenter: fn(
            self: *const IViewObjectPresentSite,
            pDevice: ?*IUnknown,
            width: u32,
            height: u32,
            backBufferCount: u32,
            format: DXGI_FORMAT,
            mode: VIEW_OBJECT_ALPHA_MODE,
            ppQueue: ?*?*ISurfacePresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsHardwareComposition: fn(
            self: *const IViewObjectPresentSite,
            pIsHardwareComposition: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionMode: fn(
            self: *const IViewObjectPresentSite,
            mode: VIEW_OBJECT_COMPOSITION_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_CreateSurfacePresenter(self: *const T, pDevice: ?*IUnknown, width: u32, height: u32, backBufferCount: u32, format: DXGI_FORMAT, mode: VIEW_OBJECT_ALPHA_MODE, ppQueue: ?*?*ISurfacePresenter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).CreateSurfacePresenter(@ptrCast(*const IViewObjectPresentSite, self), pDevice, width, height, backBufferCount, format, mode, ppQueue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_IsHardwareComposition(self: *const T, pIsHardwareComposition: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).IsHardwareComposition(@ptrCast(*const IViewObjectPresentSite, self), pIsHardwareComposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_SetCompositionMode(self: *const T, mode: VIEW_OBJECT_COMPOSITION_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).SetCompositionMode(@ptrCast(*const IViewObjectPresentSite, self), mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPixelArrayData_Value = @import("../zig.zig").Guid.initString("305107f9-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ICanvasPixelArrayData = &IID_ICanvasPixelArrayData_Value;
pub const ICanvasPixelArrayData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferPointer: fn(
            self: *const ICanvasPixelArrayData,
            ppBuffer: ?*?*u8,
            pBufferLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasPixelArrayData_GetBufferPointer(self: *const T, ppBuffer: ?*?*u8, pBufferLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasPixelArrayData.VTable, self.vtable).GetBufferPointer(@ptrCast(*const ICanvasPixelArrayData, self), ppBuffer, pBufferLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPrint_Value = @import("../zig.zig").Guid.initString("305106e3-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPrint = &IID_IViewObjectPrint_Value;
pub const IViewObjectPrint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPrintBitmap: fn(
            self: *const IViewObjectPrint,
            ppPrintBitmap: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPrint_GetPrintBitmap(self: *const T, ppPrintBitmap: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPrint.VTable, self.vtable).GetPrintBitmap(@ptrCast(*const IViewObjectPrint, self), ppPrintBitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentNotifySite_Value = @import("../zig.zig").Guid.initString("305107fa-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentNotifySite = &IID_IViewObjectPresentNotifySite_Value;
pub const IViewObjectPresentNotifySite = extern struct {
    pub const VTable = extern struct {
        base: IViewObjectPresentSite.VTable,
        RequestFrame: fn(
            self: *const IViewObjectPresentNotifySite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IViewObjectPresentSite.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentNotifySite_RequestFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentNotifySite.VTable, self.vtable).RequestFrame(@ptrCast(*const IViewObjectPresentNotifySite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentNotify_Value = @import("../zig.zig").Guid.initString("305107f8-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentNotify = &IID_IViewObjectPresentNotify_Value;
pub const IViewObjectPresentNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPreRender: fn(
            self: *const IViewObjectPresentNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentNotify_OnPreRender(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentNotify.VTable, self.vtable).OnPreRender(@ptrCast(*const IViewObjectPresentNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrackingProtection_Value = @import("../zig.zig").Guid.initString("30510803-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITrackingProtection = &IID_ITrackingProtection_Value;
pub const ITrackingProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateUrl: fn(
            self: *const ITrackingProtection,
            bstrUrl: ?BSTR,
            pfAllowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnabled: fn(
            self: *const ITrackingProtection,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackingProtection_EvaluateUrl(self: *const T, bstrUrl: ?BSTR, pfAllowed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackingProtection.VTable, self.vtable).EvaluateUrl(@ptrCast(*const ITrackingProtection, self), bstrUrl, pfAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackingProtection_GetEnabled(self: *const T, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackingProtection.VTable, self.vtable).GetEnabled(@ptrCast(*const ITrackingProtection, self), pfEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBFCacheable_Value = @import("../zig.zig").Guid.initString("30510861-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IBFCacheable = &IID_IBFCacheable_Value;
pub const IBFCacheable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnterBFCache: fn(
            self: *const IBFCacheable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitBFCache: fn(
            self: *const IBFCacheable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBFCacheable_EnterBFCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBFCacheable.VTable, self.vtable).EnterBFCache(@ptrCast(*const IBFCacheable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBFCacheable_ExitBFCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBFCacheable.VTable, self.vtable).ExitBFCache(@ptrCast(*const IBFCacheable, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const DXGI_FORMAT = @import("../graphics/dxgi.zig").DXGI_FORMAT;
const HDC = @import("../graphics/gdi.zig").HDC;
const HRESULT = @import("../foundation.zig").HRESULT;
const HRGN = @import("../graphics/gdi.zig").HRGN;
const IActiveIMMApp = @import("../globalization.zig").IActiveIMMApp;
const IDispatch = @import("../system/ole_automation.zig").IDispatch;
const IDispatchEx = @import("../system/ole_automation.zig").IDispatchEx;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IUnknown = @import("../system/com.zig").IUnknown;
const LOGFONTW = @import("../graphics/gdi.zig").LOGFONTW;
const POINT = @import("../foundation.zig").POINT;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SAFEARRAY = @import("../system/ole_automation.zig").SAFEARRAY;
const SIZE = @import("../foundation.zig").SIZE;
const VARIANT = @import("../system/ole_automation.zig").VARIANT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
